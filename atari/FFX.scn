**********************  fastForth  MODEL  **********************
*                                                              *
*                             by                               *
*                                                              *
*                        Charles Curley                        *
*                        P. O. Box 845                         *
*                    Thermopolis, WY 82443                     *
*                                                              *
*                                                              *
*                          RELEASE 2                           *
*         Fast JSR/BSR threaded Forth for the MC 68000         *
*                                                              *
*                                                              *
*               Distributed by Charles Curley for              *
*              Atari ST and other 68000 computers              *
*****  Further distribution must include the above notice. *****
     ERROR MESSAGES                         06 12 84 CRC
 Empty Stack
 Dictionary Full
 Has Wrong Addressing Mode
 Isn't Unique
 Branch out of Range
 Disk Range ?
 Full Stack
 Disk Error !!!
Bytes (hex) Dictionary space available.
 CMOS only instruction or addressing mode
  This can't happen!! msg 13
  This can't happen!! msg 13
  This can't happen!! msg 13
     ?? Not in dictionary ??
real-FORTH on Atari ST           (c) 1985-1993 by Charles Curley
     ERROR MESSAGES                          7  4 85 CRC
 Compilation Only, Use in definitions
 Execution only
 Conditionals not paired
 Definitions not finished
 In protected dictonary
 Use only when loading
 Off Current Screen
 Declare Vocabulary
  This can't happen!! msg 25
 Centronics Interface Printer Failure!!
  This can't happen!! msg 27
  This can't happen!! msg 28
  This can't happen!! msg 29
  This can't happen!! msg 30
  This can't happen!! msg 31
( Bogus load screen!!!!                   ( 25 11 88 CRC 13:39 )
CR CR

."       This disk doesn't have overlays on it!  "


CR CR   abort









































\ test for getver                         ( 27 12 91 CRC 16:06 )
debug base @ >r decimal
forth definitions forget task   : task ;        editor flush









r> base !



































( Bogus load screen!!!!                   ( 25 11 88 CRC 13:39 )
CR CR

."       This disk doesn't have overlays on it!  "


CR CR   abort









\ editor help screen                      ( 17  9 87 CRC 22:34 )
f1 - blanks left        f2 - merge        f3 - blanks right
f4 - upper case left    f5 - upper right  f9 - home cursor
                      f7 - place date
ctl a - back up by len in pad   ctl d - delete current line
ctl e - erase current line      ctl j - insert contents of pad
ctl r - replace current line    ctl s - add a line at cursor
ctl z - hold current line       ctl c - del by length at pad
ctl k - stamp screen            ctl u - next line
ctl b - back up a screen        ctl n - forward a screen
ctl q - push a $ from scr       ctl l - copy to $ stack
ctl w - insert from $ stack     ctl p - overwrite to scr from $s
ctl y - clear $ stack           ctl o - "other" screen
Backsp - del to left of cursor  delete - del to right of cursor
Undo - abort this session       Insert - toggle placing mode
                <<Any key returns to editor!>>
































































\ experimental block for kernal changes   ( 26  6 93 CRC 22:17 )
FORGET TASK hex                 : TASK ;  FORTH DEFINITIONS
: tlit  \ state f@ if
  dup here -  dup .  -8000 8000 within if
  41fa w,  here - w,  2708 w,
  else [compile] literal  then
\  then
  ;     immediate
0 variable snark
code foo   snark *+ ar0 lea, ar0 s -[ mov,  next ;c
code bar   snark *+ s -[ mov,  next ;c
: baz  [ snark ] tlit ;


editor flush

\ experimental block for kernal changes   ( 23  8 91 CRC 21:28 )
FORGET TASK HEX                 : TASK ;  FORTH DEFINITIONS

\ {compile] literal                       ( 10  3 92 CRC  9:21 )
: LITERAL   STATE F@ IF  DUP -80 7F WITHIN IF
    FF AND  7000 OR  W,  2700 W,  ELSE  273C W, ,  THEN  THEN ;
IMMEDIATE

: tlit  state f@ if
  dup here -  -8000 8000 within if
  41fa w,  here - w,  2708 w,
  else [compile] literal  then  then  ;     immediate


EDITOR FLUSH

\ experimental block for kernal changes   ( 19 10 92 CRC 11:06 )
FORGET TASK HEX  DEBUG          : TASK ;  FORTH DEFINITIONS












EDITOR FLUSH

\ experimental block for kernal changes   ( 19 10 92 CRC 11:06 )
FORGET TASK HEX  DEBUG          : TASK ;  FORTH DEFINITIONS












EDITOR FLUSH

















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































\ Pexec code                              (  2  9 93 CRC 19:49 )


base f@ >r  decimal

1 2 +thru

r> base f!
forth definitions







\ Pexec code                              (  2  9 93 CRC 19:51 )
CREATE ENVIR 0 ,

CREATE COMM 80 ALLOT    COMM 80 ERASE

CREATE FNAM 80 ALLOT    FNAM 80 ERASE

FILING PARSEFILE: H:\FAST4TH.TTP
FILE FORTH FNAM C/L CMOVE

3 VARIABLE FUNCTION             ;S      functions:
0: load & execute
3: load & return             ( base page ret. in dr0 )
4: execute previously loaded ( base page addr at fnam )


\ Pexec code                              (  2  9 93 CRC 19:51 )
HEX
0 VARIABLE BASEPAGE

CODE PEXEC      \ --- fl | execute pexec, return code
  RP DR7 MOV,  ENVIR *+ PEA,  COMM *+ PEA,   FNAM *+ PEA,
  FUNCTION 2+ *+ RP -[ .W MOV,   4B # RP -[ .W MOV,
  1 # TRAP,  DR7 RP MOV,
  BASEPAGE *+ AR0 LEA, DR0 AR0 [ MOV,  NEXT ;C

CODE MFREE      \ --- fl | discard reserved memory
  RP DR7 MOV,  BASEPAGE *+ RP -[ MOV,  49 # RP -[ MOV,
  1 # TRAP,  DR7 RP MOV,
  BASEPAGE *+ AR0 LEA,  DR0 AR0 [ MOV,   NEXT  ;C


















































































































































































































































**********************  fig-FORTH  MODEL  **********************
*                                                              *
*                                                              *
*                68000 real-FORTH TARGET COMPILER              *
*                       32 Bit Data Path                       *
*                      by Charles Curley                       *
*                                                              *
*          real-FORTH source modified by Charles Curley        *
*                  C 1983, 1986 Charles Curley                 *
*                                                              *
*                          RELEASE 1                           *
*                                                              *
*               Distributed by Charles Curley for              *
*                  68000 disk based computers                  *
*                                                              *
*****  Further distribution must include the above notice. *****
















































( LOAD SCREEN -- serial -- Recompiling    ( 10  6 86 CRC 11:15 )
DECIMAL  FILING FORTH DEFINITIONS       FORGET TASK

FALSE VARIABLE SPEAK
: VERBOSE SPEAK ON ;            : LACONIC SPEAK OFF ;

\  210 needed pexec         \   78 NEEDED TRANSIENT
   106 +vol: mainf NEEDED INTERNAL
   107 +vol: mainf NEEDED IFTRUE
   235 LOAD ( loaders       )  237 LOAD  ( loud quiet )
 ( 402 LOAD ( aim68k format )  ?CR pTODAY

EDITOR FLUSH

   CR HEX 0F MESSAGE DECIMAL CR   : TASK ;
   HERE 1024 BLANKS \ ."  Disposing... " DISPOSE CTL G EMIT
\ trace file creation screen              ( 28  6 87 CRC 11:34 )
232 NEEDED TARGET    PRINTER LEFT @ >R   5 LEFTS
CR FILING SETDRIVE: H  R-W DIR *.*




FILING R-W CREATEFILE: TRACE.TXT
OUTFILE  CR TARGET CR CR ATARI

CR CLOSEOUTFILE  R-W DIR *.*
R> PRINTER LEFT !
FORTH



\ Documenting screen                      ( 13  2 87 CRC 11:51 )
DECIMAL  DOCUMENTING  FORTH SCR @
         0  B/DRV 1-  DOCUMENTING SINCE 26  1 87
NECPAGE  SCR !












\       target compiler: loaders, 132col  ( 27  1 92 CRC 11:49 )
FORTH DEFINITIONS
365 +BLK LOADER JSR             245 +BLK LOADER ATARI \ ff xcomp
169 +BLK LOADER FILE              3 +BLK LOADER DOCUMENTED

: BOTH  JSR ATARI ;     \ build atari fastForth

: ?CR   OUT @ C/L > IF CR THEN ;        ?CR

: 132COL ( ?PRINT IF CR CTL \ EMIT THEN ) ;     immediate

: 80COL  ( ?PRINT IF CR CTL Y EMIT THEN ) ;     immediate

\ : 2CONSTANT  <BUILDS SWAP  , ,    DOES> 2@ ;


\ 68000 addressing setup                  (  2  9 85 CRC       )
BASE @ HEX 8300 CONSTANT COMPILE-ADDR \ set on 241
CODE >< TOP LDA, TOP 1+ LDY, TOP STY, TOP 1+ STA, NEXT JMP,
CODE R@  ' @ CFA @ HERE 2- ! CODE R! ' ! CFA @ HERE 2- !
: ?TARGET  \ addr -- fl | flag to indicate target or resident
                 DUP COMPILE-ADDR U< SWAP FIRST U< XOR ;
: @  DUP R@ SWAP ?TARGET  IF      ><      THEN    ;
: !  DUP         ?TARGET  IF SWAP >< SWAP THEN R! ;
: , HERE ! 2 ALLOT ;        : ? @ . ;
: COMPILE    ?COMP  R> DUP 2+ >R R@ , ;
: W@  @ ;                   : W!   ! ;
: W,  , ;
: 2@  DUP 2+       @ SWAP @ ;  : 2!  DUP ROT SWAP ! 2+ ! ;
                                               BASE !


\ compiling aids                          (  2  6 86 CRC 11:37 )
FORTH DEFINITIONS
: LOUD  ASSEMBLER (QUIET) ON  132COL ;

: QUIET ASSEMBLER (QUIET) OFF 80COL  ;

ATCOLD: FLUSH

: SETBUFS \ n --   | set system to have n buffers
  FLUSH B/BUF 6 + * LIMIT SWAP - 'FIRST !
  EMPTY-BUFFERS  #BUFS 4 .R ."  Buffers " ;     ?CR

#BUFS 32 = IFTRUE 160 SETBUFS IFEND             ?CR

: STDBUFS  FLUSH 112 +ORIGIN @ 'FIRST ! SETU/P ;

\ Target documentor                       ( 13  9 85 CRC       )
CR ." Cross Compilation of 68000 real-FORTH for Atari."
\ CR CR TARGET ATARI
  CR CR jsr    ATARI
?CRT 0= IFTRUE PAGE IFEND        WARNING ON
CR 3 VTAB CR ." Atari " 18 BYTE:IN (ABORT)    COUNT TYPE
CR CR 15 MESSAGE CR CR   ." VLIST  of kernel." CR
TVLIST CR CR
\ ?CRT 0= IFTRUE PAGE IFEND
\ ." Concordance of kernel" CR CR
\ CROSS
?CRT 0= IFTRUE PAGE IFEND




\ Document for product release            ( 24  8 86 CRC 17:58 )
DOCUMENTING    SCR @
  300 369 INDEX
  411 419 INDEX
  300 369 SHOW
  380 392 SHOW
  411 419 SHOW                  NECPAGE
EDITOR         SCR !
























































































































































































































































































































































































































































































;S debugger help screen                   ( 20  6 86 CRC 11:40 )
.STAT        -- print out the most recent status register.
AR0  DR0   S  RP , etc. -- select registers by name.
NOTRACE      -- Stop trace in a compiled word.
SR@  &  SR!  -- for playing with the status register.
       --> VERY dangerous!!! This can shut off keyboard, etc,!!
SHOWALL      -- display all registers in the debugger.
SKIP         -- skip over the next instruction in the trace.
SPEAKER      -- show the processor after each instruction while
                 doing a multi-step trace. Turn  ON  &  OFF .
STEP         -- execute one step in the current trace.
STEPS        -- execute n steps in the current trace.
TRACING      -- start tracing in a compile word.
TRACE        -- start tracing at a given address.
WHERE        -- points the editor to the error source
  Scr 241 has some sample code for use with the debugger.
















































































































































































































































































































































































































































































\ PDP 11 target compiler: dump              24 01 85 CRC
  BASE @ HEX       : OCTAL  8 BASE ! ;

: (WDUMP) \  from-address-2 cnt-1  ---  | memory displayed
   OVER + SWAP DO I T@ 7 U.R 2 +LOOP ;

: WHEAD   CR 6 SPACES 0F AND 10 0  \ start  ---  | header
   DO DUP I + BASE @ 1- AND 7 .R 2 +LOOP
   DROP ."  <<    ASCII   >>" ;

: WDUMP  \ from-addr  count ---  | dump
   BASE @ >R HEX   OVER  DUP WHEAD
   + SWAP   DO CR I 6 U.R I 10 2DUP (WDUMP) SPACE
   ASCI  I  F0 AND F0 = IF I WHEAD THEN
   ?TERMINAL  IF LEAVE  THEN  10 +LOOP CR R> BASE ! ;
  BASE !   ;S
















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































\ 68000 : wdump for trials                ( 26  2 86 CRC       )
HEX | : IF.  IF DROP ASCII . THEN ;
| : (WDUMP) \  from-address-2 cnt-1  ---  | memory displayed
   BOUNDS DO I W@ 0 7 D.R 2 +LOOP ;

| : WHEAD   CR 5 SPACES 07 AND 10 0  \ start  ---  | header
    DO DUP I + BASE @ 1- AND 7 .R 2 +LOOP
    DROP ."  <<    ASCII   >>" ;
: ASCI  -TRAILING BOUNDS    ( from-addr cnt ASCI)
   DO I C@ 7F AND  DUP ASCII ~ > IF.  DUP BL < IF. EMIT LOOP ;

: WDUMP  \ from-addr  count ---  | dump
   OVER  DUP WHEAD
   + SWAP   DO CR I 0 5 D.R I 10 2DUP (WDUMP) SPACE
   ASCI  I  F0 AND F0 = IF I WHEAD THEN
   ?TERMINAL  IF LEAVE  THEN  10 +LOOP CR ;
\ 68000 : (key) for rs232 input           ( 26  2 86 CRC       )
\ LOUD    \ replaced with code on disk.
CODE (?RSKEY) \   -- fl | a key is ready
  RP DR7 MOV,   DR6 CLR,
  U 78 ( i/o) &[ RP -[ .W MOV,
  1 # RP -[ .W MOV, ( routine # ) 0D # TRAP,
  DR7 RP MOV,
  DR0  S -[ MOV,  NEXT  ;C

CODE (RSKEY) \ -- c | get a character from device
  RP DR7 MOV,
  U 78 ( i/o) &[ RP -[ .W MOV,
  2 # RP -[ .W MOV,   \ routine #  -- get a char!!
  0D # TRAP,
  DR0 S -[ MOV,  DR7 RP MOV,  NEXT    ;C
\ QUIET
( improved overlays                       (  4  1 89 crc  7:42 )
\ 0 VARIABLE >MEM      ( --> mem to pick up          )
\ 0 VARIABLE +HEAD     ( --> start in first block    )
|  C0 USER >MEM            |  C4 USER +HEAD

| CODE HEAD@+   OFUSER +HEAD AR0 LEA,   AR0 [ S -[ MOV,
  4 # AR0 [ ADDQ,  NEXT                 ;C

| : ADVANCE   DUP >MEM +!  CMOVE   ASCII . EMIT ;

| : NEWBLK    BUFFER  DUP B/BUF ERASE  UPDATE ;

    ;s
| : HEAD@+    +HEAD @  4 +HEAD +!  ;
| : ADVANCE   DUP >MEM +!  CMOVE   2E EMIT ;

( improved overlays                       (  4  1 88 crc  8:04 )
| : GETDICT   ( addr --- | build overlay restoration info )
  2+ +HEAD !              ( set pointer past raw block flag  )
  [COMPILE] ' NFA 4- DUP      ( starting point               )
    >MEM !        HEAD@+ !    ( starting point               )
  HERE            HEAD@+ !    ( top of dictionary            )
  CURRENT @       HEAD@+ !    ( current vocabulary           )
  CONTEXT @       HEAD@+ !    ( context                      )
  VOC-LINK @      HEAD@+ !    ( vocabulary chain start       )
  VOC-LINK   BEGIN  @  -DUP   ( vocabulary chain             )
      WHILE  DUP 4- @ HEAD@+  !  REPEAT
  HEAD@+ OFF ;                ( end of data                  )




( improved overlays                       (  4  1 88 crc  8:24 )
| : SETDICT   ( addr ---  | build overlay restoration info     )
  2+ +HEAD !              ( set pointer past raw block flag  )
  HEAD@+ @          >MEM !    ( starting point               )

  HEAD@+ @            DP !    ( top of dictionary            )
  HEAD@+ @       CURRENT !    ( current vocabulary           )
  HEAD@+ @       CONTEXT !    ( context                      )
  HEAD@+ @      VOC-LINK ! ;  ( vocabulary chain start       )

| : SETVOCS   ( addr ---  | install vocabulary link pointers   )
  +HEAD !                     ( set pointer                  )
  VOC-LINK   BEGIN  @  -DUP   ( vocabulary chain             )
      WHILE  HEAD@+ @  OVER 4- !  REPEAT  ;


( improved overlays                       (  4  1 89 crc  7:42 )
: SAVEOVER  ( blk# ---  | save overlays to blk# from given word)
  DUP NEWBLK  DUP >R  GETDICT    ( dict info stored            )
  >MEM @  +HEAD @  B/BUF OVER R> -  -  ( src, dest, ct         )
  ADVANCE
  BEGIN  >MEM @  HERE  U< WHILE
     1+  >MEM @  OVER NEWBLK 2+
     { B/BUF 2- } LITERAL  ADVANCE  REPEAT
  DROP FLUSH ;







( improved overlays                       (  4  1 88 crc  8:25 )
: BRING     ( blk# ---  | restore overlays from blk#         )
  DUP  BLOCK  DUP SETDICT         ( set dictionary info      )
  +HEAD @ OVER  - >R              ( offset to voc-link data  )
  +HEAD @                         ( begin at voc-link data   )
  BEGIN  DUP @ WHILE 4+ REPEAT 4+ ( skip voclinx for now     )
  OVER - >R  R +  ( src)  >MEM @  ( dest                     )
     B/BUF R> -  ADVANCE  DUP     ( move first block to mem  )
  BEGIN  >MEM @  HERE  U< WHILE
     1+  DUP BLOCK 2+  >MEM @
     { B/BUF 2- } LITERAL  ADVANCE  REPEAT
  DROP
  BLOCK R> + SETVOCS ;



\ assemble special loaderfile for tos     ( 12  7 91 CRC 17:57 )
HEX DPNEW @ COMPILE-ADDR - 2 +OVERHEAD !
100  0A +OVERHEAD  !
  0  18 +OVERHEAD W!            \ stripped file flag

DPNEW @  DELTA -   FBASE -  4+         4/
        ASSEMBLER CTDATA DELTA +  !       FORTH









\ assemble preamble for tos               ( 12  7 91 CRC 17:57 )
DECIMAL 12 == SAFESIZE          ASSEMBLER

DECIMAL 1 11 +THRU      HEX     ?ALIGN SETOLD SETNEW

100000 SAFE 4+  DELTA + F!

PREAMBLE DUP  STDATA  DELTA +  f!    CR
DPNEW @ COMPILE-ADDR -
DUP 8 U.R ."  bytes of preamble used."
-  DUP  8 U.R  ."  Bytes of preamble left."
DUP 0< IFTRUE ABORT" Out of Preamble!"  IFEND
HERE  OVER ALLOT  SWAP ERASE



\ preamble: text messages here.           (  1  9 93 CRC 21:40 )
FALSE IFL,  \ force to start of code
LABEL SAFE HERE  SAFESIZE ALLOT  SAFESIZE ERASE
  FBASE ASSEMBLER SAFE DELTA + !
LABEL STDATA  4 ALLOT   \       LABEL CHKSUM 4 ALLOT
LABEL CTDATA  4 ALLOT   \ size of forth data to be moved
LABEL ACR    0D C,  0A C,                                  0 C,
LABEL ROOM   TXT *Forth overwrites OS*"                    0 C,
LABEL ANYKEY TXT  Hit any Key."                            0 C,
LABEL SCRSTUF  LI C,  ASCII v C,   LI C, ASCII e C,        0 C,
  LABEL DTR  TXT Jsr/Bsr Threaded FastForth"   0D C, 0A C, 0 C,
\ LABEL DTR  TXT Indirect Threaded realForth"  0D C, 0A C, 0 C,
LABEL COPY TXT Copyright 1994+ Charles Curley" 0D C, 0A C, 0 C,
LABEL MSHRINKFL TXT Mshrink Failed!"           0D C, 0A C, 0 C,
?ALIGN

\ preamble:   error out                   (  1  4 89 CRC  7:55 )
\ address of $ in ar0; print it out
LABEL PRINTLINE  RP DR7 MOV,  AR0 RP -[ MOV,
  9 # RP -[ .W MOV,  1 # TRAP,   DR7 RP MOV,  RTS,

LABEL WAITKEY   RP DR7 MOV,   2 # RP -[ .W MOV,
  2 # RP -[ .W MOV, 0D # TRAP,
  DR7 RP MOV,    RTS,

LABEL ERROROUT       \ error$ in ar2 for printout, ret in dr6
  ACR               *+ AR0 LEA,     PRINTLINE *+ BSR,
  AR2 AR0 MOV,                      PRINTLINE *+ BSR,
  ANYKEY 1+ *+ AR0 LEA,             PRINTLINE *+ BSR,
  WAITKEY *+ BSR,  ACR *+ AR0 LEA,  PRINTLINE *+ BSR, \ 4 shells
  DR6 RP -[ .W MOV,  4C # RP -[ .W MOV,  1 # TRAP,

\ preamble:   number printed out          ( 20 12 89 CRC 19:19 )
LABEL PRINTASCII  \ print out a value as an ascii character
  0F #L DR0 AND,   30 # DR0 .W ADD,
  ASCII 9 # DR0 .W CMP,  GT IF,  7 # DR0 .W ADD,  THEN,

LABEL PRINTDR0    \ print a character in dr0
  DR0 RP -[ .W MOV,             2 # RP -[ .W MOV,
  3 # RP -[ .W MOV, \ routine   ^ device
  0D # TRAP,  6 # RP ADDQ,  RTS,

LABEL PRINTREG    \ print contents of dr4
  07 # DR5 MOVQ,  FALSE DR5 DO,  4 # DR4 ROL,
  DR4 DR0 MOV,  PRINTASCII *+ BSR,  LOOP,
  20 # DR0 .W MOVQ,  PRINTDR0 *+ BRA,


\ Atari screen setup                      ( 21  5 86 CRC 18:04 )
THENL,  \ Like, wow! The actual code! Far out!!
\  0: lo res  1: medium res  2: hi (monochrome) res.
LABEL SETSCRRES     \ we use either hi or medium res at boot.
  RP DR7 MOV,  4 # RP -[ .W MOV,  0E # TRAP,  \ ? resolution
  DR0 TST,  EQ IF,  DR7 RP MOV,
    1 # .W RP -[ .W MOV, \ Set resolution to medium unless high
    DR1 CLR,  1 # DR1 SUBQ,   \ physbase & logbase stay put.
    DR1 RP -[ MOV,  DR1 RP -[ MOV,
    5 # RP -[ .W MOV,  0E # TRAP,
    THEN,    DR7 RP MOV,

;S   This code will set the screen resolution to medium iff the
current resolution is low. Then you're on your own!!

  RP -[ .W CLR, 1 # TRAP,    \ end it all!
\ preamble:                               ( 19  9 91 CRC  9:07 )
  ACR *+ AR0 LEA,  PRINTLINE *+ BSR,
        \ set cursor on, wrap on right edge.
  SCRSTUF *+ AR0 LEA,   PRINTLINE *+ BSR,

        \ put login message out
  DTR  1+ *+ AR0 LEA,  PRINTLINE *+ BSR,

        \ put copyright message out
  COPY 1+ *+ AR0 LEA,  PRINTLINE *+ BSR,






\ preamble: room for data?                (  6 10 93 CRC 20:45 )
  RP AR4 MOV,  4 AR4 &[ AR4 MOV,  \ ar4 -> base page
                        \ get base of data to be moved
  SAFE *+ AR3 LEA,  AR3 [ AR1 MOV,

LABEL ROOM?    \ start of boot + size of boot = safe addr
  STDATA *+ AR0 MOV,  AR4 8 &[ AR0 ADD,
  AR1 AR0 CMP,
  GE IF,  AR0 DR4 MOV,  PRINTREG *+ BSR, \ print min addr
    AR3 [ DR4 MOV,  PRINTREG *+ BSR, \ print our base addr
    -1 # DR6 .W MOV,  ROOM 1+ *+ AR2 LEA,
    ERROROUT *+ BSR,  THEN,




\ preamble: move data                     ( 12  7 91 CRC 18:00 )
        \ Check image for safe load: addr must exceed our addr
  CTDATA *+ DR1 MOV,    \ length of data to move.

  DR1 DR0 MOV, 2 # DR0 LSL,     \ how many bytes we'll move.
  DR0 AR0 ADD,  DR0 AR1 ADD,    \ where we'll start the move.

                        \ descending move & clean as we go.
  DR1 FALSE DO,  AR0 -[ AR1 -[ MOV,  AR0 [ CLR,  LOOP,







\ preamble: release unwanted room         (  1  9 93 CRC 19:52 )
LABEL PRERELEASE        \ assume ar4 -> base page
  4 AR4 &[ DR4 .L MOV,  \ top of available memory
  SAFE *+ AR3 LEA,      \ safe area
  AR3 4 &[ DR5 MOV,     \ user specified max size
  AR3 [ DR5 ADD,        \ max size + fbase
  DR4 DR5 CMP,  LT IF,
     DR5 DR4 MOV,       \ top of Forth mem, for later use
     RP DR7 MOV,        \ save stack for later cleanup
     AR4 DR5 SUB,
     DR5 RP -[ MOV,     \ length of mem saved.
     AR4 RP -[ MOV,     \ base address of mem saved.
     RP -[ .W CLR,      \ magic #



\ preamble: more release                  (  6 10 93 CRC 20:46 )
     4A # RP -[ .W MOV, \ function number, Mshrink
     1 # TRAP,          \ do it.
     DR7 RP MOV,        \ clean up stack
     DR0 TST,  NE IF,
       DR0 DR4 MOV,  PRINTREG *+ BSR, \ print error #
       MSHRINKFL 1+ *+ AR0 LEA,  fe # DR6 MOVq,
       ERROROUT *+ BSR,  THEN,
  THEN,
  AR3 [ AR0 MOV,        \ get base addr of forth
  DR4 AR0 -F4 &[ MOV,   \ top address allowed to "-f4 +origin"





\ preamble: go to supervisor              ( 16  6 92 CRC  9:24 )
LABEL TOSUPER
  SAFE *+ AR3 LEA,  AR3 [ AR5 MOV,      \ get base addr of file,
\ ar3 dr4 mov,  printreg *+ bsr,        \ show the addr of safe
\ ar5 dr4 mov,  printreg *+ bsr,        \ show contents of safe
  RP -FC AR5 &[ MOV,    \ save user stack to "-fc +origin"

  RP DR7 MOV,
  HERE DELTA - 0A + *+ PEA,
  26 ( 38 DECIMAL) # RP -[ .W MOV,
  0E # TRAP,
\ nop, nop,
  DR7 RP MOV,                   \ we want to be in supervisor!
\ dr7 dr4 mov,  printreg *+ bsr,


\ preamble: do it                         ( 27  6 91 CRC 13:25 )

  AR3 [ AR0 MOV,                        \ get base addr of file,
  AR4 -100 AR0 &[ MOV,                  \ save base page addr
  AR3 8 &[ AR0 -F8 &[ MOV,              \ cfa of disk handler
\ ar0 ar7 -[ mov,  ar1 ar7 -[ mov,
\ ar0 dr4 mov,  printreg *+ bsr,        \ show jump point
\ ar7 [+ ar1 mov,  ar7 [+ ar0 mov,
  AR0 [ JMP,                            \ and go do it!







\ On Base Pages                           (  2  4 89 CRC  9:24 )
At $80 bytes into the base page one can find the command line.
However, the first byte is not part of the text itself.

-- in TOS, the first byte is a count of the bytes.

-- in Mark Williams C msh shell, this always contains $7f. This
   1) gives us a way to tell the difference, and 2) means that
   one has to detect a string by checking to see if the $81st
   byte has anything in it.






\ Loader file documentation               ( 20 12 89 CRC 19:29 )
         Register usage:
AR0: --> string to be output by printline
AR1: --> safe buffer for addr & len
AR2: --> error message for failure, to errorout
AR3: --> "safe" area
AR4: --> TOS base page
AR5: --> used in setscrres for temp register, & to check addr
DR0: --> print this char in printdr0, printascii
DR1: --> used in setscrres for temp register
DR4: --> used to hold value printreg
DR5: --> used for count in printreg
DR6: --> error return number in errorout
DR7: --> save rp during traps
On entry, RP points to four bytes below the base page, a temp.

















\   cross reference utility. Ken Bell     ( 14  5 86 CRC 15:37 )
CODE QU  S [ CLR,    NEXT

\ pfa in host ---    | cross printed out
: (WHO)   SPACE COL CFA @ >R [ ' NEWFORTH 2+ ] LITERAL @
   BEGIN  PFA DUP 4- @ DELTA + DUP @ *COLON* = IF  4+ \ targ pf
     BEGIN  DUP @ \ HEX CR  .S
      DUP     0< IF ( cr .s ) DROP QU ( .s )  ELSE CASE
      R ( .S )   OF  OVER  NFA TID.  COL       QU  ENDOF
      NF*LIT*    OF 4+  ENDOF    *;S*       OF QU  ENDOF
      *@EXEC*    OF QU  ENDOF    *WLIT*     OF 2+  ENDOF
      *(.")*     OF DUP 4+ C@ 1+ + =CELLS          ENDOF

-->


\   cross reference utility. Ken Bell     ( 28  8 86 CRC 13:07 )
      *(;CODE)*  OF   QU                           ENDOF

      *(LOOP)*   OF 2+  ENDOF    *(+LOOP)*  OF 2+  ENDOF
      *BRAN*     OF 2+  ENDOF    *0BRAN*    OF 2+  ENDOF
    [ 'NF COMPILE CFA ] LITERAL  OF 4+  ENDOF       ENDCASE
    THEN  -DUP WHILE 4+ REPEAT ELSE DROP THEN LFA @ DUP 0=
             UNTIL R> 2DROP   OUT @ IF CR THEN ;

: ?LINES  \  n ---  | page if less than n lines available
  PRINTER LNCTR @ SWAP  4* 2* + 488 > IF PAGE THEN ;
    BLK @ 1+ DUP 1+ RTHRU
;S



\ cross reference utility. Target compiler( 28  8 86 CRC 13:06 )
: LOC   \ nfa  ---  nfa | print out screen & line # if can
    DECIMAL ' WHERETHEN OVER U< IF SPACE 4- @ WHERETHEN  C/L /
    14 [ BLK @ 1+ ] LITERAL .LINE 3 .R SPACE .SCR SPACE THEN ;

: (CROSS)   CR BASE @ SWAP  \ nfa --- | start cross reference
    BEGIN  DUP PFA 4- @ [ ' QUIT 4- @ ] LITERAL - IF 4 ?LINES
    15 [ BLK @ 1+ ] LITERAL .LINE  SPACE  DUP TID. 30 TAB
    COL DUP LOC DUP   PFA (WHO)
    THEN  PFA DUP 4- @ DELTA + 4- @ 0=  \ is target link = 0 ?
    ?TERMINAL OR SWAP LFA @ DUP 0=      \ is host link = 0 ?
    ROT OR UNTIL  DROP BASE ! ;

: WHO: COL CR BASE @ 15 [ BLK @ 1+ ] LITERAL .LINE SPACE
  [COMPILE]  'NF HERE COUNT TYPE DUP NFA LOC (WHO) BASE ! ;

\ target vlist    utility. Target compiler(  2  9 85 CRC       )
: TVLIST  CR BASE @  [ ' NEWFORTH 2+ ] LITERAL  @
    BEGIN DUP PFA 4- @ [ ' QUIT 4- @ ] LITERAL -
    IF DUP TID.  3 SPACES  OUT @ C/L > IF CR THEN
    THEN  PFA DUP 4- @ DELTA + 4- @ 0=  \ is target link = 0 ?
    ?TERMINAL OR SWAP LFA @ DUP 0=      \ is host link = 0 ?
    ROT OR UNTIL  DROP BASE ! ;

: CROSS   [ ' NEWFORTH 2+ ] LITERAL @ (CROSS) ;

: 'CROSS  'NF NFA (CROSS) ;  \ start cross at given word
\ e.g  'cross fred  begins a cross ref at  fred .

;S
Line number
Words using:
\ move target file into TPA.              ( 27  6 91 CRC 18:49 )
\ warning: only run from desktop so we have enough room!
\ atari
editor flush
hex compile-addr                \ source
-100 +origin @ 100 +            \ destination
over imagetop - minus           \ count
cmove                           \ doit

non-symbolic  fudge off
debug -100 +origin @ dup 4- swap 100 + trace
ar7 !   showall




\ autoloading file creation screen        (  4  7 91 CRC 13:40 )
decimal         232 NEEDED TARGET       \       ATARI
  'NF 10.DS    CFA ASSEMBLER SAFE 8 + DELTA + ! \ flop disk boot
\ 'NF HARDDISK CFA ASSEMBLER SAFE 8 + DELTA + ! \ hard disk boot
FILING H: SETDIR: \ DIR REAL4TH.*

FILING CREATEFILE: REAL4TH.TTP          HEX

FILEHEADER OVERHEAD HANDLE F@ WTF  .
COMPILE-ADDR  DPNEW @ OVER - 200 +  ( ?? )
                    HANDLE F@ WTF  .
DECIMAL

CR CLOSEIT  R-W DIR REAL4TH.*
EDITOR FLUSH  FORTH

\ aim68k object file format utilities     ( 16  5 86 CRC 16:38 )
HEX 160 USER CHKSUM  164 USER LINECT  CHKSUM 8 ERASE
  \  checksum of line   line count
  \ This format is defined in the AIM 65 User's Guide, pg F-5
  \ to F-7

: ABYTE  0 # # 2DROP ;       : ACELL  0 # # # # 2DROP ;

: BUILDCHK  \  addr cnt  --- | checksum in chksum
  2DUP + CHKSUM ! BOUNDS      DO I TC@ CHKSUM +! LOOP ;

: BUILDBYTES  \ addr cnt --- | string construction
  SWAP 1- SWAP OVER + DO I TC@ ABYTE -1 +LOOP ;
BLK @ 1+ LOAD


\ aim68k object file format utilities     ( 29  1 86 CRC       )
: ALINE  \ builds a line in the string construction area
         \ addr cnt ---  addr$ cnt$ ready for typing
  2DUP BUILDCHK  <# CHKSUM @ ACELL  2DUP BUILDBYTES
  SWAP ACELL ( addr) ABYTE ( cnt)
  ASCII ; HOLD 0 0 #> LINECT 1+! ;

: LASTLINE  \  -- addr$ cnt$ | builds last line of file for ty
  <# LINECT @ 1+ DUP ACELL ( chksum) ACELL ( lines)
  0 ABYTE ASCII ; HOLD 0 0 #> LINECT OFF TYPE CR ;

: LINES    \ addr cnt --    | dump contiguous memory
  BEGIN DUP 18 > WHILE 2DUP 18 MIN DUP >R ALINE TYPE CR
  R> DUP MINUS D+  REPEAT
  -DUP IF ALINE TYPE CR ELSE DROP THEN ;

\ autoloading file creation screen        ( 19 10 92 CRC 21:44 )
DECIMAL         232 NEEDED TARGET       \       ATARI
  'NF OPENIT   CFA ASSEMBLER SAFE 8 + DELTA + ! \ file boot
\ 'NF 10.DS    CFA ASSEMBLER SAFE 8 + DELTA + ! \ flop disk boot
\ 'NF HARDDISK CFA ASSEMBLER SAFE 8 + DELTA + ! \ hard disk boot

FILING home L FAST4TH.*        rm: fast4th.old
  mv:: fast4th.ttp fast4th.old
  FILING MKF: FAST4TH.TTP         HEX
\ FILING MKF: FAST4TH.tst         HEX
FILEHEADER OVERHEAD HANDLE F@ WTF  .
COMPILE-ADDR  DPNEW @ OVER - 200 +  ( ?? )
                    HANDLE F@ WTF  .  DECIMAL
CR CLF  R-W L FAST4TH.*         EDITOR FLUSH  FORTH


















































































































\ 68000 : forward refs 8                    17  2 85 CRC
     0A      5 BYTE:IN (CR) C!
   0D        6 BYTE:IN (CR) C!

   'NF R  CFA 4+  -4 BYTE:IN I    !
   'NF 4- CFA 4+  -4 BYTE:IN CFA  !










\ 68000 : forward refs 1                    17  2 85 CRC
     0A      5 BYTE:IN (CR) C!
   0D        6 BYTE:IN (CR) C!

   'NF R  CFA 4+  -4 BYTE:IN I    !
   'NF 4- CFA 4+  -4 BYTE:IN CFA  !










\ 68000 : forward refs 2                    27  2 85 CRC
        *COLON*   -4 BYTE:IN :    !
    0 BYTE:IN :                REPLACED:BY ?EXEC
    4 BYTE:IN :                REPLACED:BY !CSP
    8 BYTE:IN :                REPLACED:BY CURRENT
   10 BYTE:IN :                REPLACED:BY CONTEXT
   18 BYTE:IN :                REPLACED:BY CREATE
   1C BYTE:IN :                REPLACED:BY ]
   20 BYTE:IN :                REPLACED:BY (;CODE)

    0 BYTE:IN USER             REPLACED:BY CREATE
    4 BYTE:IN USER             REPLACED:BY SMUDGE
    8 BYTE:IN USER             REPLACED:BY W,
   0C BYTE:IN USER             REPLACED:BY (;CODE)


\ 68000 : forward refs 3                    27  2 85 CRC
    0 BYTE:IN ;                REPLACED:BY ?CSP
    4 BYTE:IN ;                REPLACED:BY COMPILE
   0C BYTE:IN ;                REPLACED:BY SMUDGE
   10 BYTE:IN ;                REPLACED:BY [

   *COLON*   -4 BYTE:IN ;    !
   *(;CODE)*  4 BYTE:IN VARIABLE  !

    0 BYTE:IN CONSTANT         REPLACED:BY CREATE
    4 BYTE:IN CONSTANT         REPLACED:BY SMUDGE
    8 BYTE:IN CONSTANT         REPLACED:BY ,
   0C BYTE:IN CONSTANT         REPLACED:BY (;CODE)



\ 68000 : forward refs 4                    17  2 85 CRC
   0A BYTE:IN ?ERROR           REPLACED:BY ERROR

   1C BYTE:IN ."               REPLACED:BY WORD
   3A BYTE:IN ."               REPLACED:BY WORD

   16 BYTE:IN WORD             REPLACED:BY BLOCK

   2A BYTE:IN ERROR            REPLACED:BY MESSAGE

80  'NF X CFA  5 - DELTA + C!    \ make it null





\ 68000 : forward refs 5                    17  2 85 CRC
ASSEMBLER COLDSTART          2 BOOTPARAMETER
HEX       WARM               8 BOOTPARAMETER      FORTH
LAST @ DELTA -        10 BOOTPARAMETER          \ 14 = backspace
EM US    -    18 BOOTPARAMETER          \  uarea
ASSEMBLER TOS 1C BOOTPARAMETER          \  TOS
RTS           20 BOOTPARAMETER          \  top of return stack
TIBX                         INITIALISES TIB
1F                           INITIALISES WIDTH
1                            INITIALISES WARNING
DPNEW @ DELTA -         DUP  INITIALISES FENCE
                             INITIALISES DP
EM US - 70 +                 INITIALISES VOC-LINK  \ for 4th voc
'NF (KEY)       CFA          INITIALISES 'KEY
'NF (EXPECT)    CFA          INITIALISES 'EXPECT
;S  fill in boot parameters
\ 68000 : forward refs 6                  ( 18 10 85 CRC       )
'NF (?TERMINAL) CFA          INITIALISES '?TERMINAL
'NF (EMIT)      CFA          INITIALISES 'EMIT
'NF (TYPE)      CFA          INITIALISES 'TYPE
'NF 2DROP       CFA          INITIALISES 'GOTOXY
'NF (PAGE)      CFA          INITIALISES 'PAGE
'NF (LIST)      CFA          INITIALISES 'LIST
'NF (CR)        CFA          INITIALISES 'CR
'NF (R/W)       CFA          INITIALISES 'R/W
PRIVATE IFTRUE 'NF CMDBOOT  OTHERWISE  'NF (QUIT)   IFEND
( 'NF (QUIT)    CFA          INITIALISES 'QUIT
'NF (ABORT)     CFA          INITIALISES 'ABORT
'NF (CREATE)    CFA          INITIALISES 'CREATE
TIBX      US - CO - 100 -    INITIALISES 'FIRST
TIBX      US -      100 -    INITIALISES 'LIMIT
;S  fill in more boot parameters
\ 68000 : forward refs 7                  ( 23  5 86 CRC 12:32 )
FORTH   \ N.B. placement of voc pseudoheader.
81A0                  78 BOOTPARAMETER       \  dummy vocs
LAST @ DELTA -        7C BOOTPARAMETER       \  vlfth
0                     80 BOOTPARAMETER       \  vlnk
     \ voc-link points to this guy.
BOT                   INITIALISES BOTSTACK
20002                 INITIALISES I/O   \ Atari special!
DPNEW @  IMAGETOP OVER - ERASE
CR ."  Forward references resolved."    CR

  .HERE  .SIZE  CR  WARNING ON  ?0S
CR 10 BYTE:IN (ABORT)    COUNT TYPE
CR 0F MESSAGE   CR
FORTH DEFINITIONS

\ 68000 : disk size constants             ( 26  7 87 CRC 14:35 )
BASE @ DECIMAL
| 360 CONSTANT S9B/DRV         |  719 CONSTANT S9MAX
| 410 CONSTANT SAB/DRV         |  819 CONSTANT SAMAX
| 720 CONSTANT D9B/DRV         | 1439 CONSTANT D9MAX
| 820 CONSTANT DAB/DRV         | 1639 CONSTANT DAMAX

| 'NF B/DRV  CFA 4+ CONSTANT 'B/DRV
| 'NF MAXBLK CFA 4+ CONSTANT 'MAXBLK
| 'NF B/SIDE CFA 4+ CONSTANT 'B/S

BASE !




\ 68000 : Memory setup                    (  1  3 87 CRC 13:59 )
  \ Set maxblk(s) according to the number of floppies on system.
LABEL SETDISKS  HEX  HERE 12 + DELTA - *+ BRA,
       \                   9.ss    10.ss   9.ds    10.ds
   LABEL DISKSIZES DECIMAL 360 W,  410 W,  720 W,  820 W,  HEX
   LABEL SIZEDISK   DR4 DR3 .W MOV,
         AR1 [+ DR3 MULU,  1 # DR3 .W SUBQ,  RTS,
 \ branch to here!
   4A6 ( _nflops) @# DR4 .W MOV,    DISKSIZES *+ AR1  LEA,
   SIZEDISK *+ BSR,  DR3 'NF S9MAX  CFA 4+ @#L MOV,  \  9.ss
   SIZEDISK *+ BSR,  DR3 'NF SAMAX  CFA 4+ @#L MOV,  \ 10.ss
   SIZEDISK *+ BSR,  DR3 'NF D9MAX  CFA 4+ @#L MOV,  \  9.ds
   SIZEDISK *+ BSR,  DR3 'NF DAMAX  CFA 4+ @#L MOV,  \ 10.ds
   RTS,


















\ 68000 : (tr/w)                          (  3  2 87 CRC 11:42 )
| CODE (TSECT)  \ addr diskblk flag  ---  flag  | sect setup
  S [+ DR1 MOV,  S [+ DR0 MOV,  IOB *+ AR0 LEA,
  0A # DR0 DIVU,  DR0 AR0 0C &[ .W MOV,               \ track
  DR0 .W SWAP,  1 # DR0 ADDQ,  DR0 AR0 0A &[ .W MOV,  \ sect
  S [ AR0 [ MOV,   DR1 S [ MOV,  NEXT   ;C     \ addr

: (TR/W)  \ addr  blk  fl ---   | write, fl=0; read, fl=1
  OVER 0 MAXBLK WITHIN 0=      6 ?ERROR    >R
        0 B/DRV U/   8 +IOB W!  \ set device, 1- 2
  DUP + ( 2*) R>  (TSECT)  -DISK ?DERR ;





\ 68000 : (dtr/w)                         ( 29  1 87 CRC 11:19 )
\ iob layout. is shoved to return stack by  -disk, scr 359
\ bytes     0-3    4-7  8-9  A-B   C-D  E-F 10-11
\   buffer addr  ->DSB  dev sect track side count

   \ 10 sectors per track, double sided
: (DTR/W)  \ addr  blk  fl ---   | write, fl=0; read, fl=1
  OVER 0 MAXBLK WITHIN 0=      6 ?ERROR    >R
        0 B/DRV U/       8 +IOB W!  \ set device, 1- 2
        0 2     U/ SWAP 0E +IOB W!  \ set side,
  DUP + ( 2*) R>  (TSECT)  -DISK  ?DERR ;





\ r/w for one double sided disk: ver 1    ( 29  1 87 CRC 11:36 )
| CODE DSECT  \ addr dskblk# flag ---  | f:  0 = write 1 = read
  S [+ DR1 MOV,  S [+ DR0 MOV,  IOB *+ AR0 LEA,
  9 # DR0 DIVU,  DR0 AR0 0E &[ .W MOV, \ set side
  DR0 .W SWAP,  1 # DR0 ADDQ,  DR0 AR0 0A &[ .W MOV,  \ set sect
  S [ AR0 [ MOV,   DR1 S [ MOV,  NEXT   ;C     \ addr

: (DR/W) \ addr blk# flag ---  | f:  0 = write 1 = read
  OVER 0 MAXBLK WITHIN 0= 6 ?ERROR   >R
     0 B/DRV     U/  8 +IOB W! \ set device, 0 -  1
     0     9     U/ 0C +IOB W! \ set track,  0 - 79
  DUP + ( 2*)  2DUP  R DSECT -DISK ?DERR
          200 1 D+  R> DSECT -DISK ?DERR  ;



\ hard disk raw access                    ( 26 12 90 CRC 18:48 )
\ --> requires presence of hard disk driver in RAM. <--
HEX
CTL D 1- CONSTANT HDRV   \ rwfl: 0: write, non-0: read

CODE RWABS \ rwfl addr sec# dev ---  erfl | r/w disk sect
 RP DR7 MOV,  S [+ DR0 MOV,  DR0 RP -[ .W MOV, \ dev     ct = 2
 S [+ DR1 MOV,  DR1 RP -[ .W MOV,  ( rec# ) 2 # RP -[ .W MOV,
 S [+ RP -[ MOV, ( addr)  S [ DR0 MOV,     \ get flag
 NE IF,  DR0 .W CLR,  ELSE,     \ r/w flag, ignore disk change
   DR1 TST,  NE IF,  >R >R      \ no writes to 0 blk!
     1 # DR0 .W MOVQ,  THEN,  DR0 RP -[ .W MOV,
 4 # RP -[ .W MOV, ( fc) 0D # TRAP,  R> R> THEN,   DR7 RP MOV,
 DR0 S [ MOV,  NEXT           ;C


\ hard disk raw access                    ( 26 12 90 CRC 19:15 )
DECIMAL
| 9 CONSTANT MAXBADS            2160 CONSTANT MINHBLK
  0 CONSTANT MAXHBLK
HEX

CODE GETBPB  \ dev# -- addr | bios parameter block
 S [ DR0 MOV,  DR0 RP -[ .W MOV,  ( dev# ) 7 # RP -[ .W MOV,
 0D # TRAP,   4 # RP ADDQ,  DR0 S [ MOV,  NEXT    ;C

: GETMAXHBLK  HDRV GETBPB  DUP 0E + W@  SWAP 0C + W@ 2 /  + 1-
  MAXBADS -     \ spare blocks for bad map
  MINHBLK +  { 'NF MAXHBLK CFA 4+ } LITERAL  ! ;



\ bad sector mapping                      ( 26  7 87 CRC 15:15 )
: .BADS   BADMAP @ 1+ -DUP IF 0
  DO  BADMAP 4+  I 4* +  ? LOOP THEN ;

: >BAD    \ blk#  ---   | added to bad sector map
  BADMAP @ 2+ DUP MAXBADS = IF ." Bad map full "  0 ERROR THEN
  4*  BADMAP + !  BADMAP 1+!  .BADS ;









\ bad sector mapping                      ( 21  6 87 CRC 16:32 )
CODE ?BAD  \ blk# --- blk# fl | map bad sectors to spare list
  DR2 CLR,  S [ DR0 MOV,  'NF BADMAP CFA 4+ *+ DR1 MOV,
  PL IF,  'NF BADMAP CFA 8 + *+ AR0 LEA,
    EQ DR1 DO,  AR0 [+ DR0 CMP,  LOOP,
    EQ IF,  2 # DR1 ADDQ,  DR1 S [ MOV,   1 # DR2 ADDQ,  THEN,
  THEN,  DR2 S -[ MOV,  NEXT    ;C

: REBLOCK  \ blk# --  blk#' | remap if bad sector
  ?BAD IF MAXHBLK + THEN ;






\ hard disk raw access                    ( 26 12 90 CRC 19:37 )
DECIMAL           \ fl: 0: write, non-0: read
: (HR/W) \ addr blk# fl ---   | read from hard disk
  ROT ROT DUP  MINHBLK MAXHBLK WITHIN 0= 6 ?ERROR   REBLOCK
  MINHBLK -  DUP + ( blk-> sect)  HDRV ( drive)  RWABS
  -DUP IF BASE @ HEX SWAP 6 .R BASE ! SPACE 8 ERROR THEN ;

HEX
| 'NF ABORT CFA  VARIABLE FLOPPYVEC

: FHR/W   OVER MAXBLK > IF  (HR/W)  ELSE
  FLOPPYVEC @EXECUTE  THEN ;

: HR/W  >R  DUP MAXBLK  > 1-  MINHBLK AND + R> (HR/W)  ;


\ 68000 : disk switchers                  ( 16  2 91 CRC 16:17 )
DECIMAL
: 9.SS   { 'NF (R/W) CFA } LITERAL  'R/W !  1 16 +IOB !
  S9MAX   'MAXBLK !  S9B/DRV 'B/DRV !  S9B/DRV 'B/S !     ;

: 10.SS  { 'NF (TR/W) CFA } LITERAL  'R/W !  2 16 +IOB !
  SAMAX   'MAXBLK !  SAB/DRV 'B/DRV !  SAB/DRV 'B/S !     ;









\ 68000 : disk switchers                  ( 16  2 91 CRC 16:17 )
DECIMAL
: 9.DS   { 'NF (DR/W) CFA } LITERAL  'R/W !  1 16 +IOB W!
  D9MAX   'MAXBLK !  D9B/DRV 'B/DRV  !   S9B/DRV 'B/S !   ;

: 10.DS  { 'NF (DTR/W) CFA } LITERAL  'R/W !  2 16 +IOB W!
  DAMAX   'MAXBLK !  DAB/DRV 'B/DRV  !   SAB/DRV 'B/S !   ;

\ 'NF 10.DS CFA   'NF DSKSET CFA DELTA + 4+ !







\ 68000 : disk switchers                  ( 16  2 91 CRC 16:09 )
\ use to make hard disk the only disk. the first 720 k are
\ shadowed at minhblk, to maintain consistency across models.
\ First indicate the type of floppy you want to emulate, then
\ run harddisk. The rest of the hard disk is added automatically

\ e.g: 10.ds harddisk  for "floppies" + harddisk
: HARDDISK    GETMAXHBLK
  { 'NF HR/W CFA } LITERAL  'R/W ! ;

\ use to add hard disk to any existing floppies. E.g:
\   10.SS +HARDDISK
: +HARDDISK   GETMAXHBLK
  'R/W @ FLOPPYVEC !
  { 'NF FHR/W CFA } LITERAL 'R/W ! ;
DECIMAL
































































































































































































































































































































































































































































































































































































































































































































































\ 68000 Source Code: loader               (  6  3 92 CRC 10:42 )
BASE F@ >R       FORTH DEFINITIONS   CHOP        6 LENGTH F!
SETOLD mf SETNEW     DECIMAL       WARNING ON
        -99 +LOAD   \ loader pre-amble
     3   10 +THRU   \ source from lit to sp!
   165  167 +THRU   \ compiler directives
    11   30 +THRU   \ source from (key) to first : def
   170 +BLK  LOAD   \ optimizers
    31   85 +THRU   \ source from 1st : def to end of nucleus
     (   86 +LOAD CR  (  wdump) SETOLD SETNEW
   111  118 +THRU   \ forward references
TXT Copyright 2019 C. Curley"   SETOLD SETNEW   EDITOR FLUSH
QUIET SETOLD ( CR mf ) HEX  DPNEW F@ IMAGETOP OVER - ERASE
DECIMAL 119 +LOAD       \ file setup
DECIMAL CR #BUFS . ." Buffers "  R> BASE F! CR PTODAY CR

\ base-addr memory map                    ( 17 10 85 CRC       )
all addresses are offset from base-addr
addr   count   comment
   0       6   jump to cold start
   6       6   jump to warm start
  0C       4   "68000" in radix 36, per fig model
  10       4   nfa of top of dictionary. Why, I don't know.
  14       4   backspace characters. Usually 7F & 08
  18       4   user area base address
  1C       4   top of parameter stack; orphaned user  S0
  20       4   top of return stack
  24      60   initial values for user variables




















\ boot parameters, execute                (  6  9 91 CRC 22:20 )
ASSEMBLER HEX ~ 0 @#L .L JMP,   \ cold start jmp,
 ( 4EF9 )     ~ 0 @#L .L JMP,   \ warm start jmp,
  9F7800 ,             0 ,    7F W, CTL H W, \ 2 backspaces on
\ 68000 radix 36   dict top   backspace chr  \ atari & ibm pc
HERE 8C  DUP == COLDS  4- DUP ALLOT   ERASE  \ colds

CODE EXECUTE  S [+ AR0 MOV,  AR0 [ JMP, ;C  FIXED

CODE ;S       4 # RP ADDQ,  NEXT ;C   FIXED

        \ force all of these to assemble bsr
HERE DELTA - DUP MUTATES *CONSTANT*  DUP MUTATES *DOES>*
MUTATES *(;CODE)*


\ (of) (loop)                             ( 28  1 92 CRC  8:56 )
ASSEMBLER BEGIN,  >R >R
  AR0 [ AR1 .W MOV,  AR1 AR0 ADD,  AR0 [ JMP,

CODE (OF)   RP [+ AR0 MOV,  S [+ DR0 MOV,   S [ DR0 CMP,
  R> R> EQ UNTIL,  4 # S ADDQ,  2 # AR0 ADDQ,  AR0 [ JMP,  ;C
                                                FIXED
ASSEMBLER BEGIN,  2DUP  >R >R   2 # AR0 ADDQ,
  RP [+ DR6 MOV,  RP [+ DR5 MOV,  AR0 [ JMP,
\       dr5: index                      dr6: limit
CODE (LOOP)     RP [+ AR0 MOV,  1 # DR5 ADDQ,
  LABEL LP2     DR5 DR6 CMP,
                R> R> GT UNTIL,
  LABEL LP5     AR0 [ AR0 .W ADD,
                AR0 [ JMP,  ;C        FIXED
'NF (LOOP) CFA  MUTATES *(LOOP)*
\ (+loop) (do) (pause) paws               ( 23  1 92 CRC  9:48 )
>R >R CODE (+LOOP)  RP [+ AR0 MOV,
  S [+ DR0 MOV,  DR0 DR5 ADD,  DR0 TST,  PL LP2 *+ BCC,
  DR5 DR6 CMP,  LT LP5 *+ BCC,   R> R> AGAIN,    ;C   FIXED
\       dr5: index                      dr6: limit
'NF (+LOOP) CFA  MUTATES *(+LOOP)*
CODE (DO)  RP [ AR0 MOV,  DR5 RP [ MOV,  DR6 RP -[ MOV,
  S [+ DR5 MOV,  S [+ DR6 MOV,  AR0 [ JMP, ;C FIXED

  \ call to pause current task.
LABEL (PAUSE)  RP 4 U &[ MOV,  8 U &[ U MOV,
  4 U &[ RP MOV,  RTS,
  \ call from i/o code definitions inside loops
CODE PAUSE   DR5 RP -[ MOV,  DR6 RP -[ MOV,  S RP -[ MOV,
             (PAUSE) *+ BSR,   \ execution resumes here
  RP [+ S MOV,  RP [+ DR6 MOV,  RP [+ DR5 MOV, NEXT  ;C  FIXED
\ i i! digit pause                        ( 27  1 92 CRC 10:27 )
CODE I  DR5 S -[ MOV,  NEXT  ;C

CODE I!  S [+ DR5 MOV,  NEXT  ;C        \ use to play w/ index

CODE DIGIT  DR2 CLR,  S [+ DR1 MOV,  S [ DR0 MOV,
   ASCII 0 # DR0 .W SUB,   CS IF,
LABEL BADDIG   DR2 S [ MOV,  NEXT  THEN, \ error exit
   09 # DR0 .W CMP,
   GT IF,  11 # DR0 .W CMP,  LT BADDIG *+ BCC,
   7 # DR0 .W SUB,    THEN,
   DR1 DR0 .W CMP,  GE BADDIG *+ BCC,
   DR0 .L EXT,  1 # DR2 ADDQ,
   DR0 S [ MOV,    DR2 S -[  MOV, NEXT   ;C


\ (find) - part 1                         ( 14  2 92 CRC  9:16 )
\ DEBUG FORGET TASK
\ FORTH DEFINITIONS  : TASK ;        BASE F@ >R HEX
CODE (FIND)  S [+ AR1 MOV,  S [ AR0 MOV,
  AR0 [+ DR7 .B MOV,  AR0 DR2 MOV,                \ -> 1st char
  6C ( forth's pseudo nfa) U &[ AR5 LEA,          \ taskfix
  BEGIN,  AR1 AR5 CMP,  LE IF, AR5 AR1 MOV,  THEN, \ taskfix
    AR1 [ DR1 .B MOV,  3F # .W DR1 AND,   \ get len
    DR7 DR1 .B CMP,  EQ IF,   \  br on lens /=
    AR1 AR2 MOV,  1 # AR2 ADDQ,  DR2 AR0 MOV,
;S  -->
stack: here, dict to search ---
dr2 : word being searched       ar0 : here
dr0 : word sought               dr7 : len of word sought
dr1 : length of current word    ar1 : nfa being searched
trial code for mods on scr 5298
\ (find) - part 2                         ( 14  2 92 CRC  9:16 )
    BEGIN,  AR2 [+ .B DR4 MOV,  AR0 [+ DR0 .B MOV,
       DR0 DR4 .B EOR,  1 # DR4 .B ASL,
          EQ IF, ( ** ) >R >R  CS UNTIL,
       2 # AR2 ADDQ,  AR2 S [ MOV,                    \ cfa
       DR1 CLR,  AR1 [ DR1 .B MOV,  DR1 S -[ MOV,     \ count
       1 # DR0 MOVQ,  DR0 S -[ MOV,  NEXT             \ flag
    ( **) R> R> THEN, THEN,
    -4 AR1 &[ AR1 MOV,  AR1 DR0 MOV,  EQ UNTIL,
  DR0 S [ MOV, NEXT  ;C                                 ;S

: TEST  BL WORD  HERE COUNT UPPER  HERE 10 DUMP
        HERE LATEST FND ;       EDITOR FLUSH   R> BASE F!



\ enclose                                 ( 26  2 86 CRC       )
CODE ENCLOSE  S [+ DR0 MOV,      S [ AR0 MOV,
              -1 #L DR1 MOV,
      BEGIN,  1 # DR1 ADDQ,      0 AR0 1 &D[ DR0 .B CMP,
              NE UNTIL,          DR1 S -[ MOV,
LABEL ENCL3   0 AR0 1 &D[ DR0 .B CMP,      NE IF,
              0 # 0 AR0 1 &D[ .B CMP,      NE IF,
              1 # DR1 ADDQ,      ENCL3 *+ BRA,
      THEN,   S [ DR1 CMP,       EQ IF,
              1 # DR1 ADDQ,      DR1 S -[ MOV,
LABEL ENCL8   DR1 S -[ MOV,      NEXT
      THEN,   DR1 S -[ MOV,      ENCL8 *+ BRA,
      THEN,   DR1 S -[ MOV,      1 # DR1 ADDQ,
              ENCL8 *+ BRA,                    ;C
;S

\ @execute exec sp@ sp!                   ( 31  7 92 CRC 10:35 )
CODE @EXECUTE   4 # RP ADDQ,  S [+ AR1 MOV,
  AR1 [ AR0 MOV,  AR0 [ JMP, ;C         FIXED
'NF @EXECUTE CFA  MUTATES *@EXEC*

CODE <EXEC>  \ index ---  | index into execution array
  S [+ DR0 MOV,  2 # DR0 ASL,  RP [+ AR0 MOV,  DR0 AR0 ADD,
  AR0 [ AR0 MOV,  AR0 [ JMP,  ;C                FIXED

CODE SP!  0C U &[ S MOV,        NEXT ;C

CODE SP@  S S -[ MOV,           NEXT ;C

CODE RP@  RP S -[ MOV,          NEXT ;C

ASSEMBLER LABEL MASK 7F W,
\ (emit) (key) (?terminal) bye            ( 26  8 93 CRC  8:59 )
CODE (EMIT)  S [+ DR0 MOV,  MASK *+ .W DR0 AND,  \ data
  DR0 RP -[ .W MOV,  U 7E ( i/o) &[ RP -[ .W MOV,
  3 # RP -[ .W MOV, \ routine            ^ device
  0D # TRAP,  6 # RP ADDQ,  NEXT   ;C           FIXED

CODE (KEY) BEGIN,   'NF PAUSE CFA *+ BSR,  U 7C &[ RP -[ .W MOV,
  1 # RP -[ .W MOV, 0D # TRAP,  4 # RP ADDQ,  DR0 TST, NE UNTIL,
  U 7C &[ RP -[ .W MOV,  2 # RP -[ .W MOV,  0D # TRAP,
  4 # RP ADDQ,  FF #L DR0 AND,  DR0 S -[ MOV,  NEXT  ;C

CODE (?TERMINAL)   DR7 CLR,  U 7C ( i/o) &[ RP -[ .W MOV,  \ dev
  1 # RP -[ .W MOV, ( routine # ) 0D # TRAP,  DR0 .W TST,
  NE IF, ( eat it)  4 # RP ADDQ,   U 7C ( i/o) &[ RP -[ .W MOV,
  2 # RP -[ .W MOV,  0D # TRAP,  1 # DR7 ADDQ,
  THEN,  DR7 S -[ MOV,  4 # RP ADDQ,  NEXT  ;C
\ 0= 0< >                                 ( 23 10 93 CRC 18:06 )
CODE 0=   DR0 CLR,   S [ TST,   EQ IF,  1 # DR0 ADDQ,  THEN,
  DR0 S [ MOV,  NEXT    ;C

CODE 0<   DR0 CLR,   S [ TST,   MI IF,  1 # DR0 ADDQ,  THEN,
  DR0 S [ MOV,  NEXT    ;C

CODE >    DR0 CLR,  S [+ DR1 MOV,  S [ DR1 CMP,
   LT IF,  1 # DR0 ADDQ,  THEN,  DR0 S [ MOV,  NEXT ;C







\ drop 2drop 2*s 2/s                      ( 19  3 92 CRC 10:39 )
CODE DROP   4 # S ADDQ,  NEXT  ;C

CODE 2DROP  8 # S ADDQ,  NEXT  ;C

CODE 2/S \ n ct -- n | shift right count times
  S [+ DR0 MOV,  S [ DR1 MOV,  DR0 DR1 LSR,  DR1 S [ MOV,  NEXT
;C

CODE 2*S \ n ct -- n | shift left count times
  S [+ DR0 MOV,  S [ DR1 MOV,  DR0 DR1 LSL,  DR1 S [ MOV,  NEXT
;C




\ u*                                      ( 19  3 92 CRC 10:39 )
CODE U*    DR5 RP -[ MOV,  DR6 RP -[ MOV,
        S [+ DR0 MOV,     DR0 DR2 MOV,   DR0 DR4 MOV,
        S [+ DR1 MOV,     DR1 DR3 MOV,   DR1 DR5 MOV,
        DR2 .W SWAP,      DR3 .W SWAP,
        DR2 DR6 MOV,      DR3 DR7 MOV,
        DR7 DR2 MULU,     DR6 DR1 MULU,
        DR5 DR0 MULU,     DR4 DR3 MULU,  DR7 CLR,
        DR0 S -[ .W MOV,  DR0 .W SWAP,
        DR0 DR1 .W ADD,   DR7 DR2 ADDX,  DR2 .W SWAP,
        DR3 DR1 ADD,      DR7 DR2 ADDX,  DR2 .W SWAP,
        DR1 S -[ .W MOV,  DR1 .W SWAP,
        DR1 DR2 .W ADD,   DR2 S -[ MOV,
  RP [+ DR6 MOV,  RP [+ DR5 MOV,    NEXT   ;C


\ u/ 4+ 2+ 1+ =cells                      ( 12  2 87 CRC 17:38 )
CODE U/   S [+ DR2 MOV,  S [+ DR0 MOV,  S [ DR1 MOV,
  1F # DR3 .W MOV,     FALSE DR3 DO,
  1 # DR1 LSL,  1 # DR0 ROXL,   DR2 DR0 SUB,
  CS IF,  DR2 DR0 ADD,  ELSE,  1 # DR1 ADDQ, THEN,  LOOP,
  DR0 S [ MOV,   DR1 S -[ MOV,   NEXT   ;C

CODE 4+  4 # S [ ADDQ,   NEXT ;C

CODE 2+  2 # S [ ADDQ,   NEXT ;C

CODE 1+  1 # S [ ADDQ,   NEXT ;C

CODE =CELLS  S [ DR7 MOV,  1 # DR1 MOVQ,  DR1 DR7 AND,
  DR7 S [ ADD,  NEXT ;C
\ fe # dr0 movq,  1 # s [ addq,  dr0 s [ and,  next ;c
\ and or xor rp! leave ?leave             ( 23  1 92 CRC  9:57 )
CODE AND   S [+ DR7 MOV,  DR7 S [ AND,          NEXT     ;C

CODE OR    S [+ DR7 MOV,  DR7 S [ OR,           NEXT     ;C

CODE XOR   S [+ DR7 MOV,  DR7 S [ EOR,          NEXT     ;C

CODE RP!   10 U &[ RP MOV,                      NEXT     ;C

\       dr5: index                      dr6: limit
CODE LEAVE  DR5 DR6       MOV,                  NEXT     ;C

CODE ?LEAVE  s [+ dr0 mov,  ne if,  dr5 dr6 mov,  then, next  ;c



\ < rot + - d+                            ( 16  2 86 CRC       )
CODE <   DR0 CLR,  S [+ DR1 MOV,  S [ DR1 CMP,
   GT IF,  1 # DR0 ADDQ,  THEN,  DR0 S [ MOV,  NEXT  ;C

CODE ROT   S 8 &[ DR0 MOV,  S 4 &[ S 8 &[ MOV,
   S [ S 4 &[ MOV,  DR0 S [ MOV,  NEXT ;C

CODE +     S [+ DR7 MOV,  DR7 S [ ADD,     NEXT     ;C

CODE -     S [+ DR7 MOV,  DR7 S [ SUB,     NEXT     ;C

CODE D+    S [+ DR0 .L MOV,  S [+ DR1 .L MOV,
           DR1 S 4 &[  ADD,
           S [ DR1 MOV,  DR1 DR0 ADDX,
           DR0 S [ MOV,  NEXT ;C

\ minus dminus over s->d swap dup           17  2 85 CRC
CODE MINUS   S [ NEG,  NEXT  ;C

CODE DMINUS   S 4 &[ NEG,  S [ NEGX,  NEXT ;C

CODE OVER   4 S &[ S -[ MOV,  NEXT ;C

CODE S->D   DR0 CLR, S [  TST,   MI IF,
    1 # DR0 SUBQ,  THEN,  DR0 S -[ MOV,  NEXT ;C

CODE SWAP   S [+ DR0 MOV,  S [ DR1 MOV,
            DR0 S [  MOV,  DR1 S -[ MOV,   NEXT ;C

CODE DUP   S [ S -[ MOV, NEXT  ;C


\ -dup 2dup +! toggle within              ( 27  6 91 CRC  9:17 )
CODE -DUP   S [ TST,  NE IF,  S [ S -[ MOV,  THEN,  NEXT ;C

CODE 2DUP   4 S &[ S -[ MOV,  4 S &[ S -[ MOV,  NEXT ;C

CODE NIP  S [+ S [ MOV,  NEXT   ;C

CODE +!   S [+ AR0 MOV,  S [+ DR1 MOV,  DR1 AR0 [ ADD,  NEXT ;C

CODE TOGGLE   S [+ DR1 MOV,  S [+ AR0 MOV,
              DR1 AR0 [ .B EOR,  NEXT ;C

CODE WITHIN  \ n l1 l2 --- fl | is n between lim1 & lim2 incl.?
 1 # DR0 MOVQ,  S [+ DR1 MOV,   S [+ DR2 MOV,
 S [ DR1 CMP,  LT IF,  DR0 CLR,  THEN,
 S [ DR2 CMP,  GT IF,  DR0 CLR,  THEN,  DR0 S [ MOV,  NEXT ;C
\ @ c@ !                                    21  2 85 CRC
CODE @   S [ AR0 .L MOV,       \ avoid byte boundary
   AR0 [+   S  [ .B MOV,       \ problems
   AR0 [+ 1 S &[ .B MOV,
   AR0 [+ 2 S &[ .B MOV,
   AR0 [  3 S &[ .B MOV,  NEXT  ;C

CODE C@  DR0 CLR,  S [ AR0 .L MOV,
         AR0 [ DR0 .B MOV,
         DR0 S [ MOV,   NEXT ;C

CODE !   S [+ AR0 .L MOV,
         S [+ AR0 [+ .B MOV,
         S [+ AR0 [+ .B MOV,
         S [+ AR0 [+ .B MOV,
         S [+ AR0 [  .B MOV, NEXT ;C
\ c! 4- 2- 1- on off 1+!                  ( 18  3 86 CRC       )
CODE C!  S [+ AR0 MOV,  3 # S ADDQ,
         S [+ AR0 [ .B MOV,  NEXT ;C

CODE 4-  4 # S [ SUBQ,  NEXT ;C

CODE 2-  2 # S [ SUBQ,  NEXT ;C

CODE 1-  1 # S [ SUBQ,  NEXT ;C

CODE ON  S [+ AR0 MOV,  1 # DR0 MOVQ,  DR0 AR0 [ MOV,  NEXT ;C

CODE OFF S [+ AR0 MOV,  AR0 [ CLR,  NEXT                 ;C

CODE 1+! S [+ AR0 MOV,  1 # AR0 [ ADDQ,  NEXT   ;C

\ 6- w@ w! f@ f!                          ( 22 12 91 CRC 12:22 )
CODE 6-  6 # S [ SUBQ,  NEXT ;C

CODE W@   S [+ AR0 MOV,  AR0 1 &[ S -[ .B MOV,
  AR0 [ S -[ .B MOV,  S -[ .W CLR,   NEXT ;C

CODE W!   S [+ AR0 MOV,  2 # S ADDQ,  S [+ AR0 [+ .B MOV,
  S [+ AR0 [ .B MOV,  NEXT  ;C

CODE F@         \ @ from even address only
  S [ AR0 MOV,  AR0 [ S [ MOV,  NEXT  ;C

CODE F!         \ store to even address only
  S [+ AR0 MOV,  S [+ AR0 [ MOV,  NEXT  ;C


\ m*                                        19  2 85 CRC
CODE M*    S [ DR2 MOV,  S 4 &[ DR1 MOV,
   DR1 DR3 MOV,  DR1 DR4 MOV,  DR4 .W SWAP,
   DR2 DR0 MOV,  DR0 .W SWAP,

   DR2 DR1 MULU,  DR4 DR2 MULU,  DR0 DR3 MULU,  DR0 DR4 MULU,

   DR1 .W SWAP,  DR2 DR1 .W ADD,
   DR0 CLR,  DR0 DR4 ADDX,  DR3 DR1 .W ADD,  DR0 DR4 ADDX,
   DR1 .W SWAP,  DR2 .W CLR,  DR2 .W SWAP, DR3 .W CLR,
   DR3 .W SWAP, DR3 DR2 ADD,  DR4 DR2 ADD,

   S [ TST,  MI IF,  S 4 &[ DR2 SUB,  THEN,
   S 4 &[ TST,  MI IF,  S [ DR0 SUB,  THEN,
   DR2 S [ MOV,  DR1 S 4 &[ MOV,
   NEXT ;C
\ cmove                                   ( 20  5 94 CRC 19:50 )
CODE CMOVE  \ slower than qcmove, but larger count
   S [+ DR0 MOV,  S [+ AR1 MOV,  S [+ AR0 MOV,
   NE IF,  BEGIN,  AR0 [+ AR1 [+ .B MOV,  1 # DR0 SUBQ,
           EQ UNTIL,  THEN,  NEXT ;C
DEBUGGING IFTRUE
WARNING F@  WARNING OFF
LABEL PRINTASCII  \ print out a value as an ascii character
  0F #L DR0 AND,   30 # DR0 .W ADD,
  ASCII 9 # DR0 .W CMP,  GT IF,  7 # DR0 .W ADD,  THEN,

LABEL PRINTDR0    \ print a character in dr0
  DR0 RP -[ .W MOV,             2 # RP -[ .W MOV,
  3 # RP -[ .W MOV, \ routine   ^ device
  0D # TRAP,  6 # RP ADDQ,  RTS,
WARNING F!       IFEND
\ m/                                      ( 12  2 92 CRC  9:48 )
DEBUGGING IFTRUE
CODE SHW        \ n -- print n as 32 bit #. For debug.
  20 # DR0 MOVQ,  PRINTDR0 *+ BSR,
  S [ DR4 MOV,  07 # DR3 MOVQ,  FALSE DR3 DO,  4 # DR4 ROL,
  DR4 DR0 MOV,  PRINTASCII *+ BSR,  LOOP,  NEXT  ;C
IFEND   ;S
CODE TM/      EDITOR FLUSH ASSEMBLER  HEX
  S [+ DR2 MOV,  S [+ DR0 MOV,  S [ DR1 MOV,
  DR2 TST,  MI IF,  DR1 NEG,  DR0 NEGX,  DR2 NEG,  THEN,
  DR0 TST,  MI IF,  DR2 DR0 ADD,  THEN,
  1F # DR3 .W MOV,  1 # DR1 LSL,
  FALSE DR3 DO,  1 # DR0 ROXL,  DR2 DR0 SUBX,
      CS IF,  DR2 DR0 ADD,  THEN,  1 # DR1 ROXL,  LOOP,
  DR1 NOT,  DR0 S [ MOV,  DR1 S -[ MOV,  NEXT   ;C   ;S

\ constant variable                       (  5  2 92 CRC  7:49 )
                                \ call to literal -> bra later
: VARIABLE  GAP ( create)  GAP ( , )    GAP ( immediate )
  DOES>  GAP ( literal )  STOP
                                    MUTATES *VARIABLE*

: CONSTANT  GAP ( create ) GAP ( immediate ) GAP ( , )
  DOES> F@ GAP ( literal ) STOP  \ call to literal -> bra later
                MUTATES *CONSTANT*

   40 CONSTANT C/L              20 CONSTANT BL
*B/BUF* CONSTANT B/BUF          400 *B/BUF* / CONSTANT B/SCR
CODE 0  S -[ CLR,  NEXT ;C



\ user some constants +origin             ( 22  2 92 CRC  7:28 )
CODE +ORIGIN  FBASE #L S [ ADD,  NEXT ;C

: USER   GAP ( create)  GAP  ( w, ) GAP ( immediate)  ;CODE
  RP [+ AR0 MOV,  U AC &[ ( ofuser state ) TST,  NE IF,
    DR0 CLR,  AR0 [ DR0 .W MOV,  DR0 S -[ MOV,
    } 41EE GAP ( w,)  GAP ( w,)  2708  GAP ( w,)
    { ASSEMBLER  SETNEW  ELSE,  U DR0 MOV,  AR0 [ DR0 .W ADD,
    DR0 S -[ MOV,   THEN,    NEXT  ;C  MUTATES *USER*

HEX ( |  0 USER MOI           | 0C USER S0       )
        14 USER TIB             18 USER WIDTH
        1C USER WARNING         20 USER FENCE
        24 USER DP              28 USER VOC-LINK


\ initialised user variable               ( 17  2 92 CRC  7:18 )
HEX     2C USER 'KEY            30 USER 'EXPECT
        34 USER '?TERMINAL      38 USER 'EMIT
        3C USER 'TYPE           40 USER 'GOTOXY
        44 USER 'PAGE           48 USER 'LIST
        4C USER 'CR
        50 USER 'R/W            54 USER 'QUIT
        58 USER 'ABORT          5C USER 'CREATE
        60 USER 'FIRST          64 USER 'LIMIT
\         headptr      vnfa       vclnk
\ vocs: ptr->head | pseudoname | voc-link
    68 == HEADPTR   6C == VNFA   70 == VCLNK
|       74 USER BOTSTACK
        78 USER LENGTH  \ len to compile in line
        7C USER I/O \ change  (key) , etc. if you change this
\ last user inited by cold on boot is  i/o
\ uninitialised user variable             ( 15 10 91 CRC 10:10 )
        80 USER LASTTHEN        84 USER LASTSUB
        88 USER REL     \       8c user spare

        90 USER BLK             94 USER IN
        98 USER OUT             9C USER SCR
        A0 USER OFFSET          A4 USER CONTEXT
        A8 USER CURRENT         AC USER STATE
        B0 USER BASE            B4 USER DPL
        B8 USER FLD             BC USER CSP
        C0 USER R#              C4 USER HLD
        C8 USER USE             CC USER PREV




\ first limit here allot , c, w,          ( 22  8 91 CRC 15:08 )
CODE FIRST  OFUSER 'FIRST S -[ MOV,  NEXT     ;C
CODE LIMIT  OFUSER 'LIMIT S -[ MOV,  NEXT     ;C

CODE HERE   OFUSER DP S -[ MOV,  NEXT     ;C

CODE ALLOT  S [+ DR0 MOV,  DR0 OFUSER DP ADD,  NEXT     ;C

CODE ,   OFUSER DP AR0 MOV,
    4 # OFUSER DP ADDQ,   S [+ AR0 [ MOV,  NEXT ;C

CODE C,  OFUSER DP AR0 MOV,
    1 # OFUSER DP ADDQ,  'NF C! CFA 2+ *+ BRA, ;C

CODE W,  OFUSER DP AR0 MOV,
    2 # OFUSER DP ADDQ,  'NF W! CFA 2+ *+ BRA, ;C
\ subroutine threading code               ( 31  8 91 CRC 12:17 )
CODE BACK    OFUSER DP AR0 MOV,   AR0 DR0 MOV,
  DR0 S [ SUB,  'NF W, CFA 4+ *+ BRA,  ;C

LENGTH F@  DUP 10 MAX  LENGTH F!
: <BSR>   REL OFF  2-  HERE -  DUP -80  80 WITHIN
  IF  FF AND  6100 OR  ELSE  6100 W,  THEN  W, ;

: <SUB>         \ addr --  | compile a subroutine to addr
  HERE DUP LASTSUB F!  OVER - -8000  7FFF WITHIN
  IF  <BSR>  ELSE  4EB9 W,  ,  THEN ;

: <COMP>        \ addr --  | subroutine or inline?
  DUP 2- W@  -DUP IF { >R >R } LENGTH  F@ 1+ <
  IF  HERE OVER 2- W@  DUP ALLOT  CMOVE
       ELSE { R> R> } THEN <SUB> THEN ;         LENGTH F!
\ = key emit page cr r/w ?terminal        ( 27  6 91 CRC  9:23 )
CODE = DR0 CLR,  S [+ DR1 MOV,  S [ DR1 CMP,
  EQ IF,  1 # DR0 ADDQ, THEN,  DR0 S [ MOV,   NEXT   ;C

: KEY             PAUSE  'KEY       @EXECUTE    STOP

: EMIT   OUT 1+!  PAUSE  'EMIT      @EXECUTE    STOP

: PAGE                  'PAGE F@ EXECUTE  OUT OFF ;

: CR                    'CR   F@ EXECUTE  OUT OFF ;

: R/W        PAUSE  'R/W       @EXECUTE    STOP

: ?TERMINAL  PAUSE  '?TERMINAL @EXECUTE    STOP

\ traverse latest n>c c>n                 ( 17  2 92 CRC  7:18 )
LABEL (TRAV)   BEGIN,  DR0 AR0 ADD,  7 # AR0 [ .B BTST,
  NE UNTIL,  RTS,

CODE C>N  FE # DR0 MOVQ,  S [ AR0 MOV,  2 # AR0 SUBQ,
  (TRAV) *+ BSR,  AR0 S [ MOV,  NEXT  ;C

CODE N>C   2 # DR0 MOVQ,  S [ AR0 MOV,  1 # AR0 SUBQ, \ was pfa
  (TRAV) *+ BSR,  3 # AR0 .W ADD,  AR0 S [ MOV,  NEXT  ;C

CODE TRAVERSE   S [+ DR0 MOV,  S [ AR0 MOV,
  (TRAV) *+ BSR,  AR0 S [ MOV,  NEXT  ;C

CODE LATEST  OFUSER CURRENT AR0 MOV,  AR0 [ S -[ MOV,  NEXT ;C

: N>L  4- ;
\ space (page) u< ?align 4/ 4*            ( 17  9 88 CRC 12:51 )
: SPACE    BL EMIT  ;

: (PAGE)   0C EMIT  ;

CODE U<   DR0 CLR,  S [+ DR1 MOV,  S [ DR1 CMP,
   HI IF,  1 # DR0 ADDQ,  THEN,  DR0 S [ MOV,  NEXT  ;C

CODE ?ALIGN   OFUSER DP DR0 MOV,  1 # DR1 MOVQ,  DR1 DR0 AND,
          DR0 OFUSER DP ADD,   NEXT ;C
\ ofuser dp ar0 lea,  1 # ar0 [ addq,
\ fe # dr0 movq,  dr0 ar0 [ and,  next ;c

CODE 4/  S [ DR0 MOV,  2 # DR0 LSR,  DR0 S [ MOV,  NEXT ;C

CODE 4*  S [ DR0 MOV,  2 # DR0 LSL,  DR0 S [ MOV,  NEXT ;C
\ !csp ?error ?comp ?exec ?loading        ( 15  2 86 CRC       )
CODE !CSP   S OFUSER CSP MOV,  NEXT     ;C

: ?ERROR    SWAP IF GAP   ( error) ELSE DROP THEN ;

: ?COMP     STATE F@ 0=   11 ?ERROR ;

: ?EXEC     STATE F@      12 ?ERROR ;

: ?PAIRS    -  13 ?ERROR ;

: ?CSP      SP@ CSP F@ - 14 ?ERROR ;

: ?LOADING  BLK F@ 0= 16 ?ERROR ;


\ <compile> [ ] smudge                    ( 10 12 91 CRC 12:22 )
: <COMPILE>    ?COMP  R>  DUP 4+ >R  F@ <COMP> ;
'NF <COMPILE>  CFA  MUTATES *<COMPILE>*

CODE [  OFUSER STATE CLR, NEXT  ;C      IMMEDIATE

CODE ]  C0 #L OFUSER STATE MOV,  NEXT ;C

CODE SMUDGE   OFUSER CURRENT AR0 MOV,
 AR0 [ AR0 MOV,  5 # AR0 [ BCHG,  NEXT ;C






\ hex bounds decimal pad hold :           ( 31  8 91 CRC 10:48 )
CODE HEX      10 # DR0 MOVQ,  DR0 OFUSER BASE MOV,  NEXT ;C

CODE DECIMAL  0A # DR0 MOVQ,  DR0 OFUSER BASE MOV,  NEXT ;C

CODE BOUNDS  S [+ DR0 MOV,  S [ DR1 MOV,  DR1 DR0 ADD,
  DR0 S [ MOV,  DR1 S -[ MOV,  NEXT  ;C

CODE HOLD   1 # OFUSER HLD SUBQ,   OFUSER HLD AR0 MOV,
  S [+ DR0 MOV,  DR0 AR0 [ .B MOV,   NEXT ;C

CODE PAD   OFUSER DP S -[ MOV,  80 #L S [ ADD,  NEXT ;C

: CREATE  'CREATE   @EXECUTE     STOP


\ fill erase blanks abort quit type       ( 31  8 91 CRC 12:15 )
CODE FILL S [+ DR0 MOV,  S [+ DR1 MOV,  S [+ AR0 MOV,
  BEGIN, DR0 AR0 [+ .B MOV,  1 # DR1 SUBQ,  EQ UNTIL,  NEXT ;C

CODE ERASE         DR0 CLR,  'NF FILL CFA 2+ *+ BRA, ;C

CODE BLANKS  BL # DR0 MOVQ,  'NF FILL CFA 2+ *+ BRA, ;C

: QUIT   'QUIT  @EXECUTE STOP      'NF QUIT  CFA MUTATES *QUIT*

: ABORT  'ABORT @EXECUTE STOP      'NF ABORT CFA MUTATES *ABORT*

: TYPE   'TYPE  @EXECUTE STOP



\ replace immediate                       (  5  9 91 CRC 21:29 )
: REPLACE       \ addr  call ---  | calculate call to addr
  DUP W@ 4EB9 = IF  2+ F!  ELSE
    DUP W@ FF AND IF  2DUP 2+ -  FF AND  SWAP 1+ C!
       ELSE  2+ 2DUP -  FFFF AND  SWAP W!  THEN DROP  THEN ;

CODE IMMEDIATE  OFUSER CURRENT AR0 MOV,
 AR0 [ AR0 MOV,  6 # AR0 [ BCHG,  NEXT   ;C

0 VARIABLE ERRNO        \ nothing if not fashionable
                        \ get errno from variable
CODE BYE   -FC FBASE + *+ AR0 MOV,  AR0 USP MOV,
  VAR: ERRNO 2+ *+ RP -[ .W MOV,
  4C # RP -[ .W MOV,  1 # TRAP,  ;C     \ like the MTA....


\ (;code) does>                           ( 19  3 92 CRC 10:37 )
\ replace jsr operand.  create  now makes 'em immediate!
: (;CODE)  IMMEDIATE  R>  LATEST N>C  REPLACE  LASTSUB OFF ;
'NF (;CODE) CFA MUTATES *(;CODE)*

HERE DELTA - MUTATES *DOES>* ?CR
  ASSEMBLER  LABEL DODOES
  RP [+ AR0 MOV,        \ save does> address
  RP [+ S -[ MOV,       \ get data addr on stack
  AR0 [ JMP,            \ go do the does> code.

: DOES>  REL OFF  COMPILE (;CODE) { SETNEW
  ASSEMBLER DODOES NEWFORTH } LITERAL <SUB>
  LASTSUB OFF  ; IMMEDIATE


\ count (type) -trailing (.") (cr)        ( 30  8 86 CRC 16:30 )
CODE COUNT  S [ AR0 MOV,  1 # S [ ADDQ,  DR0 CLR,
  AR0 [ DR0 .B MOV,  DR0 S -[ MOV,  NEXT   ;C

: (TYPE) -DUP IF BOUNDS DO I C@ EMIT LOOP  ELSE DROP THEN ;

CODE -TRAILING  S [+ DR0 MOV,  S [ AR0 MOV,  DR0 AR0 ADD,
  1 # DR0 ADDQ, BEGIN, 1 # DR0 SUBQ, NE IF, BL # AR0 -[ .B CMP,
  DROP ROT ROT NE UNTIL,  2 THEN,  DR0 S -[ MOV,  NEXT  ;C

: (.") R COUNT DUP 1+ =CELLS  R> + >R TYPE ;
   'NF (.")           CFA  MUTATES *(.")*

: (CR)  ."   " ;


\ ." (expect) expect query                ( 27  1 92 CRC 10:27 )
: ." ASCII "  STATE F@
     IF COMPILE (.") GAP ( word)  HERE C@ 1+ =CELLS ALLOT
     ELSE GAP ( word) HERE COUNT TYPE THEN ;          IMMEDIATE

: (EXPECT) OVER + OVER          \ add for atari/ibm pc keyboard
     DO KEY DUP 14 +ORIGIN W@ =   OVER 16 +ORIGIN W@ = OR
        IF DROP 08 OVER I = DUP I 2- + I! - ELSE
          DUP 0D = IF LEAVE DROP BL 0 ELSE  DUP THEN I C!
        0 I 1+ C! THEN   EMIT ( DROP)  LOOP  DROP ;

: EXPECT  PAUSE 'EXPECT  @EXECUTE  STOP

: QUERY TIB F@ 50  EXPECT  IN OFF  ;


\ x pad word upper (number)               ( 31  8 91 CRC 10:50 )
: X       BLK F@ IF ?EXEC THEN RDROP ;  IMMEDIATE

: WORD BLK F@ IF BLK F@  GAP  ELSE  TIB F@ THEN IN F@ + SWAP
  ENCLOSE HERE 22 BLANKS IN +! OVER - >R  R HERE C!
  + HERE 1+ R> CMOVE  ;  \  gap = block

CODE UPPER  S [+ DR0 MOV,  S [+ AR0 MOV,
  ASCII a # DR2 .B MOVQ,  ASCII z # DR3 .B MOVQ,  DR0 FALSE DO,
  AR0 [ DR1 .B MOV,  DR1 DR3 .B CMP,  HS IF,  DR1 DR2 .B CMP,
    LS IF,  20 # AR0 [ .B EOR,  THEN,  THEN,   1 # AR0 ADDQ,
    LOOP, NEXT   ;C

: (NUMBER) BEGIN 1+ DUP >R C@ BASE F@ DIGIT
  WHILE SWAP BASE F@ U* DROP ROT BASE  F@ U* D+
       DPL F@ 1+ IF DPL 1+! THEN R> REPEAT R> ;
\ number -find error id.                  ( 30  8 91 CRC 22:28 )
: NUMBER 0 0 ROT DUP 1+ C@ ASCII - = DUP >R + -1
  BEGIN DPL F! (NUMBER) DUP C@ BL -
      WHILE DUP C@ ASCII . - 0 ?ERROR 0 REPEAT
  DROP R> IF DMINUS THEN ;
LENGTH F@  DUP 0A MAX  LENGTH F!
: -FIND   BL WORD  HERE COUNT UPPER  HERE CONTEXT F@ F@
  (FIND) DUP 0= IF DROP HERE LATEST  (FIND) THEN ;
             LENGTH F!
: ERROR   WARNING F@ 0<
  IF ABORT THEN HERE COUNT TYPE ."  ? "
  GAP ( message) SP!  BLK F@ IF IN F@ BLK F@ THEN
  QUIT                                STOP

: ID. PAD BL ASCII _ FILL DUP N>C 2- OVER -
     PAD SWAP CMOVE PAD COUNT 1F AND TYPE SPACE ;
\ b/drv maxblk drive setu/p empty-buffers (  6  1 94 CRC 10:33 )
DECIMAL
| 360 VARIABLE 'B/DRV           719 VARIABLE 'MAXBLK
| 360 VARIABLE 'B/SIDE          \   359 for 1 drive

CODE MAXBLK VAR: 'MAXBLK  @#L S -[ MOV,  NEXT ;C
CODE B/DRV  VAR: 'B/DRV   @#L S -[ MOV,  NEXT ;C
CODE B/SIDE VAR: 'B/SIDE  @#L S -[ MOV,  NEXT ;C

: DRIVE  B/DRV  U* DROP OFFSET F! ;
HEX
CODE SETU/P          OFUSER 'FIRST DR0 MOV,
  DR0 OFUSER USE MOV,  DR0 OFUSER PREV MOV,  NEXT ;C

: EMPTY-BUFFERS FIRST LIMIT OVER - ERASE SETU/P ;

\ {compile] literal                       ( 30  6 93 CRC 22:54 )
: [COMPILE] -FIND 0= 0 ?ERROR DROP <COMP> ;  IMMEDIATE

: LITERAL   STATE F@ IF  DUP -80 7F WITHIN IF
    FF AND  7000 OR  W,  2700 W,  ELSE
 (  DUP HERE -  -8000 8000 WITHIN IF
      41FA W,  HERE - W,  2708 W,
      ELSE ) 273C W, ,  THEN  THEN ( THEN ) ;
IMMEDIATE







\ dliteral ?stack interpret               ( 31  8 91 CRC 10:24 )
: DLITERAL  STATE F@ IF SWAP [COMPILE] LITERAL
        [COMPILE] LITERAL  THEN ;                   IMMEDIATE

: ?STACK  S0 F@ SP@             U< 1 ?ERROR
                SP@ BOTSTACK F@ U< 7 ?ERROR ;
\ fixed so that tos & bos are user variables for multitasking

: INTERPRET   BEGIN -FIND  IF  ( found) STATE F@ <
    IF  <COMP>  ELSE  EXECUTE  THEN
    ELSE HERE NUMBER  DPL F@ 1+
    IF [COMPILE] DLITERAL ELSE DROP [COMPILE] LITERAL THEN
        THEN ?STACK AGAIN     STOP



\ vocabulary forth definitions (          ( 14  2 92 CRC  9:22 )
: VOCABULARY   CREATE  CURRENT F@ 4+ ,  81A00000  ,
  HERE  VOC-LINK F@ ,  VOC-LINK F!  ;CODE
  RP [+ OFUSER CONTEXT MOV,  NEXT ;C
FIXED   MUTATES *VOCAB*
\  Romable vocabulary !!!!!
CODE FORTH   U HEADPTR &[ AR0 LEA,  AR0 OFUSER CONTEXT MOV,
 NEXT  ;C       IMMEDIATE

CODE DEFINITIONS  OFUSER CONTEXT  OFUSER CURRENT MOV,  NEXT ;C

: (  ASCII ) WORD      ;                             IMMEDIATE
;s        headptr      vnfa       vclnk
  vocs: ptr->head | pseudoname | voc-link


\ compile (quit) (abort)                  ( 26  2 92 CRC 12:59 )
DECIMAL \ patch today's date into (abort). automated version ctl
(DATE)  BLK F@ BLOCK  682 + SWAP CMOVE  UPDATE   HEX

: COMPILE   { 'NF <COMPILE> CFA } LITERAL  <COMP>
  -FIND 0= 0 ?ERROR DROP , ;        IMMEDIATE

: (QUIT)   BLK OFF [COMPILE] [  BEGIN BEGIN
  RP! CR QUERY INTERPRET  STATE F@ 0= UNTIL ."  ok" AGAIN STOP

: (ABORT) SP! DECIMAL CR ." FastForth 3.0 24  9 19 "
  [COMPILE] FORTH  DEFINITIONS  QUIT  STOP

  SETNEW (GETTIME) W, SETOLD    LABEL TIMESTAMP


\ empt startup                            ( 28  9 93 CRC 10:30 )
| -1 VARIABLE EMPT      \ should be a constant when we rom

LABEL  STRTUP   cr ." strtup = " STRTUP 6 U.R

} RP!  SP!              \ install in the iob: the count.
  EMPT F@ IF EMPT OFF EMPTY-BUFFERS THEN
  -F8 +ORIGIN F@ -DUP IF  EXECUTE  THEN \ -1 BADMAP F!
  SETU/P  OFFSET OFF  ABORT {







\ ct->0 getcmd cmdboot                    (  4  8 91 CRC 12:53 )
CODE CT->0      \ addr ---  addr ct | count to next 0
  S [ AR0 MOV,  BEGIN,  AR0 [+ DR0 .B MOV,  EQ UNTIL,
  1 # AR0 SUBQ,  S [ AR0 SUB,  AR0 S -[ MOV,  NEXT ;C

| : GETCMD        \  --- addr ct | return addr & ct of cmd line
  -100 +ORIGIN F@  80 + DUP C@   \  desktop or msh?
  7F - IF  COUNT  ELSE  1+ CT->0  THEN ;

| : CMDBOOT       \  ---  | fetch & execute command line
  { 'NF (QUIT) CFA } LITERAL 'QUIT F!
  GETCMD  DUP IF  CR 2DUP TYPE  SPACE  2DUP + 4 ERASE  2DUP
  TIB F@ SWAP  1+  CMOVE  IN OFF  DROP 1- OFF  INTERPRET
  CTL G EMIT   ELSE  2DROP  THEN  QUIT STOP


\ ff.scr (clf)                            (  9 11 92 CRC 18:40 )
\ : FILE:   CREATE  0 ,  BL FWORD  HERE C@ 2+ ALLOT ?ALIGN
\   DOES> ;               FIXED

0 VARIABLE FF.SCR       TXT ff.scr"  0 HERE 1- C!

CODE (CLF) \ handle --- ec | close file at handle
  S [ DR0 MOV,  DR0 RP -[ .W MOV,
  3E # RP -[ .W MOV,  1 # TRAP,  4 # RP ADDQ,  DR0 S [ MOV,
  NEXT  ;C






\ lseek variables                         ( 13  6 93 CRC 19:13 )
        \ type: 0= from start 1= rel to current  2=from end
CODE LSEEK      \ faddr handle type --- fl |
  RP DR7 MOV,  S [+ DR0 MOV,  DR0 RP -[ .W MOV, \  type
  S [+ DR0 MOV,  DR0 RP -[ .W MOV,              \  handle
  S [ RP -[ MOV,  ( addr)  42 # RP -[ .W MOV,   1 # TRAP,
  DR7 RP MOV,  DR0 S [ MOV,  NEXT  ;C

0 VARIABLE (ATT)

'NF FF.SCR 2+ F@ DUP
        VARIABLE RHANDLE
        VARIABLE WHANDLE



\ openit (opf)                            ( 20 10 92 CRC  9:55 )
CODE (OPF) \ addr --- handle/ec | open file at addr
  'NF (ATT) 2+ F@ *+ RP -[ .W MOV,  S [ RP -[ MOV,
  3D # RP -[ .W MOV,  1 # TRAP,  8 # RP ADDQ,  DR0  S [ MOV,
  NEXT  ;C

: OPENIT
  { 'NF FF.SCR 2+ F@ 5 + } LITERAL  (OPF)
  DUP 0< IF  WARNING OFF ." *Can't find file  "
  { SETNEW CTL G  HERE 2- C! }
  { 'NF FF.SCR 2+ F@ 4+ } LITERAL COUNT TYPE
  ELSE  FF.SCR F!  FF.SCR  DUP RHANDLE F!  WHANDLE F!
  0 RHANDLE F@ F@ 2  LSEEK  0 B/BUF U/  1- 'MAXBLK F!  THEN
  DROP ;


\ rdf wtf                                 ( 13  6 93 CRC 19:44 )
CODE RDF   \ addr count handle --- ct/er | read from addr for
    \ count bytes to file/handle. Return count read or error.
  RP DR7 MOV,  S [+ DR0 MOV,
  S [+ DR1 MOV,  S [ RP -[ MOV, ( addr )  DR1 RP -[ MOV, ( ct)
  DR0 RP -[ .W MOV, ( handle)  3F # RP -[ .W MOV,
  1 # TRAP,  DR7 RP MOV,  DR0  S [ MOV,  NEXT  ;C

CODE WTF   \ addr count handle --- ct/er | read to addr for
    \ count bytes from file/handle. Return count read or error.
  RP DR7 MOV,  S [+ DR0 MOV,
  S [+ DR1 MOV,  S [ RP -[ MOV, ( addr )  DR1 RP -[ MOV, ( ct)
  DR0 RP -[ .W MOV, ( handle)  40 # RP -[ .W MOV,
  1 # TRAP,  DR7 RP MOV,  DR0  S [ MOV,  NEXT  ;C


\ auto-file time update code              (  3  8 93 CRC 20:45 )
CODE FDATE     \ hndl  ---  hndl | set time & date of file
  RP DR7 MOV,  S [ DR3 MOV,             \ save stack, handle
  2A # RP -[ .W MOV,  1 # TRAP,         \ get date
  DR0 S -[ .W MOV,                      \ date stored
  2C # RP -[ .W MOV,  1 # TRAP,         \ get time
  DR0 S -[ .W MOV,                      \ time stored
  1 # RP -[ .W MOV,                     \ flag
  DR3 RP -[ .W MOV,                     \ handle
  S RP -[ MOV,                          \ buffer addr
  57 # RP -[ .W MOV,  1 # TRAP,         \ do it
  4 # S ADDQ,                           \ drop storage space
  DR7 RP MOV,  NEXT  ;C                 \ restore stack



\ Memory setup                            (  1  9 93 CRC 20:51 )
\ do setup for memory here. Return highest addr in dr0
LABEL -SETSTUF-
ASSEMBLER  0 #L DR0 MOV,   -4 ALLOT
 \ this is done to leave the opcode of an #L MOV, in place. If
 \ the user wants to force a given high address, he can  !  it
 \ in over the next opcode, and patch the bsr in  COLD  to
 \ point to this opcode instead of to SETSTUF.

HEX  \ do setup for memory here. Return highest addr in dr0
LABEL SETSTUF     \ forth boot parameters in ar0.
-F4 FBASE + *+ DR0 MOV,        ;S

436 @# DR0 .L MOV,   \  _memtop, top of available memory


\ Memory setup                            (  1  9 93 CRC 20:51 )
    \ enter here with pre-calculated memory size in dr0
  FBASE *+ AR0 LEA,    DR0 DR1 MOV,
  TM   TOS - #L DR1 SUB,        DR1 AR0 1C &[ MOV, \ tos
  TOS  BOT - #L DR1 SUB,        DR1 AR0 84 &[ MOV, \ bos
  BOT  RTS - #L DR1 SUB,        DR1 AR0 20 &[ MOV, \ rts
  RTS TIBX - #L DR1 SUB,        DR1 AR0 24 &[ MOV, \ tib
  US #L DR1 SUB,  DR1 DR2 MOV,  DR1 AR0 18 &[ MOV, \ uarea
    VCLNK #L DR1 ADD,  \ get offset into users of forth vocab
                                DR1 AR0 38 &[ MOV, \ voc-link
  100        #L DR2 SUB,        DR2 AR0 74 &[ MOV, \ limit
  CO         #L DR2 SUB,        DR2 AR0 70 &[ MOV, \ first
  RTS,



















\ setsup                                  (  2  6 86 CRC 10:47 )
LABEL SETSUP
  18 FBASE + *+ U MOV, \ set user area pointer

  FBASE 10 + *+ AR1 LEA,  \ from addr
  U   AR0 MOV, \ to addrs
  AR1 DR2 ADD, \ limit of the move

BEGIN,  AR1 [+ AR0 [+ MOV,  AR1 DR2 .L CMP,  LT UNTIL,
\ move user area stuff out from cold start area

  RTS,  \ execute cold start orphan




\ cold                                    ( 15  7 92 CRC  9:23 )
CODE COLD
LABEL COLDSTART         \ supervisor code moved to loader
 SETSTUF *+ BSR,
 'NF RHANDLE 2+ F@ *+ AR5 LEA, AR5 [ AR0 MOV,  AR0 [ DR0 MOV,
 'NF (CLF) F@ 2+ *+ BSR,        AR5 [ CLR,
 AR5  'NF WHANDLE 2+ F@  'NF RHANDLE 2+ F@ -  &[ CLR,
 COLDS #L DR2 .L MOV,  FALSE IF,    \ forced

LABEL WARM   10 #L DR2 .L MOV,  THEN,
      SETSUP *+ BSR,    STRTUP *+ BRA, ;C       ;S

DR2 contains the number of words moved into the user area; by
the end of the setup it has the address of the last byte moved.
DR0 has the top address in memory placed in it.

\ +buf update +- d+- abs dabs             ( 16  5 86 CRC 15:48 )
CODE +BUF \ bufaddr --- bufaddr' | locate next buffer in ram
  DR1 CLR,  S [ DR0 MOV,  6 *B/BUF* + #L DR0 ADD,
  OFUSER 'LIMIT DR0 CMP,
     EQ IF,  OFUSER 'FIRST DR0 MOV,  THEN,  DR0 S [ MOV,
  OFUSER PREV DR0 CMP,  NE IF,  1 # DR1 ADDQ,  THEN,
  DR1 S -[ MOV,  NEXT   ;C

CODE UPDATE   \  ---  | flag most recent buffer as updated
  OFUSER PREV AR0 MOV,  7 # AR0 [ .B BSET,  NEXT ;C

CODE +-  S [+ TST, MI IF,               S [ NEG,  THEN, NEXT ;C
CODE D+- S [+ TST, MI IF,  4 S &[ NEG,  S [ NEGX, THEN, NEXT ;C

CODE ABS S [  TST, MI IF,  S [ NEG, THEN,               NEXT ;C
: DABS    DUP D+-  ;
\ arithmetic stuff -- min  to */          ( 22  5 86 CRC 16:56 )
CODE MIN  S [+ DR0 MOV,  S [ DR1 MOV,  DR0 DR1 CMP,
  PL IF,  DR0 S [ MOV,  THEN,  NEXT    ;C
CODE MAX  S [+ DR0 MOV,  S [ DR1 MOV,  DR0 DR1 CMP,
  MI IF,  DR0 S [ MOV,  THEN,  NEXT    ;C

: M/      OVER >R >R DABS
              R ABS U/ R> R XOR +- SWAP R> +- SWAP ;
: *       U* DROP ;
: /MOD    >R S->D R> M/ ;
: /       /MOD      NIP  ;
: MOD     /MOD      DROP ;
: */MOD   >R M* R> M/ ;
: */      */MOD NIP ;
: M/MOD   >R 0 R U/ R> SWAP >R U/ R> ;

\ numeric output                          ( 22  2 92 CRC  7:29 )
: SPACES  0 MAX -DUP IF 0 DO SPACE LOOP THEN ;

CODE <#   U OFUSER HLD MOV, NEXT ;C   \ must be moi to use w/
: #>    2DROP HLD F@ MOI   OVER - ; \ wp-forth &/or tasker !!!
: SIGN  ROT 0< IF ASCII - HOLD THEN ;
: #     BASE F@ M/MOD ROT 9 OVER < IF 7 + THEN ASCII 0 + HOLD ;
: #S    BEGIN # 2DUP OR 0= UNTIL ;
: D.R   >R SWAP  OVER  DABS  <#  #S  SIGN #>
        R> OVER  -  SPACES  TYPE ;
: D.    0 D.R SPACE ;
: .R    >R S->D R> D.R ;
: .     S->D D. ;               : ?       @ . ;
: W?    W@ . ;                  : C?      C@ . ;


\ vlist buffer r                          ( 17  2 92 CRC  7:18 )
: VLIST   CR  CONTEXT F@ F@  BEGIN OUT F@ C/L >   IF  CR THEN
     DUP ID. SPACE SPACE N>L  F@
     DUP 0=  ?TERMINAL OR UNTIL   DROP  ;

: BUFFER   USE F@ DUP >R BEGIN +BUF UNTIL  USE F!
  R F@  0< IF  R 4+  R F@  7FFFFFFF AND  0 R/W  THEN
  R F! R PREV F! R> 4+ ;

CODE R  OFUSER STATE TST,  NE IF, 2717 #L S -[ MOV,
  'NF W, CFA *+ BRA,  THEN,  4 RP &[  S -[ MOV,
  NEXT  ;C      IMMEDIATE




\ block (line) .line message load -->     ( 27 10 86 CRC 13:17 )
: BLOCK   PAUSE OFFSET F@ + >R PREV F@ DUP F@ R - DUP +
    IF BEGIN +BUF 0= IF DROP R BUFFER DUP R 1 R/W 4- THEN
       DUP F@ R - DUP + 0= UNTIL DUP PREV F!  THEN RDROP  4+ ;

: (LINE)  >R C/L B/BUF */MOD R>  + BLOCK + C/L ;
: .LINE   (LINE) -TRAILING TYPE ;

: MESSAGE WARNING F@ IF ( we have disk ) -DUP
       IF 1 OFFSET F@ - .LINE THEN ELSE  \ 4 is fig std.
          ." msg # " .  THEN ;

: LOAD  BLK F@ >R  IN F@ >R  IN OFF BLK F!  INTERPRET
        R> IN F!   R> BLK F! ;

: --> ?LOADING IN OFF BLK 1+! ;               IMMEDIATE
\ #bufs flush >r r>                       ( 19  3 92 CRC 10:47 )
: #BUFS  LIMIT FIRST -  { *B/BUF*  6 + } LITERAL  /MOD
     SWAP IF ." Bad buffers!"  EMPT ON COLD  THEN ;

: FLUSH  #BUFS  1+  0 DO 7FFFFFFF BUFFER DROP LOOP ;

CODE >R  OFUSER STATE TST,  NE IF, 2F1B #L S -[ MOV,
  'NF W, CFA *+ BRA,  THEN,  RP [ AR0 MOV,
  S [+ RP [ MOV,  AR0 [ JMP,    ;C     IMMEDIATE

CODE R>  OFUSER STATE TST,  NE IF, 271F #L S -[ MOV,
  'NF W, CFA *+ BRA,  THEN,  RP [+ AR0 MOV,
  RP [+ S -[ MOV,  AR0 [ JMP,   ;C     IMMEDIATE



















\ (r/w)                                   ( 31 12 92 CRC 18:27 )
: (R/W)         \ addr blk# r/w --- | r/w for a file once opened
  OVER MAXBLK > 6 ?ERROR  OVER  0< 6 ?ERROR
  RHANDLE F@ IFL >R  0a 2*s ( B/BUF * )
  R IF  RHANDLE F@ ELSE  WHANDLE F@ THEN  F@ 0 LSEEK
      dup 0< if  10 .r  space then    \  2019 02 07
      0< IF ."  File Seek Error " 0 ERROR THEN
      B/BUF R> IF  RHANDLE F@ F@ RDF
          ELSE  WHANDLE F@ F@  FDATE WTF  THEN
      dup 0< if  10 .r  space then    \  2019 02 07
      B/BUF - IF ."  File Size Overflow "  0 ERROR THEN
    ELSEL ."  File not open!!" 0 ERROR THENL ;




\ ' index list (list)                       25 12 84 CRC
: '   -FIND  0= 0 ?ERROR  DROP  [COMPILE] LITERAL  ; IMMEDIATE

: INDEX   CR  1+  SWAP    DO CR I  5 .R
   SPACE  0  I .LINE  ?TERMINAL  IF  LEAVE  THEN   LOOP ;

: LIST    'LIST @EXECUTE STOP

: (LIST)    DECIMAL
   CR  DUP  SCR F!  ." scr # "   .  10 0
   DO  CR I 3 .R SPACE I SCR F@ .LINE  LOOP CR ;





\ forget, multitasking version            ( 14  2 92 CRC  9:18 )
| : PFUI   TIB OVER U< IF TIB - THEN  ;
| : PFUI2  PFUI >R PFUI R>         U< ;
    \ filtre addresses outside our task.         \ multitasking
| CODE TASKFIX   VCLNK ( forth's voc link) U &[ AR0 LEA,
  S [ AR0 CMP,  LE IF,  AR0 S [ MOV,  THEN,  NEXT      ;C
: (FORGET) \ pfa ---  | can be compiled into definitions
  C>N  DUP FENCE F@ PFUI2 15 ?ERROR
   >R  VOC-LINK F@  TASKFIX         BEGIN
     R OVER PFUI2 WHILE [COMPILE] FORTH  DEFINITIONS
     F@ TASKFIX DUP VOC-LINK F!  REPEAT      BEGIN  PAUSE
        DUP 4- BEGIN N>L F@  TASKFIX  DUP R PFUI2  UNTIL
     OVER 4- N>L F!  F@ TASKFIX -DUP 0= UNTIL   R> N>L DP F! ;
: FORGET   [COMPILE] ' STATE F@ IF COMPILE (FORGET)
                                ELSE (FORGET) THEN ;  IMMEDIATE
;S Make  FORGET  smart enough to compile it!! Very useful!
\ wherenow                                (  3 10 93 CRC 20:47 )
: WHERENOW      ( line start & blk compressed for storage )
  BLK F@  OFFSET F@ +  5 2*s  IN F@  5 2/s  OR ;













\ (create) :                              (  3 10 93 CRC 20:47 )
: (CREATE)     FIRST HERE 0A0 + U< 2 ?ERROR
  ?ALIGN  0 ,  ( see: ) LATEST ,        \ link field
  -FIND IF DROP C>N ID.   4 MESSAGE SPACE THEN
  HERE  DUP C@ WIDTH F@ MIN 1+ =CELLS ALLOT
  DUP C0 TOGGLE HERE 1- 80 TOGGLE
  CURRENT F@ F!                 \ set voc to new name field
  WHERENOW LATEST 8 - F!        \ see: data
  0 W,                          \ len
  { *VARIABLE* F@ } LITERAL <SUB> ;

: :   ?EXEC !CSP  CURRENT F@ CONTEXT F!  CREATE  SMUDGE
  IMMEDIATE  REL ON  LATEST N>C  DP F!  ] ;



\ compiler directives                     ( 24  7 93 CRC 21:34 )
: DO    ?COMP  COMPILE (DO) HERE 3 ;           IMMEDIATE
: LOOP         3 ?PAIRS COMPILE (LOOP)  BACK ; IMMEDIATE
: +LOOP        3 ?PAIRS COMPILE (+LOOP) BACK ; IMMEDIATE

: 0BRAN 201B6700 , \ s [+ dr0 .l mov,  2 *+ eq bcc,
                        HERE  0 W, ;
: BRAN  60000000 ( 2 *+ bra, ) ,  HERE 2- ;
: RESOLVE       HERE OVER -  SWAP  W! ;

: IF    ?COMP  0BRAN 2 ;                        IMMEDIATE
: THEN   HERE LASTTHEN F!
        ?COMP  2 ?PAIRS  RESOLVE ;              IMMEDIATE

: ELSE  2 ?PAIRS  BRAN
        SWAP 2 [COMPILE] THEN  2 ;              IMMEDIATE
\ compiler directives                     (  9 10 91 CRC 12:41 )
: ENDIF [COMPILE]  THEN  ;                      IMMEDIATE
: BEGIN ?COMP HERE 1 ;                          IMMEDIATE

| : SBKWD  10000 /  HERE ROT SWAP - 2-   FF AND OR  W, ;
| : LBKWD           HERE ROT SWAP - 2- FFFF AND OR   , ;
| : BKWD  OVER HERE -  2-  -7F 7F WITHIN
        IF SBKWD ELSE LBKWD THEN ;

: UNTIL 1 ?PAIRS  201B W,  67000000 BKWD ;      IMMEDIATE
: AGAIN 1 ?PAIRS           60000000 BKWD ;      IMMEDIATE
: REPEAT        >R >R [COMPILE] AGAIN R> R> 2-
                [COMPILE] THEN  ;               IMMEDIATE
: WHILE [COMPILE] IF 2+ ;                       IMMEDIATE
: END   [COMPILE]  UNTIL ;                      IMMEDIATE

( good stuff to have in the nucleus       (  2 10 91 CRC 13:28 )
: EXECS   BEGIN -FIND  IF  ( found) STATE F@ <
    IF  ,  ELSE  EXECUTE  THEN
    ELSE  0 ?ERROR  THEN  ?STACK  STATE F@ 0= UNTIL  ;

: EXEC  COMPILE <EXEC>  EXECS ;    IMMEDIATE

: LEN   N>C 2- ;        ( nfa -- lnfa )

: LEN?   2- W? ;        ( cfa  --  | display moveable length )
(
: ?LEN:  [COMPILE] ' LEN? ; ( --  | len of next word in stream)

: SETLEN   LATEST LEN  W! ;

: FIXED    0 SETLEN ;   ( don't copy into new words. )
( good stuff to have in the nucleus       (  2 10 91 CRC 11:27 )
: (RES)         ( addr ---  | resolve bsr/jsr at addr )
  DUP W@  DUP 4EB9 =  SWAP 4EF9 =  OR IF  2+ F@  ELSE \ jsr/jmp
  DUP W@  FF AND IF  DUP 1+ C@  DUP 80 AND            \ bsr s
      IF  FFFFFF00 OR  THEN + 2+  ELSE
  2+ DUP  W@  DUP  8000  AND  IF  FFFF0000 OR  THEN + \ bsr l
                                           THEN   THEN ;

: C>P     ( cfa --- pfa  | find the parameter field )
  DUP W@ 6100 = IF  4+  ELSE  DUP W@ 4EB9 =
  OVER W@ 4EF9 =  OR  IF 6 +  ELSE  2+  THEN THEN ;

| : 6SR LASTSUB F@  W@ 4EB9
            = IF  4EF9  LASTSUB F@ W!  0  ELSE  1  THEN ;

| : DOBSR   = IF    60  LASTSUB F@ C!  0  ELSE  1  THEN ;
\ smart next code                         ( 26  2 92 CRC 12:08 )
| : 2SR LASTSUB F@  W@ FF00 AND 6100  DOBSR ;
| : 4SR LASTSUB F@  W@ 6100           DOBSR ;

        \ --- fl | 1 indicates failure to change bsr to bra, etc
| : LAST?  REL F@ 0=  HERE  LATEST N>C -    LENGTH F@ 1- >  OR
  IF  HERE LASTSUB F@ -
    DUP 2 = IF  DROP 2SR  ELSE    DUP 4 = IF  DROP 4SR  ELSE
        6 = IF  6SR  ELSE  1  THEN  THEN  THEN  ELSE 1 THEN ;

: SETL  REL F@ IF  HERE LATEST N>C  -  SETLEN  THEN  ;

: ;  ?COMP ?CSP    SETL HERE LASTTHEN F@ -
\  a         b             b            b     a              a
  IF  LAST?  IF  4E75 W,  ELSE  FIXED  THEN  ELSE  4E75 W, THEN
  SMUDGE [COMPILE] [ ;   IMMEDIATE
\ version checksum code                   ( 26  2 92 CRC 12:59 )
\ the checksum is the starting address exclusive ored with each
\ byte in the given range. Thus, the same data at different
\ addresses will give a different checksum.

CODE CHX        \ addr ct -- chk | accumulate checksum over area
  S [+ DR1 MOV,  1 # DR1 SUBQ,  S [ AR0 MOV,  AR0 DR0 MOV,
  DR1 FALSE DO,  AR0 [+ DR2 .B MOV,  DR2 DR0 .B EOR,  LOOP,
  DR0 S [ MOV,  NEXT  ;C

: SYSCHK        \  ---  chk | compute partial nucleus checksum
  0 +ORIGIN 7E  CHX
  { 'NF (ABORT) CFA  DUP } LITERAL
  { ASSEMBLER TIMESTAMP SWAP - } LITERAL  CHX  + ;


\ syscheck                                ( 26  9 93 CRC 17:19 )
: SYSCHECK      \ blk# --  fl | verify version of overlay
  BLOCK 2+  DUP  F@  HERE -   SWAP 4+ F@  SYSCHK -  + ;













( improved overlays                       ( 25  8 93 CRC 18:22 )
\ 0 VARIABLE >MEM      ( --> mem to pick up          )
\ 0 VARIABLE +HEAD     ( --> start in first block    )
\ |  D0 USER >MEM                 | D4 USER +HEAD now macros

| CODE HEAD@+   ( ofuser +head) D4 U &[ AR0 LEA,
  AR0 [ S -[ MOV,  4 # AR0 [ ADDQ,  NEXT  ;C

| : ADVANCE   DUP >MEM +!  CMOVE   ASCII . EMIT ;

| : NEWBLK    BUFFER  DUP B/BUF ERASE  UPDATE ;
    ;s
| : CHKORG   0 +ORIGIN - 1D ?ERROR ;
    ;s
| : HEAD@+    +HEAD F@  4 +HEAD +!  ;
| : ADVANCE   DUP >MEM +!  CMOVE   2E EMIT ;
( improved overlays                       ( 25  8 93 CRC 18:23 )
| : GETDICT   ( addr --- | build overlay restoration info )
  2+ +HEAD F!             ( set pointer past raw block flag  )
  [COMPILE] ' C>N N>L 4- DUP  ( starting point               )
    >MEM F!     HEAD@+ F!     ( starting point               )
\ 0 +ORIGIN     HEAD@+ F!     ( origin, for relocating kernel)
  SYSCHK        HEAD@+ F!     ( nucleus checkum              )
  HERE          HEAD@+ F!     ( top of dictionary            )
  CURRENT F@    HEAD@+ F!     ( current vocabulary           )
  CONTEXT F@    HEAD@+ F!     ( context                      )
  VOC-LINK DUP  F@ HEAD@+ F!  ( vocabulary chain start       )
             BEGIN  F@ -DUP   ( vocabulary chain             )
      WHILE  DUP N>L 4- F@ HEAD@+  F! REPEAT
  HEAD@+ OFF ;                ( end of data                  )

: VERCHK  SYSCHK - 1D ?ERROR ;
( improved overlays                       (  4  1 88 crc  8:24 )
| : SETDICT   ( addr ---  | build overlay restoration info     )
  2+ +HEAD F!               ( set pointer past raw block flag  )
  HEAD@+ F@        >MEM F!    ( starting point               )
\ HEAD@+ F@         CHKORG    ( check origin                 )
  HEAD@+ F@         VERCHK    ( nucleus checkum              )
  HEAD@+ F@          DP F!    ( top of dictionary            )
  HEAD@+ F@     CURRENT F!    ( current vocabulary           )
  HEAD@+ F@     CONTEXT F!    ( context                      )
  HEAD@+ F@    VOC-LINK F! ;  ( vocabulary chain start       )

| : SETVOCS   ( addr ---  | install vocabulary link pointers   )
  +HEAD F!                     ( set pointer                  )
  VOC-LINK   BEGIN  F@  -DUP   ( vocabulary chain             )
      WHILE  HEAD@+ F@  OVER 4- N>L F!  REPEAT  ;

( improved overlays                       (  4  1 89 crc  7:42 )
: SAVEOVER  ( blk# ---  | save overlays to blk# from given word)
  DUP NEWBLK  DUP >R  GETDICT    ( dict info stored            )
  >MEM F@  +HEAD F@  B/BUF OVER R> -  -  ( src, dest, ct )
  ADVANCE
  BEGIN  >MEM F@  HERE  U< WHILE
     1+  >MEM F@  OVER NEWBLK 2+
     { B/BUF 2- } LITERAL  ADVANCE  REPEAT
  DROP FLUSH ;







( improved overlays                       (  4  1 88 crc  8:25 )
: BRING     ( blk# ---  | restore overlays from blk#         )
  DUP  BLOCK  DUP SETDICT         ( set dictionary info      )
  +HEAD F@ OVER  - >R             ( offset to voc-link data  )
  +HEAD F@                        ( begin at voc-link data   )
  BEGIN  DUP F@ WHILE 4+ REPEAT 4+ ( skip voclinx for now     )
  OVER - >R  R +  ( src)  >MEM F@  ( dest                     )
     B/BUF R> -  ADVANCE  DUP     ( move first block to mem  )
  BEGIN  >MEM F@  HERE  U< WHILE
     1+  DUP BLOCK 2+  >MEM F@
     { B/BUF 2- } LITERAL  ADVANCE  REPEAT  DROP
  BLOCK R> + SETVOCS ;




\ 68000 : wdump for trials                (  1  9 91 CRC  8:59 )
HEX  : IF.  IF DROP ASCII . THEN ;
: (DUMP) \  from-address-2 cnt-1  ---  | memory displayed
   BOUNDS DO I W@ 0 5 D.R 2 +LOOP ;

: HEAD   CR 9 SPACES 0F AND 10 0  \ start  ---  | header
    DO DUP I + BASE F@ 1- AND 5 .R 2 +LOOP
    DROP ."  <<    ascii   >>" ;
: ASCI  -TRAILING BOUNDS    ( from-addr cnt ASCI)
   DO I C@ 7F AND  DUP ASCII ~ > IF.  DUP BL < IF. EMIT LOOP ;

: DUMP  \ from-addr  count ---  | dump
   OVER  DUP HEAD
   + SWAP   DO CR I 0 9 D.R I 10 2DUP (DUMP) SPACE
   ASCI  I  F0 AND F0 = IF I HEAD THEN
   ?TERMINAL  IF LEAVE  THEN  10 +LOOP CR ;
















































































































































































































































\ aim68k object file format utilities     ( 16  5 86 CRC 16:38 )
HEX 160 USER CHKSUM  164 USER LINECT  CHKSUM 8 ERASE
  \  checksum of line   line count
  \ This format is defined in the AIM 65 User's Guide, pg F-5
  \ to F-7

: ABYTE  0 # # 2DROP ;       : ACELL  0 # # # # 2DROP ;

: BUILDCHK  \  addr cnt  --- | checksum in chksum
  2DUP + CHKSUM F! BOUNDS      DO I TC@ CHKSUM +! LOOP ;

: BUILDBYTES  \ addr cnt --- | string construction
  SWAP 1- SWAP OVER + DO I TC@ ABYTE -1 +LOOP ;
BLK F@ 1+ LOAD


\ aim68k object file format utilities     ( 29  1 86 CRC       )
: ALINE  \ builds a line in the string construction area
         \ addr cnt ---  addr$ cnt$ ready for typing
  2DUP BUILDCHK  <# CHKSUM F@ ACELL  2DUP BUILDBYTES
  SWAP ACELL ( addr) ABYTE ( cnt)
  ASCII ; HOLD 0 0 #> LINECT 1+! ;

: LASTLINE  \  -- addr$ cnt$ | builds last line of file for ty
  <# LINECT F@ 1+ DUP ACELL ( chksum) ACELL ( lines)
  0 ABYTE ASCII ; HOLD 0 0 #> LINECT OFF TYPE CR ;

: LINES    \ addr cnt --    | dump contiguous memory
  BEGIN DUP 18 > WHILE 2DUP 18 MIN DUP >R ALINE TYPE CR
  R> DUP MINUS D+  REPEAT
  -DUP IF ALINE TYPE CR ELSE DROP THEN ;

















































































































\ 68000 : forward refs  1                 (  9  3 92 CRC  9:12 )
SETOLD SETNEW                   HEX
     0A      3 BYTE:IN (CR) C!
   0D        4 BYTE:IN (CR) C!

    0 BYTE:IN VARIABLE         REPLACED:BY CREATE
    4 BYTE:IN VARIABLE         REPLACED:BY ,
    8 BYTE:IN VARIABLE         REPLACED:BY IMMEDIATE
   0C BYTE:IN VARIABLE         REPLACED:BY (;CODE)
   14 BYTE:IN VARIABLE         REPLACED:BY LITERAL

   10 BYTE:IN VARIABLE  *DOES>* F@ 2- OVER DELTA - -
        FFFF AND  61000000 OR SWAP F!

60 14 BYTE:IN VARIABLE C!

\ 68000 : forward refs  2                 ( 18  2 92 CRC  8:54 )
HEX 0 BYTE:IN USER             REPLACED:BY CREATE
    4 BYTE:IN USER             REPLACED:BY W,
    8 BYTE:IN USER             REPLACED:BY IMMEDIATE
   0C BYTE:IN USER             REPLACED:BY (;CODE)

   24 BYTE:IN USER             REPLACED:BY W,
   28 BYTE:IN USER             REPLACED:BY W,
   32 BYTE:IN USER             REPLACED:BY W,







\ 68000 : forward refs  3                 (  5  2 92 CRC  8:36 )
HEX 0 BYTE:IN CONSTANT         REPLACED:BY CREATE
    4 BYTE:IN CONSTANT         REPLACED:BY IMMEDIATE
    8 BYTE:IN CONSTANT         REPLACED:BY ,
   0C BYTE:IN CONSTANT         REPLACED:BY (;CODE)
   18 BYTE:IN CONSTANT         REPLACED:BY LITERAL
60 18 BYTE:IN CONSTANT C!       \ make it a bra.

   10 BYTE:IN CONSTANT  *DOES>* F@ 2- OVER DELTA - -
        FFFF AND  61000000 OR SWAP F!






\ 68000 : forward refs  4                 (  3  3 92 CRC  9:43 )
HEX
    8 BYTE:IN ?ERROR           REPLACED:BY ERROR

   14 BYTE:IN ."               REPLACED:BY WORD
   2E BYTE:IN ."               REPLACED:BY WORD

   0C BYTE:IN WORD             REPLACED:BY BLOCK

   24 BYTE:IN ERROR            REPLACED:BY MESSAGE

80  'NF X CFA  DELTA +  4+  C>N 1+  C!  \ make it null




\ 68000 : forward refs  5                 ( 24 10 91 CRC 19:55 )
ASSEMBLER COLDSTART          2 BOOTPARAMETER
HEX       WARM               8 BOOTPARAMETER      FORTH
LAST F@ DELTA -       10 BOOTPARAMETER          \ 14 = backspace
EM US    -    18 BOOTPARAMETER          \  uarea
ASSEMBLER TOS 1C BOOTPARAMETER          \  TOS
RTS           20 BOOTPARAMETER          \  top of return stack
TIBX                         INITIALISES TIB
1F                           INITIALISES WIDTH
1                            INITIALISES WARNING
;S  fill in boot parameters





\ 68000 : forward refs  6                 (  3  3 92 CRC  9:43 )
DPNEW F@ DELTA -        DUP  INITIALISES FENCE
                             INITIALISES DP
EM US - VCLNK +              INITIALISES VOC-LINK \ for 4th voc
'NF (KEY)       CFA          INITIALISES 'KEY
'NF (EXPECT)    CFA          INITIALISES 'EXPECT
'NF (?TERMINAL) CFA          INITIALISES '?TERMINAL
'NF (EMIT)      CFA          INITIALISES 'EMIT
'NF (TYPE)      CFA          INITIALISES 'TYPE
'NF 2DROP       CFA          INITIALISES 'GOTOXY
'NF (PAGE)      CFA          INITIALISES 'PAGE
'NF (LIST)      CFA          INITIALISES 'LIST
'NF (CR)        CFA          INITIALISES 'CR



\ 68000 : forward refs  7                 ( 24 10 91 CRC 19:55 )
'NF (R/W)       CFA          INITIALISES 'R/W
'NF CMDBOOT     CFA          INITIALISES 'QUIT
'NF (ABORT)     CFA          INITIALISES 'ABORT
'NF (CREATE)    CFA          INITIALISES 'CREATE

TIBX      US - CO - 100 -    INITIALISES 'FIRST
TIBX      US -      100 -    INITIALISES 'LIMIT
4                            INITIALISES LENGTH

0 INITIALISES LASTTHEN
0 INITIALISES LASTSUB
1 INITIALISES REL



\ 68000 : forward refs  8                 ( 11  2 92 CRC 17:43 )
FORTH   \ N.B. placement of voc pseudoheader!
LAST F@ DELTA -       78 BOOTPARAMETER       \  headptr
81A00000              7C BOOTPARAMETER       \  vnfa
0                     80 BOOTPARAMETER       \  vclnk
     \ voc-link points to this guy.
BOT                   INITIALISES BOTSTACK
20002                 INITIALISES I/O   \ Atari special!
\ 'NF HARDDISK CFA ASSEMBLER SAFE 8 + DELTA + ! \ hard disk boot
FORTH  DPNEW F@  IMAGETOP OVER - ERASE
?CR SPEAK F@ IFTRUE  ."  Forward references resolved. "    CR
.HERE  .SIZE  CR  ?0S  IFEND    CR
12 BYTE:IN (ABORT)    COUNT TYPE   CR
WARNING ON  FORTH DEFINITIONS      ;s
\       headptr:4     vnfa:4     vclnk:4
\ vocs: ptr->head | pseudoname | voc-link
\ assemble special loaderfile for tos     ( 12  7 91 CRC 17:57 )
HEX DPNEW F@ COMPILE-ADDR - 2 +OVERHEAD F!
100  0A +OVERHEAD F!
  0  18 +OVERHEAD W!            \ stripped file flag

DPNEW F@  DELTA -   FBASE -  4+         4/
        ASSEMBLER CTDATA DELTA +  F!       FORTH









\ 68000      target compiler: load        ( 14  8 91 CRC 13:38 )
DECIMAL FORTH DEFINITIONS  FORGET TASK \ 480 ' ATARI C>P F!
DECIMAL FORTH DEFINITIONS       : TASK ;   QUIET
EDITOR FLUSH
: RLENGTH  LENGTH ;     RLENGTH F@ >R  16 RLENGTH F!
1 +BLK 2 +BLK THRU  \ 299 LOAD  \ 68K
: RLOAD DUP BLOCK W@
  IF DECIMAL  SPEAK F@ IF  CR DUP  7 .R SPACE  THEN  LOAD
  SPEAK F@ IF .S  THEN  ELSE DROP THEN ;
: RTHRU  1+ SWAP DO I RLOAD LOOP ;
HEX HERE FIRST OVER - ERASE DECIMAL
3 +BLK  31 +BLK RTHRU
CR  FORTH DEFINITIONS   pTODAY  R> RLENGTH F!  ;S

load  628 - 630 after  (loop)  and  (+loop)
have been defined in the target memory
\ Target compiler: set fundamentals       ( 27  6 91 CRC 18:12 )
BASE F@ HEX                     FORTH  DEFINITIONS
200  CONSTANT PREAMBLE          1C CONSTANT OVERHEAD
CREATE COMPILE-ADDR         \ work-space
COMPILE-ADDR  C000 DUP ALLOT  ERASE
HERE  CONSTANT IMAGETOP
\ 190100 PREAMBLE - CONSTANT BASE-ADDR     \ run time origin
   80100 PREAMBLE - CONSTANT BASE-ADDR     \ run time origin
COMPILE-ADDR CONSTANT WORKSPACE
COMPILE-ADDR BASE-ADDR - CONSTANT DELTA         DELTA FUDGE F!
78000 CONSTANT TM             400 CONSTANT   *B/BUF*
    20   *B/BUF*    6     +  *    CONSTANT CO
\ count  b/buf   overhead +  * == count of buffer space
                              200 CONSTANT US
BASE-ADDR PREAMBLE + CONSTANT FBASE

\ Target compiler: target memory          ( 27  1 92 CRC 12:32 )
              \ note the  non-standard memory map!
TM  40  -  CONSTANT TOS
TM 3A0  -  CONSTANT BOT
TM 410  -  CONSTANT RTS
TM 800  -  CONSTANT TIBX
TIBX       CONSTANT EM
1F         CONSTANT CTLMASK
0 VARIABLE CHOPLINE   0 , 0 ,
DELTA 0= IFTRUE  CODE TRIAL  FBASE @#L JMP,  ;C IFEND
BASE  F!
0 VARIABLE DOESWORD
: MUTATES  [COMPILE] '  DUP (RES)
  [ ' COMPILE-ADDR (RES) ] LITERAL
  - IF BELL ABORT" Can't mutate anything but a variable!" THEN
  C>P F! ;
\ Target compiler: compiler addrs         ( 30 10 91 CRC 20:01 )
FORTH  DEFINITIONS
  0 VARIABLE *(.")*             0 VARIABLE *USER*
  0 VARIABLE *DOES>*            0 VARIABLE *<COMPILE>*
  0 VARIABLE *(;CODE)*          0 VARIABLE *CONSTANT*
  0 VARIABLE *VARIABLE*         0 VARIABLE *VOCAB*
  0 VARIABLE *ABORT*            0 VARIABLE *QUIT*
  0 VARIABLE *@EXEC*
  0 VARIABLE *(LOOP)*           0 VARIABLE *(+LOOP)*

\ 0 VARIABLE OPT      \         0 VARIABLE RELS
  4 VARIABLE LENGTH

false constant debugging
\ TRUE  CONSTANT PRIVATE          \ version
\ true  constant files
\ Target compiler: disassembler           ( 23  8 91 CRC 20:33 )
: OPDS  (RES)  DUP  *(LOOP)* F@ =  SWAP  *(+LOOP)* F@ =  OR
  IF  2 IP +!  THEN  ;

: INST  IP F@  DUP 7 U.R  SPACE  DISASSEMBLER (INST)  DUP OPDS
  IP F@ OVER -  43 TAB  2DUP ASCI  54 TAB (WDUMP) ;

: (DIS)   BASE F@ HEX !CSP BEGIN ?STACK  CR  INST
    SP@  CSP F@ - IF .S THEN
    KEY DUP CTL T = IF  RANGE F@  IP F! ."  **" THEN
    LI = UNTIL BASE F! ;

: DISASSEM  DUP RANGE F!  IP F!  (DIS) ;



\ Target compiler: newforth               ( 23  8 91 CRC 20:34 )
VOCABULARY NEWFORTH IMMEDIATE   HEX
: OF/NF [COMPILE] NEWFORTH DEFINITIONS [COMPILE] FORTH ;
 0 VARIABLE DPOLD   COMPILE-ADDR   VARIABLE DPNEW
 0 VARIABLE O/N    \ old/new:  t=new, false=old
  1F  ( 0) VARIABLE TWIDTH   \ target width. 0 = headerless
  1F  ( 0) VARIABLE WID      \ width for a word. use | to make
                             \ an ophan out of it.
  1F       VARIABLE HEAD
: SETOLD   O/N  F@    IF  O/N OFF  HERE DPNEW F!
  DPOLD  F@ DP F!  THEN ;
: SETNEW   O/N  F@ 0= IF  O/N ON   HERE DPOLD F!
  DPNEW  F@ DP F!  THEN ;

DELTA VARIABLE LAST   \ addr of top of new dictionary

\ Target compiler: ?0s                    ( 14  5 86 CRC 16:57 )
: ?0S CR 15 [ BLK F@ ] LITERAL .LINE 80 OUT F! DPNEW F@ DELTA -
  FBASE DO 2 I T@ 0= IF ?CR I 6 U.R 2+ THEN
  ?TERMINAL IF LEAVE THEN  +LOOP  ;
                                                HEX
: TID. PAD BL ASCII _ FILL DUP N>C 2- OVER -
  PAD SWAP CMOVE PAD COUNT 1F AND
  1- 2DUP TYPE  + C@ 7F AND EMIT          SPACE ;
DECIMAL
: .HERE  DPNEW F@ DELTA - 13 [ BLK F@ ] LITERAL .LINE
  10 .R ;
: .SIZE  DPNEW F@ DELTA -  BASE-ADDR - 14 [ BLK F@ ] LITERAL
  .LINE         10  U.R ;                        ;S
       target here =
       target size =
       Addresses of long words containing 0 in them:
\ Target compiler: subroutine /smudged nff( 31  8 91 CRC 10:55 )
HEX     0 VARIABLE <IMMED> C0 ALLOT
<IMMED> HERE OVER - ERASE       <IMMED> 4+ <IMMED> F!
HERE CONSTANT LASTIMMED

: SUBROUTINE    \ addr --  | compile a subroutine to addr
(  HERE OVER DELTA + - FFFF8000  7FFF WITHIN )  ASSEMBLER
  HERE LASTSUB F! ( IF ) REL OFF  DELTA +  *+ BSR,
    (  ELSE  @#L JSR,  THEN ) ;

: /SMUDGE <IMMED> F@ <IMMED> 4+ 2DUP - IF
  DO  I F@  BL TOGGLE  4 +LOOP  ELSE  2DROP  THEN ;

: NFFIND BL WORD HERE DUP COUNT UPPER
  [ ' NEWFORTH C>P ] LITERAL  F@ (FIND) ;

\ Target compiler: 'nf byte:in nfsee:     ( 25  8 91 CRC  8:32 )
HEX
: 'NF  /SMUDGE  NFFIND DUP         \ new does> structure !!!
  IF SWAP DROP THEN      /SMUDGE 0=    \ use 4 + on old vocabs
  IF HERE COUNT TYPE SPACE ." NF?" QUIT THEN ;

: REPLACED:BY  'NF  F@  2- OVER DELTA -  -
  FFFF AND  61000000 OR SWAP F! ;
: BYTE:IN                  'NF F@ DELTA + + ;

: NFSEE:   'NF C>N N>L 4- F@ WHERETHEN  R# F! EDIT ;
: NFDUMP:  BASE F@ HEX   >R DELTA FUDGE F!  'NF F@ DUP
   6 U.R  10 - -10 AND C/L DUMP R> BASE F! ;



\ Target compiler: auto-disk buffer grabbe( 27  1 92 CRC 12:07 )
HEX
CREATE FILEHEADER  HERE OVERHEAD DUP ALLOT ERASE
: +OVERHEAD    FILEHEADER + ;   601A FILEHEADER W!

: SCAN  \ n  ---   | scan image for long word value n.
  DPNEW F@  COMPILE-ADDR
  DO  DUP I @  = IF  I DELTA - 8 .R THEN  ?STACK
     ?TERMINAL IF CR I 8 .R  LEAVE THEN  LOOP  DROP ;

: TRES  \ taddr --- taddr' | resolution of call at taddr
  DELTA + (RES) DELTA - ;
        \ tcfa ---  | copy in line or bsr to word at cfa
: SCARF   DUP DELTA + 2- W@  -DUP IF  LENGTH F@ 1+
          < IF  DELTA +  HERE  OVER 2- W@  DUP ALLOT  CMOVE
          ELSE  SUBROUTINE  THEN   ELSE SUBROUTINE THEN  ;
\ Target compiler: auto-disk buffer grabbe( 11  2 92 CRC 11:30 )
: <NFCOMPILE>   ?COMP R> DUP 4+ >R  F@
  O/N F@ IF  SCARF  ELSE  <COMP>  THEN ;

: TVLIST  CR BASE F@ >R  [ ' NEWFORTH C>P ] LITERAL  F@
  BEGIN  ?STACK   DUP TID.  3 SPACES  ?CR
  N>L F@ DUP 0=      \ is host link = 0 ?
  ?TERMINAL OR    UNTIL  DROP  R> BASE F! ;

: NFDIS:   DELTA FUDGE F!  'NF F@ DISASSEM ;
ASSEMBLER DEFINITIONS           BASE F@ HEX
: IFL,    IF, 0 LAY DROP 2+ 12 ;
: ELSEL,  ?EXEC 12 ?PAIRS 6000 ~ LAY  0 LAY
          HERE OVER - SWAP W!  HERE 2-  12 ;
: THENL,  ?EXEC 12 ?PAIRS HERE OVER - SWAP W! ~  SETLAST  ;
FORTH DEFINITIONS               BASE F!
\ Target compiler: create-old             ( 14  2 92 CRC 16:47 )
: NFCOMPILE   [ ' <NFCOMPILE> ] LITERAL <COMP>
  'NF F@ ,  ;        IMMEDIATE

HEX
: CREATE-OLD SETOLD FIRST ( TAREA ) PAD - 0< 2 ?ERROR
  [COMPILE] NEWFORTH DEFINITIONS
  ?ALIGN  0 ,  LATEST , HERE CURRENT F@ F!
  BL WORD HERE DUP  DUP C@ WIDTH F@ MIN 1+ =CELLS ALLOT
  SPEAK F@ IF  DUP COUNT TYPE SPACE  THEN
  80 TOGGLE HERE 1- 80 TOGGLE
  WHERENOW  SWAP N>L l>s F! \  installs scr & line #s
  0 W, ;        \ length field



\ Target compiler: create-new             (  3 10 93 CRC 20:43 )
HEX
: CREATE-NEW  SETNEW  ?ALIGN
  IMAGETOP DPNEW F@ [ PAD HERE - C/L + ] LITERAL - - 0< 2 ?ERROR
  ( ?-BUF)  WID F@ IF   \ if not headerless, make header
    0 ,                                         \ see: data
    LAST F@ DELTA - ,  HERE LAST F!             \ voc chain link
    BL WORD HERE DUP C@ TWIDTH F@ 1F AND MIN 1+ =CELLS ALLOT
        80 TOGGLE  HERE 1- 80 TOGGLE            \ assert bits 7
    0 W,  WHERENOW  LAST F@ 4- 4- F!  THEN      \ compile field
  SPEAK F@ IF  OUT F@ 30 >  IF CR 6 SPACES THEN
  BASE F@ HEX HERE DELTA - 5 U.R SPACE  BASE F! THEN  \ show add
  WID F@ HEAD F!                                \ header here ?
  TWIDTH F@ WID F! ;            ;S              \ permanent widt


\ initialises, bootparameter, smart ; setu(  5  2 92 CRC  8:08 )
: BOOTPARAMETER  FBASE +  DELTA +  F! ;
HEX
: INITIALISES  'NF \ F@ DELTA + \ warning: code dependent on
 0E + F@  10 + BOOTPARAMETER ; \  definition of  user

: 6SR LASTSUB F@  W@ 4EB9
          = IF  4EF9  LASTSUB F@ W!  0 ELSE  1  THEN ;
: 2SR LASTSUB F@  W@ FF00 AND 6100
          = IF  60 LASTSUB F@  C!  0  ELSE  1  THEN ;
: 4SR LASTSUB F@  W@ 6100
          = IF  60 LASTSUB F@  C!  0  ELSE  1  THEN ;
: LAST?  HERE LASTSUB F@ -
  DUP 2 = IF  DROP 2SR  ELSE    DUP 4 = IF  DROP 4SR  ELSE
      6 = IF  6SR  ELSE         1  THEN  THEN  THEN ;

\ Target compiler: nf: nf; ascii txt      ( 27  1 92 CRC 12:23 )
: NF: !CSP CREATE-OLD SMUDGE
  IMMEDIATE [COMPILE] FORTH ] ;

: NF; [COMPILE] ; ;       IMMEDIATE

: TXT ASCII " WORD  HERE C@ 1+ =CELLS ALLOT ( ?-BUF)  ;
   IMMEDIATE

: |  ?CR  WID OFF SPEAK F@ IF  ." <orphan> " THEN ;

: mf  CR mf BASE F@ HEX
  IMAGETOP DPNEW F@ - . ." Target bytes left. " BASE F! ;

: OFDUMP:   BASE F@ HEX   >R FUDGE OFF [COMPILE] ' DUP
   6 U.R  16 - -16 AND C/L DUMP R> BASE F! ;
\ Target/resident literal                 (  1  7 93 CRC 10:32 )
HEX     \ n # dr0 movq,  dr0 s -[ mov,     @#l s -[ mov,
: <LIT>   DUP  -80  7F WITHIN  IF
  FF AND 7000 OR W,  2700 W,  ELSE
( DUP DELTA + HERE -  -8000 8000 WITHIN IF  REL OFF  41FA W,
  SPEAK F@ IF CR  ." *+ variable "  THEN
  \ *+ ar0 lea,  ar0 s -[ mov,       @#l s -[ mov,
  DELTA + HERE - W,  2708 W,  ELSE ) 273C W, ,  THEN ( THEN ) ;
: LITERAL  STATE F@ IF
   O/N F@  IF DPL F@ 1+ IF
             SWAP  <LIT>   <LIT>         \ 64 bit target literal
             ELSE DROP  <LIT> THEN  ELSE \ 32 bit target literal
      DPL F@ 1+ IF        \ resident literal, any size
      [COMPILE] DLITERAL ELSE  [COMPILE] LITERAL
      THEN   THEN         \ interpretive literal
   ELSE DPL F@  1+ 0= IF DROP THEN  THEN  ;     IMMEDIATE
( optimizers: unary                       (  1  7 93 CRC 10:17 )
HEX
: UNARY  IN F@  CREATE-OLD  61000000 ,   SMUDGE  IN F!
  NFFIND  IF  DROP  F@ ,  ELSE  0 ERROR  THEN
  W, W, W, W,  SMUDGE  SETNEW  [COMPILE] FORTH
  DOES> SETNEW HERE OPT F@ -            \ not following a begin?
      IF  HERE 6 - W@  273C =           \ following a literal?
        IF  4 OPGET  HERE 6 - W!        \ yyy ** @#l xxx,
        ELSE  HERE 2- W@  2708 =        \ ar0 s -[ mov, eg user
          IF  -2 ALLOT  HERE 4- W@  41EE = \ user variable?
            IF  6 OPGET  HERE 4- W!     \ yyy u ** &[ xxx,
            ELSE  HERE 4- W@  41FA =    ( pc *+ variable?      )
              OVER 0A OPGET 273A =  AND ( f@ only!)
                IF 0A OPGET HERE 4- W! rel off ( a *+ s -[ mov )
              ELSE 8 OPGET W, THEN      \ yyy ar0 [ xxx,
            THEN        [
( optimizers: unary                       ( 30  8 93 CRC 20:13 )
HEX
]         ELSE  HERE 4- W@ 272E =       \ user f@ optimize
            IF  206E  HERE 4- W!  8 OPGET  W,
            ELSE  HERE 6 - W@  2739 =   \ literal f@ optimize
              IF  2079 HERE 6 - W!     8 OPGET W,
              ELSE    F@ SCARF       THEN  THEN  THEN  THEN
      ELSE  F@ SCARF       THEN     \ following br resolution
    ;

: BINARY  IN F@  CREATE-OLD  61000000 ,  SMUDGE  IN F!
  NFFIND  IF  DROP  F@ ,  ELSE  0 ERROR  THEN
  W, W,     SMUDGE  SETNEW  [COMPILE] FORTH
  DOES>  SETNEW  [                    ;s  only if compiling...


\ binary defining word                    ( 30  8 93 CRC 20:13 )
HEX     WARNING ON
]   HERE OPT F@ -                       \ not following a begin?
      IF  HERE 4- C@  70 =              \ byte literal?
        IF  HERE 4- E TOGGLE            \ xx # dr7 moveq,
          -2 ALLOT  4 OPGET W,          \ dr7 s [ xxx,
        ELSE  HERE 6 - W@ 273C =        \ large literal?
          IF  6 OPGET  HERE 6 - W!      \ yy #l s [ xxx,
          ELSE  HERE 4- W@  272E =      \ user f@ ??
            IF  HERE 4- 9 TOGGLE  4 OPGET W,  \ ofuser s [ add
            ELSE  HERE 6 - W@  2739 =   \ literal f@ ??
              IF  HERE 6 - 9 TOGGLE  4 OPGET W, \ lit dr7 mov,
              ELSE    F@ SCARF       THEN  THEN  THEN  THEN
      ELSE  F@ SCARF       THEN  ;  \ following br resolution

: ?FLAGS ?CR LATEST C? ;
\ Target compiler: literal -- interpret   ( 20  2 92 CRC  9:35 )
HEX
: IMMEDIATE   LAST F@ C/L TOGGLE   LATEST
  <IMMED> F@ F!  4 <IMMED> +!  SMUDGE
  <IMMED> F@ LASTIMMED = IF ABORT" Out of Immediate table space"
       THEN ;

: INTERPRET   BEGIN -FIND  IF  ( found) STATE F@ <
    IF  O/N F@  IF  F@ SCARF  ELSE  <COMP>  THEN
      ELSE  EXECUTE THEN
    ELSE HERE NUMBER [COMPILE] LITERAL  THEN   \    cr .s
        ?TERMINAL IF IN F@ R# F! BLK F@ SCR F! ABORT THEN
  ?STACK  AGAIN  STOP

: CNVT ( file offset -> addr )  OVERHEAD -  PREAMBLE -
  FBASE +  HEX ;
\ Target compiler: quit -- label          ( 13  5 86 CRC 14:51 )
: NFQUIT BLK OFF [COMPILE] [
     BEGIN BEGIN RP! CR QUERY INTERPRET OK STATE F@ 0= UNTIL
        .S ." NK"       AGAIN STOP
: LOAD  DUP BLOCK  W@ IF
  BASE F@ >R  SPEAK F@ IF  DECIMAL DUP CR 5 U.R SPACE  THEN
  HEX  BLK 2@ >R >R  C/L IN F! BLK F! INTERPRET
  R> R> BLK 2!  SPEAK F@ IF  ?CR 3 SPACES HEX .S  THEN
  R> BASE F!  ELSE DROP THEN  ;
: THRU  1+ SWAP DO I LOAD LOOP ;
: CFA  F@ ;
: ==       ?EXEC SETOLD CURRENT F@ >R
     [COMPILE] ASSEMBLER DEFINITIONS CONSTANT
     R> CURRENT F! [COMPILE] FORTH SETNEW ;
: LABEL SETOLD DPNEW F@ DELTA - ==
     [COMPILE] ASSEMBLER ;
\ Target compiler: code -- constant       ( 27  1 92 CRC 12:30 )
HEX
: CODE  !CSP  IN F@ ?EXEC  CREATE-NEW  REL ON
  IN F!  HERE DELTA -  CREATE-OLD ,  SMUDGE  SETNEW
  [COMPILE] ASSEMBLER  ASSEMBLER ~ ;

: CONSTANT   WID F@  IN F@  CREATE-NEW  IN F!
  IF  LAST F@ C/L TOGGLE  THEN
  *CONSTANT* F@ SUBROUTINE  HERE DELTA -  SWAP DUP ,
  NF:  [COMPILE] LITERAL   COMPILE <LIT>
  4 CSP +!  [COMPILE] NF;  ,
  ?STACK  SETNEW [COMPILE] FORTH ;




\ Target compiler: variable               (  9  3 92 CRC  9:21 )
HEX
: VARIABLE  WID F@ IN F@  CREATE-NEW  IN F!
  IF  LAST F@ C/L TOGGLE  THEN
  *VARIABLE* F@ SUBROUTINE  HERE DELTA -  SWAP  ,
  NF:  [COMPILE] LITERAL   COMPILE <LIT>
  4 CSP +!  [COMPILE] NF;
  ?STACK  SETNEW [COMPILE] FORTH ;

: VAR:          \  --- addr | returns target variable address
  'NF 2+ F@ ;





\ Target compiler: vocabulary -- user  68K(  7  9 91 CRC 15:42 )
HEX
\ : VOCABULARY IN F@ CREATE-NEW
\     IN F! HERE DELTA -  *VOCAB* F@ ,  A081 W,
\     LAST F@ DELTA - , 0 ,    \ new does>   !!
\     CREATE-OLD , SETNEW [COMPILE] FORTH ;

: USER     WID F@  IN F@  CREATE-NEW  IN F!
  IF  LAST F@ C/L TOGGLE  THEN
  *USER* F@ SUBROUTINE  DUP  W,
  NF:   41EE [COMPILE] LITERAL   COMPILE W,
        273C W,  ,  COMPILE W,  \ lit the hard way, so ofuser
        2708 [COMPILE] LITERAL   COMPILE W,     \ will work
     4 CSP +!    [COMPILE] NF;
  ?STACK  SETNEW [COMPILE] FORTH ;

\ assembler extensions for target compiler( 30 10 91 CRC 20:04 )
ASSEMBLER DEFINITIONS           HEX
: OFUSER  \  --  | assemble an access to a user: u off &[
  U 'NF  DUP 2+ F@  41EE - 0F ?ERROR    \ q&d test.
  0E + F@ &[ ;   \ def of user dependant!

: *+  DELTA + *+  REL OFF ;
: W     BELL ABORT"  'W' usage!!"  ;
: IP    BELL ABORT"  'IP' usage!!"  ;
FORTH DEFINITIONS

: +LOAD  +BLK LOAD ;

: +THRU  1+ SWAP DO I +LOAD LOOP ;


\ Target compiler: assembler extensions   ( 11 11 91 CRC 15:24 )
\ : LEN   N>C 2- ;        \ nfa -- lnfa

: SETLEN   LAST F@ LEN  W! ;

: ?LEN:   'NF F@ DELTA +  LEN? ;      \  --  |

: FIXED    0 SETLEN ;   \ don't copy into new words.

ASSEMBLER DEFINITIONS
: ;C ?EXEC ?CSP SMUDGE [COMPILE] FORTH  HEAD F@  REL F@  AND
      IF HERE  LAST F@ N>C - 2-  SETLEN THEN ;

: NEXT   RTS, ;         FORTH DEFINITIONS


\ chop target compiler                    ( 11 12 86 CRC 17:16 )
: GOLDEN  \ -- | saves data to chop xcompiler
  [ ' NEWFORTH  C>P ] LITERAL F@ CHOPLINE    F!
  [ ' ASSEMBLER C>P ] LITERAL F@ CHOPLINE 4+ F!
  HERE                           CHOPLINE 8 + F! ;

: CHOP   [COMPILE] FORTH DEFINITIONS   EDITOR FLUSH
  CHOPLINE 8 + F@ DP F!  DELTA FUDGE F!
  WORKSPACE IMAGETOP OVER - ERASE    ASSEMBLER ~ FORTH
  SETNEW  COMPILE-ADDR DP F!  SETOLD SETNEW  DELTA LAST F!
  <IMMED> 4+ <IMMED> F!
  CHOPLINE F@    [ ' NEWFORTH  C>P ] LITERAL F!
  CHOPLINE 4+ F@ [ ' ASSEMBLER C>P ] LITERAL F!  ;    ;S
WARNING:  no additions to any voc save  NEWFORTH  and  ASSEMBLER
after  GOLDEN  is invoked!!!!!!!!!!!!!!!

\ Target compiler: user -- vocabulary  68k( 24  8 91 CRC 16:21 )
HEX
: WHO DELTA + C>N ID. ;

: :     !CSP IN F@ ?EXEC CREATE-NEW
  IN F! HERE DELTA - CREATE-OLD , SMUDGE SETNEW
  REL ON  ]  ASSEMBLER ~ ;

NF: OF/NF [COMPILE] NEWFORTH DEFINITIONS [COMPILE] FORTH  NF;
\ ' NFQUIT 4- ' 'NF 40 + F! patch to use nfquit.
LATEST N>L OFF





\ Target compiler: nf: x -- [compile]     ( 14  8 91 CRC 14:22 )
HEX
NF: X BLK F@    IF ?EXEC THEN R> DROP NF;
80 LATEST 1+ C!                     \ rename it "null"

NF: \ [COMPILE] \ NF;

NF: GAP   0 ,  REL OFF NF;

NF: COMPILE  ?COMP   *<COMPILE>* F@ SUBROUTINE
    'NF CFA , NF;

NF: [COMPILE]  'NF F@ SUBROUTINE  NF;



\ Target compiler: nf: ;code -- ."        ( 22  8 91 CRC 16:38 )
HEX
NF: ;CODE       *(;CODE)* F@  SUBROUTINE
     HERE DELTA -  -4  CSP +!    \ adjust csp
     [COMPILE] ASSEMBLER   [COMPILE] [  NF;
\  HERE  is left on the stack. The programmer MUST manually
\ insert it into the proper *xxxxx* variable
\ e.g. : fred .... ;code ... next  mutates *fred*

NF: DOES>  *(;CODE)* F@ SUBROUTINE  HERE DELTA -  -4 CSP +!
  REL ON  DOESWORD ON
  *DOES>* F@ SUBROUTINE  NF;   \ in *xxx* variable

NF: ."  *(.")* F@ SUBROUTINE  [COMPILE] TXT  NF;


\ Target compiler: {         -- }         ( 16  1 87 CRC 18:59 )
NF: {  SETOLD   [COMPILE] FORTH     [COMPILE] [ NF;

NF: }  SETNEW ] [COMPILE] NEWFORTH              NF;

NF: ( [COMPILE] ( NF;

NF: FORTH                      NF;

NF: LITERAL              <LIT> NF;

NF: SEE:        SEE: NF;

NF: WHERE    OF/NF [COMPILE] WHERE   NF;


\ Target compiler: >r r> where            ( 23  4 92 CRC  8:51 )
HEX
NF: >R     2F1B W,  NF;         \ s [+ rp -[ mov,

NF: R>     271F W,  NF;         \ rp [+ s -[ mov,

NF: R      2717 W,  NF;         \ rp [ s -[ mov,

NF: RDROP  588F W,  NF;         \ 4 # rp addq,

NF: MOI  270E W,  NF;           \ headerless user variables
NF: S0     41EE000C ,  2708 W,  NF;
NF: >MEM   41EE00D0 ,  2708 W,  NF;     \ for the overlay
NF: +HEAD  41EE00D4 ,  2708 W,  NF;     \ code.

DECIMAL                                     GOLDEN
















































































































































































































\ Target compiler: ;                      ( 27 10 91 CRC 16:20 )
NF: ;  ?COMP ?CSP   HERE LASTTHEN F@ -
  IF  LAST?  IF  ASSEMBLER RTS,  FORTH  THEN
     ELSE  ASSEMBLER RTS, FORTH  THEN
  REL F@  DOESWORD F@ 0=  AND
         IF  HERE 2-  LAST F@ N>C  -  SETLEN  THEN
\       ." Relocatable : " CR BELL RELS 1+!  THEN
  SMUDGE [COMPILE] FORTH [COMPILE] [
  DOESWORD OFF                        NF;







\ Target compiler: nf: if -- while        ( 20 10 92 CRC  9:58 )
NF: IF          [COMPILE] [ ASSEMBLER ~  S [+ DR0 MOV,
                        NE IF, ] NF;
NF: THEN        HERE LASTTHEN F!        HERE OPT F!
                [COMPILE] [ ASSEMBLER ~  THEN, ] NF;
NF: DO          NFCOMPILE (DO)    HERE      NF;
NF: LOOP        NFCOMPILE (LOOP)  HERE - W, NF;
NF: +LOOP       NFCOMPILE (+LOOP) HERE - W, NF;
NF: BEGIN       HERE OPT F!
          [COMPILE] [ ASSEMBLER ~  BEGIN, ] NF;
NF: WHILE       [COMPILE] [ ASSEMBLER ~  S [+ DR0 MOV,
                        NE WHILE,  ] NF;
NF: UNTIL       [COMPILE] [ ASSEMBLER ~  S [+ DR0 MOV,
                        NE UNTIL,  ] NF;
NF: AGAIN       [COMPILE] [ ASSEMBLER ~  AGAIN,  ] NF;
NF: REPEAT      [COMPILE] [ ASSEMBLER ~  REPEAT, ] NF;
\ Target compiler: again  -- stop         ( 20 10 92 CRC  9:58 )
NF: ELSE        HERE LASTTHEN F!        HERE OPT F!
                [COMPILE] [ ASSEMBLER ~  ELSE,   ] NF;

NF: ASCII   BL WORD  HERE 1+ C@  0 [COMPILE] LITERAL NF;
NF: CTL     BL WORD  HERE 1+ C@  CTLMASK AND  0
                                 [COMPILE] LITERAL  NF;

NF: STOP    SMUDGE [COMPILE] FORTH [COMPILE] [ SETOLD NF;

NF: IFL         [COMPILE] [ ASSEMBLER ~  S [+ DR0 MOV,
                        NE IFL, ] NF;
NF: THENL       HERE LASTTHEN F!  HERE OPT F!
          [COMPILE] [ ASSEMBLER THENL, ] NF;
NF: ELSEL       HERE LASTTHEN F!  HERE OPT F!
          [COMPILE] [ ASSEMBLER ELSEL, ] NF;
































\ optimizers for : defs                   (  1  7 93 CRC 10:17 )
BASE F@ HEX
\ opget    0a   8    6     4
             0 5290 52AE  52B9  UNARY 1+!
             0 4290 42AE  42B9  UNARY OFF
             0 209B 2D5B  23DB  UNARY F!
          273A 2710 272E  2739  UNARY F@

\             l.w. lit  byte lit
                 693   DF93    BINARY +
                 493   9F93    BINARY -
                  93   8F93    BINARY OR
                 293   CF93    BINARY AND
                 A93   BF93    BINARY XOR
                BASE F!

















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































