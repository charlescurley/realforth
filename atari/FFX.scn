**********************  fastForth  MODEL  **********************
*                                                              *
*                             by                               *
*                                                              *
*                        Charles Curley                        *
*                        P. O. Box 845                         *
*                    Thermopolis, WY 82443                     *
*                                                              *
*                                                              *
*                          RELEASE 2                           *
*         Fast JSR/BSR threaded Forth for the MC 68000         *
*                                                              *
*                                                              *
*               Distributed by Charles Curley for              *
*              Atari ST and other 68000 computers              *
*****  Further distribution must include the above notice. *****
     ERROR MESSAGES                         06 12 84 CRC
 Empty Stack
 Dictionary Full
 Has Wrong Addressing Mode
 Isn't Unique
 Branch out of Range
 Disk Range ?
 Full Stack
 Disk Error !!!
Bytes (hex) Dictionary space available.
 CMOS only instruction or addressing mode
  This can't happen!! msg 13
  This can't happen!! msg 13
  This can't happen!! msg 13
     ?? Not in dictionary ??
real-FORTH on Atari ST           (c) 1985-1993 by Charles Curley
     ERROR MESSAGES                          7  4 85 CRC
 Compilation Only, Use in definitions
 Execution only
 Conditionals not paired
 Definitions not finished
 In protected dictonary
 Use only when loading
 Off Current Screen
 Declare Vocabulary
  This can't happen!! msg 25
 Centronics Interface Printer Failure!!
  This can't happen!! msg 27
  This can't happen!! msg 28
  This can't happen!! msg 29
  This can't happen!! msg 30
  This can't happen!! msg 31
( Bogus load screen!!!!                   ( 25 11 88 CRC 13:39 )
CR CR

."       This disk doesn't have overlays on it!  "


CR CR   abort









































\ test for getver                         ( 27 12 91 CRC 16:06 )
debug base @ >r decimal
forth definitions forget task   : task ;        editor flush









r> base !



































( Bogus load screen!!!!                   ( 25 11 88 CRC 13:39 )
CR CR

."       This disk doesn't have overlays on it!  "


CR CR   abort









\ editor help screen                      ( 17  9 87 CRC 22:34 )
f1 - blanks left        f2 - merge        f3 - blanks right
f4 - upper case left    f5 - upper right  f9 - home cursor
                      f7 - place date
ctl a - back up by len in pad   ctl d - delete current line
ctl e - erase current line      ctl j - insert contents of pad
ctl r - replace current line    ctl s - add a line at cursor
ctl z - hold current line       ctl c - del by length at pad
ctl k - stamp screen            ctl u - next line
ctl b - back up a screen        ctl n - forward a screen
ctl q - push a $ from scr       ctl l - copy to $ stack
ctl w - insert from $ stack     ctl p - overwrite to scr from $s
ctl y - clear $ stack           ctl o - "other" screen
Backsp - del to left of cursor  delete - del to right of cursor
Undo - abort this session       Insert - toggle placing mode
                <<Any key returns to editor!>>
































































\ experimental block for kernal changes   ( 26  6 93 CRC 22:17 )
FORGET TASK hex                 : TASK ;  FORTH DEFINITIONS
: tlit  \ state f@ if
  dup here -  dup .  -8000 8000 within if
  41fa w,  here - w,  2708 w,
  else [compile] literal  then
\  then
  ;     immediate
0 variable snark
code foo   snark *+ ar0 lea, ar0 s -[ mov,  next ;c
code bar   snark *+ s -[ mov,  next ;c
: baz  [ snark ] tlit ;


editor flush

\ experimental block for kernal changes   ( 23  8 91 CRC 21:28 )
FORGET TASK HEX                 : TASK ;  FORTH DEFINITIONS

\ {compile] literal                       ( 10  3 92 CRC  9:21 )
: LITERAL   STATE F@ IF  DUP -80 7F WITHIN IF
    FF AND  7000 OR  W,  2700 W,  ELSE  273C W, ,  THEN  THEN ;
IMMEDIATE

: tlit  state f@ if
  dup here -  -8000 8000 within if
  41fa w,  here - w,  2708 w,
  else [compile] literal  then  then  ;     immediate


EDITOR FLUSH

\ experimental block for kernal changes   ( 19 10 92 CRC 11:06 )
FORGET TASK HEX  DEBUG          : TASK ;  FORTH DEFINITIONS












EDITOR FLUSH

\ experimental block for kernal changes   ( 19 10 92 CRC 11:06 )
FORGET TASK HEX  DEBUG          : TASK ;  FORTH DEFINITIONS












EDITOR FLUSH

















































































































































































\ 68000 assem: load, user variables       ( 26  2 86 CRC 18:11 )
BASE F@ HEX                     VOCABULARY ASSEMBLER IMMEDIATE
ASSEMBLER DEFINITIONS           1 VARIABLE SIZE
aka create ncreate

130 USER DP2                    134 USER (QUIET)
138 USER OP#
13C USER REG                    150 USER REG1
140 USER MODE                   154 USER MOD1
144 USER EXT                    158 USER EXT1
148 USER EXTL                   15C USER EXTL1
14C USER ADTYPE                 160 USER ADTYPE1
DP2 EXTL1 OVER - 4+ ERASE      REG1 REG - CONSTANT VARLEN
  DECIMAL 1 +blk 27 +blk HEX THRU  BASE F!


\ 68000 assem: clearvar, sizes, .scr&line ( 12  9 85 CRC       )
: CLEARVAR     REG  VARLEN ERASE  0F REG  F! ;    CLEARVAR

: CLEARVAR1    REG1 VARLEN ERASE  0F REG1 F! ;    CLEARVAR1

: 0U.  0 <# # # # # #> TYPE ;

: .SCR&LINE  \ print current line
  BLK F@ DUP .SCR SPACE IN F@ C/L / DUP 3 .R 10 TAB SWAP .LINE ;

: .SIZE CREATE , DOES> F@ SIZE F! ;

0 .SIZE .B        1 .SIZE .W     2 .SIZE .L
DECIMAL
: .MSG  -DUP IF [ 26 +blk ] literal
         (LINE) -TRAILING TYPE THEN ;   hex
\ 68000 assem: 1st, error, (operand), v!  ( 17  7 86 CRC 11:33 )
: 1ST ( !CSP)  CLEARVAR CLEARVAR1   .L  \ set to cell size
  (QUIET) F@ IF BASE F@ DECIMAL CR .SCR&LINE 52 TAB
  HEX HERE  0U. ( ASCII |) 7C EMIT BASE F! THEN ;
: 2ND REG  REG1 VARLEN CMOVE          CLEARVAR ;
: ~  OP# OFF CLEARVAR  CLEARVAR1 ;   \ reset operand info
: ERROR ~  HERE COUNT TYPE ."  ? "  .MSG  \ custom error stuff
     SP!  BLK F@ IF IN F@ BLK F@ THEN  QUIT [ SMUDGE
: ?ERROR    SWAP IF ERROR ELSE DROP THEN ;
: (OPERAND)  OP# F@ -DUP IF  \ operand storage setup
      1-  1 ?ERROR   2ND ELSE 1ST THEN OP# 1+! ;
: ^ ;  IMMEDIATE    \ maintain compatibility
: SIZECK  -1 XOR OVER AND  3 ?ERROR ;
: V!  ADTYPE F! MODE F! 7 SIZECK REG F! ;
: { [COMPILE] [ ;   IMMEDIATE

\ 68000 assem: registers, .lr             (  1  2 93 CRC 21:42 )
: .LR   EXT F@ 800 OR EXT F! ;  \ make index reg long

: INDEXREG   7 SIZECK  0c 2*s  EXT F@ OR SWAP FF SIZECK OR ;

: DATAREG   CREATE W,  DOES> (OPERAND)  W@  0 1 V! ;
: ADDREG    CREATE W,  DOES> (OPERAND)  W@  1 2 V! ;

  0 DATAREG DR0  1 DATAREG DR1  2 DATAREG DR2  3 DATAREG DR3
  4 DATAREG DR4  5 DATAREG DR5  6 DATAREG DR6  7 DATAREG DR7

  0  ADDREG AR0  1  ADDREG AR1  2  ADDREG AR2  3  ADDREG AR3
  4  ADDREG AR4  5  ADDREG AR5  6  ADDREG AR6  7  ADDREG AR7
                                               3  ADDREG S
                                6  ADDREG U    7  ADDREG RP
 \ These just happen to be the "C" registers, ay - yup!!
\ 68000 assem: addressing modes           ( 29  5 86 CRC 14:53 )
: DOL  DUP EXT F! EXTL F! ; \ do longs
 \ register indirect            register indirect w/ postinc.
:  [ REG F@ 2 4  V! ;           : [+ REG F@ 3 8  V! ;
 \ addr indirect w/ predec      register indirect w/ displace .w
: -[ REG F@ 4 10 V! ;           : &[ REG F@ 5 20 V!  EXT F! ;
 \ address reg indirect w/ index ( and displacement)
: &D[ REG F@ 6 40 V!  INDEXREG 7FFF AND EXT F! ; \ # ar dr# &d[
 \ e.g.  4 ar0 3 &d[: disp 4 + ar0 + dr3  disp: 8 bits s. ext.
: &A[ REG F@ 6 40 V!  INDEXREG 8000 OR  EXT F! ; \ # ar ar# &a[
 \ absolute short address
: @#  (OPERAND)  0 7  80 V!       EXT F!       ; \ absolute
 \ absolute long address
: @#L (OPERAND)  1 7 100 V!  DOL ;   \   r# mod adtype
: ?PCREL  \ addr --- offset for pc relative & indexed modes
  HERE - 2- DUP 100 -100 WITHIN 0E ?ERROR FF AND  REL OFF ;
\ 68000 assem: more addressing modes      (  2  4 86 CRC 15:37 )
: *+    (OPERAND)  2 7  200 V! HERE  - 2- EXT F! ;
  \ pc w/ index ( and displacement) -- data register
: &D*+  (OPERAND)  3 7  400 V! SWAP ?PCREL SWAP
         INDEXREG 7FFF AND EXT F!  ; \ disp dr &D*+
  \ pc w/ index ( and displacement) -- addr register
: &A*+  (OPERAND)  3 7  400 V! SWAP ?PCREL SWAP
         INDEXREG 8000 OR  EXT F! ; \ disp ar &A*+
  \ immediate data ( word)
: #     (OPERAND)  4 7  800 V!  EXT F! ;
  \ immediate data ( long)
: #L    (OPERAND)  4 7 1000 V! DOL ;
: SR    (OPERAND)  4 7 4000 V!  .W ;
: CCR   (OPERAND)  4 7 2000 V!  ;
: USP   (OPERAND)  4 7 8000 V!  ;

\ 68000 assem: lay, odds&ends, bad        (  7  8 86 CRC 12:34 )
: LAY    DUP tW, (QUIET) F@ IF BASE F@ HEX SWAP 0U. BASE F!
      2 SPACES ELSE DROP THEN ;

: ODDS&ENDS   \ SP@ CSP F@ - -DUP IF 6 .R    3 ERROR
  ADTYPE1 F@ 1000 = IF SIZE F@ 2-    4 ?ERROR THEN
\ ADTYPE1 F@  800 = IF SIZE F@ 2 AND 5 ?ERROR THEN
  ADTYPE  F@ 2 AND ADTYPE1 F@ 2 AND OR SIZE F@ 0= AND
  7 ?ERROR ;  \ reset for next instruction.

: BAD  7 ERROR   { SMUDGE

: LOUD    (QUIET) ON  ;

: QUIET   (QUIET) OFF ;

\ 68000 assem: layext, finish             ( 19  1 86 CRC       )
: LAYEXT        ADTYPE1  F@  0EE0 AND
   IF  \ &[  &D[ &A[  @#  *+  &D*+  &A*+  #
     EXT1 F@ LAY    ELSE  ADTYPE1 F@  1100 AND
   IF  ( @#L  #L ) EXTL1 W@ LAY EXT1 F@ LAY   THEN THEN
                ADTYPE   F@  0EE0 AND
   IF  \ &[  &D[ &A[  @#  *+  &D*+  &A*+  #
     EXT  F@ LAY    ELSE  ADTYPE  F@  1100 AND
   IF  ( @#L  #L ) EXTL  W@ LAY EXT F@ LAY    THEN THEN    ;

: FINISH  ODDS&ENDS LAY  LAYEXT ~ ;     ;S
     rather than play around with how this code works, I split
long word operands into two parts, as per the 16 bit version.
But the division is done between the  F!  in  DOL  and the  W@
here.

\ 68000 assem: condition codes, ?bytebr   (  5  2 92 CRC  9:24 )
: BRCH  CREATE W,  DOES> W@  ;

  0 BRCH TRUE   100 BRCH FALSE   200 BRCH HI     300 BRCH LS
400 BRCH CC     500 BRCH CS      600 BRCH NE     700 BRCH EQ
400 BRCH HS     500 BRCH LO   \ synonyms
800 BRCH VC     900 BRCH VS      A00 BRCH PL     B00 BRCH MI
C00 BRCH GE     D00 BRCH LT      E00 BRCH GT     F00 BRCH LE

: ?BYTEBR  ( n --- n f )  DUP -80 7F WITHIN  >R FF AND R> ;
;S
FORTH DEFINITIONS
: ;C   ?EXEC ?CSP  SMUDGE  [COMPILE] FORTH
  REL F@ IF  HERE  LATEST N>C - 2- SETLEN  THEN ;
ASSEMBLER DEFINITIONS

\ 68000 assem: typesfit, case stuff       ( 20 10 85 CRC       )
: TYPESFIT?  \ caseval1, caseval2 --- fl
        ADTYPE  F@ -DUP IF AND 0= THEN SWAP
        ADTYPE1 F@ -DUP IF AND 0= THEN OR 0= ;

: TYPESOF    \ executes if operand1 & operand2 types are in
             \ caseval pairs.
        4 ?PAIRS COMPILE TYPESFIT?   0BRAN
        5 ; IMMEDIATE

: ENDTYPESCASE  4 ?PAIRS COMPILE BAD
       \ does bad if mode illegal; adds finish at end
         BEGIN  SP@ CSP F@ -
         WHILE 2 [COMPILE] THEN  REPEAT
         CSP F! COMPILE FINISH ;   IMMEDIATE

\ 68000 assem:  1manip --  6manip, 11-14  (  1  2 93 CRC 22:01 )
:  1MANIP   REG1 F@ OR ;              \ 0-2R1
:  2MANIP   REG  F@ OR ;              \ 0-2R1

:  3MANIP   REG1 F@ 9 2*s OR ;        \ 9-11R1
:  4MANIP   REG  F@ 9 2*s OR ;        \ 9-11R1

:  5MANIP   1MANIP  MOD1 F@ 3 2*s OR ;  \  EA1
:  6MANIP   2MANIP  MODE F@ 3 2*s OR ;  \  EA1

: 11MANIP   SIZE F@ 0=   8 ?ERROR ;
: 12MANIP   SIZE F@      9 ?ERROR ;
: 13MANIP   SIZE F@ 1-  0A ?ERROR ;
: 14MANIP   SIZE F@ 2-  0B ?ERROR ;


\ 68000 assem:  7manip -- 10manip, 15-17  (  1  2 93 CRC 22:01 )
:  7MANIP   SIZE F@  6 2*s OR ;         \ 6-7 size
:  8MANIP   11MANIP  SIZE F@ 2 / 6 2*s OR ;
:  9MANIP   11MANIP  SIZE F@ 2 / 8 2*s OR ;

10003000 VARIABLE MSIZE 2000 W, 3000 W,            \ movesi
: 10MANIP   MODE F@ 6 2*s OR SIZE F@ 2* MSIZE + W@ OR ;

: 15MANIP   EXT F@ ?BYTEBR       \ bra, bsr
      IF ( 8 bit) ADTYPE OFF OR ELSE DROP  THEN ;

: 16MANIP   SWAP F00 SIZECK OR ;  \  branch
: 17MANIP   ROT  F00 SIZECK OR  SWAP 7 SIZECK OR ;  \ dbcc



\ 68000 assem: 18manip -- 22manip         (  1  2 93 CRC 22:01 )
         \ addq
: 18MANIP   ADTYPE1 OFF  EXT1 F@ 1- 7 SIZECK 1+ 7 AND 9 2*s OR ;

: 19MANIP   ADTYPE1 OFF ADTYPE OFF EXT1 F@ FF SIZECK OR ; \ move

: 20MANIP   MOD1 F@ 0= IF 20 OR REG1 F@  \ shift
            ELSE EXT1 F@ 1- 7 SIZECK 1+ 7 AND
            ADTYPE1 OFF THEN  9 2*s OR ;

: 21MANIP   ADTYPE OFF EXT F@ 0F SIZECK OR ;  \ trap

                               \ movem
: 22MANIP   EXT F@ EXT1 F@ EXT F! EXT1 F!  EXTL1 F@ EXTL F!
            ADTYPE F@ ADTYPE1 F@ ADTYPE F! ADTYPE1 F! ;

\ 68000 assem: 23manip -- manip           ( 22  5 86 CRC 18:15 )
: 23MANIP   ADTYPE F@ 10 = ( reverse mask?)
            IF EXT1 F@ 10 0 DO  0 2 U/ LOOP
                    1 10 0 DO  ROT OVER * ROT OR SWAP 2* LOOP
            DROP EXT1 F! THEN ;
: MANIP  DUP 0< 7 ?ERROR  19 MIN   EXEC
  |       1MANIP  2MANIP  3MANIP  4MANIP  5MANIP  6MANIP  7MANIP
  8MANIP  9MANIP 10MANIP 11MANIP 12MANIP 13MANIP 14MANIP 15MANIP
 16MANIP 17MANIP 18MANIP 19MANIP 20MANIP 21MANIP 22MANIP 23MANIP
 .B      BAD   { SMUDGE
;s
: OFUSER  \  --  | assemble an access to a user: u off &[
  U [COMPILE] '
  DUP (RES) { ' BASE (RES) ] LITERAL -  0F ?ERROR
  C>P W@ &[ ;   \ e.g:
\ code definitions  ofuser context ofuser current mov, next
\ 68000 assem: saveset, getlegal, forminst( 20 10 85 CRC       )

: SAVESET W, ( 3rd manip) W, ( 2nd) W, ( 1st) \ make , to
           W, ( instruction basis)     \ use on pdp 11 - word!!
      W, W,  ( bit mapped set of 1st & 2nd legal modes) ;

: GETLEGALTYPESET \ ptr -- ptr modset modset
\     DUP  7 +  @ OVER 5 +  @ ;                       \ byte
      DUP 0A + W@ OVER 8 + W@ ;                       \ 11, 68k
: FORMINST  \ ptr -- instruction word                \ 11:
      DUP 6 + W@   \ get basis                        \  6 +
      OVER 4+ W@ MANIP   \ modify basis by 1st manip \  4 +
      OVER 2+ W@ MANIP   \ modify basis by 2nd manip \  2+
      SWAP    W@ MANIP   \ modify basis by 3rd manip
   ;

\ 68000 assem: savesets, 1mi, 2mi         ( 20 10 85 CRC       )
:  SAVESETS \ tos has count, number of sets to save.
   0 DO SAVESET  LOOP ;

: 1MI CREATE   SAVESET   DOES> CASE
        GETLEGALTYPESET  TYPESOF FORMINST ENDOF
           ENDTYPESCASE ;

: 2MI CREATE 2 SAVESETS  DOES> CASE
        GETLEGALTYPESET  TYPESOF FORMINST ENDOF
  0C +  GETLEGALTYPESET  TYPESOF FORMINST ENDOF \ 11 version
           ENDTYPESCASE ;

\  9 +  GETLEGALTYPESET  TYPESOF FORMINST ENDOF \ byte ver


\ 68000 assem: 4mi, 6mi                   ( 20 10 85 CRC       )
: 4MI CREATE 4 SAVESETS  DOES> CASE
        GETLEGALTYPESET  TYPESOF FORMINST ENDOF
  0C +  GETLEGALTYPESET  TYPESOF FORMINST ENDOF \ 11 version
  0C +  GETLEGALTYPESET  TYPESOF FORMINST ENDOF \ 11 version
  0C +  GETLEGALTYPESET  TYPESOF FORMINST ENDOF \ 11 version
           ENDTYPESCASE ;
: 6MI CREATE 6 SAVESETS  DOES> CASE
        GETLEGALTYPESET  TYPESOF FORMINST ENDOF
  0C +  GETLEGALTYPESET  TYPESOF FORMINST ENDOF \ 11 version
  0C +  GETLEGALTYPESET  TYPESOF FORMINST ENDOF \ 11 version
  0C +  GETLEGALTYPESET  TYPESOF FORMINST ENDOF \ 11 version
  0C +  GETLEGALTYPESET  TYPESOF FORMINST ENDOF \ 11 version
  0C +  GETLEGALTYPESET  TYPESOF FORMINST ENDOF \ 11 version
           ENDTYPESCASE ;

\ 68000 assem: instructions adbc -- and   ( 23  7 85 CRC       )
\    1     1 C100    1    4   0C
\   10    10 C108    1    4   0C     2MI ADBC,
  1FFF     2 D0C0    4    5    9               \ adda,
  1800   1FD  600    0    6    7               \ addi,
   7FF     1 D000    4    5    7
     1   1FC D100    3    6    7     4MI ADD,
   800   1FF 5000    6    7   12     1MI ADDQ,
     1     1 D100    1    4    7
    10    10 D108    1    4    7     2MI ADDX,
  1800  41FD  200    0    6    7               \ andi,
     1   1FC C100    3    6    7
   7FD     1 C000    4    5    7
   7FD     1 C000    4    5    7     4MI AND,


\ 68000 assem: instructions asl  -- bsr   ( 12  9 85 CRC       )
   801     1 E100    2    7   14
     0   1FC E1C0    0    6   13     2MI ASL,
\  801     1 E000    2    7   14
\    0   1FC E0C0    0    6   0D     2MI ASR,
     0   200 6000    0   0F   10     1MI BCC,
     1   1FD  140    0    3    6
   800   1FD  840    0    0    6     2MI BCHG,
\    1   1FD  180    0    3    6
\  800   1FD  880    0   18    6     2MI BCLR,
     0   200 6000    0    0   0F     1MI BRA,
\    1   1FD  1C0    0    3    6
\  800   1FD  8C0    0   18    6     2MI BSET,
     0   200 6100    0    0   0F     1MI BSR,


\ 68000 assem: instructions btst -- eor   ( 23  7 85 CRC       )
     1   1FD  100    0    3    6
   800   1FD  800    0   18    6     2MI BTST,
\  FFD     1 4180    4    5   0D     1MI CHK,
     0   1FD 4200    0    6    7     1MI CLR,
  1FFF     2 B0C0    4    5    9               \ cmpa,
  1800   1FD  C00    0    6    7               \ cmpi
     8     8 B108    1    4    7               \ cmpm
   7FF     1 B000    4    5    7     4MI CMP,
     0   200 50C8    0    0   11     1MI DBCC,
\  FFD     1 81C0    0    4    5     1MI DIVS,
\  FFD     1 80C0    0    4    5     1MI DIVU,
  1800  41FD  A00    0    6    7               \ eori
     1   1FD B100    3    6    7     2MI EOR,


\ 68000 assem: instructions exg  -- lsr   ( 11  9 85 CRC       )
\    1     1 C140    2    3   0E
\    2     2 C148    2    3   0E
\    1     2 C188    1    4   0E
\    2     1 C188    2    3   0E     4MI EXG,
     0     1 4880    0    2    8     1MI EXT,
     0   7E4 4EC0    0    0    6     1MI JMP,
\    0   7E4 4E80    0    0    6     1MI JSR,
   7E4     2 41C0    4    5   0E     1MI LEA,
\    2   800 4E50    0    0    1     1MI LINK,
   801     1 E108    2    7   14
     0   1FC E3C0    0    6   0D     2MI LSL,
   801     1 E008    2    7   14
     0   1FC E2C0    0    6   0D     2MI LSR,


\ 68000 assem: instructions mov  -- mulu  ( 19  3 86 CRC 14:33 )
  1FFF   1FF    0    4    5   0A               \ mov, incl mova
   FFD  2000 44C0    0    5   0C               \ mov, to ccr
   FFD  4000 46C0    0    5   0D               \ mov, to sr
  4000   1FD 40C0    0    6   0D               \ mov, from sr
     2  8000 4E60    0    1   0E               \ mov, to usp
  8000     2 4E68    0    2   0E     6MI MOV,  \ mov, from usp
\  7EC   800 4C80    5    8   16
\  800   1F4 4880    6    8   17     2MI MOVM,
\    1    20  188    2    3    8
\   20     1  108    1    4    8     2MI MOVP,
   800     1 7000    0    4   13     1MI MOVQ,
\  FFD     1 C1C0    0    4    5     1MI MULS,
   FFD     1 C0C0    0    4    5     1MI MULU,


\ 68000 assem: instructions nbcd -- rol   ( 23  7 85 CRC       )
\    0   1FD 4800    0    6   0C     1MI NBCD,
     0   1FD 4400    0    6    7     1MI NEG,
     0   1FD 4000    0    6    7     1MI NEGX,
\    0     0 4E71    0    0    0     1MI NOP,
\    0   1FD 4600    0    6    7     1MI NOT,
  1800  41FD    0    0    6    7               \ ori,
     1   1FC 8100    3    6    7
   7FD     1 8000    4    5    7
   7FD     1 8000    4    5    7     4MI OR,
\    0   7E4 4840    0    0    6     1MI PEA,
\    0     0 4E70    0    0    0     1MI RESET,
   801     1 E118    2    7   14
     0   1FC E7C0    0    6   0D     2MI ROL,


\ 68000 assem: instructions ror  -- stop  ( 23  7 85 CRC       )
\  801     1 E018    2    7   14
\    0   1FC E6C0    0    6   0D     2MI ROR,
   801     1 E110    2    7   14
     0   1FC E5C0    0    6   0D     2MI ROXL,
\  801     1 E010    2    7   14
\    0   1FC E4C0    0    6   0D     2MI ROXR,
\    0     0 4E73    0    0    0     1MI RTE,
\    0     0 4E77    0    0    0     1MI RTR,
     0     0 4E75    0    0    0     1MI RTS,
\    1     1 8100    1    4   0C
\   10    10 8108    1    4   0C     2MI SBCD,
\    0   1FD 50C0    6   0C   10     1MI SCC,
\    0   800 4E72    0    0   0D     1MI STOP,


\ 68000 assem: instructions sub  -- unlk  (  2  9 85 CRC       )
  1FFF     2 90C0    4    5    9               \ suba,
  1800   1FD  400    0    6    7               \ subi,
   7FF     1 9000    4    5    7
     1   1FC 9100    3    6    7     4MI SUB,
   800   1FF 5100    6    7   12     1MI SUBQ,
\    1     1 9100    1    4    7
\   10    10 9108    1    4    7     2MI SUBX,
     0     1 4840    0    2   0D     1MI SWAP,
\    0   1FD 4AC0   18    6   0C     1MI TAS,
     0   800 4E40    0    0   15     1MI TRAP,
\    0     0 4E76    0    0    0     1MI TRAPV,
     0   1FD 4A00    0    6    7     1MI TST,
\    0     2 4E58    0    0    2     1MI UNLK,


\ 68000 assem: next, fillbr, condbr       ( 26  2 92 CRC 12:08 )
: NEXT   RTS, ;

: BYTEBRCHK  ?BYTEBR 0= 0C ?ERROR ;
: FILLBR   HERE OVER - 2- BYTEBRCHK OVER tW@ OR SWAP (QUIET) F@
  IF 2DUP  4 SPACES 0U.  ( ASCII |) 7C EMIT 0U. THEN tW! ;

: CONDBR  F00 SIZECK 100 XOR 6000 OR ; \ cond --- 6x00
: ENDBR   SWAP HERE - 2- ?BYTEBR IF OR ~ LAY
   ELSE SWAP ~ LAY LAY THEN ;   \ addr 6x00  ---

: IF,     CONDBR ~ LAY HERE 2- 2 ;
: ELSE,   2 ?PAIRS 6000 ~ LAY FILLBR HERE 2- 2 ;
: SETLAST HERE LASTTHEN F! ;
: THEN,   2 ?PAIRS FILLBR  SETLAST  ;
: BEGIN,  HERE 1 ~ ;
\ 68000 assem: conditionals               (  2  1 91 CRC 20:50 )
: AGAIN,  ?EXEC 1 ?PAIRS 6000 ENDBR  ;
: UNTIL,  ?EXEC SWAP 1 ?PAIRS CONDBR ENDBR ;
    \  --- whileaddr beginaddr 1 |
: WHILE,  ?EXEC SWAP 1 ?PAIRS CONDBR ~ LAY HERE 2- SWAP 1 ;
: REPEAT, AGAIN, FILLBR ;
\ : IFL,    IF, 0 LAY DROP 2+ 12 ;
\ : ELSEL,  ?EXEC 12 ?PAIRS 6000 ~ LAY 0 LAY  HERE OVER -
\           SWAP tW!   HERE 2- 12 ;
\ : THENL,  ?EXEC 12 ?PAIRS HERE OVER - SWAP tW! ~  SETLAST  ;
\ : WHILEL, WHILE, 0 LAY ;
\ : REPEATL, AGAIN, 2+ HERE OVER - SWAP tW! ;
: DO,    \ cc  ---  cc reg addr chk | mark start of  dbcc  loop
  ADTYPE F@ 1-  0D ?ERROR REG F@ BEGIN, 4+  ~ ;
: LOOP,  \ cc reg addr chk ---  | assemble  dbcc  loop
  5 ?PAIRS *+ DBCC, ;   \ e.g. NE DR0 DO, ...  LOOP,
\ 68000 assem: entry points               (  7  2 93 CRC 17:12 )
: ;C ?EXEC  REL F@  ?HEADs F@ AND
  IF HERE  delta +  LATEST  N>C  -
     2-  SETLEN THEN  [compile] host ;

: OFUSER  \  --  | assemble an access to a user: u off &[
  U  native context f@ >r  host [compile] target
  [compile] ' c>p  8 + W@
  host assembler &[  r> native context f! ;

HOST ( FORTH) DEFINITIONS ASSEMBLER
: ENTERCODE   [COMPILE] ASSEMBLER   ASSEMBLER ~ ;
\ : ;CODE   COMPILE (;CODE) [COMPILE] [ ENTERCODE ; IMMEDIATE
: LABEL  HERE EQU  ENTERCODE ;
DECIMAL

















\ 68000 assem: message screen!!!          ( 22  5 86 CRC 18:12 )
 Too many operands??
 Wrong argument count!
 Something too large here!!
 #L requires .L !!
 # requires .W !!
 No byte ops on addr regsisters!
 Has Wrong Addressing Mode
 Can't use byte!
 Byte only!
 Word only!
 Long only!
 Branch out of Range
 Data Register only
 PC Relative out of range!
 >> NOT a User Variable <<
































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































\ Pexec code                              (  2  9 93 CRC 19:49 )


base f@ >r  decimal

1 2 +thru

r> base f!
forth definitions







\ Pexec code                              (  2  9 93 CRC 19:51 )
CREATE ENVIR 0 ,

CREATE COMM 80 ALLOT    COMM 80 ERASE

CREATE FNAM 80 ALLOT    FNAM 80 ERASE

FILING PARSEFILE: H:\FAST4TH.TTP
FILE FORTH FNAM C/L CMOVE

3 VARIABLE FUNCTION             ;S      functions:
0: load & execute
3: load & return             ( base page ret. in dr0 )
4: execute previously loaded ( base page addr at fnam )


\ Pexec code                              (  2  9 93 CRC 19:51 )
HEX
0 VARIABLE BASEPAGE

CODE PEXEC      \ --- fl | execute pexec, return code
  RP DR7 MOV,  ENVIR *+ PEA,  COMM *+ PEA,   FNAM *+ PEA,
  FUNCTION 2+ *+ RP -[ .W MOV,   4B # RP -[ .W MOV,
  1 # TRAP,  DR7 RP MOV,
  BASEPAGE *+ AR0 LEA, DR0 AR0 [ MOV,  NEXT ;C

CODE MFREE      \ --- fl | discard reserved memory
  RP DR7 MOV,  BASEPAGE *+ RP -[ MOV,  49 # RP -[ MOV,
  1 # TRAP,  DR7 RP MOV,
  BASEPAGE *+ AR0 LEA,  DR0 AR0 [ MOV,   NEXT  ;C


















































































































































































































































**********************  fig-FORTH  MODEL  **********************
*                                                              *
*                                                              *
*                68000 real-FORTH TARGET COMPILER              *
*                       32 Bit Data Path                       *
*                      by Charles Curley                       *
*                                                              *
*          real-FORTH source modified by Charles Curley        *
*                  C 1983, 1986 Charles Curley                 *
*                                                              *
*                          RELEASE 1                           *
*                                                              *
*               Distributed by Charles Curley for              *
*                  68000 disk based computers                  *
*                                                              *
*****  Further distribution must include the above notice. *****
















































( LOAD SCREEN -- serial -- Recompiling    ( 10  6 86 CRC 11:15 )
DECIMAL  FILING FORTH DEFINITIONS       FORGET TASK

FALSE VARIABLE SPEAK
: VERBOSE SPEAK ON ;            : LACONIC SPEAK OFF ;

\  210 needed pexec         \   78 NEEDED TRANSIENT
   106 +vol: mainf NEEDED INTERNAL
   107 +vol: mainf NEEDED IFTRUE
   235 LOAD ( loaders       )  237 LOAD  ( loud quiet )
 ( 402 LOAD ( aim68k format )  ?CR pTODAY

EDITOR FLUSH

   CR HEX 0F MESSAGE DECIMAL CR   : TASK ;
   HERE 1024 BLANKS \ ."  Disposing... " DISPOSE CTL G EMIT
\ trace file creation screen              ( 28  6 87 CRC 11:34 )
232 NEEDED TARGET    PRINTER LEFT @ >R   5 LEFTS
CR FILING SETDRIVE: H  R-W DIR *.*




FILING R-W CREATEFILE: TRACE.TXT
OUTFILE  CR TARGET CR CR ATARI

CR CLOSEOUTFILE  R-W DIR *.*
R> PRINTER LEFT !
FORTH



\ Documenting screen                      ( 13  2 87 CRC 11:51 )
DECIMAL  DOCUMENTING  FORTH SCR @
         0  B/DRV 1-  DOCUMENTING SINCE 26  1 87
NECPAGE  SCR !












\       target compiler: loaders, 132col  ( 27  1 92 CRC 11:49 )
FORTH DEFINITIONS
365 +BLK LOADER JSR    \ jsr threaded xcompiler
  5 +BLK LOADER TARGET ( itc )  245 +BLK LOADER ATARI \ ff xcomp
 43      LOADER BOOT              3 +BLK LOADER DOCUMENTED
169 +BLK LOADER FILE
: BOTH  JSR ATARI ;     \ build atari fastForth

: ?CR   OUT @ C/L > IF CR THEN ;        ?CR

: 132COL ( ?PRINT IF CR CTL \ EMIT THEN ) ;     immediate

: 80COL  ( ?PRINT IF CR CTL Y EMIT THEN ) ;     immediate

\ : 2CONSTANT  <BUILDS SWAP  , ,    DOES> 2@ ;

\ 68000 addressing setup                  (  2  9 85 CRC       )
BASE @ HEX 8300 CONSTANT COMPILE-ADDR \ set on 241
CODE >< TOP LDA, TOP 1+ LDY, TOP STY, TOP 1+ STA, NEXT JMP,
CODE R@  ' @ CFA @ HERE 2- ! CODE R! ' ! CFA @ HERE 2- !
: ?TARGET  \ addr -- fl | flag to indicate target or resident
                 DUP COMPILE-ADDR U< SWAP FIRST U< XOR ;
: @  DUP R@ SWAP ?TARGET  IF      ><      THEN    ;
: !  DUP         ?TARGET  IF SWAP >< SWAP THEN R! ;
: , HERE ! 2 ALLOT ;        : ? @ . ;
: COMPILE    ?COMP  R> DUP 2+ >R R@ , ;
: W@  @ ;                   : W!   ! ;
: W,  , ;
: 2@  DUP 2+       @ SWAP @ ;  : 2!  DUP ROT SWAP ! 2+ ! ;
                                               BASE !


\ compiling aids                          (  2  6 86 CRC 11:37 )
FORTH DEFINITIONS
: LOUD  ASSEMBLER (QUIET) ON  132COL ;

: QUIET ASSEMBLER (QUIET) OFF 80COL  ;

ATCOLD: FLUSH

: SETBUFS \ n --   | set system to have n buffers
  FLUSH B/BUF 6 + * LIMIT SWAP - 'FIRST !
  EMPTY-BUFFERS  #BUFS 4 .R ."  Buffers " ;     ?CR

#BUFS 32 = IFTRUE 160 SETBUFS IFEND             ?CR

: STDBUFS  FLUSH 112 +ORIGIN @ 'FIRST ! SETU/P ;

\ Target documentor                       ( 13  9 85 CRC       )
CR ." Cross Compilation of 68000 real-FORTH for Atari."
\ CR CR TARGET ATARI
  CR CR jsr    ATARI
?CRT 0= IFTRUE PAGE IFEND        WARNING ON
CR 3 VTAB CR ." Atari " 18 BYTE:IN (ABORT)    COUNT TYPE
CR CR 15 MESSAGE CR CR   ." VLIST  of kernel." CR
TVLIST CR CR
\ ?CRT 0= IFTRUE PAGE IFEND
\ ." Concordance of kernel" CR CR
\ CROSS
?CRT 0= IFTRUE PAGE IFEND




\ Document for product release            ( 24  8 86 CRC 17:58 )
DOCUMENTING    SCR @
  300 369 INDEX
  411 419 INDEX
  300 369 SHOW
  380 392 SHOW
  411 419 SHOW                  NECPAGE
EDITOR         SCR !








\ 68000      target compiler: load        ( 14  8 91 CRC 13:38 )
EDITOR FLUSH   CR pTODAY CR CR
DECIMAL FORTH DEFINITIONS  FORGET TASK
DECIMAL FORTH DEFINITIONS       : TASK ;     QUIET
300 ' atari !
241 242  THRU  \ 299 LOAD  \ 68k
: RLOAD DUP BLOCK @ IF DUP CR   7 .R SPACE LOAD .S
      ELSE DROP THEN ;
: RTHRU  1+ SWAP DO I RLOAD LOOP ;
HEX HERE FIRST OVER - ERASE DECIMAL
243  257  RTHRU    260 263 RTHRU
CR  FORTH DEFINITIONS   pTODAY    ;S

load  321 & 322 after  ;s ,  (loop) ,  (+loop) ,  branch  and
0Branch  have been defined in the target memory

\ Target compiler: set fundamentals       ( 27  6 91 CRC 18:12 )
BASE @ HEX                      FORTH  DEFINITIONS
TRUE  CONSTANT PRIVATE          \ version
200  CONSTANT PREAMBLE          1C CONSTANT OVERHEAD
0 VARIABLE COMPILE-ADDR         \ work-space
COMPILE-ADDR  4000 DUP 4- ALLOT  ERASE
HERE  CONSTANT IMAGETOP
50100 PREAMBLE - CONSTANT BASE-ADDR     \ run time origin
COMPILE-ADDR CONSTANT WORKSPACE
COMPILE-ADDR BASE-ADDR - CONSTANT DELTA
                                  DELTA FUDGE !
78000 CONSTANT TM             400 CONSTANT   *B/BUF*
    20   *B/BUF*    6     +  *    CONSTANT CO
\ count  b/buf   overhead +  * == count of buffer space
                              180 CONSTANT US
base-addr preamble + constant fbase
\ Target compiler: target memory          ( 11 12 86 CRC 17:25 )
              \ note the  non-standard memory map!
TM  40  -           CONSTANT TOS
TM 1A0  -           CONSTANT BOT
TM 210  -           CONSTANT RTS
TM 400  -           CONSTANT TIBX
TIBX                CONSTANT EM

ASSEMBLER DEFINITIONS
: ;C ?EXEC ?CSP SMUDGE [COMPILE] FORTH ;
FORTH DEFINITIONS    BASE  !

0 VARIABLE CHOPLINE   0 , 0 ,
DELTA 0= IFTRUE  CODE TRIAL  BASE-ADDR @#L JMP,  IFEND


\ Target compiler: compiler addrs         ( 13  5 86 CRC 15:40 )
FORTH  DEFINITIONS
 0 CONSTANT *(.")*               0 CONSTANT *USER*
 0 CONSTANT *DOES>*              0 CONSTANT *COLON*
 0 CONSTANT *(;CODE)*            0 CONSTANT *CONSTANT*
 0 CONSTANT *VARIABLE*           0 CONSTANT *VOCAB*
 0 CONSTANT *USERCONSTANT*       0 CONSTANT *;S*
 0 CONSTANT *ABORT*              0 CONSTANT *QUIT*
 0 CONSTANT *@EXEC*
 0 CONSTANT *(LOOP)*             0 CONSTANT *(+LOOP)*
 0 CONSTANT *BRAN*               0 CONSTANT *0BRAN*

   '  LIT CFA DUP                  CONSTANT *LIT*
   CONSTANT OF*LIT*              0 CONSTANT NF*LIT*
   ' WLIT CFA DUP                  CONSTANT *WLIT*
   CONSTANT OF*WLIT*             0 CONSTANT NF*WLIT*
\ Target compiler: newforth               ( 13  5 86 CRC 14:20 )
VOCABULARY NEWFORTH IMMEDIATE        BASE  @  HEX
: OF/NF [COMPILE] NEWFORTH DEFINITIONS [COMPILE] FORTH ;
 0 VARIABLE DPOLD   COMPILE-ADDR   VARIABLE DPNEW
 0 VARIABLE O/N    \ old/new:  t=new, false=old
  1F  ( 0) VARIABLE TWIDTH   \ target width. 0 = headerless
  1F  ( 0) VARIABLE WID      \ width for a word. use | to make
                             \ an ophan out of it.
: SETOLD   O/N  @    IF O/N OFF HERE DPNEW !
                    OF*WLIT*  ' *WLIT*  !
     DPOLD  @  DP ! OF*LIT*   ' *LIT*   !          THEN ;
: SETNEW   O/N  @ 0= IF O/N ON  HERE DPOLD !
                    NF*WLIT*  ' *WLIT*  !
     DPNEW  @  DP ! NF*LIT*   ' *LIT*   !          THEN ;
DELTA VARIABLE LAST   \ addr of top of new dictionary
BASE !  ;S
\ Target compiler: ?0s                    ( 14  5 86 CRC 16:57 )
: ?0S  CR 15 [ BLK  @ ] LITERAL .LINE 80 OUT ! DPNEW  @ DELTA -
  FBASE DO 2 I T@ 0= IF ?CR I 6 U.R 2+ THEN
  ?TERMINAL IF LEAVE THEN  +LOOP  ;
BASE @ HEX
: TID. PAD BL ASCII _ FILL DUP PFA LFA OVER -
  PAD SWAP CMOVE PAD COUNT 1F AND
  1- 2DUP TYPE  + C@ 7F AND EMIT          SPACE ;
BASE !
: .HERE  DPNEW  @ DELTA - 13 [ BLK  @ ] LITERAL .LINE
  10 .R ;
: .SIZE  DPNEW  @ DELTA -  BASE-ADDR - 14 [ BLK  @ ] LITERAL
  .LINE         10  U.R ;                        ;S
       target here =
       target size =
       Addresses of long words containing 0 in them:
\ Target compiler: /smudged               ( 14  5 86 CRC 13:21 )
BASE  @ HEX  0 VARIABLE <IMMED> 70 ALLOT
<IMMED> HERE OVER - ERASE                  <IMMED> 4+ <IMMED> !
: /SMUDGE <IMMED>  @ <IMMED> 4+ 2DUP - IF
  DO I  @ BL TOGGLE 4 +LOOP ELSE 2DROP THEN ;
: NFFIND BL WORD HERE DUP COUNT UPPER
  [ ' NEWFORTH 2+ ] LITERAL   @ (FIND) ;
: 'NF  /SMUDGE  NFFIND DUP         \ new does> structure !!!
   IF SWAP DROP THEN      /SMUDGE 0=    \ use 4 + on old vocabs
   IF HERE COUNT TYPE SPACE ." NF?" QUIT THEN ;
: REPLACED:BY              'NF CFA  @ SWAP ! ;
: BYTE:IN                  'NF CFA  @ DELTA + + 4+ ;
: [FROM:NEWFORTH]          'NF CFA  @ , ;  IMMEDIATE
: NFSEE:   'NF NFA 4-  @ WHERETHEN  R# ! EDIT ;
: NFDUMP:  BASE  @ HEX   >R DELTA FUDGE !  'NF CFA  @ DUP
   6 U.R  10 - -10 AND C/L WDUMP R> BASE ! ;   BASE ! ;S
\ Target compiler: auto-disk buffer grabbe( 12  2 87 CRC 19:41 )
BASE @ HEX
0 VARIABLE FILEHEADER  -4 ALLOT
HERE OVERHEAD DUP ALLOT ERASE
: +OVERHEAD    FILEHEADER + ;

HEX 601A FILEHEADER W!

\ DECIMAL  396 RLOAD
BASE !

: NFDIS:   DELTA FUDGE !  'NF CFA @ T@ DISASSEM ;




\ Target compiler: create-old create-new 6( 29  5 86 CRC 11:59 )
BASE  @ HEX
: CREATE-OLD SETOLD FIRST ( TAREA ) PAD - 0< 2 ?ERROR 0 ,
  ?ALIGN BL WORD HERE DUP  DUP C@ WIDTH @ MIN 1+ =CELLS ALLOT
  DUP DUP COUNT TYPE SPACE 80 TOGGLE HERE 1- 80 TOGGLE
  WHERENOW  SWAP  4- ! \  installs scr & line #s
  [COMPILE] NEWFORTH DEFINITIONS LATEST , CURRENT  @ ! ;

: CREATE-NEW SETNEW  OUT @ 32 > IF CR 6 SPACES THEN  ?ALIGN
  IMAGETOP DPNEW @ [ PAD HERE - C/L + ] LITERAL - - 0< 2 ?ERROR
  ( ?-BUF)  WID  @ IF
  BL WORD HERE DUP C@ TWIDTH @ 1F AND MIN 1+ =CELLS ALLOT
  DUP 80 TOGGLE HERE 1- 80 TOGGLE
  LAST  @ DELTA - , LAST ! THEN BASE  @ HEX HERE DELTA - 5 U.R
  BASE ! SPACE TWIDTH  @ WID ! ;   BASE ! ;S

\ initialises: easier setup for the colds ( 10  6 86 CRC 12:08 )
: BOOTPARAMETER  FBASE +  DELTA +  ! ;


: INITIALISES  'NF 4-  @ DELTA + DUP @ *USER* -
    IF ." Invalid user name " 0 ERROR  THEN
    4+ W@ ( 11/68k version ) 16 + BOOTPARAMETER ;

;S syntax:  val-1  INITIALISES  username
where  val  is some value, and username is the user variable
it will initialise.
Typical uses:
'NF (EMIT) CFA  HIWORD INITIALISES 'EMIT
EM US - CO -           INITIALISES 'FIRST

    2+ @ ( 11/68k version ) 12 + COMPILE-ADDR + ! ;
\ Target compiler: nf: nf; ascii txt      ( 14  5 86 CRC 12:25 )
: NF: !CSP CREATE-OLD SMUDGE
   [ ' QUIT CFA  @ ] LITERAL , IMMEDIATE [COMPILE] FORTH ] ;

: NF; ?CSP COMPILE ;S SMUDGE [COMPILE] [ ;           IMMEDIATE

: TXT ASCII " WORD  HERE C@ 1+ =CELLS ALLOT ( ?-BUF)  ;
   IMMEDIATE

: |  ?CR  WID OFF ." <orphan> "  ;

: mf  CR mf  BASE @ HEX
  IMAGETOP DPNEW @ - . ." Target bytes left. " BASE ! ;

: OFDUMP   BASE  @ HEX   >R FUDGE OFF [COMPILE] ' DUP CFA
   6 U.R  16 - -16 AND C/L WDUMP R> BASE ! ;
\ Target/resident literal                 ( 26  7 87 CRC 15:21 )
BASE  @ HEX
: <LIT>  DUP  FFFF8000  7FFF WITHIN
           IF   NF*WLIT* , W, ELSE       \ 16 bit target literal
                NF*LIT* ,  ,  THEN ;     \ 32 bit target literal

: LITERAL  STATE  @ IF
   O/N  @  IF DPL @ 1+ IF
             SWAP  <LIT>   <LIT>         \ 64 bit target literal
             ELSE DROP  <LIT> THEN  ELSE \ 32 bit target literal
      DPL  @ 1+ IF      \ resident literal, any size
      [COMPILE] DLITERAL ELSE [COMPILE] LITERAL
    THEN  THEN       \ interpretive literal
   ELSE DPL  @  1+ 0= IF DROP THEN  THEN  ;
IMMEDIATE             BASE ! ;S

\ Target compiler: literal -- interpret   ( 14  5 86 CRC 12:17 )
BASE  @ HEX
: IMMEDIATE LAST  @ C/L TOGGLE LATEST
        <IMMED>  @ ! 4 <IMMED> +! SMUDGE ;

: INTERPRET   BEGIN -FIND  IF  ( found) STATE  @ <
        IF CFA O/N  @ IF           @ THEN ,
        ELSE CFA  EXECUTE THEN
        ELSE HERE NUMBER [COMPILE] LITERAL
        THEN
\       ?TERMINAL IF IN  @ R# ! BLK  @ SCR ! ABORT THEN
        AGAIN ;

: V   IN @ NFDUMP: IN ! OFDUMP ;

                      BASE ! ;S
\ Target compiler: quit -- label          ( 13  5 86 CRC 14:51 )
: NFQUIT BLK OFF [COMPILE] [
     BEGIN BEGIN RP! CR QUERY INTERPRET OK STATE  @ 0= UNTIL
        .S ." NK"       AGAIN STOP
: LOAD  DUP BLOCK  W@ IF
        DUP BASE  @ >R DECIMAL SWAP CR 5 U.R SPACE  HEX
        BLK 2@ >R >R  C/L IN ! BLK ! INTERPRET
        R> R> BLK 2! ?CR 3 SPACES HEX .S R> BASE !
        ELSE DROP THEN ;
: THRU  1+ SWAP DO I LOAD LOOP ;
: CFA CFA  @ ;
: ==       ?EXEC SETOLD CURRENT  @ >R
     [COMPILE] ASSEMBLER DEFINITIONS CONSTANT
     R> CURRENT ! [COMPILE] FORTH SETNEW ;
: LABEL SETOLD DPNEW  @ DELTA - ==
     [COMPILE] ASSEMBLER ;
\ Target compiler: code -- variable       ( 14  5 86 CRC 11:05 )
BASE  @ HEX
: CODE  !CSP IN  @ ?EXEC CREATE-NEW
    IN ! HERE DELTA - CREATE-OLD , SMUDGE SETNEW
    HERE DELTA - 4+ , [COMPILE] ASSEMBLER  ASSEMBLER ~ ;

: CONSTANT IN  @ CREATE-NEW
    IN ! HERE DELTA - *CONSTANT* , SWAP   ,
    CREATE-OLD , SETNEW [COMPILE] FORTH ;

: VARIABLE IN  @ CREATE-NEW
    IN ! HERE DELTA - *VARIABLE* , SWAP   ,
    CREATE-OLD , SETNEW [COMPILE] FORTH ;
 BASE  !   ;S


\ assembler extensions for target compiler(  1  7 86 CRC 14:31 )
ASSEMBLER DEFINITIONS  BASE @ HEX

: OFUSER  \  --  | assemble an access to a user: u off &[
  U 'NF CFA DUP T@ *USER* -  0F ?ERROR   4+ TW@ &[ ;

: *+  DELTA + *+ ;

BASE ! FORTH DEFINITIONS

: +LOAD  +BLK LOAD ;

: +THRU  1+ SWAP DO I +LOAD LOOP ;



\ Target compiler: vocabulary -- user  68K( 13  5 86 CRC 14:56 )
BASE  @ HEX
\ : VOCABULARY IN  @ CREATE-NEW
\     IN ! HERE DELTA - ( *DOES>* , )  *VOCAB* ,  A081 W,
\     LAST  @ DELTA - , 0 ,    \ new does>   !!
\     CREATE-OLD , SETNEW [COMPILE] FORTH ;

: USER     IN  @ CREATE-NEW
    IN ! HERE DELTA - *USER*     , SWAP W,  \ words for 68K!!
    CREATE-OLD , SETNEW [COMPILE] FORTH ;   \ offset is 16 bit

\ : COMPILE   ?COMP R> DUP 4+ >R  @ ,   ;  \ n.b. target only!
BASE !   ;S
    IN ! HERE DELTA - ( *DOES>* , )  *VOCAB* ,  A081 ,


\ chop target compiler                    ( 11 12 86 CRC 17:16 )
: GOLDEN  \ -- | saves data to chop xcompiler
  [ ' NEWFORTH  2+ ] LITERAL @ CHOPLINE    !
  [ ' ASSEMBLER 2+ ] LITERAL @ CHOPLINE 4+ !
  HERE                         CHOPLINE 8 + ! ;

: CHOP   [COMPILE] FORTH DEFINITIONS   EDITOR FLUSH
  CHOPLINE 8 + @ DP !  DELTA FUDGE !
  WORKSPACE IMAGETOP OVER - ERASE    ASSEMBLER ~ FORTH
  SETNEW  COMPILE-ADDR DP !  SETOLD SETNEW  DELTA LAST !
  <IMMED> 4+ <IMMED> !  CHOPLINE @ [ ' NEWFORTH 2+ ] LITERAL !
  CHOPLINE 4+ @ [ ' ASSEMBLER 2+ ] LITERAL !  ;    ;S

WARNING:  no additions to any voc save  NEWFORTH  and  ASSEMBLER
after  GOLDEN  is invoked!!!!!!!!!!!!!!!

\ 68000 ASSEMBLER ADDRESSING MODES          08 08 85 BJR
;S
     DRn                data reg direct         Dn
     ARn                addr reg direct         An
     ARn [              indirect                (An)
     ARn [+             indirect postincr       (An)+
     ARn -[             indirect predecr        -(An)
   d ARn &[             indirect w/ displ       d(An)
   d ARn i &A[          indirect w/ index       d(An,Ai.W)
   d ARn i &A[ .LR              "               d(An,Ai.L)
   d ARn i &D[                  "               d(An,Di.W)
   d ARn i &D[ .LR              "               d(An,Di.L)
 abs @#                 absolute short          abs.W
 abs @#L                absolute long           abs.L


\ 68000 ASSEMBLER ADDRESSING MODES          08 08 85 BJR
;S
     *+                 PC w/ displ             d(PC)
 d i &A*+               PC w/ index             d(PC,Ai.W)
 d i &A*+ .LR                "                  d(PC,Ai.L)
 d i &D*+                    "                  d(PC,Di.W)
 d i &D*+ .LR                "                  d(PC,Di.L)
   n #                  immediate               #nnn
   n #L                 immediate long          #nnn
     CCR                implicit                CCR
     SR                     "                   SR
     USP                    "                   USP

Note 1: size indicators  .B  .W  .L  precede opcode
Note 2: immediate mode must match size (e.g. .L requires #L)
Note 3:   cc i adr *+ DBCC,  is equivalent to  DBcc Di,adr
\ Target compiler: user -- vocabulary  68k( 14  5 86 CRC 14:18 )
BASE  @ HEX
: WHO DELTA + 4+ NFA ID. ;

: :   !CSP IN  @ ?EXEC CREATE-NEW
    IN ! HERE DELTA - *COLON*    ,
    CREATE-OLD , SMUDGE SETNEW ] ;

NF: OF/NF [COMPILE] NEWFORTH DEFINITIONS [COMPILE] FORTH  NF;


' NFQUIT 4- ' 'NF 40 + !       LATEST PFA LFA OFF
 BASE  !   ;S



\ Target compiler: nf: x -- [compile]     ( 11  7 86 CRC 11:41 )
BASE  @ HEX
NF: X BLK  @    IF ?EXEC THEN R> DROP NF;
80 LATEST 1+ C!                     \ rename it "null"

NF: \ [COMPILE] \ NF;

NF: GAP   0 , NF;

NF: [COMPILE] [COMPILE] [FROM:NEWFORTH]  NF;
 BASE  !   ;S

NF: WHO DELTA + NFA ID.  NF;



\ Target compiler: nf: ;code -- ."        ( 13  5 86 CRC 15:01 )
BASE  @ HEX
NF: ;CODE
     *(;CODE)*  , HERE DELTA - -4  CSP +!    \ adjust csp
     [COMPILE] ASSEMBLER   [COMPILE] [  NF;
\  HERE  is left on the stack. The programmer MUST manually
\ insert it into the proper *xxxxx*  constant
\ e.g. : fred .... ;code ... next  ' *fred* !

\ NF: ASSEMBLER    ASSEMBLER                      NF;

NF: DOES>            *(;CODE)* ,  HERE DELTA -  -4 CSP +!
  4EB9 ,          *DOES>* ,  NF;   \ in *xxx* constant
 \ absolute .long jsr,
NF: ."           *(.")*  , [COMPILE]  TXT   NF;
 BASE  !   ;S
\ Target compiler: {         -- }         ( 16  1 87 CRC 18:59 )
NF: {  SETOLD   [COMPILE] FORTH     [COMPILE] [ NF;

NF: }  SETNEW ] [COMPILE] NEWFORTH              NF;

NF: <BUILDS 0 CONSTANT -4 ALLOT NF;

NF: ( [COMPILE] ( NF;

NF: FORTH                      NF;

NF: LITERAL              <LIT> NF;

NF: SEE: SEE: NF;

NF: WHERE    OF/NF [COMPILE] WHERE   NF;    GOLDEN
\ Target compiler: nf: ;  -- while        ( 13  5 86 CRC 15:22 )
BASE @ HEX
NF: ;   ?CSP COMPILE  [FROM:NEWFORTH] ;S
     SMUDGE [COMPILE] FORTH [COMPILE] [ NF;
NF: THEN        HERE OVER - SWAP W! NF;
NF: BEGIN       HERE NF;
NF: DO          COMPILE [FROM:NEWFORTH] (DO) HERE NF;
NF: LOOP        COMPILE [FROM:NEWFORTH] (LOOP)  HERE - W, NF;
NF: +LOOP       COMPILE [FROM:NEWFORTH] (+LOOP) HERE - W, NF;
NF: UNTIL       COMPILE [FROM:NEWFORTH] 0BRANCH HERE - W, NF;
NF: IF          COMPILE [FROM:NEWFORTH] 0BRANCH HERE 0 W, NF;
NF: WHILE       COMPILE [FROM:NEWFORTH] 0BRANCH HERE 0 W, NF;
 BASE  !   ;S
NF: ENDIF       HERE OVER - SWAP W! NF;
N.B.  all branches use 16 bit displacements!!!
if you can't write a word with that, you're in trouble.
\ Target compiler: again  -- stop         ( 13  5 86 CRC 15:21 )
BASE @ HEX
NF: AGAIN       COMPILE [FROM:NEWFORTH] BRANCH HERE - W, NF;
NF: REPEAT SWAP COMPILE [FROM:NEWFORTH] BRANCH HERE - W,
             HERE OVER - SWAP W! NF;
NF: ELSE        COMPILE [FROM:NEWFORTH] BRANCH HERE 0 W,
        SWAP HERE OVER - SWAP W! NF;

NF: ASCII   *WLIT* ,  BL WORD  HERE 1+ C@          W,  NF;

NF: CTL     *WLIT* ,  BL WORD  HERE 1+ C@
  WLIT [ 1F W, ] AND                               W,  NF;

NF: STOP    SMUDGE [COMPILE] FORTH [COMPILE] [ SETOLD NF;
 BASE  !   ;S

















































;S debugger help screen                   ( 20  6 86 CRC 11:40 )
.STAT        -- print out the most recent status register.
AR0  DR0   S  RP , etc. -- select registers by name.
NOTRACE      -- Stop trace in a compiled word.
SR@  &  SR!  -- for playing with the status register.
       --> VERY dangerous!!! This can shut off keyboard, etc,!!
SHOWALL      -- display all registers in the debugger.
SKIP         -- skip over the next instruction in the trace.
SPEAKER      -- show the processor after each instruction while
                 doing a multi-step trace. Turn  ON  &  OFF .
STEP         -- execute one step in the current trace.
STEPS        -- execute n steps in the current trace.
TRACING      -- start tracing in a compile word.
TRACE        -- start tracing at a given address.
WHERE        -- points the editor to the error source
  Scr 241 has some sample code for use with the debugger.
\ 68000 assem: load, user variables       ( 12  9 85 CRC       )
FORTH DEFINITIONS               VOCABULARY ASSEMBLER IMMEDIATE
BASE @ HEX
ASSEMBLER DEFINITIONS           1 VARIABLE SIZE
   \ double these for use on 32 bit machine!!
90 USER DP2                    92 USER (QUIET)
94 USER OP#
96 USER REG                    A0 USER REG1
98 USER MODE                   A2 USER MOD1
9A USER EXT                    A4 USER EXT1
9C USER EXTL                   A6 USER EXTL1
9E USER ADTYPE                 A8 USER ADTYPE1
DP2 EXTL1 OVER - 2+ ERASE      REG1 REG - CONSTANT VARLEN
  DECIMAL 271 296 HEX THRU
BASE ! FORTH DEFINITIONS

\ 68000 assem: clearvar, sizes, .scr&line ( 19  5 86 CRC 15:37 )
: CLEARVAR     REG  VARLEN ERASE  0F REG  ! ;    CLEARVAR

: CLEARVAR1    REG1 VARLEN ERASE  0F REG1 ! ;    CLEARVAR1

: 0U.  0 <# # # # # #> TYPE ;

: .SCR&LINE  \ print current line
   BLK @ DUP .SCR SPACE IN @ C/L / DUP 3 .R 10 TAB SWAP .LINE ;

: .SIZE <BUILDS , DOES> @ SIZE ! ;

0 .SIZE .B        1 .SIZE .W     2 .SIZE .L
DECIMAL
: .MSG    -DUP IF 297 (LINE) -TRAILING TYPE THEN ;
HEX
\ 68000 assem: 1st, error, (operand), v!  ( 28  9 85 CRC       )
: 1ST ( !CSP)  CLEARVAR CLEARVAR1   .L  \ set to cell size
  (QUIET) @ IF BASE @ DECIMAL CR .SCR&LINE 52 TAB
  HEX HERE FUDGE @ - 0U. ASCII | EMIT BASE ! THEN ;
: 2ND REG  REG1 VARLEN CMOVE          CLEARVAR ;
: ~  OP# OFF CLEARVAR  CLEARVAR1 ;   \ reset operand info
: ERROR ~  HERE COUNT TYPE ."  ? "  .MSG
     SP! IN  @ BLK @  QUIT  STOP  \ custom error stuff
: ?ERROR    SWAP IF ERROR ELSE DROP THEN ;
: (OPERAND)  OP# @ -DUP IF  \ operand storage setup
      1-  1 ?ERROR   2ND ELSE 1ST THEN OP# 1+! ;
: ^ ;     \ maintain compatibility
: SIZECK  -1 XOR OVER AND  3 ?ERROR ;
: V!  ADTYPE ! MODE ! 7 SIZECK REG ! ;
: {  [COMPILE] [ ;       IMMEDIATE

\ 68000 assem: registers, .lr               11 02 85 CRC
: .LR   EXT @ 800 OR EXT ! ;

: INDEXREG   7 SIZECK 1000 * EXT @ OR SWAP FF SIZECK OR ;

: DATAREG   <BUILDS ,   DOES> (OPERAND)  @  0 1 V! ;
: ADDREG    <BUILDS ,   DOES> (OPERAND)  @  1 2 V! ;

  0 DATAREG DR0  1 DATAREG DR1  2 DATAREG DR2  3 DATAREG DR3
  4 DATAREG DR4  5 DATAREG DR5  6 DATAREG DR6  7 DATAREG DR7

  0  ADDREG AR0  1  ADDREG AR1  2  ADDREG AR2  3  ADDREG AR3
  4  ADDREG AR4  5  ADDREG AR5  6  ADDREG AR6  7  ADDREG AR7
                                               3  ADDREG S
  4  ADDREG IP   5  ADDREG W    6  ADDREG U    7  ADDREG RP
 \ These just happen to be the "C" registers, ay - yup!!
\ 68000 assem: addressing modes           (  4  9 85 CRC       )
 \ register indirect            register indirect w/ postinc.
:  [ REG @ 2 4  V! ;            : [+ REG @ 3 8  V! ;
 \ addr indirect w/ predec      register indirect w/ displace
: -[ REG @ 4 10 V! ;            : &[ REG @ 5 20 V!  EXT ! ;
 \ address reg indirect w/ index ( and displacement)
: &D[ REG @ 6 40 V!  INDEXREG 7FFF AND EXT ! ; \ # ar dr# &d[
       \ e.g.  4 ar0 3 &d[: disp 4 + ar0 + dr3
: &A[ REG @ 6 40 V!  INDEXREG 8000 OR  EXT ! ; \ # ar ar# &a[
 \ absolute short address
: @#  (OPERAND)  0 7  80 V!       EXT !        ; \ absolute
 \ absolute long address
: @#L (OPERAND)  1 7 100 V!       EXT ! EXTL ! ;
 \   r# mod adtype


\ 68000 assem: more addressing modes      (  4  9 85 CRC       )
: *+    (OPERAND)  2 7  200 V! HERE - 2- EXT ! ;
  \ pc w/ index ( and displacement) -- data register
: &D*+  (OPERAND)  3 7  400 V! SWAP HERE - 2- SWAP
         INDEXREG 7FFF AND EXT ! ; \ disp dr &D*+
  \ pc w/ index ( and displacement) -- addr register
: &A*+  (OPERAND)  3 7  400 V! SWAP HERE - 2- SWAP
         INDEXREG 8000 OR  EXT ! ; \ disp dr &A*+
  \ immediate data ( word)
: #     (OPERAND)  4 7  800 V!  EXT !        ;
  \ immediate data ( long)
: #L    (OPERAND)  4 7 1000 V!  EXT ! EXTL ! ;
: SR    (OPERAND)  4 7 4000 V!  .W ;
: CCR   (OPERAND)  4 7 2000 V!  ;
: USP   (OPERAND)  4 7 8000 V!  ;

\ 68000 assem: lay, odds&ends, bad        ( 12  9 85 CRC       )
: LAY    DUP , (QUIET) @ IF BASE @ HEX SWAP 0U. BASE !
      2 SPACES ELSE DROP THEN ;

: ODDS&ENDS   \ SP@ CSP @ - -DUP IF 6 .R    3 ERROR
      ADTYPE1 @ 1000 = IF SIZE @ 2-    4 ?ERROR THEN
      ADTYPE1 @  800 = IF SIZE @ 2 AND 5 ?ERROR THEN
      ADTYPE  @ 2 AND ADTYPE1 @ 2 AND OR SIZE @ 0= AND 7 ?ERROR
       ;  \ reset for next instruction.

: BAD  7 ERROR   STOP





\ 68000 assem: layext, finish             ( 12  9 85 CRC       )
: LAYEXT        ADTYPE1  @  0EE0 AND
   IF  \ &[  &D[ &A[  @#  *+  &D*+  &A*+  #
     EXT1 @ LAY    ELSE  ADTYPE1 @  1100 AND
   IF  ( @#L  #L ) EXT1 2@ LAY LAY   THEN THEN
                ADTYPE   @  0EE0 AND
   IF  \ &[  &D[ &A[  @#  *+  &D*+  &A*+  #
     EXT  @ LAY    ELSE  ADTYPE  @  1100 AND
   IF  ( @#L  #L ) EXT  2@ LAY LAY  THEN THEN    ;

: FINISH  ODDS&ENDS LAY  LAYEXT ~ ;





\ 68000 assem: condition codes, ?bytebr     08 10 84 CRC
: BRCH <BUILDS ,  DOES> @  ;

  0 BRCH TRUE   100 BRCH FALSE   200 BRCH HI     300 BRCH LS
400 BRCH CC     500 BRCH CS      600 BRCH NE     700 BRCH EQ
800 BRCH VC     900 BRCH VS      A00 BRCH PL     B00 BRCH MI
C00 BRCH GE     D00 BRCH LT      E00 BRCH GT     F00 BRCH LE

: ?BYTEBR  ( n --- n f )  DUP -81 OVER < SWAP 80 < AND
      SWAP FF AND SWAP ;






\ 68000 assem: typesfit, case stuff       ( 12  9 85 CRC       )
: TYPESFIT?  \ caseval1, caseval2 --- fl
        ADTYPE  @ -DUP IF AND 0= THEN SWAP
        ADTYPE1 @ -DUP IF AND 0= THEN OR 0= ;
transient
: TYPESOF    \ executes if operand1 & operand2 types are in
             \ caseval pairs.
        4 ?PAIRS COMPILE TYPESFIT?  COMPILE 0BRANCH
        HERE 0 , 5 ; IMMEDIATE

: ENDTYPESCASE  4 ?PAIRS COMPILE BAD
       \ does bad if mode illegal; adds finish at end
         BEGIN  SP@ CSP @ = 0=
         WHILE 2 [COMPILE] THEN  REPEAT
         CSP ! COMPILE FINISH ;   IMMEDIATE
permanent
\ 68000 assem:  1manip --  6manip, 11-14  ( 12  9 85 CRC       )
:  1MANIP   REG1 @ OR ;              \ 0-2R1
:  2MANIP   REG  @ OR ;              \ 0-2R1

:  3MANIP   REG1 @ 200 * OR ;        \ 9-11R1
:  4MANIP   REG  @ 200 * OR ;        \ 9-11R1

:  5MANIP   1MANIP  MOD1 @ 8 * OR ;  \  EA1
:  6MANIP   2MANIP  MODE @ 8 * OR ;  \  EA1

: 11MANIP   SIZE @ 0=   8 ?ERROR ;
: 12MANIP   SIZE @      9 ?ERROR ;
: 13MANIP   SIZE @ 1 - 0A ?ERROR ;
: 14MANIP   SIZE @ 2 - 0B ?ERROR ;


\ 68000 assem:  7manip -- 10manip, 15-17  ( 23  7 85 CRC       )
:  7MANIP   SIZE @ C/L * OR ;         \ 6-7 size
:  8MANIP   11MANIP  SIZE @ BL * OR ;
:  9MANIP   11MANIP  SIZE @ 80 * OR ;

1000 VARIABLE MSIZE 3000 , 2000 , 3000 ,
: 10MANIP   MODE @ 40 * OR  SIZE @ 2* MSIZE + @ OR ;  \ movesize

: 15MANIP   EXT @ ?BYTEBR       \ bra, bsr
      IF ( 8 bit) ADTYPE OFF OR ELSE DROP  THEN ;

: 16MANIP   SWAP F00 SIZECK OR ;  \  branch
: 17MANIP   ROT  F00 SIZECK OR  SWAP 7 SIZECK OR ;  \ dbcc



\ 68000 assem: 18manip -- 22manip         ( 23  7 85 CRC       )
         \ addq
: 18MANIP   ADTYPE1 OFF  EXT1 @ 1- 7 SIZECK 1+ 7 AND 200 * OR ;

: 19MANIP   ADTYPE1 OFF ADTYPE OFF EXT1 @ FF SIZECK OR ; \ moveq

: 20MANIP   MOD1 @ 0= IF 20 OR REG1 @  \ shift
            ELSE EXT1 @ 1- 7 SIZECK 1+ 7 AND
            ADTYPE1 OFF THEN  200 * OR ;

: 21MANIP   ADTYPE OFF EXT @ 0F SIZECK OR ;  \ trap

: 22MANIP   EXT @ EXT1 @ EXT ! EXT1 !  EXTL1 @ EXTL !  \ movem
            ADTYPE @ ADTYPE1 @ ADTYPE ! ADTYPE1 ! ;


\ 68000 assem: 23manip -- manip           ( 12  9 85 CRC       )
: 23MANIP   ADTYPE @ 10 = ( reverse mask?)
            IF EXT1 @ 10 0 DO  0 2 U/ LOOP
                    1 10 0 DO  ROT OVER * ROT OR SWAP 2* LOOP
            DROP EXT1 ! THEN ;

: 24MANIP   .B ;  \ used to force bit instr to correct size

: MANIP     DUP 0< 7 ?ERROR   19 MIN  EXEC
  |       1MANIP  2MANIP  3MANIP  4MANIP  5MANIP  6MANIP  7MANIP
  8MANIP  9MANIP 10MANIP 11MANIP 12MANIP 13MANIP 14MANIP 15MANIP
 16MANIP 17MANIP 18MANIP 19MANIP 20MANIP 21MANIP 22MANIP 23MANIP
 24MANIP   BAD   STOP



\ 68000 assem: saveset, getlegal, forminst  11 02 85 CRC
transient
: SAVESET  C, ( 3rd manip) C,  ( 2nd) C,  ( 1st) \ make , to
           ,  ( instruction basis)     \ use on pdp 11 - word!!
        , ,  ( bit mapped set of 1st & 2nd legal modes) ;
permanent
: GETLEGALTYPESET \ ptr -- ptr modset modset
      DUP  7 + @ OVER 5 + @ ;                       \ 11, 68K
\     DUP 0A + @ OVER 8 + @ ;                       \ byte
: FORMINST  \ ptr -- instruction word                \ 11:
      DUP 3 + @   \ get basis                        \  6 +
      OVER 2+ C@ MANIP   \ modify basis by 1st manip \  4 +
      OVER 1+ C@ MANIP   \ modify basis by 2nd manip \  2+
      SWAP    C@ MANIP   \ modify basis by 3rd manip
   ;

\ 68000 assem: savesets, 1mi, 2mi           04 01 85 CRC
transient
:  SAVESETS \ tos has count, number of sets to save.
   0 DO SAVESET  LOOP ;
permanent
: 1MI <BUILDS   SAVESET   DOES> CASE
        GETLEGALTYPESET  TYPESOF FORMINST ENDOF
           ENDTYPESCASE ;

: 2MI <BUILDS 2 SAVESETS  DOES> CASE
        GETLEGALTYPESET  TYPESOF FORMINST ENDOF
   9 +  GETLEGALTYPESET  TYPESOF FORMINST ENDOF
           ENDTYPESCASE ;

\ 0C +  GETLEGALTYPESET  TYPESOF FORMINST ENDOF \ 11 version

\ 68000 assem: 4mi, 6mi                     04 01 85 CRC
: 4MI <BUILDS 4 SAVESETS  DOES> CASE
        GETLEGALTYPESET  TYPESOF FORMINST ENDOF
   9 +  GETLEGALTYPESET  TYPESOF FORMINST ENDOF
   9 +  GETLEGALTYPESET  TYPESOF FORMINST ENDOF
   9 +  GETLEGALTYPESET  TYPESOF FORMINST ENDOF
           ENDTYPESCASE ;
: 6MI <BUILDS 6 SAVESETS  DOES> CASE
        GETLEGALTYPESET  TYPESOF FORMINST ENDOF
   9 +  GETLEGALTYPESET  TYPESOF FORMINST ENDOF
   9 +  GETLEGALTYPESET  TYPESOF FORMINST ENDOF
   9 +  GETLEGALTYPESET  TYPESOF FORMINST ENDOF
   9 +  GETLEGALTYPESET  TYPESOF FORMINST ENDOF
   9 +  GETLEGALTYPESET  TYPESOF FORMINST ENDOF
           ENDTYPESCASE ;

\ 68000 assem: instructions adbc -- and   ( 23  7 85 CRC       )
\    1     1 C100    1    4   0C
\   10    10 C108    1    4   0C     2MI ADBC,
  1FFF     2 D0C0    4    5    9         \ adda,
  1800   1FD  600    0    6    7         \ addi,
   7FF     1 D000    4    5    7
     1   1FC D100    3    6    7     4MI ADD,
   800   1FF 5000    6    7   12     1MI ADDQ,
     1     1 D100    1    4    7
    10    10 D108    1    4    7     2MI ADDX,
  1800  41FD  200    0    6    7         \ andi,
     1   1FC C100    3    6    7
   7FD     1 C000    4    5    7
   7FD     1 C000    4    5    7     4MI AND,


\ 68000 assem: instructions asl  -- bsr   ( 23  4 86 CRC 11:19 )
   801     1 E100    2    7   14
     0   1FC E1C0    0    6   0D     2MI ASL,
   801     1 E000    2    7   14
     0   1FC E0C0    0    6   0D     2MI ASR,
     0   200 6000    0   0F   10     1MI BCC,
     1   1FD  140    0    3    6
   800   1FD  840    0    0    6     2MI BCHG,
     1   1FD  180    0    3    6
   800   1FD  880    0   18    6     2MI BCLR,
     0   200 6000    0    0   0F     1MI BRA,
     1   1FD  1C0    0    3    6
   800   1FD  8C0    0   18    6     2MI BSET,
     0   200 6100    0    0   0F     1MI BSR,


\ 68000 assem: instructions btst -- eor   ( 23  7 85 CRC       )
     1   1FD  100    0    3    6
   800   1FD  800    0   18    6     2MI BTST,
   FFD     1 4180    4    5   0D     1MI CHK,
     0   1FD 4200    0    6    7     1MI CLR,
  1FFF     2 B0C0    4    5    9         \ cmpa,
  1800   1FD  C00    0    6    7         \ cmpi
     8     8 B108    1    4    7         \ cmpm
   7FF     1 B000    4    5    7     4MI CMP,
     0   200 50C8    0    0   11     1MI DBCC,
   FFD     1 81C0    0    4    5     1MI DIVS,
   FFD     1 80C0    0    4    5     1MI DIVU,
  1800  41FD  A00    0    6    7         \ eori
     1   1FD B100    3    6    7     2MI EOR,


\ 68000 assem: instructions exg  -- lsr   ( 11  9 85 CRC       )
     1     1 C140    2    3   0E
     2     2 C148    2    3   0E
     1     2 C188    1    4   0E
     2     1 C188    2    3   0E     4MI EXG,
     0     1 4880    0    2    8     1MI EXT,
     0   7E4 4EC0    0    0    6     1MI JMP,
     0   7E4 4E80    0    0    6     1MI JSR,
\  7E4     2 41C0    4    5   0E     1MI LEA,
\    2   800 4E50    0    0    1     1MI LINK,
   801     1 E108    2    7   14
     0   1FC E3C0    0    6   0D     2MI LSL,
   801     1 E008    2    7   14
     0   1FC E2C0    0    6   0D     2MI LSR,


\ 68000 assem: instructions mov  -- mulu  ( 23  7 85 CRC       )
  1FFF   1FF    0    4    5   0A         \ mov, incl mova
   FFD  2000 44C0    0    5   0C         \ mov, to ccr
   FFD  4000 46C0    0    5   0D         \ mov, to sr
  4000   1FD 40C0    0    6   0D         \ mov, from sr
     2  8000 4E60    0    1   0E         \ mov, to usp
  8000     2 4E68    0    2   0E         \ mov, from usp
                                     6MI MOV,
   7EC   800 4C80    5    8   16
   800   1F4 4880    6    8   17     2MI MOVM,
\    1    20  188    2    3    8
\   20     1  108    1    4    8     2MI MOVP,
   800     1 7000    0    4   13     1MI MOVQ,
   FFD     1 C1C0    0    4    5     1MI MULS,
   FFD     1 C0C0    0    4    5     1MI MULU,

\ 68000 assem: instructions nbcd -- rol   ( 23  7 85 CRC       )
\    0   1FD 4800    0    6   0C     1MI NBCD,
     0   1FD 4400    0    6    7     1MI NEG,
     0   1FD 4000    0    6    7     1MI NEGX,
     0     0 4E71    0    0    0     1MI NOP,
     0   1FD 4600    0    6    7     1MI NOT,
  1800  41FD    0    0    6    7         \ ori,
     1   1FC 8100    3    6    7
   7FD     1 8000    4    5    7
   7FD     1 8000    4    5    7     4MI OR,
\    0   7E4 4840    0    0    6     1MI PEA,
\    0     0 4E70    0    0    0     1MI RESET,
   801     1 E118    2    7   14
     0   1FC E7C0    0    6   0D     2MI ROL,


\ 68000 assem: instructions ror  -- stop  ( 23  7 85 CRC       )
   801     1 E018    2    7   14
     0   1FC E6C0    0    6   0D     2MI ROR,
   801     1 E110    2    7   14
     0   1FC E5C0    0    6   0D     2MI ROXL,
   801     1 E010    2    7   14
     0   1FC E4C0    0    6   0D     2MI ROXR,
     0     0 4E73    0    0    0     1MI RTE,
\    0     0 4E77    0    0    0     1MI RTR,
     0     0 4E75    0    0    0     1MI RTS,
\    1     1 8100    1    4   0C
\   10    10 8108    1    4   0C     2MI SBCD,
     0   1FD 50C0    6   12   10     1MI SCC,
\    0   800 4E72    0    0   0D     1MI STOP,


\ 68000 assem: instructions sub  -- unlk  (  2  9 85 CRC       )
  1FFF     2 90C0    4    5    9         \ suba,
  1800   1FD  400    0    6    7         \ subi,
   7FF     1 9000    4    5    7
     1   1FC 9100    3    6    7     4MI SUB,
   800   1FF 5100    6    7   12     1MI SUBQ,
     1     1 9100    1    4    7
    10    10 9108    1    4    7     2MI SUBX,
     0     1 4840    0    2   0D     1MI SWAP,
     0   1FD 4AC0   18    6   0C     1MI TAS,
     0   800 4E40    0    0   15     1MI TRAP,
\    0     0 4E76    0    0    0     1MI TRAPV,
     0   1FD 4A00    0    6    7     1MI TST,
\    0     2 4E58    0    0    2     1MI UNLK,


\ 68000 assem: next, fillbr, condbr       ( 28  9 85 CRC       )
\ HERE   ~ IP [+ ^ W MOV, ~  W [+ ^ AR0 MOV,  ~ AR0 [ JMP,
\ : NEXT  {  2 CSP +! ] LITERAL  HERE 6 DUP ALLOT CMOVE ;
: NEXT ~ IP [+ ^ W MOV, ~  W [+ ^ AR0 MOV,  ~ AR0 [ JMP, ;
: BYTEBRCHK  ?BYTEBR 0= 0C ?ERROR ;
: FILLBR   HERE OVER - 2- BYTEBRCHK OVER @ OR SWAP (QUIET) @
  IF 2DUP  4 SPACES FUDGE @ - 0U. ASCII | EMIT 0U. THEN ! ;

: CONDBR  F00 SIZECK 100 XOR 6000 OR ; \ cond --- 6x00
: ENDBR   SWAP HERE - 2- ?BYTEBR IF OR ~ LAY
   ELSE SWAP ~ LAY LAY THEN ;   \ addr 6x00  ---

: IF, ?EXEC CONDBR ~ LAY HERE 2- 2 ;
: ELSE,   ?EXEC 2 ?PAIRS 6000 ~ LAY FILLBR HERE 2- 2 ;
: THEN,   ?EXEC 2 ?PAIRS FILLBR ;
: BEGIN,  ?EXEC HERE 1 ~ ;
\ 68000 assem: conditionals               ( 14  9 85 CRC       )
: AGAIN,  ?EXEC 1 ?PAIRS 6000 ENDBR ;
: UNTIL,  ?EXEC SWAP 1 ?PAIRS CONDBR ENDBR ;
    \  --- whileaddr beginaddr 1 |
: WHILE,  ?EXEC SWAP 1 ?PAIRS CONDBR ~ LAY HERE 2- SWAP 1 ;
: REPEAT, AGAIN, FILLBR ;
\ : IFL,    IF, 0 LAY DROP 2+ 12 ;
\ : ELSEL,  ?EXEC 12 ?PAIRS 6000 ~ LAY 0 LAY  HERE OVER -
\           SWAP !   HERE 2- 12 ;
\ : THENL,  ?EXEC 12 ?PAIRS HERE OVER - SWAP ! ~ ;
\ : WHILEL, WHILE, 0 LAY ;
\ : REPEATL, AGAIN, 2+ HERE OVER - SWAP ! ;
: DO,    \ cc  ---  cc reg addr chk | mark start of  dbcc  loop
  ADTYPE @ 1-  0D ?ERROR REG @ BEGIN, 4 + ;
: LOOP,  \ cc reg addr chk ---  | assemble  dbcc  loop
  5 ?PAIRS *+ DBCC, ;   \ e.g. screen 394
\ 68000 assem: message screen!!!          ( 12  9 85 CRC       )
 Too many operands??
 Something too large here!!
 Wrong argument count!
 #L requires .L !
 # requires .W !
 No byte ops on addr regsisters!
 Has Wrong Addressing Mode
 Can't use byte!
 Byte only!
 Word only!
 Long only!
 Branch out of Range
 Data Register only
 PC Relative out of range!
 >> NOT a User Variable <<
\ 68000 Source Code: trial loader         ( 12  9 85 CRC       )
BASE @ HEX FORTH DEFINITIONS   DELTA LAST ! OF/NF    CR
DELTA FUDGE !   COMPILE-ADDR DUP DPNEW ! FIRST OVER - ERASE
SETOLD COMPILE-ADDR DPNEW ! mf SETNEW     DECIMAL WARNING ON
LOUD
\ LABEL >OUTPUT  2 , LABEL >INPUT  2 ,
\ 311 LOAD   \ source to be tried
ASSEMBLER DPNEW @ DELTA - LABEL IOB 18 ALLOT 359 LOAD
QUIET SETOLD CR mf DPNEW @ FIRST OVER - ERASE DECIMAL
?CRT 0= IFTRUE PAGE IFEND
BASE-ADDR  DPNEW @ DELTA - OVER - HEX  2DUP DUMP WDUMP

?CRT 0= IFTRUE PAGE IFEND
DECIMAL SPACE #BUFS . ." Buffers left"   BASE ! ;S


\ PDP 11 target compiler: dump              24 01 85 CRC
  BASE @ HEX       : OCTAL  8 BASE ! ;

: (WDUMP) \  from-address-2 cnt-1  ---  | memory displayed
   OVER + SWAP DO I T@ 7 U.R 2 +LOOP ;

: WHEAD   CR 6 SPACES 0F AND 10 0  \ start  ---  | header
   DO DUP I + BASE @ 1- AND 7 .R 2 +LOOP
   DROP ."  <<    ASCII   >>" ;

: WDUMP  \ from-addr  count ---  | dump
   BASE @ >R HEX   OVER  DUP WHEAD
   + SWAP   DO CR I 6 U.R I 10 2DUP (WDUMP) SPACE
   ASCI  I  F0 AND F0 = IF I WHEAD THEN
   ?TERMINAL  IF LEAVE  THEN  10 +LOOP CR R> BASE ! ;
  BASE !   ;S
\ 68000 Source Code: loader               ( 26  7 87 CRC 14:59 )
BASE @ >R       DECIMAL -60 +BLK NEEDED WORKSPACE
HEX FORTH DEFINITIONS    pTODAY  CHOP
SETOLD mf SETNEW     DECIMAL       WARNING ON
       81 +LOAD   \ loader pre-amble
   3   10 +THRU   \ source from lit to sp!
 -36  -35 +THRU   \ compiler directives
  11   64 +THRU   \ source from (key) to while
  75   79 +THRU   \ source from (key) on
(  73     +LOAD CR (  wdump)  SETOLD SETNEW
 112  119 +THRU  \ forward references
TXT Copyright 1986-1991 C. Curley" setold setnew
       80 +LOAD   \ tos loader patches
QUIET SETOLD CR mf HEX  DPNEW @ IMAGETOP OVER - ERASE
DECIMAL CR #BUFS . ." Buffers"  R> BASE !       CR pTODAY CR

\ base-addr memory map                    ( 17 10 85 CRC       )
all addresses are offset from base-addr
addr   count   comment
   0       6   jump to cold start
   6       6   jump to warm start
  0C       4   "68000" in radix 36, per fig model
  10       4   nfa of top of dictionary. Why, I don't know.
  14       4   backspace characters. Usually 7F & 08
  18       4   user area base address
  1C       4   top of parameter stack; orphaned user  S0
  20       4   top of return stack
  24      60   initial values for user variables




















\ 68000 : boot parameters area            ( 26  7 87 CRC 15:24 )
ASSEMBLER HEX ~ 0 @#L .L JMP,   \ cold start jmp,
 ( 4EF9 )     ~ 0 @#L .L JMP,   \ warm start jmp,
  9F7800 ,             0 ,    7F W, CTL H W, \ 2 backspaces on
\ 68000 radix 36   dict top   backspace chr  \ atari & ibm pc
HERE 78  DUP == COLDS  4- DUP ALLOT   ERASE  \ colds
CODE LIT  IP [+ S -[ MOV,  NEXT  ;C  'NF LIT  CFA  ' NF*LIT* !

CODE WLIT  IP [+ AR0 .W MOV,   AR0 S -[ MOV,  NEXT  ;C
       'NF WLIT  CFA    ' NF*WLIT*  !

CODE EXECUTE  S [+ W MOV,  W [+ AR0 MOV,  AR0 [ JMP, ;C




\ 68000 : branch 0branch (of) (loop) ;s   (  3  2 87 CRC 11:14 )
CODE BRANCH   BEGIN, 2DUP 2DUP  >R >R >R >R >R >R
  LABEL LP3   IP [ IP .W ADD,  NEXT ;C
CODE 0BRANCH  S [+ TST,  R> R> NE UNTIL,  2 # IP ADDQ, NEXT  ;C
   'NF 0BRANCH CFA  ' *0BRAN* !   'NF BRANCH CFA  ' *BRAN* !

CODE (OF)     S [+ DR0 MOV,   S [ DR0 CMP,   R> R> EQ UNTIL,
              2 # IP ADDQ,  4 # S ADDQ,  NEXT    ;C

CODE (LOOP)   1 # RP [ ADDQ,
  LABEL LP2   4 RP &[ DR7 MOV,  RP [ DR7 CMP,  R> R>  LE UNTIL,
  LABEL LP5   8 # RP ADDQ,  2 # IP ADDQ,   NEXT ;C
'NF (LOOP) CFA  ' *(LOOP)* !

CODE ;S       RP [+ IP MOV,  NEXT  ;C
         'NF ;S CFA  ' *;S*  !
\ 68000 : (+loop) (do) (pause) paws       ( 21  1 87 CRC 20:50 )
CODE (+LOOP)  S [+ DR7 MOV,  DR7 RP [ ADD,  DR7 TST,
              PL LP2 *+ BCC,
              4 RP &[ DR7 MOV,  RP [ DR7 CMP,
              GE LP5 *+ BCC,   LP3 *+ BRA,   ;C
'NF (+LOOP) CFA  ' *(+LOOP)* !
CODE (DO)  S [+ DR7 MOV,  S [+ RP -[ MOV,
           DR7 RP -[ MOV,  NEXT ;C
  \ call to pause current task.
LABEL (PAUSE)  RP 4 U &[ MOV, ( BEGIN,)  8 U &[ U MOV,
 ( U [ TST,  NE UNTIL,)  4 U &[ RP MOV,  RTS,
  \ call from i/o code definitions inside loops
LABEL PAWS   IP RP -[ MOV,  S RP -[ MOV,
             (PAUSE) *+ BSR,   \ execution resumes here
             RP [+ S MOV,  RP [+ IP MOV,  RTS,

\ 68000 : i digit pause                   ( 20  5 86 CRC 10:11 )
   \ or expand it out
CODE PAUSE  PAWS *+ BSR, NEXT   ;C

CODE I                                                       ;C

CODE DIGIT  DR7 CLR,  S [+ DR1 MOV,  S [ DR0 MOV,
   ASCII 0 # DR0 .W SUB,   CS IF,
LABEL BADDIG   DR7 S [ MOV,  NEXT  THEN, \ error exit
   09 # DR0 .W CMP,
   GT IF,  11 # DR0 .W CMP,  LT BADDIG *+ BCC,
   7 # DR0 .W SUB,    THEN,
   DR1 DR0 .W CMP,  GE BADDIG *+ BCC,
   DR0 .L EXT,  1 # DR7 ADDQ,
   DR0 S [ MOV,    DR7 S -[  MOV, NEXT   ;C

\ 68000 : (find) - part 1                 ( 18  9 88 CRC  9:14 )
\ DEBUG FORGET TASK
\ FORTH DEFINITIONS  : TASK ;        BASE @ >R HEX
CODE (FIND)  S [+ AR1 MOV,  S [ AR0 MOV,
  AR0 [+ DR7 .B MOV,  AR0 DR6 MOV,                \ -> 1st char
  6A ( forth's pseudo nfa) U &[ W LEA,            \ taskfix
  BEGIN,  AR1 W CMP,  LE IF,  W AR1 MOV,  THEN,   \ taskfix
    AR1 [ DR1 .B MOV,  3F # .W DR1 AND,   \ get len
    DR7 DR1 .B CMP,  EQ IF,   \  br on lens /=
    AR1 AR2 MOV,  1 # AR2 ADDQ,  DR6 AR0 MOV,
;S  -->

dr6 : word being searched
dr0 : word sought               dr7 : len of word sought
dr1 : length of current word
trial code for mods on scr 5298
\ 68000 : (find) - part 2                 ( 18  9 88 CRC  9:32 )
    BEGIN,  AR2 [+ .B DR4 MOV,  AR0 [+ DR0 .B MOV,
       DR0 DR4 .B EOR,  1 # DR4 .B ASL,
          EQ IF, ( ** ) >R >R  CS UNTIL,
       8 # AR2 ADDQ,  AR2 S [ MOV,                    \ pfa
       DR1 CLR,  AR1 [ DR1 .B MOV,  DR1 S -[ MOV,     \ count
       1 # DR0 MOVQ,  DR0 S -[ MOV,  NEXT             \ flag
    ( **) R> R> THEN, THEN,  1 # AR1 SUBQ,
    BEGIN,  2 # AR1 ADDQ,  7 # AR1 [ BTST, NE UNTIL, \ nf -> lf
    1 AR1 &[ AR1 MOV,  AR1 DR0 MOV,  EQ UNTIL,
  DR0 S [ MOV, NEXT  ;C

;s
: TEST  BL WORD  HERE COUNT UPPER  HERE 10 DUMP
        HERE LATEST FND ;
editor flush   r> base !
\ 68000 : enclose                         ( 26  2 86 CRC       )
CODE ENCLOSE  S [+ DR0 MOV,      S [ AR0 MOV,
              -1 #L DR1 MOV,
      BEGIN,  1 # DR1 ADDQ,      0 AR0 1 &D[ DR0 .B CMP,
              NE UNTIL,          DR1 S -[ MOV,
LABEL ENCL3   0 AR0 1 &D[ DR0 .B CMP,      NE IF,
              0 # 0 AR0 1 &D[ .B CMP,      NE IF,
              1 # DR1 ADDQ,      ENCL3 *+ BRA,
      THEN,   S [ DR1 CMP,       EQ IF,
              1 # DR1 ADDQ,      DR1 S -[ MOV,
LABEL ENCL8   DR1 S -[ MOV,      NEXT
      THEN,   DR1 S -[ MOV,      ENCL8 *+ BRA,
      THEN,   DR1 S -[ MOV,      1 # DR1 ADDQ,
              ENCL8 *+ BRA,                    ;C
;S

\ 68000 : @execute exec sp@ sp!           ( 19  4 91 CRC 12:47 )
CODE @EXECUTE   RP [+ IP MOV,  S [+ AR1 MOV,
  AR1 [ W MOV,  W [+ AR0 MOV,  AR0 [ JMP, ;C
'NF @EXECUTE CFA  ' *@EXEC* !

CODE EXEC  \ index ---  | index to execution array
  S [+ DR0 MOV,  2 # DR0 ASL,  DR0 IP ADD,
  IP [ W MOV,  RP [+ IP MOV,  W [+ AR0 MOV,  AR0 [ JMP,  ;C

CODE SP!  0C U &[ S MOV,                   NEXT     ;C

CODE SP@  S S -[ MOV, NEXT  ;C

ASSEMBLER LABEL MASK 7F W,


\ 68000 : (emit) (key) (?terminal) mon    ( 19  4 91 CRC 12:46 )
CODE (EMIT)  S [+ DR0 MOV,  MASK *+ .W DR0 AND,  \ data
  DR0 RP -[ .W MOV,  U 7A ( i/o) &[ RP -[ .W MOV,
  3 # RP -[ .W MOV, \ routine            ^ device
  0D # TRAP,  6 # RP ADDQ,  NEXT   ;C
CODE (KEY)   BEGIN,  PAWS *+ BSR,  U 78 &[ RP -[ .W MOV,
  1 # RP -[ .W MOV, 0D # TRAP,  4 # RP ADDQ,  DR0 TST, NE UNTIL,
  U 78 &[ RP -[ .W MOV,  2 # RP -[ .W MOV,  0D # TRAP,
  4 # RP ADDQ,  FF #L DR0 AND,  DR0 S -[ MOV,  NEXT  ;C
CODE (?TERMINAL)   DR6 CLR,  U 78 ( i/o) &[ RP -[ .W MOV,  \ dev
  1 # RP -[ .W MOV, ( routine # ) 0D # TRAP,  DR0 .W TST,
  NE IF, ( eat it)  4 # RP ADDQ,   U 78 ( i/o) &[ RP -[ .W MOV,
  2 # RP -[ .W MOV,  0D # TRAP,  1 # DR6 ADDQ,
  THEN,  DR6 S -[ MOV,  4 # RP ADDQ,  NEXT    ;C
CODE MON   -FC FBASE + @#L AR0 MOV,  AR0 USP MOV,
  RP -[ .W CLR,  1 # TRAP,  ;C
\ 68000 : cmove 0= 0< >                   (  2  6 86 CRC 15:04 )
\ CODE QCMOVE    \ Warning: max count $7fff!!
\   S [+ DR0 MOV,  S [+ AR1 MOV,        scr 323
\   S [+ AR0 MOV,   HERE 4+ DELTA - *+ BRA,
\   FALSE DR0 DO,  AR0 [+ AR1 [+ .B MOV,   LOOP,  NEXT  ;C
\ <cmove removed from code; is separate word for addons

CODE 0=   DR7 CLR,   S [ TST,   EQ IF,  1 # DR7 ADDQ,  THEN,
  DR7 S [ MOV,  NEXT    ;C

CODE 0<   DR7 CLR,   S [ TST,   MI IF,  1 # DR7 ADDQ,  THEN,
  DR7 S [ MOV,  NEXT    ;C

CODE >    DR0 CLR,  S [+ DR1 MOV,  S [ DR1 CMP,
   LT IF,  1 # DR0 ADDQ,  THEN,  DR0 S [ MOV,  NEXT ;C

\ 68000 : drop 2drop u*                   ( 15  7 86 CRC 11:51 )
CODE DROP   4 # S ADDQ,  NEXT  ;C
CODE 2DROP  8 # S ADDQ,  NEXT  ;C

CODE U* S [+ DR0 MOV,     DR0 DR2 MOV,   DR0 DR4 MOV,
        S [+ DR1 MOV,     DR1 DR3 MOV,   DR1 DR5 MOV,
        DR2 .W SWAP,      DR3 .W SWAP,
        DR2 DR6 MOV,      DR3 DR7 MOV,
        DR7 DR2 MULU,     DR6 DR1 MULU,
        DR5 DR0 MULU,     DR4 DR3 MULU,  DR7 CLR,
        DR0 S -[ .W MOV,  DR0 .W SWAP,
        DR0 DR1 .W ADD,   DR7 DR2 ADDX,  DR2 .W SWAP,
        DR3 DR1 ADD,      DR7 DR2 ADDX,  DR2 .W SWAP,
        DR1 S -[ .W MOV,  DR1 .W SWAP,
        DR1 DR2 .W ADD,   DR2 S -[ MOV,
  NEXT   ;C
\ 68000 : u/ 4+ 2+ 1+ =cells              ( 12  2 87 CRC 17:38 )
CODE U/   S [+ DR2 MOV,  S [+ DR0 MOV,  S [ DR1 MOV,
  1F # DR3 .W MOV,     FALSE DR3 DO,
  1 # DR1 LSL,  1 # DR0 ROXL,   DR2 DR0 SUB,
  CS IF,  DR2 DR0 ADD,  ELSE,  1 # DR1 ADDQ, THEN,  LOOP,
  DR0 S [ MOV,   DR1 S -[ MOV,   NEXT   ;C

CODE 4+  4 # S [ ADDQ,   NEXT ;C

CODE 2+  2 # S [ ADDQ,   NEXT ;C

CODE 1+  1 # S [ ADDQ,   NEXT ;C

CODE =CELLS  S [ DR0 MOV,  1 # DR1 MOVQ,  DR1 DR0 AND,
  DR0 S [ ADD,  NEXT ;C

\ 68000 : and or xor rp! leave >r r> r      16  2 85 CRC
CODE AND   S [+ DR7 MOV,  DR7 S [ AND,          NEXT     ;C

CODE OR    S [+ DR7 MOV,  DR7 S [ OR,           NEXT     ;C

CODE XOR   S [+ DR7 MOV,  DR7 S [ EOR,          NEXT     ;C

CODE RP!   10 U &[ RP MOV,                      NEXT     ;C

CODE LEAVE  RP [ 4 RP &[  MOV,                  NEXT     ;C

CODE >R   S [+ RP -[ MOV,                       NEXT     ;C

CODE R>   RP [+ S -[ MOV,                       NEXT     ;C

CODE R    RP [  S -[ MOV,                       NEXT     ;C
\ 68000 : < rot + - d+                    ( 16  2 86 CRC       )
CODE <   DR0 CLR,  S [+ DR1 MOV,  S [ DR1 CMP,
   GT IF,  1 # DR0 ADDQ,  THEN,  DR0 S [ MOV,  NEXT  ;C

CODE ROT   S 8 &[ DR0 MOV,  S 4 &[ S 8 &[ MOV,
   S [ S 4 &[ MOV,  DR0 S [ MOV,  NEXT ;C

CODE +     S [+ DR7 MOV,  DR7 S [ ADD,     NEXT     ;C

CODE -     S [+ DR7 MOV,  DR7 S [ SUB,     NEXT     ;C

CODE D+    S [+ DR0 .L MOV,  S [+ DR1 .L MOV,
           DR1 S 4 &[  ADD,
           S [ DR1 MOV,  DR1 DR0 ADDX,
           DR0 S [ MOV,  NEXT ;C

\ 68000 : minus dminus over s->d swap dup   17  2 85 CRC
CODE MINUS   S [ NEG,  NEXT  ;C

CODE DMINUS   S 4 &[ NEG,  S [ NEGX,  NEXT ;C

CODE OVER   4 S &[ S -[ MOV,  NEXT ;C

CODE S->D   DR0 CLR, S [  TST,   MI IF,
    1 # DR0 SUBQ,  THEN,  DR0 S -[ MOV,  NEXT ;C

CODE SWAP   S [+ DR0 MOV,  S [ DR1 MOV,
            DR0 S [  MOV,  DR1 S -[ MOV,   NEXT ;C

CODE DUP   S [ S -[ MOV, NEXT  ;C


\ 68000 : -dup 2dup +! toggle within      ( 27  6 91 CRC  9:17 )
CODE -DUP   S [ TST,  'NF DUP CFA 4+ *+ NE BCC,  NEXT   ;C

CODE 2DUP   4 S &[ S -[ MOV,  4 S &[ S -[ MOV,  NEXT ;C

CODE NIP  S [+ S [ MOV,  NEXT   ;C

CODE +!   S [+ AR0 MOV,  S [+ DR1 MOV,  DR1 AR0 [ ADD,  NEXT ;C

CODE TOGGLE   S [+ DR1 MOV,  S [+ AR0 MOV,
              DR1 AR0 [ .B EOR,  NEXT ;C

CODE WITHIN  \ n l1 l2 --- fl | is n between lim1 & lim2 incl.?
 1 # DR0 MOVQ,  S [+ DR1 MOV,   S [+ DR2 MOV,
 S [ DR1 CMP,  LT IF,  DR0 CLR,  THEN,
 S [ DR2 CMP,  GT IF,  DR0 CLR,  THEN,  DR0 S [ MOV,  NEXT ;C
\ 68000 : @ c@ !                            21  2 85 CRC
CODE @   S [ AR0 .L MOV,       \ avoid byte boundary
   AR0 [+   S  [ .B MOV,       \ problems
   AR0 [+ 1 S &[ .B MOV,
   AR0 [+ 2 S &[ .B MOV,
   AR0 [  3 S &[ .B MOV,  NEXT  ;C

CODE C@  DR0 CLR,  S [ AR0 .L MOV,
         AR0 [ DR0 .B MOV,
         DR0 S [ MOV,   NEXT ;C

CODE !   S [+ AR0 .L MOV,
         S [+ AR0 [+ .B MOV,
         S [+ AR0 [+ .B MOV,
         S [+ AR0 [+ .B MOV,
         S [+ AR0 [  .B MOV, NEXT ;C
\ 68000 : c! 4- 2- 1- on off 1+!          ( 18  3 86 CRC       )
CODE C!  S [+ AR0 MOV,  3 # S ADDQ,
         S [+ AR0 [ .B MOV,  NEXT ;C

CODE 4-  4 # S [ SUBQ,  NEXT ;C

CODE 2-  2 # S [ SUBQ,  NEXT ;C

CODE 1-  1 # S [ SUBQ,  NEXT ;C

CODE ON  S [+ AR0 MOV,  1 # DR0 MOVQ,  DR0 AR0 [ MOV,  NEXT ;C

CODE OFF S [+ AR0 MOV,  AR0 [ CLR,  NEXT                 ;C

CODE 1+! S [+ AR0 MOV,  1 # AR0 [ ADDQ,  NEXT   ;C

\ 68000 : w@ w!                           ( 23  4 86 CRC 12:10 )
CODE W@   S [+ AR0 MOV,  AR0 1 &[ S -[ .B MOV,
  AR0 [ S -[ .B MOV,  S -[ .W CLR,   NEXT ;C

CODE W!   S [+ AR0 MOV,  2 # S ADDQ,  S [+ AR0 [+ .B MOV,
  S [+ AR0 [ .B MOV,  NEXT  ;C










\ 68000 : m*                                19  2 85 CRC
CODE M*    S [ DR2 MOV,  S 4 &[ DR1 MOV,
   DR1 DR3 MOV,  DR1 DR4 MOV,  DR4 .W SWAP,
   DR2 DR0 MOV,  DR0 .W SWAP,

   DR2 DR1 MULU,  DR4 DR2 MULU,  DR0 DR3 MULU,  DR0 DR4 MULU,

   DR1 .W SWAP,  DR2 DR1 .W ADD,
   DR0 CLR,  DR0 DR4 ADDX,  DR3 DR1 .W ADD,  DR0 DR4 ADDX,
   DR1 .W SWAP,  DR2 .W CLR,  DR2 .W SWAP, DR3 .W CLR,
   DR3 .W SWAP, DR3 DR2 ADD,  DR4 DR2 ADD,

   S [ TST,  MI IF,  S 4 &[ DR2 SUB,  THEN,
   S 4 &[ TST,  MI IF,  S [ DR0 SUB,  THEN,
   DR2 S [ MOV,  DR1 S 4 &[ MOV,
   NEXT ;C
\ 68000 : cmove                           ( 20  5 94 CRC 19:59 )
CODE CMOVE  \ slower than qcmove, but larger count
   S [+ DR0 MOV,  S [+ AR1 MOV,  S [+ AR0 MOV, \  DR0 TST,
   NE IF,  BEGIN,  AR0 [+ AR1 [+ .B MOV,  1 # DR0 SUBQ,
           EQ UNTIL,  THEN,  NEXT ;C











\ 68000 : m/                              ( 23  7 86 CRC 12:41 )
;S
CODE TM/      EDITOR FLUSH ASSEMBLER  HEX
  S [+ DR2 MOV,  S [+ DR0 MOV,  S [ DR1 MOV,
  DR2 TST,  MI IF,  DR1 NEG,  DR0 NEGX,  DR2 NEG,  THEN,
  DR0 TST,  MI IF,  DR2 DR0 ADD,  THEN,
  1F # DR3 .W MOV,  1 # DR1 LSL,
  FALSE DR3 DO,  1 # DR0 ROXL,  DR2 DR0 SUBX,
      CS IF,  DR2 DR0 ADD,  THEN,  1 # DR1 ROXL,  LOOP,
  DR1 NOT,  DR0 S [ MOV,  DR1 S -[ MOV,  NEXT   ;C   ;S






\ 68000 : : ; constant variable           ( 22  8 91 CRC 15:04 )
: :     GAP  ( ?exec) GAP ( !csp) GAP ( current)  @
        GAP  ( context)  !  GAP  ( create)  GAP  (  ] )
   ;CODE  IP RP -[ MOV,  W IP MOV,  NEXT  ;C IMMEDIATE
' *COLON*  !

: ;   GAP ( ?csp) GAP ( compile) ;S GAP ( smudge)
      GAP ( [ ) ;       IMMEDIATE

: CONSTANT  GAP ( create) GAP ( smudge) GAP ( , )
   ;CODE  W [ S -[ MOV,  NEXT  ;C  ' *CONSTANT* !

: VARIABLE  CONSTANT  ;CODE
  W S -[ MOV,  NEXT  ;C         ' *VARIABLE*  !


\ 68000 : user some constants +origin     (  7  8 86 CRC 13:51 )
: USER   GAP ( create) GAP ( smudge )  GAP  ( w, )
  ;CODE   U AR0 MOV,   W [ AR0 .W ADD,
  AR0 S -[ MOV,  NEXT ;C       ' *USER* !

    5 CONSTANT 5              40 CONSTANT C/L
    0 CONSTANT 0               1 CONSTANT 1
    2 CONSTANT 2               3 CONSTANT 3
    4 CONSTANT 4              20 CONSTANT BL

*B/BUF*  CONSTANT B/BUF   400 *B/BUF* / CONSTANT B/SCR

CODE +ORIGIN  FBASE #L S [ ADD,  NEXT ;C



\ 68000 : initialised user variable       ( 18  6 86 CRC 10:29 )
HEX  |  0 USER MOI              | 0C USER S0
       14 USER TIB                18 USER WIDTH
       1C USER WARNING            20 USER FENCE
       24 USER DP                 28 USER VOC-LINK
       2C USER 'KEY               30 USER 'EXPECT
       34 USER '?TERMINAL         38 USER 'EMIT
       3C USER 'TYPE              40 USER 'GOTOXY
       44 USER 'PAGE              48 USER 'LIST
       4C USER 'CR
       50 USER 'R/W               54 USER 'QUIT
       58 USER 'ABORT             5C USER 'CREATE
       60 USER 'FIRST             64 USER 'LIMIT
     ( 68 dummy for vocabs )   |  6C USER VLFTH
     ( 70 dummy for vocabs )   |  74 USER BOTSTACK
       78 USER I/O \ change  (key) , etc. if you change this
\ 68000 : uninitialised user variable     ( 18  3 86 CRC       )
\ leave gap to 80 for expansion of initialised user variables
   80 USER BLK                84 USER IN
   88 USER OUT                8C USER SCR
   90 USER OFFSET             94 USER CONTEXT
   98 USER CURRENT            9C USER STATE
   A0 USER BASE               A4 USER DPL
   A8 USER FLD                AC USER CSP
   B0 USER R#                 B4 USER HLD
   B8 USER USE                BC USER PREV

\ |  C0 USER CURSEG          |  C4 USER MEMPTR

CODE FIRST  OFUSER 'FIRST S -[ MOV,  NEXT     ;C

CODE LIMIT  OFUSER 'LIMIT S -[ MOV,  NEXT     ;C
\ 68000 : here allot , c, w,              ( 22  8 91 CRC 15:08 )
CODE HERE   OFUSER DP S -[ MOV,  NEXT     ;C

CODE ALLOT  S [+ DR0 MOV,  DR0 OFUSER DP ADD,  NEXT     ;C

CODE ,   OFUSER DP AR0 MOV,
    4 # OFUSER DP ADDQ,   'NF ! CFA T@ 2+ *+ BRA, ;C

CODE W,  OFUSER DP AR0 MOV,
    2 # OFUSER DP ADDQ,  'NF W! CFA T@ 2+ *+ BRA, ;C

CODE C,  OFUSER DP AR0 MOV,
    1 # OFUSER DP ADDQ,  'NF C! CFA T@ 2+ *+ BRA, ;C

CODE BACK    OFUSER DP AR0 MOV,   AR0 DR0 MOV,
  DR0 S [ SUB,  'NF W, CFA T@ 4+ *+ BRA,  ;C
\ 68000 : = key emit page cr r/w ?terminal( 27  6 91 CRC  9:23 )
CODE = DR0 CLR,  S [+ DR1 MOV,  S [ DR1 CMP,
  EQ IF,  1 # DR0 MOVQ, THEN,  DR0 S [ MOV,   NEXT   ;C

: KEY             PAUSE  'KEY       @EXECUTE    STOP

: EMIT   OUT 1+!  PAUSE  'EMIT      @EXECUTE    STOP

: PAGE                  'PAGE @ EXECUTE  OUT OFF ;

: CR                    'CR   @ EXECUTE  OUT OFF ;

: R/W        PAUSE  'R/W       @EXECUTE    STOP

: ?TERMINAL  PAUSE  '?TERMINAL @EXECUTE    STOP

\ 68000 : traverse latest pfa             ( 17  9 88 CRC 12:49 )
LABEL (TRAV)   BEGIN,  DR0 AR0 ADD,  7 # AR0 [ .B BTST,
  NE UNTIL,  RTS,

CODE NFA  FE # DR0 MOVQ,  S [ AR0 MOV,  8 # AR0 SUBQ,
  (TRAV) *+ BSR,  AR0 S [ MOV,  NEXT  ;C

CODE PFA   2 # DR0 MOVQ,  S [ AR0 MOV,  1 # AR0 SUBQ,
  (TRAV) *+ BSR,  9 # AR0 .W ADD,  AR0 S [ MOV,  NEXT  ;C

CODE TRAVERSE   S [+ DR0 MOV,  S [ AR0 MOV,
  (TRAV) *+ BSR,  AR0 S [ MOV,  NEXT  ;C

CODE LATEST  OFUSER CURRENT AR0 MOV,  AR0 [ S -[ MOV,  NEXT ;C

CODE LFA 8 # S [ SUBQ, NEXT ;C       CODE CFA   ;C
\ 68000 : space (page) u< ?align 4/ 4*    ( 17  9 88 CRC 12:51 )
: SPACE    BL EMIT  ;

: (PAGE)   0C EMIT  ;

CODE U<   DR0 CLR,  S [+ DR1 MOV,  S [ DR1 CMP,
   HI IF,  1 # DR0 ADDQ,  THEN,  DR0 S [ MOV,  NEXT  ;C

CODE ?ALIGN   OFUSER DP DR0 MOV,  1 # DR1 MOVQ,  DR1 DR0 AND,
          DR0 OFUSER DP ADD,   NEXT ;C

CODE 4/  S [ DR0 MOV,  2 # DR0 LSR,  DR0 S [ MOV,  NEXT ;C

CODE 4*  S [ DR0 MOV,  2 # DR0 LSL,  DR0 S [ MOV,  NEXT ;C


\ 68000 : !csp ?error ?comp ?exec ?loading( 15  2 86 CRC       )
CODE !CSP   S OFUSER CSP MOV,  NEXT     ;C

: ?ERROR    SWAP IF GAP   ( error) ELSE DROP THEN ;

: ?COMP     STATE @ 0=   11 ?ERROR ;

: ?EXEC     STATE @      12 ?ERROR ;

: ?PAIRS    -  13 ?ERROR ;

: ?CSP      SP@ CSP @ - 14 ?ERROR ;

: ?LOADING  BLK @ 0= 16 ?ERROR ;


\ 68000 : compile [ smudge hex bounds hex ( 29  1 89 CRC 10:19 )
: COMPILE    ?COMP  R> DUP 4+ >R @ , ;

CODE [  OFUSER STATE CLR, NEXT  ;C IMMEDIATE

CODE ]  C0 #L OFUSER STATE MOV,  NEXT ;C

CODE SMUDGE   OFUSER CURRENT AR0 MOV,
 AR0 [ AR0 MOV,  5 # AR0 [ BCHG,  NEXT ;C

CODE HEX      10 # DR0 MOVQ,  DR0 OFUSER BASE MOV,  NEXT ;C

CODE DECIMAL  0A # DR0 MOVQ,  DR0 OFUSER BASE MOV,  NEXT ;C

CODE BOUNDS  S [+ DR0 MOV,  S [ DR1 MOV,  DR1 DR0 ADD,
  DR0 S [ MOV,  DR1 S -[ MOV,  NEXT  ;C
\ 68000 : fill erase blanks abort quit    ( 29  5 86 CRC 17:11 )
CODE FILL S [+ DR0 MOV,  S [+ DR1 MOV,  S [+ AR0 MOV,
  BEGIN, DR0 AR0 [+ .B MOV,  1 # DR1 SUBQ,  EQ UNTIL,  NEXT ;C

CODE ERASE           DR0 CLR,
       'NF FILL CFA T@ 2+ *+ BRA, ;C

CODE BLANKS  BL # DR0 .W MOV,
       'NF FILL CFA T@ 2+ *+ BRA, ;C

: QUIT   'QUIT  @EXECUTE STOP      'NF QUIT  CFA ' *QUIT*  !

: ABORT  'ABORT @EXECUTE STOP      'NF ABORT CFA ' *ABORT* !

: TYPE   'TYPE  @EXECUTE STOP

\ 68000 : (;code) <builds does>             27  2 85 CRC
: (;CODE) R> LATEST PFA CFA ! ;  'NF (;CODE) CFA ' *(;CODE)* !

: <BUILDS   0 CONSTANT -4 ALLOT ;   \ new <builds ... does>
HERE DELTA - ' *DOES>* ! ?CR
  ASSEMBLER  LABEL DODOES
  RP [+ DR7 .L MOV,  \ get does addr
  IP RP -[ MOV,      \ push ip -- docol
  DR7 IP .L MOV,     \ we interpret at does
  W S -[ MOV,        \ put w on stack
  NEXT

: DOES>  COMPILE (;CODE) LIT { SETNEW
  ASSEMBLER DODOES ,  NEWFORTH }  4EB9 W,  , ; IMMEDIATE
                                    \ absolute .long jsr,

\ 68000 : count (type) -trailing (.") (cr)( 30  8 86 CRC 16:30 )
CODE COUNT  S [ AR0 MOV,  1 # S [ ADDQ,  DR0 CLR,
  AR0 [ DR0 .B MOV,  DR0 S -[ MOV,  NEXT   ;C

: (TYPE) -DUP IF BOUNDS DO R C@ EMIT LOOP  ELSE DROP THEN ;

CODE -TRAILING  S [+ DR0 MOV,  S [ AR0 MOV,  DR0 AR0 ADD,
  1 # DR0 ADDQ, BEGIN, 1 # DR0 SUBQ, NE IF, BL # AR0 -[ .B CMP,
  DROP ROT ROT NE UNTIL,  2 THEN,  DR0 S -[ MOV,  NEXT  ;C

: (.") R COUNT DUP 1+ =CELLS  R> + >R TYPE ;
   'NF (.")           CFA  ' *(.")*        !

: (CR)  ."   " ;


\ 68000 : ." (expect) expect query        ( 13  4 86 CRC       )
: ." ASCII "  STATE @
     IF COMPILE (.") GAP ( word)  HERE C@ 1+ =CELLS ALLOT
     ELSE GAP ( word) HERE COUNT TYPE THEN ;          IMMEDIATE

: (EXPECT) OVER + OVER          \ add for atari/ibm pc keyboard
     DO KEY DUP 14 +ORIGIN W@ =   OVER 16 +ORIGIN W@ = OR
        IF DROP 08 OVER R = DUP R> 2- + >R - ELSE
          DUP 0D = IF LEAVE DROP BL 0 ELSE  DUP THEN R C!
        0 R 1+ C! THEN   EMIT ( DROP)  LOOP     DROP ;

: EXPECT  PAUSE 'EXPECT  @EXECUTE  STOP

: QUERY TIB @ A0  EXPECT  IN OFF  ;


\ 68000 : x hold pad word (number)        ( 12  2 87 CRC 17:20 )
: X       BLK @ IF ?EXEC THEN R> DROP ;         IMMEDIATE
CODE HOLD 1 # OFUSER HLD SUBQ,   OFUSER HLD AR0 MOV,
  S [+ DR0 MOV,  DR0 AR0 [ .B MOV,   NEXT ;C
CODE PAD   OFUSER DP S -[ MOV,  80 #L S [ ADD,  NEXT ;C
: WORD BLK @ IF BLK @  GAP  ELSE  TIB @ THEN IN @ + SWAP
  ENCLOSE HERE 22 BLANKS IN +! OVER - >R  R HERE C!
  + HERE 1+ R> CMOVE ;    \  gap = block
CODE UPPER  S [+ DR0 MOV,  S [+ AR0 MOV,
  ASCII a # DR2 .B MOVQ,  ASCII z # DR3 .B MOVQ,  DR0 FALSE DO,
  AR0 [ DR1 .B MOV,  DR1 DR3 .B CMP,  HS IF,  DR1 DR2 .B CMP,
    LS IF,  20 # AR0 [ .B EOR,  THEN,  THEN,   1 # AR0 ADDQ,
    LOOP, NEXT   ;C
: (NUMBER) BEGIN 1+ DUP >R C@ BASE @ DIGIT
  WHILE SWAP BASE @ U* DROP ROT BASE  @ U* D+
       DPL @ 1+ IF DPL 1+! THEN R> REPEAT R> ;
\ 68000 : number -find error id.          ( 29  5 86 CRC 17:14 )
: NUMBER 0 0 ROT DUP 1+ C@ ASCII - = DUP >R + -1
  BEGIN DPL ! (NUMBER) DUP C@ BL -
      WHILE DUP C@ ASCII . - 0 ?ERROR 0 REPEAT
  DROP R> IF DMINUS THEN ;

: -FIND BL WORD HERE COUNT UPPER HERE CONTEXT @ @ (FIND)
  DUP 0= IF DROP HERE LATEST (FIND) THEN ;

: ERROR   WARNING @ 0<
  IF ABORT THEN HERE COUNT TYPE ."  ? "
  GAP ( message) SP!  BLK @ IF IN @ BLK @ THEN
  QUIT                                STOP

: ID. PAD BL ASCII _ FILL DUP PFA LFA OVER -
     PAD SWAP CMOVE PAD COUNT 1F AND TYPE SPACE ;
\ 68000 : b/drv maxblk drive empty-buffers( 18  1 87 CRC 12:44 )
DECIMAL
360 CONSTANT B/DRV               719 CONSTANT MAXBLK
360 CONSTANT B/SIDE          \   359 for 1 drive
PRIVATE IFTRUE DECIMAL 180 HEX LOAD IFEND

: DRIVE  B/DRV U* DROP OFFSET ! ;

CODE SETU/P          OFUSER 'FIRST DR0 MOV,
  DR0 OFUSER USE MOV,  DR0 OFUSER PREV MOV,  NEXT ;C

: EMPTY-BUFFERS FIRST LIMIT OVER - ERASE SETU/P ;




\ 68000 : create {compile] literal        ( 26  7 87 CRC 15:23 )
: CREATE  'CREATE   @EXECUTE     STOP

: [COMPILE] -FIND 0= 0 ?ERROR DROP CFA , ;            IMMEDIATE

: LITERAL  STATE @ IF  DUP  FFFF8000 7FFF WITHIN
     IF  COMPILE WLIT W,  ELSE  COMPILE LIT ,  THEN THEN ;
IMMEDIATE

PRIVATE IFTRUE
| -1 VARIABLE BADMAP  20 ALLOT
'NF BADMAP CFA 8 + DELTA + 20 ERASE           IFEND




\ 68000 : dliteral ?stack interpret immed ( 29  1 89 CRC 10:53 )
: DLITERAL  STATE @ IF SWAP [COMPILE] LITERAL
        [COMPILE] LITERAL  THEN ;                   IMMEDIATE

: ?STACK  S0 @ SP@            U< 1 ?ERROR
               SP@ BOTSTACK @ U< 7 ?ERROR ;
\ fixed so that tos & bos are user variables for multitasking

: INTERPRET   BEGIN -FIND  IF  ( found) STATE @ <
        IF CFA , ELSE  CFA EXECUTE THEN
        ELSE HERE NUMBER  DPL @ 1+
        IF [COMPILE] DLITERAL ELSE DROP [COMPILE] LITERAL THEN
        THEN ?STACK AGAIN     STOP

CODE IMMEDIATE  OFUSER CURRENT AR0 MOV,
 AR0 [ AR0 MOV,  6 # AR0 [ BCHG,  NEXT   ;C
\ 68000 : vocabulary forth definitions (  ( 12  2 87 CRC 17:27 )
: VOCABULARY <BUILDS  81A0  W, CURRENT @ 2- ,
       HERE VOC-LINK @ , VOC-LINK !  ;CODE
       2 # W ADDQ,  W OFUSER CONTEXT MOV,  NEXT ;C
' *VOCAB* !    ( Romable vocabulary !!!!!)

CODE FORTH   OFUSER VLFTH AR0 LEA,  AR0 OFUSER CONTEXT MOV,
 NEXT  ;C       IMMEDIATE

CODE DEFINITIONS  OFUSER CONTEXT  OFUSER CURRENT MOV,  NEXT ;C

: (  ASCII ) WORD      ;                             IMMEDIATE




\ 68000 : (quit) (abort)                  (  4  7 91 CRC 12:58 )
: (QUIT)   BLK OFF [COMPILE] [  BEGIN BEGIN
  RP! CR QUERY INTERPRET  STATE @ 0= UNTIL ."  OK" AGAIN STOP

: (ABORT) SP! DECIMAL CR ." real-FORTH 1.3 23  8 91"
   [COMPILE] FORTH  DEFINITIONS  OFFSET OFF   QUIT  STOP










\ 68000 : iob +iob emp startup            (  9  7 87 CRC 22:17 )
DPNEW @ LABEL IOB 12 DUP ALLOT ERASE   \ iob layout  n.b. is not
\ bytes     0-3    4-7  8-9  A-B   C-D  E-F 10-11    romable!!
\   buffer addr  ->DSB  dev sect track side count
\                unused 0-1 1-9   0-79  0-1  1-9
CODE +IOB   IOB #L S [ ADD,  NEXT  ;C

| -1 VARIABLE EMPT  \ should be a constant when we rom
\  0 VARIABLE DSKSET  \ do only if patched!
LABEL  STRTUP  ." strtup = " STRTUP 6 U.R

                         \ install in the iob: the count.
} SP! EMPT @ IF EMPT OFF EMPTY-BUFFERS THEN  1 10 +IOB W!
  -F8 +ORIGIN @  \ DUP DSKSET !
  -DUP IF  EXECUTE  THEN -1 BADMAP !
  SETU/P        ABORT {
\ 68000 : ct->0 getcmd cmdboot            (  4  8 91 CRC 12:53 )
PRIVATE IFTRUE
CODE CT->0      \ addr ---  addr ct | count to next 0
  S [ AR0 MOV,  BEGIN,  AR0 [+ DR0 .B MOV,  EQ UNTIL,
  1 # AR0 SUBQ,  S [ AR0 SUB,  AR0 S -[ MOV,  NEXT ;C

| : GETCMD        \  --- addr ct | return addr & ct of cmd line
  -100 +ORIGIN @  80 + DUP C@   \  desktop or msh?
  7F - IF  COUNT  ELSE  1+ CT->0  THEN ;

| : CMDBOOT       \  ---  | fetch & execute command line
  { 'NF (QUIT) CFA } LITERAL 'QUIT !
  GETCMD  DUP IF  CR 2DUP TYPE  SPACE  2DUP
  TIB @ SWAP 2DUP + 4 ERASE  CMOVE  IN OFF  INTERPRET
  DROP 1- OFF     CTL G EMIT   ELSE  2DROP  THEN  QUIT STOP

\ 68000 : Memory setup                    ( 15  2 86 CRC       )
\ do setup for memory here. Return highest addr in dr0
LABEL -SETSTUF-
ASSEMBLER  0 #L DR0 MOV,   -4 ALLOT
 \ this is done to leave the opcode of an #L MOV, in place. If
 \ the user wants to force a given high address, he can  !  it
 \ in over the next opcode, and patch the bsr in  COLD  to
 \ point to this opcode instead of to SETSTUF.








\ 68000 : Memory setup                    ( 23  7 86 CRC 10:59 )
HEX  \ do setup for memory here. Return highest addr in dr0
LABEL SETSTUF     \ forth boot parameters in ar0.
436 @# DR0 .L MOV,   \  _memtop, top of available memory
    \ enter here with pre-calculated memory size in dr0
  FBASE *+ AR0 LEA,    DR0 DR1 MOV,
  TM   TOS - #L DR1 SUB,        DR1 AR0 1C &[ MOV, \ tos
  TOS  BOT - #L DR1 SUB,        DR1 AR0 84 &[ MOV, \ bos
  BOT  RTS - #L DR1 SUB,        DR1 AR0 20 &[ MOV, \ rts
  RTS TIBX - #L DR1 SUB,        DR1 AR0 24 &[ MOV, \ tib
  US #L DR1 SUB,  DR1 DR2 MOV,  DR1 AR0 18 &[ MOV, \ uarea
  'NF VLFTH CFA 4+ TW@ 4+ #L DR1 ADD,  \ get offset into user
  ( of forth vocab )            DR1 AR0 38 &[ MOV, \ voc-link
  100        #L DR2 SUB,        DR2 AR0 74 &[ MOV, \ limit
  CO         #L DR2 SUB,        DR2 AR0 70 &[ MOV, \ first

\ 68000 : Memory setup                    ( 18  1 87 CRC 12:51 )
  \ Set maxblk according to the number of floppies on system.
PRIVATE IFTRUE DECIMAL -169 HEX +LOAD  OTHERWISE

LABEL SETDISKS
4A6 ( _nflops) @# DR3 .W MOV,   DECIMAL 360 # DR3 MULU,
   1 # DR3 SUBQ,  DR3 'NF MAXBLK CFA 4+ @#L MOV,  RTS,

IFEND







\ 68000 : setsup                          (  2  6 86 CRC 10:47 )
LABEL SETSUP
  18 FBASE + *+ U MOV, \ set user area pointer

  FBASE 10 + *+ AR1 LEA,  \ from addr
  U   AR0 MOV, \ to addrs
  AR1 DR2 ADD, \ limit of the move

BEGIN,  AR1 [+ AR0 [+ MOV,  AR1 DR2 .L CMP,  LT UNTIL,
\ move user area stuff out from cold start area

  STRTUP #L IP MOV,  RTS,  \ execute cold start orphan




\ 68000 : cold                            ( 27  6 91 CRC 21:01 )
CODE COLD  SETSTUF *+ BSR,
      COLDS #L DR2 .L MOV,  EQ IF,    \ forced

LABEL WARM   10 #L DR2 .L MOV,  THEN,
      SETSUP *+ BSR,
      'NF RP! CFA T@ *+ BRA, ;C
LABEL COLDSTART    RP FBASE -FC + @#l MOV,      \ must be in
     HERE 0C + DELTA - #L RP -[ MOV,            \  user !!
     26 ( 38 decimal) # RP -[ .W MOV,
     0E # TRAP,   6 # RP ADDQ,  \ we want to be in supervisor!
     'NF COLD CFA T@ *+ BRA,   FORTH     ;S
DR2 contains the number of words moved into the user area; by
the end of the setup it has the address of the last byte moved.
DR0 has the top address in memory placed it it.

\ 68000 : +buf update                     ( 16  5 86 CRC 15:48 )
CODE +BUF \ bufaddr --- bufaddr' | locate next buffer in ram
  DR1 CLR,  S [ DR0 MOV,  6 *B/BUF* + #L DR0 ADD,
  OFUSER 'LIMIT DR0 CMP,
     EQ IF,  OFUSER 'FIRST DR0 MOV,  THEN,
  DR0 S [ MOV,
  OFUSER PREV DR0 CMP,  NE IF,  1 # DR1 ADDQ,  THEN,
  DR1 S -[ MOV,  NEXT   ;C

CODE UPDATE   \  -  | flag most recent buffer as updated
  OFUSER PREV AR0 MOV,  7 # AR0 [ .B BSET,  NEXT ;C


;s
: <#      MOI   HLD ! ;              \ must be moi to use w/

\ 68000 : arithmetic stuff -- +- to mod   ( 22  5 86 CRC 16:56 )
CODE +-  S [+ TST, MI IF,               S [ NEG,  THEN, NEXT ;C
CODE D+- S [+ TST, MI IF,  4 S &[ NEG,  S [ NEGX, THEN, NEXT ;C
CODE ABS S [  TST, MI IF,  S [ NEG, THEN,               NEXT ;C
: DABS    DUP D+-  ;
CODE MIN  S [+ DR0 MOV,  S [ DR1 MOV,  DR0 DR1 CMP,
  PL IF,  DR0 S [ MOV,  THEN,  NEXT    ;C
CODE MAX  S [+ DR0 MOV,  S [ DR1 MOV,  DR0 DR1 CMP,
  MI IF,  DR0 S [ MOV,  THEN,  NEXT    ;C

: M/      OVER >R >R DABS
              R ABS U/ R> R XOR +- SWAP R> +- SWAP ;
: *       U* DROP ;
: /MOD    >R S->D R> M/ ;
: /       /MOD      NIP  ;    \ SWAP DROP ;
: MOD     /MOD      DROP ;
\ 68000 : more arithmetic, number output  ( 18  6 86 CRC 11:13 )
: */MOD   >R M* R> M/ ;
: */      */MOD NIP ;  \  SWAP DROP ;
: M/MOD   >R 0 R U/ R> SWAP >R U/ R> ;
: SPACES  0 MAX -DUP IF 0 DO SPACE LOOP THEN ;
CODE <#   U OFUSER HLD MOV, NEXT ;C   \ must be moi to use w/
: #>      2DROP HLD @ MOI   OVER - ; \ wp-forth &/or tasker !!!!
: SIGN    ROT 0< IF ASCII - HOLD THEN ;
: #   BASE @ M/MOD ROT 9 OVER < IF 7 + THEN ASCII 0 + HOLD ;

: #S      BEGIN # 2DUP OR 0= UNTIL ;
: D.R     >R SWAP  OVER  DABS  <#  #S  SIGN #>
          R> OVER  -  SPACES  TYPE ;
: D.      0 D.R SPACE ;
: .R      >R S->D R> D.R ;    : .       S->D D. ;
: ?       @ . ;  : W? W@ . ;  : C?      C@ . ;
\ 68000 : vlist buffer                    ( 13  4 86 CRC       )
: VLIST   CR  CONTEXT @  @
     BEGIN OUT @ C/L >   IF  CR THEN
        DUP ID. SPACE SPACE PFA  LFA  @
        DUP 0=  ?TERMINAL OR UNTIL   DROP            ;

: BUFFER   USE @ DUP >R BEGIN +BUF UNTIL  USE !
        R @ 0< IF R 4+ R @ 7FFFFFFF AND 0       R/W  THEN
        R ! R PREV ! R> 4+ ;







\ 68000 : block (line) .line message load ( 27 10 86 CRC 13:17 )
: BLOCK   PAUSE OFFSET @ + >R PREV @ DUP @ R - DUP +
    IF BEGIN +BUF 0= IF DROP R BUFFER DUP R 1 R/W 4- THEN
       DUP @ R - DUP + 0= UNTIL DUP PREV ! THEN R> DROP 4+ ;

: (LINE)  >R C/L B/BUF */MOD R>  + BLOCK + C/L ;
: .LINE   (LINE) -TRAILING TYPE ;

: MESSAGE WARNING @ IF ( we have disk ) -DUP
       IF 1 OFFSET @ - .LINE THEN ELSE  \ 4 is fig std.
          ." msg # " .  THEN ;

: LOAD  BLK @ >R  IN @ >R  IN OFF BLK !  INTERPRET
        R> IN !   R> BLK ! ;

: --> ?LOADING IN OFF BLK 1+! ;               IMMEDIATE
\ 68000 : #bufs flush                     ( 17 10 85 CRC       )
: #BUFS  LIMIT FIRST - B/BUF  6  +  /MOD \ number of buffers
     SWAP IF ." Bad buffers!"  EMPT ON COLD  THEN ;

: FLUSH  #BUFS  1+  0 DO 7FFFFFFF BUFFER DROP LOOP ;











\ 68000 : toret readsec writesec          (  4  8 86 CRC 12:36 )
\ shoves appropriate number of things from buffer to return
\ stack for BIOS' convenience. Feh.
HEX
| CODE (SECT)  \ addr diskblk flag  ---  flag  | sect setup
  S [+ DR1 MOV,  S [+ DR0 MOV,  IOB *+ AR0 LEA,
  9 # DR0 DIVU,  DR0 AR0 0C &[ .W MOV,                \ track
  DR0 .W SWAP,  1 # DR0 ADDQ,  DR0 AR0 0A &[ .W MOV,  \ sect
  S [ AR0 [ MOV,   DR1 S [ MOV,  NEXT   ;C     \ addr

CODE -DISK \ fl --  er | fl 0: write   1: read; er 0: ok
  RP DR7 MOV,  IOB 12 + *+ AR0 LEA,
  8 # DR0 .W MOV,  DR0 DR3 .W MOV,  \ mov 9 words -- $12 bytes
  FALSE DR0  DO,  AR0 -[ RP -[ .W MOV,  LOOP,
  S [ TST,  EQ IF,  1 # DR3 .W ADDQ,  THEN,   DR3 RP -[ .W MOV,
  0E # TRAP,  DR0 S [ MOV,  DR7 RP MOV,   NEXT  ;C   ;S
\ 68000 : (r/w)                           ( 21  6 87 CRC 15:35 )
\ iob layout. is shoved to return stack by  -disk, scr 359
\ bytes     0-3    4-7  8-9  A-B   C-D  E-F 10-11
\   buffer addr  ->DSB  dev sect track side count

: ?DERR    \ fl --- | disk error indicator
  -DUP IF BASE @ HEX SWAP 6 .R BASE ! SPACE 8 ERROR THEN ;

| : SECT  \ addr diskblk flag ---   | read/write sector
  (SECT)  -DISK  ?DERR ;

: (R/W)  \ addr  blk  fl ---   | write, fl=0; read, fl=1
  OVER 0 MAXBLK WITHIN 0=      6 ?ERROR    >R
        0 B/DRV U/   8 +IOB W!  \ set device, 1- 2
  DUP + ( 2*)  2DUP  R SECT  200 1 D+  R> SECT ;
PRIVATE IFTRUE DECIMAL -177 -167 HEX +THRU  IFEND
\ 68000 : ' index list (list)               25 12 84 CRC
: ' -FIND 0= 0 ?ERROR DROP [COMPILE] LITERAL ;        IMMEDIATE

: INDEX   CR  1+  SWAP    DO CR R  5 .R
   SPACE  0  R .LINE  ?TERMINAL  IF  LEAVE  THEN   LOOP ;

: LIST    'LIST @EXECUTE STOP

: (LIST)    DECIMAL
   CR  DUP  SCR !  ." scr # "   .  10 0
   DO  CR R 3 .R SPACE R SCR @ .LINE  LOOP CR ;





\ 68000 : forget, multitasking version    ( 11 12 86 CRC 18:08 )
| : PFUI   TIB OVER U< IF TIB - THEN  ;
| : PFUI2  PFUI >R PFUI R>         U< ;
    \ filtre addresses outside our task.         \ multitasking
| CODE TASKFIX   70 ( forth's voc link) U &[ AR0 LEA,
  S [ AR0 CMP,  LE IF,  AR0 S [ MOV,  THEN,  NEXT      ;C
: (FORGET) \ pfa ---  | can be compiled into definitions
   NFA  DUP FENCE @ PFUI2 15 ?ERROR
   >R  VOC-LINK @  taskfix         BEGIN
     R OVER PFUI2 WHILE [COMPILE] FORTH  DEFINITIONS
     @ taskfix DUP VOC-LINK !  REPEAT      BEGIN  pause
        DUP 6 - BEGIN PFA LFA @  taskfix  DUP R PFUI2  UNTIL
     OVER 4- !  @ taskfix -DUP 0= UNTIL   R> DP ! ;
: FORGET   [COMPILE] ' STATE @ IF COMPILE (FORGET)
                               ELSE (FORGET) THEN ;  IMMEDIATE
;S Make  FORGET  smart enough to compile it!! Very useful!
\ 68000 : (create)                        ( 16 10 85 CRC       )
: (CREATE)     FIRST HERE 0A0 + U< 2 ?ERROR
   ?ALIGN -FIND IF DROP NFA ID.   4 MESSAGE SPACE THEN
   HERE  DUP C@ WIDTH @ MIN 1+ =CELLS ALLOT
   DUP A0 TOGGLE HERE 1- 80 TOGGLE
   LATEST , CURRENT @ ! HERE 4+ , ;










\ 68000 : compiler directives               16  2 85 CRC
: BEGIN       ?COMP HERE 1 ;                          IMMEDIATE
: THEN        ?COMP 2 ?PAIRS HERE OVER - SWAP W! ;    IMMEDIATE
: ENDIF       [COMPILE]  THEN  ;                      IMMEDIATE
: DO          COMPILE (DO) HERE 3 ;                   IMMEDIATE
: LOOP        3 ?PAIRS COMPILE (LOOP)  BACK ;         IMMEDIATE
: +LOOP       3 ?PAIRS COMPILE (+LOOP) BACK ;         IMMEDIATE
: UNTIL       1 ?PAIRS COMPILE 0BRANCH BACK ;         IMMEDIATE
: END         [COMPILE]  UNTIL ;                      IMMEDIATE
: AGAIN       1 ?PAIRS COMPILE BRANCH  BACK ;         IMMEDIATE
: REPEAT      >R >R [COMPILE] AGAIN R> R> 2-
                    [COMPILE] THEN  ;                 IMMEDIATE
: IF          COMPILE 0BRANCH HERE 0 W, 2 ;           IMMEDIATE
: ELSE        2 ?PAIRS COMPILE BRANCH HERE 0 W,
       SWAP 2 [COMPILE] THEN  2 ;                     IMMEDIATE
: WHILE       [COMPILE] IF 2+ ;                       IMMEDIATE
















\ Overlay Code -- after Greg Stevenson    ( 18  4 86 CRC 10:21 )
    BASE @ DECIMAL
| *B/BUF* 26 - CONSTANT SEGSIZE
\ |    0 VARIABLE CURSEG       |         0 VARIABLE MEMPTR
| : @SEG  DUP CURSEG ! BLOCK  DROP ;  \ Block #-1 ---
| : DESCRIPTORS CURSEG @ BLOCK ;      \ --- addr
| : OBJECT  DESCRIPTORS 26 + ;        \ --- addr
| : NEXTSEG  SEGSIZE MEMPTR +! ;      \ ---
| : ?SEGS     PAD 6 + @   PAD 2+ @ - \ --- n
        SEGSIZE /MOD SWAP IF 1+ THEN ;
| : RESTOREDES   DESCRIPTORS  6 + @  DP        !
                 DESCRIPTORS 10 + @  CURRENT @ !
                 DESCRIPTORS 14 + @  CONTEXT @ !
                 DESCRIPTORS 18 + @  VOC-LINK  !  ;
BASE ! ." ." ;S

\ Overlay Code -- after Greg Stevenson    ( 18  4 86 CRC 10:21 )
    BASE @ DECIMAL
| : SAVEDES        \      ---
                     PAD           OFF    \ overlay marker
    [COMPILE] ' NFA  PAD    2+       !    \ start addr
    HERE             PAD   6 +       !    \ end addr
    LATEST           PAD  10 +       !    \ dictionary link 1
    CONTEXT @ @      PAD  14 +       !    \ dictionary link 2
    VOC-LINK @       PAD  18 +       ! ;  \ dictionary link 3
BASE ! ." ." ;S

Syntax:     SAVEDES   <WORDNAME>
    PAD  is used as a holding area & contents are placed in all
blocks of the image array.


\ Overlay Code -- after Greg Stevenson    ( 18  4 86 CRC 10:36 )
    BASE @ DECIMAL
: SAVEOVER                     \ Block #-1 ---
   [COMPILE] FORTH  SAVEDES
   PAD 2+ @ MEMPTR !
   ?SEGS DUP PAD 22 + !
   BOUNDS           DO
       I BUFFER DROP   \ so we don't read it off the disk
       I @SEG UPDATE
       PAD DESCRIPTORS 26 CMOVE
       MEMPTR @ OBJECT SEGSIZE CMOVE
       NEXTSEG I 5 .R  LOOP FLUSH ;
BASE ! ." ." ;S
     Syntax:      <BLOCK#>   SAVEOVER  <WORDNAME>
where <BLOCK#> is the starting block and <WORDNAME> is the first
word to be saved to the virtual array.
\ Overlay Code -- after Greg Stevenson    ( 18  4 86 CRC 10:36 )
    BASE @ DECIMAL
: BRING                         \ Block #-1  ---
  [COMPILE] FORTH  DUP @SEG RESTOREDES
  DESCRIPTORS    2+ @ MEMPTR !
  DESCRIPTORS 22 +  @     \ # of segments
   BOUNDS           DO
        I @SEG
        OBJECT MEMPTR @ SEGSIZE CMOVE NEXTSEG
        46 EMIT LOOP CR ;
BASE ! ." ." ;S
       syntax:   <BLOCK#>  BRING
  where <BLOCK#> is the starting block of a previously saved
overlay.


\ Overlay Code -- testing stuff           ( 12  2 87 CRC 18:39 )
FORGET TASK                     : TASK ;          DECIMAL
B/BUF CONSTANT *B/BUF*          375 CONSTANT TESTMEM
|    0 VARIABLE CURSEG       |         0 VARIABLE MEMPTR

-4 -1 +THRU              FORTH DEFINITIONS
373 LOAD   DECIMAL  TESTMEM SAVEOVER IF.



EDITOR FLUSH





































\ 68000 : wdump for trials                ( 26  2 86 CRC       )
HEX | : IF.  IF DROP ASCII . THEN ;
| : (WDUMP) \  from-address-2 cnt-1  ---  | memory displayed
   BOUNDS DO I W@ 0 7 D.R 2 +LOOP ;

| : WHEAD   CR 5 SPACES 07 AND 10 0  \ start  ---  | header
    DO DUP I + BASE @ 1- AND 7 .R 2 +LOOP
    DROP ."  <<    ASCII   >>" ;
: ASCI  -TRAILING BOUNDS    ( from-addr cnt ASCI)
   DO I C@ 7F AND  DUP ASCII ~ > IF.  DUP BL < IF. EMIT LOOP ;

: WDUMP  \ from-addr  count ---  | dump
   OVER  DUP WHEAD
   + SWAP   DO CR I 0 5 D.R I 10 2DUP (WDUMP) SPACE
   ASCI  I  F0 AND F0 = IF I WHEAD THEN
   ?TERMINAL  IF LEAVE  THEN  10 +LOOP CR ;
\ 68000 : (key) for rs232 input           ( 26  2 86 CRC       )
\ LOUD    \ replaced with code on disk.
CODE (?RSKEY) \   -- fl | a key is ready
  RP DR7 MOV,   DR6 CLR,
  U 78 ( i/o) &[ RP -[ .W MOV,
  1 # RP -[ .W MOV, ( routine # ) 0D # TRAP,
  DR7 RP MOV,
  DR0  S -[ MOV,  NEXT  ;C

CODE (RSKEY) \ -- c | get a character from device
  RP DR7 MOV,
  U 78 ( i/o) &[ RP -[ .W MOV,
  2 # RP -[ .W MOV,   \ routine #  -- get a char!!
  0D # TRAP,
  DR0 S -[ MOV,  DR7 RP MOV,  NEXT    ;C
\ QUIET
( improved overlays                       (  4  1 89 crc  7:42 )
\ 0 VARIABLE >MEM      ( --> mem to pick up          )
\ 0 VARIABLE +HEAD     ( --> start in first block    )
|  C0 USER >MEM            |  C4 USER +HEAD

| CODE HEAD@+   OFUSER +HEAD AR0 LEA,   AR0 [ S -[ MOV,
  4 # AR0 [ ADDQ,  NEXT                 ;C

| : ADVANCE   DUP >MEM +!  CMOVE   ASCII . EMIT ;

| : NEWBLK    BUFFER  DUP B/BUF ERASE  UPDATE ;

    ;s
| : HEAD@+    +HEAD @  4 +HEAD +!  ;
| : ADVANCE   DUP >MEM +!  CMOVE   2E EMIT ;

( improved overlays                       (  4  1 88 crc  8:04 )
| : GETDICT   ( addr --- | build overlay restoration info )
  2+ +HEAD !              ( set pointer past raw block flag  )
  [COMPILE] ' NFA 4- DUP      ( starting point               )
    >MEM !        HEAD@+ !    ( starting point               )
  HERE            HEAD@+ !    ( top of dictionary            )
  CURRENT @       HEAD@+ !    ( current vocabulary           )
  CONTEXT @       HEAD@+ !    ( context                      )
  VOC-LINK @      HEAD@+ !    ( vocabulary chain start       )
  VOC-LINK   BEGIN  @  -DUP   ( vocabulary chain             )
      WHILE  DUP 4- @ HEAD@+  !  REPEAT
  HEAD@+ OFF ;                ( end of data                  )




( improved overlays                       (  4  1 88 crc  8:24 )
| : SETDICT   ( addr ---  | build overlay restoration info     )
  2+ +HEAD !              ( set pointer past raw block flag  )
  HEAD@+ @          >MEM !    ( starting point               )

  HEAD@+ @            DP !    ( top of dictionary            )
  HEAD@+ @       CURRENT !    ( current vocabulary           )
  HEAD@+ @       CONTEXT !    ( context                      )
  HEAD@+ @      VOC-LINK ! ;  ( vocabulary chain start       )

| : SETVOCS   ( addr ---  | install vocabulary link pointers   )
  +HEAD !                     ( set pointer                  )
  VOC-LINK   BEGIN  @  -DUP   ( vocabulary chain             )
      WHILE  HEAD@+ @  OVER 4- !  REPEAT  ;


( improved overlays                       (  4  1 89 crc  7:42 )
: SAVEOVER  ( blk# ---  | save overlays to blk# from given word)
  DUP NEWBLK  DUP >R  GETDICT    ( dict info stored            )
  >MEM @  +HEAD @  B/BUF OVER R> -  -  ( src, dest, ct         )
  ADVANCE
  BEGIN  >MEM @  HERE  U< WHILE
     1+  >MEM @  OVER NEWBLK 2+
     { B/BUF 2- } LITERAL  ADVANCE  REPEAT
  DROP FLUSH ;







( improved overlays                       (  4  1 88 crc  8:25 )
: BRING     ( blk# ---  | restore overlays from blk#         )
  DUP  BLOCK  DUP SETDICT         ( set dictionary info      )
  +HEAD @ OVER  - >R              ( offset to voc-link data  )
  +HEAD @                         ( begin at voc-link data   )
  BEGIN  DUP @ WHILE 4+ REPEAT 4+ ( skip voclinx for now     )
  OVER - >R  R +  ( src)  >MEM @  ( dest                     )
     B/BUF R> -  ADVANCE  DUP     ( move first block to mem  )
  BEGIN  >MEM @  HERE  U< WHILE
     1+  DUP BLOCK 2+  >MEM @
     { B/BUF 2- } LITERAL  ADVANCE  REPEAT
  DROP
  BLOCK R> + SETVOCS ;



\ assemble special loaderfile for tos     ( 12  7 91 CRC 17:57 )
HEX DPNEW @ COMPILE-ADDR - 2 +OVERHEAD !
100  0A +OVERHEAD  !
  0  18 +OVERHEAD W!            \ stripped file flag

DPNEW @  DELTA -   FBASE -  4+         4/
        ASSEMBLER CTDATA DELTA +  !       FORTH









\ assemble preamble for tos               ( 12  7 91 CRC 17:57 )
DECIMAL 12 == SAFESIZE          ASSEMBLER

DECIMAL 1 11 +THRU      HEX     ?ALIGN SETOLD SETNEW

100000 SAFE 4+  DELTA + F!

PREAMBLE DUP  STDATA  DELTA +  f!    CR
DPNEW @ COMPILE-ADDR -
DUP 8 U.R ."  bytes of preamble used."
-  DUP  8 U.R  ."  Bytes of preamble left."
DUP 0< IFTRUE ABORT" Out of Preamble!"  IFEND
HERE  OVER ALLOT  SWAP ERASE



\ preamble: text messages here.           (  1  9 93 CRC 21:40 )
FALSE IFL,  \ force to start of code
LABEL SAFE HERE  SAFESIZE ALLOT  SAFESIZE ERASE
  FBASE ASSEMBLER SAFE DELTA + !
LABEL STDATA  4 ALLOT   \       LABEL CHKSUM 4 ALLOT
LABEL CTDATA  4 ALLOT   \ size of forth data to be moved
LABEL ACR    0D C,  0A C,                                  0 C,
LABEL ROOM   TXT *Forth overwrites OS*"                    0 C,
LABEL ANYKEY TXT  Hit any Key."                            0 C,
LABEL SCRSTUF  LI C,  ASCII v C,   LI C, ASCII e C,        0 C,
  LABEL DTR  TXT Jsr/Bsr Threaded fastForth"   0D C, 0A C, 0 C,
\ LABEL DTR  TXT Indirect Threaded realForth"  0D C, 0A C, 0 C,
LABEL COPY TXT Copyright 1994+ Charles Curley" 0D C, 0A C, 0 C,
LABEL MSHRINKFL TXT Mshrink Failed!"           0D C, 0A C, 0 C,
?ALIGN

\ preamble:   error out                   (  1  4 89 CRC  7:55 )
\ address of $ in ar0; print it out
LABEL PRINTLINE  RP DR7 MOV,  AR0 RP -[ MOV,
  9 # RP -[ .W MOV,  1 # TRAP,   DR7 RP MOV,  RTS,

LABEL WAITKEY   RP DR7 MOV,   2 # RP -[ .W MOV,
  2 # RP -[ .W MOV, 0D # TRAP,
  DR7 RP MOV,    RTS,

LABEL ERROROUT       \ error$ in ar2 for printout, ret in dr6
  ACR               *+ AR0 LEA,     PRINTLINE *+ BSR,
  AR2 AR0 MOV,                      PRINTLINE *+ BSR,
  ANYKEY 1+ *+ AR0 LEA,             PRINTLINE *+ BSR,
  WAITKEY *+ BSR,  ACR *+ AR0 LEA,  PRINTLINE *+ BSR, \ 4 shells
  DR6 RP -[ .W MOV,  4C # RP -[ .W MOV,  1 # TRAP,

\ preamble:   number printed out          ( 20 12 89 CRC 19:19 )
LABEL PRINTASCII  \ print out a value as an ascii character
  0F #L DR0 AND,   30 # DR0 .W ADD,
  ASCII 9 # DR0 .W CMP,  GT IF,  7 # DR0 .W ADD,  THEN,

LABEL PRINTDR0    \ print a character in dr0
  DR0 RP -[ .W MOV,             2 # RP -[ .W MOV,
  3 # RP -[ .W MOV, \ routine   ^ device
  0D # TRAP,  6 # RP ADDQ,  RTS,

LABEL PRINTREG    \ print contents of dr4
  07 # DR5 MOVQ,  FALSE DR5 DO,  4 # DR4 ROL,
  DR4 DR0 MOV,  PRINTASCII *+ BSR,  LOOP,
  20 # DR0 .W MOVQ,  PRINTDR0 *+ BRA,


\ Atari screen setup                      ( 21  5 86 CRC 18:04 )
THENL,  \ Like, wow! The actual code! Far out!!
\  0: lo res  1: medium res  2: hi (monochrome) res.
LABEL SETSCRRES     \ we use either hi or medium res at boot.
  RP DR7 MOV,  4 # RP -[ .W MOV,  0E # TRAP,  \ ? resolution
  DR0 TST,  EQ IF,  DR7 RP MOV,
    1 # .W RP -[ .W MOV, \ Set resolution to medium unless high
    DR1 CLR,  1 # DR1 SUBQ,   \ physbase & logbase stay put.
    DR1 RP -[ MOV,  DR1 RP -[ MOV,
    5 # RP -[ .W MOV,  0E # TRAP,
    THEN,    DR7 RP MOV,

;S   This code will set the screen resolution to medium iff the
current resolution is low. Then you're on your own!!

  RP -[ .W CLR, 1 # TRAP,    \ end it all!
\ preamble:                               ( 19  9 91 CRC  9:07 )
  ACR *+ AR0 LEA,  PRINTLINE *+ BSR,
        \ set cursor on, wrap on right edge.
  SCRSTUF *+ AR0 LEA,   PRINTLINE *+ BSR,

        \ put login message out
  DTR  1+ *+ AR0 LEA,  PRINTLINE *+ BSR,

        \ put copyright message out
  COPY 1+ *+ AR0 LEA,  PRINTLINE *+ BSR,






\ preamble: room for data?                (  6 10 93 CRC 20:45 )
  RP AR4 MOV,  4 AR4 &[ AR4 MOV,  \ ar4 -> base page
                        \ get base of data to be moved
  SAFE *+ AR3 LEA,  AR3 [ AR1 MOV,

LABEL ROOM?    \ start of boot + size of boot = safe addr
  STDATA *+ AR0 MOV,  AR4 8 &[ AR0 ADD,
  AR1 AR0 CMP,
  GE IF,  AR0 DR4 MOV,  PRINTREG *+ BSR, \ print min addr
    AR3 [ DR4 MOV,  PRINTREG *+ BSR, \ print our base addr
    -1 # DR6 .W MOV,  ROOM 1+ *+ AR2 LEA,
    ERROROUT *+ BSR,  THEN,




\ preamble: move data                     ( 12  7 91 CRC 18:00 )
        \ Check image for safe load: addr must exceed our addr
  CTDATA *+ DR1 MOV,    \ length of data to move.

  DR1 DR0 MOV, 2 # DR0 LSL,     \ how many bytes we'll move.
  DR0 AR0 ADD,  DR0 AR1 ADD,    \ where we'll start the move.

                        \ descending move & clean as we go.
  DR1 FALSE DO,  AR0 -[ AR1 -[ MOV,  AR0 [ CLR,  LOOP,







\ preamble: release unwanted room         (  1  9 93 CRC 19:52 )
LABEL PRERELEASE        \ assume ar4 -> base page
  4 AR4 &[ DR4 .L MOV,  \ top of available memory
  SAFE *+ AR3 LEA,      \ safe area
  AR3 4 &[ DR5 MOV,     \ user specified max size
  AR3 [ DR5 ADD,        \ max size + fbase
  DR4 DR5 CMP,  LT IF,
     DR5 DR4 MOV,       \ top of Forth mem, for later use
     RP DR7 MOV,        \ save stack for later cleanup
     AR4 DR5 SUB,
     DR5 RP -[ MOV,     \ length of mem saved.
     AR4 RP -[ MOV,     \ base address of mem saved.
     RP -[ .W CLR,      \ magic #



\ preamble: more release                  (  6 10 93 CRC 20:46 )
     4A # RP -[ .W MOV, \ function number, Mshrink
     1 # TRAP,          \ do it.
     DR7 RP MOV,        \ clean up stack
     DR0 TST,  NE IF,
       DR0 DR4 MOV,  PRINTREG *+ BSR, \ print error #
       MSHRINKFL 1+ *+ AR0 LEA,  fe # DR6 MOVq,
       ERROROUT *+ BSR,  THEN,
  THEN,
  AR3 [ AR0 MOV,        \ get base addr of forth
  DR4 AR0 -F4 &[ MOV,   \ top address allowed to "-f4 +origin"





\ preamble: go to supervisor              ( 16  6 92 CRC  9:24 )
LABEL TOSUPER
  SAFE *+ AR3 LEA,  AR3 [ AR5 MOV,      \ get base addr of file,
\ ar3 dr4 mov,  printreg *+ bsr,        \ show the addr of safe
\ ar5 dr4 mov,  printreg *+ bsr,        \ show contents of safe
  RP -FC AR5 &[ MOV,    \ save user stack to "-fc +origin"

  RP DR7 MOV,
  HERE DELTA - 0A + *+ PEA,
  26 ( 38 DECIMAL) # RP -[ .W MOV,
  0E # TRAP,
\ nop, nop,
  DR7 RP MOV,                   \ we want to be in supervisor!
\ dr7 dr4 mov,  printreg *+ bsr,


\ preamble: do it                         ( 27  6 91 CRC 13:25 )

  AR3 [ AR0 MOV,                        \ get base addr of file,
  AR4 -100 AR0 &[ MOV,                  \ save base page addr
  AR3 8 &[ AR0 -F8 &[ MOV,              \ cfa of disk handler
\ ar0 ar7 -[ mov,  ar1 ar7 -[ mov,
\ ar0 dr4 mov,  printreg *+ bsr,        \ show jump point
\ ar7 [+ ar1 mov,  ar7 [+ ar0 mov,
  AR0 [ JMP,                            \ and go do it!







\ On Base Pages                           (  2  4 89 CRC  9:24 )
At $80 bytes into the base page one can find the command line.
However, the first byte is not part of the text itself.

-- in TOS, the first byte is a count of the bytes.

-- in Mark Williams C msh shell, this always contains $7f. This
   1) gives us a way to tell the difference, and 2) means that
   one has to detect a string by checking to see if the $81st
   byte has anything in it.






\ Loader file documentation               ( 20 12 89 CRC 19:29 )
         Register usage:
AR0: --> string to be output by printline
AR1: --> safe buffer for addr & len
AR2: --> error message for failure, to errorout
AR3: --> "safe" area
AR4: --> TOS base page
AR5: --> used in setscrres for temp register, & to check addr
DR0: --> print this char in printdr0, printascii
DR1: --> used in setscrres for temp register
DR4: --> used to hold value printreg
DR5: --> used for count in printreg
DR6: --> error return number in errorout
DR7: --> save rp during traps
On entry, RP points to four bytes below the base page, a temp.

















\   cross reference utility. Ken Bell     ( 14  5 86 CRC 15:37 )
CODE QU  S [ CLR,    NEXT

\ pfa in host ---    | cross printed out
: (WHO)   SPACE COL CFA @ >R [ ' NEWFORTH 2+ ] LITERAL @
   BEGIN  PFA DUP 4- @ DELTA + DUP @ *COLON* = IF  4+ \ targ pf
     BEGIN  DUP @ \ HEX CR  .S
      DUP     0< IF ( cr .s ) DROP QU ( .s )  ELSE CASE
      R ( .S )   OF  OVER  NFA TID.  COL       QU  ENDOF
      NF*LIT*    OF 4+  ENDOF    *;S*       OF QU  ENDOF
      *@EXEC*    OF QU  ENDOF    *WLIT*     OF 2+  ENDOF
      *(.")*     OF DUP 4+ C@ 1+ + =CELLS          ENDOF

-->


\   cross reference utility. Ken Bell     ( 28  8 86 CRC 13:07 )
      *(;CODE)*  OF   QU                           ENDOF

      *(LOOP)*   OF 2+  ENDOF    *(+LOOP)*  OF 2+  ENDOF
      *BRAN*     OF 2+  ENDOF    *0BRAN*    OF 2+  ENDOF
    [ 'NF COMPILE CFA ] LITERAL  OF 4+  ENDOF       ENDCASE
    THEN  -DUP WHILE 4+ REPEAT ELSE DROP THEN LFA @ DUP 0=
             UNTIL R> 2DROP   OUT @ IF CR THEN ;

: ?LINES  \  n ---  | page if less than n lines available
  PRINTER LNCTR @ SWAP  4* 2* + 488 > IF PAGE THEN ;
    BLK @ 1+ DUP 1+ RTHRU
;S



\ cross reference utility. Target compiler( 28  8 86 CRC 13:06 )
: LOC   \ nfa  ---  nfa | print out screen & line # if can
    DECIMAL ' WHERETHEN OVER U< IF SPACE 4- @ WHERETHEN  C/L /
    14 [ BLK @ 1+ ] LITERAL .LINE 3 .R SPACE .SCR SPACE THEN ;

: (CROSS)   CR BASE @ SWAP  \ nfa --- | start cross reference
    BEGIN  DUP PFA 4- @ [ ' QUIT 4- @ ] LITERAL - IF 4 ?LINES
    15 [ BLK @ 1+ ] LITERAL .LINE  SPACE  DUP TID. 30 TAB
    COL DUP LOC DUP   PFA (WHO)
    THEN  PFA DUP 4- @ DELTA + 4- @ 0=  \ is target link = 0 ?
    ?TERMINAL OR SWAP LFA @ DUP 0=      \ is host link = 0 ?
    ROT OR UNTIL  DROP BASE ! ;

: WHO: COL CR BASE @ 15 [ BLK @ 1+ ] LITERAL .LINE SPACE
  [COMPILE]  'NF HERE COUNT TYPE DUP NFA LOC (WHO) BASE ! ;

\ target vlist    utility. Target compiler(  2  9 85 CRC       )
: TVLIST  CR BASE @  [ ' NEWFORTH 2+ ] LITERAL  @
    BEGIN DUP PFA 4- @ [ ' QUIT 4- @ ] LITERAL -
    IF DUP TID.  3 SPACES  OUT @ C/L > IF CR THEN
    THEN  PFA DUP 4- @ DELTA + 4- @ 0=  \ is target link = 0 ?
    ?TERMINAL OR SWAP LFA @ DUP 0=      \ is host link = 0 ?
    ROT OR UNTIL  DROP BASE ! ;

: CROSS   [ ' NEWFORTH 2+ ] LITERAL @ (CROSS) ;

: 'CROSS  'NF NFA (CROSS) ;  \ start cross at given word
\ e.g  'cross fred  begins a cross ref at  fred .

;S
Line number
Words using:
\ move target file into TPA.              ( 27  6 91 CRC 18:49 )
\ warning: only run from desktop so we have enough room!
\ atari
editor flush
hex compile-addr                \ source
-100 +origin @ 100 +            \ destination
over imagetop - minus           \ count
cmove                           \ doit

non-symbolic  fudge off
debug -100 +origin @ dup 4- swap 100 + trace
ar7 !   showall




\ autoloading file creation screen        (  4  7 91 CRC 13:40 )
decimal         232 NEEDED TARGET       \       ATARI
  'NF 10.DS    CFA ASSEMBLER SAFE 8 + DELTA + ! \ flop disk boot
\ 'NF HARDDISK CFA ASSEMBLER SAFE 8 + DELTA + ! \ hard disk boot
FILING H: SETDIR: \ DIR REAL4TH.*

FILING CREATEFILE: REAL4TH.TTP          HEX

FILEHEADER OVERHEAD HANDLE F@ WTF  .
COMPILE-ADDR  DPNEW @ OVER - 200 +  ( ?? )
                    HANDLE F@ WTF  .
DECIMAL

CR CLOSEIT  R-W DIR REAL4TH.*
EDITOR FLUSH  FORTH

\ aim68k object file format utilities     ( 16  5 86 CRC 16:38 )
HEX 160 USER CHKSUM  164 USER LINECT  CHKSUM 8 ERASE
  \  checksum of line   line count
  \ This format is defined in the AIM 65 User's Guide, pg F-5
  \ to F-7

: ABYTE  0 # # 2DROP ;       : ACELL  0 # # # # 2DROP ;

: BUILDCHK  \  addr cnt  --- | checksum in chksum
  2DUP + CHKSUM ! BOUNDS      DO I TC@ CHKSUM +! LOOP ;

: BUILDBYTES  \ addr cnt --- | string construction
  SWAP 1- SWAP OVER + DO I TC@ ABYTE -1 +LOOP ;
BLK @ 1+ LOAD


\ aim68k object file format utilities     ( 29  1 86 CRC       )
: ALINE  \ builds a line in the string construction area
         \ addr cnt ---  addr$ cnt$ ready for typing
  2DUP BUILDCHK  <# CHKSUM @ ACELL  2DUP BUILDBYTES
  SWAP ACELL ( addr) ABYTE ( cnt)
  ASCII ; HOLD 0 0 #> LINECT 1+! ;

: LASTLINE  \  -- addr$ cnt$ | builds last line of file for ty
  <# LINECT @ 1+ DUP ACELL ( chksum) ACELL ( lines)
  0 ABYTE ASCII ; HOLD 0 0 #> LINECT OFF TYPE CR ;

: LINES    \ addr cnt --    | dump contiguous memory
  BEGIN DUP 18 > WHILE 2DUP 18 MIN DUP >R ALINE TYPE CR
  R> DUP MINUS D+  REPEAT
  -DUP IF ALINE TYPE CR ELSE DROP THEN ;

\ autoloading file creation screen        ( 19 10 92 CRC 21:44 )
DECIMAL         232 NEEDED TARGET       \       ATARI
  'NF OPENIT   CFA ASSEMBLER SAFE 8 + DELTA + ! \ file boot
\ 'NF 10.DS    CFA ASSEMBLER SAFE 8 + DELTA + ! \ flop disk boot
\ 'NF HARDDISK CFA ASSEMBLER SAFE 8 + DELTA + ! \ hard disk boot

FILING home L FAST4TH.*        rm: fast4th.old
  mv:: fast4th.ttp fast4th.old
  FILING MKF: FAST4TH.TTP         HEX
\ FILING MKF: FAST4TH.tst         HEX
FILEHEADER OVERHEAD HANDLE F@ WTF  .
COMPILE-ADDR  DPNEW @ OVER - 200 +  ( ?? )
                    HANDLE F@ WTF  .  DECIMAL
CR CLF  R-W L FAST4TH.*         EDITOR FLUSH  FORTH


















































































































\ 68000 : forward refs 8                    17  2 85 CRC
     0A      5 BYTE:IN (CR) C!
   0D        6 BYTE:IN (CR) C!

   'NF R  CFA 4+  -4 BYTE:IN I    !
   'NF 4- CFA 4+  -4 BYTE:IN CFA  !










\ 68000 : forward refs 1                    17  2 85 CRC
     0A      5 BYTE:IN (CR) C!
   0D        6 BYTE:IN (CR) C!

   'NF R  CFA 4+  -4 BYTE:IN I    !
   'NF 4- CFA 4+  -4 BYTE:IN CFA  !










\ 68000 : forward refs 2                    27  2 85 CRC
        *COLON*   -4 BYTE:IN :    !
    0 BYTE:IN :                REPLACED:BY ?EXEC
    4 BYTE:IN :                REPLACED:BY !CSP
    8 BYTE:IN :                REPLACED:BY CURRENT
   10 BYTE:IN :                REPLACED:BY CONTEXT
   18 BYTE:IN :                REPLACED:BY CREATE
   1C BYTE:IN :                REPLACED:BY ]
   20 BYTE:IN :                REPLACED:BY (;CODE)

    0 BYTE:IN USER             REPLACED:BY CREATE
    4 BYTE:IN USER             REPLACED:BY SMUDGE
    8 BYTE:IN USER             REPLACED:BY W,
   0C BYTE:IN USER             REPLACED:BY (;CODE)


\ 68000 : forward refs 3                    27  2 85 CRC
    0 BYTE:IN ;                REPLACED:BY ?CSP
    4 BYTE:IN ;                REPLACED:BY COMPILE
   0C BYTE:IN ;                REPLACED:BY SMUDGE
   10 BYTE:IN ;                REPLACED:BY [

   *COLON*   -4 BYTE:IN ;    !
   *(;CODE)*  4 BYTE:IN VARIABLE  !

    0 BYTE:IN CONSTANT         REPLACED:BY CREATE
    4 BYTE:IN CONSTANT         REPLACED:BY SMUDGE
    8 BYTE:IN CONSTANT         REPLACED:BY ,
   0C BYTE:IN CONSTANT         REPLACED:BY (;CODE)



\ 68000 : forward refs 4                    17  2 85 CRC
   0A BYTE:IN ?ERROR           REPLACED:BY ERROR

   1C BYTE:IN ."               REPLACED:BY WORD
   3A BYTE:IN ."               REPLACED:BY WORD

   16 BYTE:IN WORD             REPLACED:BY BLOCK

   2A BYTE:IN ERROR            REPLACED:BY MESSAGE

80  'NF X CFA  5 - DELTA + C!    \ make it null





\ 68000 : forward refs 5                    17  2 85 CRC
ASSEMBLER COLDSTART          2 BOOTPARAMETER
HEX       WARM               8 BOOTPARAMETER      FORTH
LAST @ DELTA -        10 BOOTPARAMETER          \ 14 = backspace
EM US    -    18 BOOTPARAMETER          \  uarea
ASSEMBLER TOS 1C BOOTPARAMETER          \  TOS
RTS           20 BOOTPARAMETER          \  top of return stack
TIBX                         INITIALISES TIB
1F                           INITIALISES WIDTH
1                            INITIALISES WARNING
DPNEW @ DELTA -         DUP  INITIALISES FENCE
                             INITIALISES DP
EM US - 70 +                 INITIALISES VOC-LINK  \ for 4th voc
'NF (KEY)       CFA          INITIALISES 'KEY
'NF (EXPECT)    CFA          INITIALISES 'EXPECT
;S  fill in boot parameters
\ 68000 : forward refs 6                  ( 18 10 85 CRC       )
'NF (?TERMINAL) CFA          INITIALISES '?TERMINAL
'NF (EMIT)      CFA          INITIALISES 'EMIT
'NF (TYPE)      CFA          INITIALISES 'TYPE
'NF 2DROP       CFA          INITIALISES 'GOTOXY
'NF (PAGE)      CFA          INITIALISES 'PAGE
'NF (LIST)      CFA          INITIALISES 'LIST
'NF (CR)        CFA          INITIALISES 'CR
'NF (R/W)       CFA          INITIALISES 'R/W
PRIVATE IFTRUE 'NF CMDBOOT  OTHERWISE  'NF (QUIT)   IFEND
( 'NF (QUIT)    CFA          INITIALISES 'QUIT
'NF (ABORT)     CFA          INITIALISES 'ABORT
'NF (CREATE)    CFA          INITIALISES 'CREATE
TIBX      US - CO - 100 -    INITIALISES 'FIRST
TIBX      US -      100 -    INITIALISES 'LIMIT
;S  fill in more boot parameters
\ 68000 : forward refs 7                  ( 23  5 86 CRC 12:32 )
FORTH   \ N.B. placement of voc pseudoheader.
81A0                  78 BOOTPARAMETER       \  dummy vocs
LAST @ DELTA -        7C BOOTPARAMETER       \  vlfth
0                     80 BOOTPARAMETER       \  vlnk
     \ voc-link points to this guy.
BOT                   INITIALISES BOTSTACK
20002                 INITIALISES I/O   \ Atari special!
DPNEW @  IMAGETOP OVER - ERASE
CR ."  Forward references resolved."    CR

  .HERE  .SIZE  CR  WARNING ON  ?0S
CR 10 BYTE:IN (ABORT)    COUNT TYPE
CR 0F MESSAGE   CR
FORTH DEFINITIONS

\ 68000 : disk size constants             ( 26  7 87 CRC 14:35 )
BASE @ DECIMAL
| 360 CONSTANT S9B/DRV         |  719 CONSTANT S9MAX
| 410 CONSTANT SAB/DRV         |  819 CONSTANT SAMAX
| 720 CONSTANT D9B/DRV         | 1439 CONSTANT D9MAX
| 820 CONSTANT DAB/DRV         | 1639 CONSTANT DAMAX

| 'NF B/DRV  CFA 4+ CONSTANT 'B/DRV
| 'NF MAXBLK CFA 4+ CONSTANT 'MAXBLK
| 'NF B/SIDE CFA 4+ CONSTANT 'B/S

BASE !




\ 68000 : Memory setup                    (  1  3 87 CRC 13:59 )
  \ Set maxblk(s) according to the number of floppies on system.
LABEL SETDISKS  HEX  HERE 12 + DELTA - *+ BRA,
       \                   9.ss    10.ss   9.ds    10.ds
   LABEL DISKSIZES DECIMAL 360 W,  410 W,  720 W,  820 W,  HEX
   LABEL SIZEDISK   DR4 DR3 .W MOV,
         AR1 [+ DR3 MULU,  1 # DR3 .W SUBQ,  RTS,
 \ branch to here!
   4A6 ( _nflops) @# DR4 .W MOV,    DISKSIZES *+ AR1  LEA,
   SIZEDISK *+ BSR,  DR3 'NF S9MAX  CFA 4+ @#L MOV,  \  9.ss
   SIZEDISK *+ BSR,  DR3 'NF SAMAX  CFA 4+ @#L MOV,  \ 10.ss
   SIZEDISK *+ BSR,  DR3 'NF D9MAX  CFA 4+ @#L MOV,  \  9.ds
   SIZEDISK *+ BSR,  DR3 'NF DAMAX  CFA 4+ @#L MOV,  \ 10.ds
   RTS,


















\ 68000 : (tr/w)                          (  3  2 87 CRC 11:42 )
| CODE (TSECT)  \ addr diskblk flag  ---  flag  | sect setup
  S [+ DR1 MOV,  S [+ DR0 MOV,  IOB *+ AR0 LEA,
  0A # DR0 DIVU,  DR0 AR0 0C &[ .W MOV,               \ track
  DR0 .W SWAP,  1 # DR0 ADDQ,  DR0 AR0 0A &[ .W MOV,  \ sect
  S [ AR0 [ MOV,   DR1 S [ MOV,  NEXT   ;C     \ addr

: (TR/W)  \ addr  blk  fl ---   | write, fl=0; read, fl=1
  OVER 0 MAXBLK WITHIN 0=      6 ?ERROR    >R
        0 B/DRV U/   8 +IOB W!  \ set device, 1- 2
  DUP + ( 2*) R>  (TSECT)  -DISK ?DERR ;





\ 68000 : (dtr/w)                         ( 29  1 87 CRC 11:19 )
\ iob layout. is shoved to return stack by  -disk, scr 359
\ bytes     0-3    4-7  8-9  A-B   C-D  E-F 10-11
\   buffer addr  ->DSB  dev sect track side count

   \ 10 sectors per track, double sided
: (DTR/W)  \ addr  blk  fl ---   | write, fl=0; read, fl=1
  OVER 0 MAXBLK WITHIN 0=      6 ?ERROR    >R
        0 B/DRV U/       8 +IOB W!  \ set device, 1- 2
        0 2     U/ SWAP 0E +IOB W!  \ set side,
  DUP + ( 2*) R>  (TSECT)  -DISK  ?DERR ;





\ r/w for one double sided disk: ver 1    ( 29  1 87 CRC 11:36 )
| CODE DSECT  \ addr dskblk# flag ---  | f:  0 = write 1 = read
  S [+ DR1 MOV,  S [+ DR0 MOV,  IOB *+ AR0 LEA,
  9 # DR0 DIVU,  DR0 AR0 0E &[ .W MOV, \ set side
  DR0 .W SWAP,  1 # DR0 ADDQ,  DR0 AR0 0A &[ .W MOV,  \ set sect
  S [ AR0 [ MOV,   DR1 S [ MOV,  NEXT   ;C     \ addr

: (DR/W) \ addr blk# flag ---  | f:  0 = write 1 = read
  OVER 0 MAXBLK WITHIN 0= 6 ?ERROR   >R
     0 B/DRV     U/  8 +IOB W! \ set device, 0 -  1
     0     9     U/ 0C +IOB W! \ set track,  0 - 79
  DUP + ( 2*)  2DUP  R DSECT -DISK ?DERR
          200 1 D+  R> DSECT -DISK ?DERR  ;



\ hard disk raw access                    ( 26 12 90 CRC 18:48 )
\ --> requires presence of hard disk driver in RAM. <--
HEX
CTL D 1- CONSTANT HDRV   \ rwfl: 0: write, non-0: read

CODE RWABS \ rwfl addr sec# dev ---  erfl | r/w disk sect
 RP DR7 MOV,  S [+ DR0 MOV,  DR0 RP -[ .W MOV, \ dev     ct = 2
 S [+ DR1 MOV,  DR1 RP -[ .W MOV,  ( rec# ) 2 # RP -[ .W MOV,
 S [+ RP -[ MOV, ( addr)  S [ DR0 MOV,     \ get flag
 NE IF,  DR0 .W CLR,  ELSE,     \ r/w flag, ignore disk change
   DR1 TST,  NE IF,  >R >R      \ no writes to 0 blk!
     1 # DR0 .W MOVQ,  THEN,  DR0 RP -[ .W MOV,
 4 # RP -[ .W MOV, ( fc) 0D # TRAP,  R> R> THEN,   DR7 RP MOV,
 DR0 S [ MOV,  NEXT           ;C


\ hard disk raw access                    ( 26 12 90 CRC 19:15 )
DECIMAL
| 9 CONSTANT MAXBADS            2160 CONSTANT MINHBLK
  0 CONSTANT MAXHBLK
HEX

CODE GETBPB  \ dev# -- addr | bios parameter block
 S [ DR0 MOV,  DR0 RP -[ .W MOV,  ( dev# ) 7 # RP -[ .W MOV,
 0D # TRAP,   4 # RP ADDQ,  DR0 S [ MOV,  NEXT    ;C

: GETMAXHBLK  HDRV GETBPB  DUP 0E + W@  SWAP 0C + W@ 2 /  + 1-
  MAXBADS -     \ spare blocks for bad map
  MINHBLK +  { 'NF MAXHBLK CFA 4+ } LITERAL  ! ;



\ bad sector mapping                      ( 26  7 87 CRC 15:15 )
: .BADS   BADMAP @ 1+ -DUP IF 0
  DO  BADMAP 4+  I 4* +  ? LOOP THEN ;

: >BAD    \ blk#  ---   | added to bad sector map
  BADMAP @ 2+ DUP MAXBADS = IF ." Bad map full "  0 ERROR THEN
  4*  BADMAP + !  BADMAP 1+!  .BADS ;









\ bad sector mapping                      ( 21  6 87 CRC 16:32 )
CODE ?BAD  \ blk# --- blk# fl | map bad sectors to spare list
  DR2 CLR,  S [ DR0 MOV,  'NF BADMAP CFA 4+ *+ DR1 MOV,
  PL IF,  'NF BADMAP CFA 8 + *+ AR0 LEA,
    EQ DR1 DO,  AR0 [+ DR0 CMP,  LOOP,
    EQ IF,  2 # DR1 ADDQ,  DR1 S [ MOV,   1 # DR2 ADDQ,  THEN,
  THEN,  DR2 S -[ MOV,  NEXT    ;C

: REBLOCK  \ blk# --  blk#' | remap if bad sector
  ?BAD IF MAXHBLK + THEN ;






\ hard disk raw access                    ( 26 12 90 CRC 19:37 )
DECIMAL           \ fl: 0: write, non-0: read
: (HR/W) \ addr blk# fl ---   | read from hard disk
  ROT ROT DUP  MINHBLK MAXHBLK WITHIN 0= 6 ?ERROR   REBLOCK
  MINHBLK -  DUP + ( blk-> sect)  HDRV ( drive)  RWABS
  -DUP IF BASE @ HEX SWAP 6 .R BASE ! SPACE 8 ERROR THEN ;

HEX
| 'NF ABORT CFA  VARIABLE FLOPPYVEC

: FHR/W   OVER MAXBLK > IF  (HR/W)  ELSE
  FLOPPYVEC @EXECUTE  THEN ;

: HR/W  >R  DUP MAXBLK  > 1-  MINHBLK AND + R> (HR/W)  ;


\ 68000 : disk switchers                  ( 16  2 91 CRC 16:17 )
DECIMAL
: 9.SS   { 'NF (R/W) CFA } LITERAL  'R/W !  1 16 +IOB !
  S9MAX   'MAXBLK !  S9B/DRV 'B/DRV !  S9B/DRV 'B/S !     ;

: 10.SS  { 'NF (TR/W) CFA } LITERAL  'R/W !  2 16 +IOB !
  SAMAX   'MAXBLK !  SAB/DRV 'B/DRV !  SAB/DRV 'B/S !     ;









\ 68000 : disk switchers                  ( 16  2 91 CRC 16:17 )
DECIMAL
: 9.DS   { 'NF (DR/W) CFA } LITERAL  'R/W !  1 16 +IOB W!
  D9MAX   'MAXBLK !  D9B/DRV 'B/DRV  !   S9B/DRV 'B/S !   ;

: 10.DS  { 'NF (DTR/W) CFA } LITERAL  'R/W !  2 16 +IOB W!
  DAMAX   'MAXBLK !  DAB/DRV 'B/DRV  !   SAB/DRV 'B/S !   ;

\ 'NF 10.DS CFA   'NF DSKSET CFA DELTA + 4+ !







\ 68000 : disk switchers                  ( 16  2 91 CRC 16:09 )
\ use to make hard disk the only disk. the first 720 k are
\ shadowed at minhblk, to maintain consistency across models.
\ First indicate the type of floppy you want to emulate, then
\ run harddisk. The rest of the hard disk is added automatically

\ e.g: 10.ds harddisk  for "floppies" + harddisk
: HARDDISK    GETMAXHBLK
  { 'NF HR/W CFA } LITERAL  'R/W ! ;

\ use to add hard disk to any existing floppies. E.g:
\   10.SS +HARDDISK
: +HARDDISK   GETMAXHBLK
  'R/W @ FLOPPYVEC !
  { 'NF FHR/W CFA } LITERAL 'R/W ! ;
DECIMAL
































































































































































































































































































































































































































































































































































































































































































































































\ 68000 Source Code: loader               (  6  3 92 CRC 10:42 )
BASE F@ >R       FORTH DEFINITIONS   CHOP        6 LENGTH F!
SETOLD mf SETNEW     DECIMAL       WARNING ON
        -99 +LOAD   \ loader pre-amble
     3   10 +THRU   \ source from lit to sp!
   165  167 +THRU   \ compiler directives
    11   30 +THRU   \ source from (key) to first : def
   170 +BLK  LOAD   \ optimizers
    31   85 +THRU   \ source from 1st : def to end of nucleus
     (   86 +LOAD CR  (  wdump) SETOLD SETNEW
   111  118 +THRU   \ forward references
TXT Copyright 2019 C. Curley"   SETOLD SETNEW   EDITOR FLUSH
QUIET SETOLD ( CR mf ) HEX  DPNEW F@ IMAGETOP OVER - ERASE
DECIMAL 119 +LOAD       \ file setup
DECIMAL CR #BUFS . ." Buffers "  R> BASE F! CR PTODAY CR

\ base-addr memory map                    ( 17 10 85 CRC       )
all addresses are offset from base-addr
addr   count   comment
   0       6   jump to cold start
   6       6   jump to warm start
  0C       4   "68000" in radix 36, per fig model
  10       4   nfa of top of dictionary. Why, I don't know.
  14       4   backspace characters. Usually 7F & 08
  18       4   user area base address
  1C       4   top of parameter stack; orphaned user  S0
  20       4   top of return stack
  24      60   initial values for user variables




















\ boot parameters, execute                (  6  9 91 CRC 22:20 )
ASSEMBLER HEX ~ 0 @#L .L JMP,   \ cold start jmp,
 ( 4EF9 )     ~ 0 @#L .L JMP,   \ warm start jmp,
  9F7800 ,             0 ,    7F W, CTL H W, \ 2 backspaces on
\ 68000 radix 36   dict top   backspace chr  \ atari & ibm pc
HERE 8C  DUP == COLDS  4- DUP ALLOT   ERASE  \ colds

CODE EXECUTE  S [+ AR0 MOV,  AR0 [ JMP, ;C  FIXED

CODE ;S       4 # RP ADDQ,  NEXT ;C   FIXED

        \ force all of these to assemble bsr
HERE DELTA - DUP MUTATES *CONSTANT*  DUP MUTATES *DOES>*
MUTATES *(;CODE)*


\ (of) (loop)                             ( 28  1 92 CRC  8:56 )
ASSEMBLER BEGIN,  >R >R
  AR0 [ AR1 .W MOV,  AR1 AR0 ADD,  AR0 [ JMP,

CODE (OF)   RP [+ AR0 MOV,  S [+ DR0 MOV,   S [ DR0 CMP,
  R> R> EQ UNTIL,  4 # S ADDQ,  2 # AR0 ADDQ,  AR0 [ JMP,  ;C
                                                FIXED
ASSEMBLER BEGIN,  2DUP  >R >R   2 # AR0 ADDQ,
  RP [+ DR6 MOV,  RP [+ DR5 MOV,  AR0 [ JMP,
\       dr5: index                      dr6: limit
CODE (LOOP)     RP [+ AR0 MOV,  1 # DR5 ADDQ,
  LABEL LP2     DR5 DR6 CMP,
                R> R> GT UNTIL,
  LABEL LP5     AR0 [ AR0 .W ADD,
                AR0 [ JMP,  ;C        FIXED
'NF (LOOP) CFA  MUTATES *(LOOP)*
\ (+loop) (do) (pause) paws               ( 23  1 92 CRC  9:48 )
>R >R CODE (+LOOP)  RP [+ AR0 MOV,
  S [+ DR0 MOV,  DR0 DR5 ADD,  DR0 TST,  PL LP2 *+ BCC,
  DR5 DR6 CMP,  LT LP5 *+ BCC,   R> R> AGAIN,    ;C   FIXED
\       dr5: index                      dr6: limit
'NF (+LOOP) CFA  MUTATES *(+LOOP)*
CODE (DO)  RP [ AR0 MOV,  DR5 RP [ MOV,  DR6 RP -[ MOV,
  S [+ DR5 MOV,  S [+ DR6 MOV,  AR0 [ JMP, ;C FIXED

  \ call to pause current task.
LABEL (PAUSE)  RP 4 U &[ MOV,  8 U &[ U MOV,
  4 U &[ RP MOV,  RTS,
  \ call from i/o code definitions inside loops
CODE PAUSE   DR5 RP -[ MOV,  DR6 RP -[ MOV,  S RP -[ MOV,
             (PAUSE) *+ BSR,   \ execution resumes here
  RP [+ S MOV,  RP [+ DR6 MOV,  RP [+ DR5 MOV, NEXT  ;C  FIXED
\ i i! digit pause                        ( 27  1 92 CRC 10:27 )
CODE I  DR5 S -[ MOV,  NEXT  ;C

CODE I!  S [+ DR5 MOV,  NEXT  ;C        \ use to play w/ index

CODE DIGIT  DR2 CLR,  S [+ DR1 MOV,  S [ DR0 MOV,
   ASCII 0 # DR0 .W SUB,   CS IF,
LABEL BADDIG   DR2 S [ MOV,  NEXT  THEN, \ error exit
   09 # DR0 .W CMP,
   GT IF,  11 # DR0 .W CMP,  LT BADDIG *+ BCC,
   7 # DR0 .W SUB,    THEN,
   DR1 DR0 .W CMP,  GE BADDIG *+ BCC,
   DR0 .L EXT,  1 # DR2 ADDQ,
   DR0 S [ MOV,    DR2 S -[  MOV, NEXT   ;C


\ (find) - part 1                         ( 14  2 92 CRC  9:16 )
\ DEBUG FORGET TASK
\ FORTH DEFINITIONS  : TASK ;        BASE F@ >R HEX
CODE (FIND)  S [+ AR1 MOV,  S [ AR0 MOV,
  AR0 [+ DR7 .B MOV,  AR0 DR2 MOV,                \ -> 1st char
  6C ( forth's pseudo nfa) U &[ AR5 LEA,          \ taskfix
  BEGIN,  AR1 AR5 CMP,  LE IF, AR5 AR1 MOV,  THEN, \ taskfix
    AR1 [ DR1 .B MOV,  3F # .W DR1 AND,   \ get len
    DR7 DR1 .B CMP,  EQ IF,   \  br on lens /=
    AR1 AR2 MOV,  1 # AR2 ADDQ,  DR2 AR0 MOV,
;S  -->
stack: here, dict to search ---
dr2 : word being searched       ar0 : here
dr0 : word sought               dr7 : len of word sought
dr1 : length of current word    ar1 : nfa being searched
trial code for mods on scr 5298
\ (find) - part 2                         ( 14  2 92 CRC  9:16 )
    BEGIN,  AR2 [+ .B DR4 MOV,  AR0 [+ DR0 .B MOV,
       DR0 DR4 .B EOR,  1 # DR4 .B ASL,
          EQ IF, ( ** ) >R >R  CS UNTIL,
       2 # AR2 ADDQ,  AR2 S [ MOV,                    \ cfa
       DR1 CLR,  AR1 [ DR1 .B MOV,  DR1 S -[ MOV,     \ count
       1 # DR0 MOVQ,  DR0 S -[ MOV,  NEXT             \ flag
    ( **) R> R> THEN, THEN,
    -4 AR1 &[ AR1 MOV,  AR1 DR0 MOV,  EQ UNTIL,
  DR0 S [ MOV, NEXT  ;C                                 ;S

: TEST  BL WORD  HERE COUNT UPPER  HERE 10 DUMP
        HERE LATEST FND ;       EDITOR FLUSH   R> BASE F!



\ enclose                                 ( 26  2 86 CRC       )
CODE ENCLOSE  S [+ DR0 MOV,      S [ AR0 MOV,
              -1 #L DR1 MOV,
      BEGIN,  1 # DR1 ADDQ,      0 AR0 1 &D[ DR0 .B CMP,
              NE UNTIL,          DR1 S -[ MOV,
LABEL ENCL3   0 AR0 1 &D[ DR0 .B CMP,      NE IF,
              0 # 0 AR0 1 &D[ .B CMP,      NE IF,
              1 # DR1 ADDQ,      ENCL3 *+ BRA,
      THEN,   S [ DR1 CMP,       EQ IF,
              1 # DR1 ADDQ,      DR1 S -[ MOV,
LABEL ENCL8   DR1 S -[ MOV,      NEXT
      THEN,   DR1 S -[ MOV,      ENCL8 *+ BRA,
      THEN,   DR1 S -[ MOV,      1 # DR1 ADDQ,
              ENCL8 *+ BRA,                    ;C
;S

\ @execute exec sp@ sp!                   ( 31  7 92 CRC 10:35 )
CODE @EXECUTE   4 # RP ADDQ,  S [+ AR1 MOV,
  AR1 [ AR0 MOV,  AR0 [ JMP, ;C         FIXED
'NF @EXECUTE CFA  MUTATES *@EXEC*

CODE <EXEC>  \ index ---  | index into execution array
  S [+ DR0 MOV,  2 # DR0 ASL,  RP [+ AR0 MOV,  DR0 AR0 ADD,
  AR0 [ AR0 MOV,  AR0 [ JMP,  ;C                FIXED

CODE SP!  0C U &[ S MOV,        NEXT ;C

CODE SP@  S S -[ MOV,           NEXT ;C

CODE RP@  RP S -[ MOV,          NEXT ;C

ASSEMBLER LABEL MASK 7F W,
\ (emit) (key) (?terminal) bye            ( 26  8 93 CRC  8:59 )
CODE (EMIT)  S [+ DR0 MOV,  MASK *+ .W DR0 AND,  \ data
  DR0 RP -[ .W MOV,  U 7E ( i/o) &[ RP -[ .W MOV,
  3 # RP -[ .W MOV, \ routine            ^ device
  0D # TRAP,  6 # RP ADDQ,  NEXT   ;C           FIXED

CODE (KEY) BEGIN,   'NF PAUSE CFA *+ BSR,  U 7C &[ RP -[ .W MOV,
  1 # RP -[ .W MOV, 0D # TRAP,  4 # RP ADDQ,  DR0 TST, NE UNTIL,
  U 7C &[ RP -[ .W MOV,  2 # RP -[ .W MOV,  0D # TRAP,
  4 # RP ADDQ,  FF #L DR0 AND,  DR0 S -[ MOV,  NEXT  ;C

CODE (?TERMINAL)   DR7 CLR,  U 7C ( i/o) &[ RP -[ .W MOV,  \ dev
  1 # RP -[ .W MOV, ( routine # ) 0D # TRAP,  DR0 .W TST,
  NE IF, ( eat it)  4 # RP ADDQ,   U 7C ( i/o) &[ RP -[ .W MOV,
  2 # RP -[ .W MOV,  0D # TRAP,  1 # DR7 ADDQ,
  THEN,  DR7 S -[ MOV,  4 # RP ADDQ,  NEXT  ;C
\ 0= 0< >                                 ( 23 10 93 CRC 18:06 )
CODE 0=   DR0 CLR,   S [ TST,   EQ IF,  1 # DR0 ADDQ,  THEN,
  DR0 S [ MOV,  NEXT    ;C

CODE 0<   DR0 CLR,   S [ TST,   MI IF,  1 # DR0 ADDQ,  THEN,
  DR0 S [ MOV,  NEXT    ;C

CODE >    DR0 CLR,  S [+ DR1 MOV,  S [ DR1 CMP,
   LT IF,  1 # DR0 ADDQ,  THEN,  DR0 S [ MOV,  NEXT ;C







\ drop 2drop 2*s 2/s                      ( 19  3 92 CRC 10:39 )
CODE DROP   4 # S ADDQ,  NEXT  ;C

CODE 2DROP  8 # S ADDQ,  NEXT  ;C

CODE 2/S \ n ct -- n | shift right count times
  S [+ DR0 MOV,  S [ DR1 MOV,  DR0 DR1 LSR,  DR1 S [ MOV,  NEXT
;C

CODE 2*S \ n ct -- n | shift left count times
  S [+ DR0 MOV,  S [ DR1 MOV,  DR0 DR1 LSL,  DR1 S [ MOV,  NEXT
;C




\ u*                                      ( 19  3 92 CRC 10:39 )
CODE U*    DR5 RP -[ MOV,  DR6 RP -[ MOV,
        S [+ DR0 MOV,     DR0 DR2 MOV,   DR0 DR4 MOV,
        S [+ DR1 MOV,     DR1 DR3 MOV,   DR1 DR5 MOV,
        DR2 .W SWAP,      DR3 .W SWAP,
        DR2 DR6 MOV,      DR3 DR7 MOV,
        DR7 DR2 MULU,     DR6 DR1 MULU,
        DR5 DR0 MULU,     DR4 DR3 MULU,  DR7 CLR,
        DR0 S -[ .W MOV,  DR0 .W SWAP,
        DR0 DR1 .W ADD,   DR7 DR2 ADDX,  DR2 .W SWAP,
        DR3 DR1 ADD,      DR7 DR2 ADDX,  DR2 .W SWAP,
        DR1 S -[ .W MOV,  DR1 .W SWAP,
        DR1 DR2 .W ADD,   DR2 S -[ MOV,
  RP [+ DR6 MOV,  RP [+ DR5 MOV,    NEXT   ;C


\ u/ 4+ 2+ 1+ =cells                      ( 12  2 87 CRC 17:38 )
CODE U/   S [+ DR2 MOV,  S [+ DR0 MOV,  S [ DR1 MOV,
  1F # DR3 .W MOV,     FALSE DR3 DO,
  1 # DR1 LSL,  1 # DR0 ROXL,   DR2 DR0 SUB,
  CS IF,  DR2 DR0 ADD,  ELSE,  1 # DR1 ADDQ, THEN,  LOOP,
  DR0 S [ MOV,   DR1 S -[ MOV,   NEXT   ;C

CODE 4+  4 # S [ ADDQ,   NEXT ;C

CODE 2+  2 # S [ ADDQ,   NEXT ;C

CODE 1+  1 # S [ ADDQ,   NEXT ;C

CODE =CELLS  S [ DR7 MOV,  1 # DR1 MOVQ,  DR1 DR7 AND,
  DR7 S [ ADD,  NEXT ;C
\ fe # dr0 movq,  1 # s [ addq,  dr0 s [ and,  next ;c
\ and or xor rp! leave ?leave             ( 23  1 92 CRC  9:57 )
CODE AND   S [+ DR7 MOV,  DR7 S [ AND,          NEXT     ;C

CODE OR    S [+ DR7 MOV,  DR7 S [ OR,           NEXT     ;C

CODE XOR   S [+ DR7 MOV,  DR7 S [ EOR,          NEXT     ;C

CODE RP!   10 U &[ RP MOV,                      NEXT     ;C

\       dr5: index                      dr6: limit
CODE LEAVE  DR5 DR6       MOV,                  NEXT     ;C

code ?leave  s [+ dr0 mov,  ne if,  dr5 dr6 mov,  then, next  ;c



\ < rot + - d+                            ( 16  2 86 CRC       )
CODE <   DR0 CLR,  S [+ DR1 MOV,  S [ DR1 CMP,
   GT IF,  1 # DR0 ADDQ,  THEN,  DR0 S [ MOV,  NEXT  ;C

CODE ROT   S 8 &[ DR0 MOV,  S 4 &[ S 8 &[ MOV,
   S [ S 4 &[ MOV,  DR0 S [ MOV,  NEXT ;C

CODE +     S [+ DR7 MOV,  DR7 S [ ADD,     NEXT     ;C

CODE -     S [+ DR7 MOV,  DR7 S [ SUB,     NEXT     ;C

CODE D+    S [+ DR0 .L MOV,  S [+ DR1 .L MOV,
           DR1 S 4 &[  ADD,
           S [ DR1 MOV,  DR1 DR0 ADDX,
           DR0 S [ MOV,  NEXT ;C

\ minus dminus over s->d swap dup           17  2 85 CRC
CODE MINUS   S [ NEG,  NEXT  ;C

CODE DMINUS   S 4 &[ NEG,  S [ NEGX,  NEXT ;C

CODE OVER   4 S &[ S -[ MOV,  NEXT ;C

CODE S->D   DR0 CLR, S [  TST,   MI IF,
    1 # DR0 SUBQ,  THEN,  DR0 S -[ MOV,  NEXT ;C

CODE SWAP   S [+ DR0 MOV,  S [ DR1 MOV,
            DR0 S [  MOV,  DR1 S -[ MOV,   NEXT ;C

CODE DUP   S [ S -[ MOV, NEXT  ;C


\ -dup 2dup +! toggle within              ( 27  6 91 CRC  9:17 )
CODE -DUP   S [ TST,  NE IF,  S [ S -[ MOV,  THEN,  NEXT ;C

CODE 2DUP   4 S &[ S -[ MOV,  4 S &[ S -[ MOV,  NEXT ;C

CODE NIP  S [+ S [ MOV,  NEXT   ;C

CODE +!   S [+ AR0 MOV,  S [+ DR1 MOV,  DR1 AR0 [ ADD,  NEXT ;C

CODE TOGGLE   S [+ DR1 MOV,  S [+ AR0 MOV,
              DR1 AR0 [ .B EOR,  NEXT ;C

CODE WITHIN  \ n l1 l2 --- fl | is n between lim1 & lim2 incl.?
 1 # DR0 MOVQ,  S [+ DR1 MOV,   S [+ DR2 MOV,
 S [ DR1 CMP,  LT IF,  DR0 CLR,  THEN,
 S [ DR2 CMP,  GT IF,  DR0 CLR,  THEN,  DR0 S [ MOV,  NEXT ;C
\ @ c@ !                                    21  2 85 CRC
CODE @   S [ AR0 .L MOV,       \ avoid byte boundary
   AR0 [+   S  [ .B MOV,       \ problems
   AR0 [+ 1 S &[ .B MOV,
   AR0 [+ 2 S &[ .B MOV,
   AR0 [  3 S &[ .B MOV,  NEXT  ;C

CODE C@  DR0 CLR,  S [ AR0 .L MOV,
         AR0 [ DR0 .B MOV,
         DR0 S [ MOV,   NEXT ;C

CODE !   S [+ AR0 .L MOV,
         S [+ AR0 [+ .B MOV,
         S [+ AR0 [+ .B MOV,
         S [+ AR0 [+ .B MOV,
         S [+ AR0 [  .B MOV, NEXT ;C
\ c! 4- 2- 1- on off 1+!                  ( 18  3 86 CRC       )
CODE C!  S [+ AR0 MOV,  3 # S ADDQ,
         S [+ AR0 [ .B MOV,  NEXT ;C

CODE 4-  4 # S [ SUBQ,  NEXT ;C

CODE 2-  2 # S [ SUBQ,  NEXT ;C

CODE 1-  1 # S [ SUBQ,  NEXT ;C

CODE ON  S [+ AR0 MOV,  1 # DR0 MOVQ,  DR0 AR0 [ MOV,  NEXT ;C

CODE OFF S [+ AR0 MOV,  AR0 [ CLR,  NEXT                 ;C

CODE 1+! S [+ AR0 MOV,  1 # AR0 [ ADDQ,  NEXT   ;C

\ 6- w@ w! f@ f!                          ( 22 12 91 CRC 12:22 )
CODE 6-  6 # S [ SUBQ,  NEXT ;C

CODE W@   S [+ AR0 MOV,  AR0 1 &[ S -[ .B MOV,
  AR0 [ S -[ .B MOV,  S -[ .W CLR,   NEXT ;C

CODE W!   S [+ AR0 MOV,  2 # S ADDQ,  S [+ AR0 [+ .B MOV,
  S [+ AR0 [ .B MOV,  NEXT  ;C

CODE F@         \ @ from even address only
  S [ AR0 MOV,  AR0 [ S [ MOV,  NEXT  ;C

CODE F!         \ store to even address only
  S [+ AR0 MOV,  S [+ AR0 [ MOV,  NEXT  ;C


\ m*                                        19  2 85 CRC
CODE M*    S [ DR2 MOV,  S 4 &[ DR1 MOV,
   DR1 DR3 MOV,  DR1 DR4 MOV,  DR4 .W SWAP,
   DR2 DR0 MOV,  DR0 .W SWAP,

   DR2 DR1 MULU,  DR4 DR2 MULU,  DR0 DR3 MULU,  DR0 DR4 MULU,

   DR1 .W SWAP,  DR2 DR1 .W ADD,
   DR0 CLR,  DR0 DR4 ADDX,  DR3 DR1 .W ADD,  DR0 DR4 ADDX,
   DR1 .W SWAP,  DR2 .W CLR,  DR2 .W SWAP, DR3 .W CLR,
   DR3 .W SWAP, DR3 DR2 ADD,  DR4 DR2 ADD,

   S [ TST,  MI IF,  S 4 &[ DR2 SUB,  THEN,
   S 4 &[ TST,  MI IF,  S [ DR0 SUB,  THEN,
   DR2 S [ MOV,  DR1 S 4 &[ MOV,
   NEXT ;C
\ cmove                                   ( 20  5 94 CRC 19:50 )
CODE CMOVE  \ slower than qcmove, but larger count
   S [+ DR0 MOV,  S [+ AR1 MOV,  S [+ AR0 MOV,
   NE IF,  BEGIN,  AR0 [+ AR1 [+ .B MOV,  1 # DR0 SUBQ,
           EQ UNTIL,  THEN,  NEXT ;C
DEBUGGING IFTRUE
WARNING F@  WARNING OFF
LABEL PRINTASCII  \ print out a value as an ascii character
  0F #L DR0 AND,   30 # DR0 .W ADD,
  ASCII 9 # DR0 .W CMP,  GT IF,  7 # DR0 .W ADD,  THEN,

LABEL PRINTDR0    \ print a character in dr0
  DR0 RP -[ .W MOV,             2 # RP -[ .W MOV,
  3 # RP -[ .W MOV, \ routine   ^ device
  0D # TRAP,  6 # RP ADDQ,  RTS,
WARNING F!       IFEND
\ m/                                      ( 12  2 92 CRC  9:48 )
DEBUGGING IFTRUE
CODE SHW        \ n -- print n as 32 bit #. For debug.
  20 # DR0 MOVQ,  PRINTDR0 *+ BSR,
  S [ DR4 MOV,  07 # DR3 MOVQ,  FALSE DR3 DO,  4 # DR4 ROL,
  DR4 DR0 MOV,  PRINTASCII *+ BSR,  LOOP,  NEXT  ;C
IFEND   ;S
CODE TM/      EDITOR FLUSH ASSEMBLER  HEX
  S [+ DR2 MOV,  S [+ DR0 MOV,  S [ DR1 MOV,
  DR2 TST,  MI IF,  DR1 NEG,  DR0 NEGX,  DR2 NEG,  THEN,
  DR0 TST,  MI IF,  DR2 DR0 ADD,  THEN,
  1F # DR3 .W MOV,  1 # DR1 LSL,
  FALSE DR3 DO,  1 # DR0 ROXL,  DR2 DR0 SUBX,
      CS IF,  DR2 DR0 ADD,  THEN,  1 # DR1 ROXL,  LOOP,
  DR1 NOT,  DR0 S [ MOV,  DR1 S -[ MOV,  NEXT   ;C   ;S

\ constant variable                       (  5  2 92 CRC  7:49 )
                                \ call to literal -> bra later
: VARIABLE  GAP ( create)  GAP ( , )    GAP ( immediate )
  DOES>  GAP ( literal )  STOP
                                    MUTATES *VARIABLE*

: CONSTANT  GAP ( create ) GAP ( immediate ) GAP ( , )
  DOES> F@ GAP ( literal ) STOP  \ call to literal -> bra later
                MUTATES *CONSTANT*

   40 CONSTANT C/L              20 CONSTANT BL
*B/BUF* CONSTANT B/BUF          400 *B/BUF* / CONSTANT B/SCR
CODE 0  S -[ CLR,  NEXT ;C



\ user some constants +origin             ( 22  2 92 CRC  7:28 )
CODE +ORIGIN  FBASE #L S [ ADD,  NEXT ;C

: USER   GAP ( create)  GAP  ( w, ) GAP ( immediate)  ;CODE
  RP [+ AR0 MOV,  U AC &[ ( ofuser state ) TST,  NE IF,
    DR0 CLR,  AR0 [ DR0 .W MOV,  DR0 S -[ MOV,
    } 41EE GAP ( w,)  GAP ( w,)  2708  GAP ( w,)
    { ASSEMBLER  SETNEW  ELSE,  U DR0 MOV,  AR0 [ DR0 .W ADD,
    DR0 S -[ MOV,   THEN,    NEXT  ;C  MUTATES *USER*

HEX ( |  0 USER MOI           | 0C USER S0       )
        14 USER TIB             18 USER WIDTH
        1C USER WARNING         20 USER FENCE
        24 USER DP              28 USER VOC-LINK


\ initialised user variable               ( 17  2 92 CRC  7:18 )
HEX     2C USER 'KEY            30 USER 'EXPECT
        34 USER '?TERMINAL      38 USER 'EMIT
        3C USER 'TYPE           40 USER 'GOTOXY
        44 USER 'PAGE           48 USER 'LIST
        4C USER 'CR
        50 USER 'R/W            54 USER 'QUIT
        58 USER 'ABORT          5C USER 'CREATE
        60 USER 'FIRST          64 USER 'LIMIT
\         headptr      vnfa       vclnk
\ vocs: ptr->head | pseudoname | voc-link
    68 == HEADPTR   6C == VNFA   70 == VCLNK
|       74 USER BOTSTACK
        78 USER LENGTH  \ len to compile in line
        7C USER I/O \ change  (key) , etc. if you change this
\ last user inited by cold on boot is  i/o
\ uninitialised user variable             ( 15 10 91 CRC 10:10 )
        80 USER LASTTHEN        84 USER LASTSUB
        88 USER REL     \       8c user spare

        90 USER BLK             94 USER IN
        98 USER OUT             9C USER SCR
        A0 USER OFFSET          A4 USER CONTEXT
        A8 USER CURRENT         AC USER STATE
        B0 USER BASE            B4 USER DPL
        B8 USER FLD             BC USER CSP
        C0 USER R#              C4 USER HLD
        C8 USER USE             CC USER PREV




\ first limit here allot , c, w,          ( 22  8 91 CRC 15:08 )
CODE FIRST  OFUSER 'FIRST S -[ MOV,  NEXT     ;C
CODE LIMIT  OFUSER 'LIMIT S -[ MOV,  NEXT     ;C

CODE HERE   OFUSER DP S -[ MOV,  NEXT     ;C

CODE ALLOT  S [+ DR0 MOV,  DR0 OFUSER DP ADD,  NEXT     ;C

CODE ,   OFUSER DP AR0 MOV,
    4 # OFUSER DP ADDQ,   S [+ AR0 [ MOV,  NEXT ;C

CODE C,  OFUSER DP AR0 MOV,
    1 # OFUSER DP ADDQ,  'NF C! CFA 2+ *+ BRA, ;C

CODE W,  OFUSER DP AR0 MOV,
    2 # OFUSER DP ADDQ,  'NF W! CFA 2+ *+ BRA, ;C
\ subroutine threading code               ( 31  8 91 CRC 12:17 )
CODE BACK    OFUSER DP AR0 MOV,   AR0 DR0 MOV,
  DR0 S [ SUB,  'NF W, CFA 4+ *+ BRA,  ;C

LENGTH F@  DUP 10 MAX  LENGTH F!
: <BSR>   REL OFF  2-  HERE -  DUP -80  80 WITHIN
  IF  FF AND  6100 OR  ELSE  6100 W,  THEN  W, ;

: <SUB>         \ addr --  | compile a subroutine to addr
  HERE DUP LASTSUB F!  OVER - -8000  7FFF WITHIN
  IF  <BSR>  ELSE  4EB9 W,  ,  THEN ;

: <COMP>        \ addr --  | subroutine or inline?
  DUP 2- W@  -DUP IF { >R >R } LENGTH  F@ 1+ <
  IF  HERE OVER 2- W@  DUP ALLOT  CMOVE
       ELSE { R> R> } THEN <SUB> THEN ;         LENGTH F!
\ = key emit page cr r/w ?terminal        ( 27  6 91 CRC  9:23 )
CODE = DR0 CLR,  S [+ DR1 MOV,  S [ DR1 CMP,
  EQ IF,  1 # DR0 ADDQ, THEN,  DR0 S [ MOV,   NEXT   ;C

: KEY             PAUSE  'KEY       @EXECUTE    STOP

: EMIT   OUT 1+!  PAUSE  'EMIT      @EXECUTE    STOP

: PAGE                  'PAGE F@ EXECUTE  OUT OFF ;

: CR                    'CR   F@ EXECUTE  OUT OFF ;

: R/W        PAUSE  'R/W       @EXECUTE    STOP

: ?TERMINAL  PAUSE  '?TERMINAL @EXECUTE    STOP

\ traverse latest n>c c>n                 ( 17  2 92 CRC  7:18 )
LABEL (TRAV)   BEGIN,  DR0 AR0 ADD,  7 # AR0 [ .B BTST,
  NE UNTIL,  RTS,

CODE C>N  FE # DR0 MOVQ,  S [ AR0 MOV,  2 # AR0 SUBQ,
  (TRAV) *+ BSR,  AR0 S [ MOV,  NEXT  ;C

CODE N>C   2 # DR0 MOVQ,  S [ AR0 MOV,  1 # AR0 SUBQ, \ was pfa
  (TRAV) *+ BSR,  3 # AR0 .W ADD,  AR0 S [ MOV,  NEXT  ;C

CODE TRAVERSE   S [+ DR0 MOV,  S [ AR0 MOV,
  (TRAV) *+ BSR,  AR0 S [ MOV,  NEXT  ;C

CODE LATEST  OFUSER CURRENT AR0 MOV,  AR0 [ S -[ MOV,  NEXT ;C

: N>L  4- ;
\ space (page) u< ?align 4/ 4*            ( 17  9 88 CRC 12:51 )
: SPACE    BL EMIT  ;

: (PAGE)   0C EMIT  ;

CODE U<   DR0 CLR,  S [+ DR1 MOV,  S [ DR1 CMP,
   HI IF,  1 # DR0 ADDQ,  THEN,  DR0 S [ MOV,  NEXT  ;C

CODE ?ALIGN   OFUSER DP DR0 MOV,  1 # DR1 MOVQ,  DR1 DR0 AND,
          DR0 OFUSER DP ADD,   NEXT ;C
\ ofuser dp ar0 lea,  1 # ar0 [ addq,
\ fe # dr0 movq,  dr0 ar0 [ and,  next ;c

CODE 4/  S [ DR0 MOV,  2 # DR0 LSR,  DR0 S [ MOV,  NEXT ;C

CODE 4*  S [ DR0 MOV,  2 # DR0 LSL,  DR0 S [ MOV,  NEXT ;C
\ !csp ?error ?comp ?exec ?loading        ( 15  2 86 CRC       )
CODE !CSP   S OFUSER CSP MOV,  NEXT     ;C

: ?ERROR    SWAP IF GAP   ( error) ELSE DROP THEN ;

: ?COMP     STATE F@ 0=   11 ?ERROR ;

: ?EXEC     STATE F@      12 ?ERROR ;

: ?PAIRS    -  13 ?ERROR ;

: ?CSP      SP@ CSP F@ - 14 ?ERROR ;

: ?LOADING  BLK F@ 0= 16 ?ERROR ;


\ <compile> [ ] smudge                    ( 10 12 91 CRC 12:22 )
: <COMPILE>    ?COMP  R>  DUP 4+ >R  F@ <COMP> ;
'NF <COMPILE>  CFA  MUTATES *<COMPILE>*

CODE [  OFUSER STATE CLR, NEXT  ;C      IMMEDIATE

CODE ]  C0 #L OFUSER STATE MOV,  NEXT ;C

CODE SMUDGE   OFUSER CURRENT AR0 MOV,
 AR0 [ AR0 MOV,  5 # AR0 [ BCHG,  NEXT ;C






\ hex bounds decimal pad hold :           ( 31  8 91 CRC 10:48 )
CODE HEX      10 # DR0 MOVQ,  DR0 OFUSER BASE MOV,  NEXT ;C

CODE DECIMAL  0A # DR0 MOVQ,  DR0 OFUSER BASE MOV,  NEXT ;C

CODE BOUNDS  S [+ DR0 MOV,  S [ DR1 MOV,  DR1 DR0 ADD,
  DR0 S [ MOV,  DR1 S -[ MOV,  NEXT  ;C

CODE HOLD   1 # OFUSER HLD SUBQ,   OFUSER HLD AR0 MOV,
  S [+ DR0 MOV,  DR0 AR0 [ .B MOV,   NEXT ;C

CODE PAD   OFUSER DP S -[ MOV,  80 #L S [ ADD,  NEXT ;C

: CREATE  'CREATE   @EXECUTE     STOP


\ fill erase blanks abort quit type       ( 31  8 91 CRC 12:15 )
CODE FILL S [+ DR0 MOV,  S [+ DR1 MOV,  S [+ AR0 MOV,
  BEGIN, DR0 AR0 [+ .B MOV,  1 # DR1 SUBQ,  EQ UNTIL,  NEXT ;C

CODE ERASE         DR0 CLR,  'NF FILL CFA 2+ *+ BRA, ;C

CODE BLANKS  BL # DR0 MOVQ,  'NF FILL CFA 2+ *+ BRA, ;C

: QUIT   'QUIT  @EXECUTE STOP      'NF QUIT  CFA MUTATES *QUIT*

: ABORT  'ABORT @EXECUTE STOP      'NF ABORT CFA MUTATES *ABORT*

: TYPE   'TYPE  @EXECUTE STOP



\ replace immediate                       (  5  9 91 CRC 21:29 )
: REPLACE       \ addr  call ---  | calculate call to addr
  DUP W@ 4EB9 = IF  2+ F!  ELSE
    DUP W@ FF AND IF  2DUP 2+ -  FF AND  SWAP 1+ C!
       ELSE  2+ 2DUP -  FFFF AND  SWAP W!  THEN DROP  THEN ;

CODE IMMEDIATE  OFUSER CURRENT AR0 MOV,
 AR0 [ AR0 MOV,  6 # AR0 [ BCHG,  NEXT   ;C

0 VARIABLE ERRNO        \ nothing if not fashionable
                        \ get errno from variable
CODE BYE   -FC FBASE + *+ AR0 MOV,  AR0 USP MOV,
  VAR: ERRNO 2+ *+ RP -[ .W MOV,
  4C # RP -[ .W MOV,  1 # TRAP,  ;C     \ like the MTA....


\ (;code) does>                           ( 19  3 92 CRC 10:37 )
\ replace jsr operand.  create  now makes 'em immediate!
: (;CODE)  IMMEDIATE  R>  LATEST N>C  REPLACE  LASTSUB OFF ;
'NF (;CODE) CFA MUTATES *(;CODE)*

HERE DELTA - MUTATES *DOES>* ?CR
  ASSEMBLER  LABEL DODOES
  RP [+ AR0 MOV,        \ save does> address
  RP [+ S -[ MOV,       \ get data addr on stack
  AR0 [ JMP,            \ go do the does> code.

: DOES>  REL OFF  COMPILE (;CODE) { SETNEW
  ASSEMBLER DODOES NEWFORTH } LITERAL <SUB>
  LASTSUB OFF  ; IMMEDIATE


\ count (type) -trailing (.") (cr)        ( 30  8 86 CRC 16:30 )
CODE COUNT  S [ AR0 MOV,  1 # S [ ADDQ,  DR0 CLR,
  AR0 [ DR0 .B MOV,  DR0 S -[ MOV,  NEXT   ;C

: (TYPE) -DUP IF BOUNDS DO I C@ EMIT LOOP  ELSE DROP THEN ;

CODE -TRAILING  S [+ DR0 MOV,  S [ AR0 MOV,  DR0 AR0 ADD,
  1 # DR0 ADDQ, BEGIN, 1 # DR0 SUBQ, NE IF, BL # AR0 -[ .B CMP,
  DROP ROT ROT NE UNTIL,  2 THEN,  DR0 S -[ MOV,  NEXT  ;C

: (.") R COUNT DUP 1+ =CELLS  R> + >R TYPE ;
   'NF (.")           CFA  MUTATES *(.")*

: (CR)  ."   " ;


\ ." (expect) expect query                ( 27  1 92 CRC 10:27 )
: ." ASCII "  STATE F@
     IF COMPILE (.") GAP ( word)  HERE C@ 1+ =CELLS ALLOT
     ELSE GAP ( word) HERE COUNT TYPE THEN ;          IMMEDIATE

: (EXPECT) OVER + OVER          \ add for atari/ibm pc keyboard
     DO KEY DUP 14 +ORIGIN W@ =   OVER 16 +ORIGIN W@ = OR
        IF DROP 08 OVER I = DUP I 2- + I! - ELSE
          DUP 0D = IF LEAVE DROP BL 0 ELSE  DUP THEN I C!
        0 I 1+ C! THEN   EMIT ( DROP)  LOOP  DROP ;

: EXPECT  PAUSE 'EXPECT  @EXECUTE  STOP

: QUERY TIB F@ 50  EXPECT  IN OFF  ;


\ x pad word upper (number)               ( 31  8 91 CRC 10:50 )
: X       BLK F@ IF ?EXEC THEN RDROP ;  IMMEDIATE

: WORD BLK F@ IF BLK F@  GAP  ELSE  TIB F@ THEN IN F@ + SWAP
  ENCLOSE HERE 22 BLANKS IN +! OVER - >R  R HERE C!
  + HERE 1+ R> CMOVE  ;  \  gap = block

CODE UPPER  S [+ DR0 MOV,  S [+ AR0 MOV,
  ASCII a # DR2 .B MOVQ,  ASCII z # DR3 .B MOVQ,  DR0 FALSE DO,
  AR0 [ DR1 .B MOV,  DR1 DR3 .B CMP,  HS IF,  DR1 DR2 .B CMP,
    LS IF,  20 # AR0 [ .B EOR,  THEN,  THEN,   1 # AR0 ADDQ,
    LOOP, NEXT   ;C

: (NUMBER) BEGIN 1+ DUP >R C@ BASE F@ DIGIT
  WHILE SWAP BASE F@ U* DROP ROT BASE  F@ U* D+
       DPL F@ 1+ IF DPL 1+! THEN R> REPEAT R> ;
\ number -find error id.                  ( 30  8 91 CRC 22:28 )
: NUMBER 0 0 ROT DUP 1+ C@ ASCII - = DUP >R + -1
  BEGIN DPL F! (NUMBER) DUP C@ BL -
      WHILE DUP C@ ASCII . - 0 ?ERROR 0 REPEAT
  DROP R> IF DMINUS THEN ;
LENGTH F@  DUP 0A MAX  LENGTH F!
: -FIND   BL WORD  HERE COUNT UPPER  HERE CONTEXT F@ F@
  (FIND) DUP 0= IF DROP HERE LATEST  (FIND) THEN ;
             LENGTH F!
: ERROR   WARNING F@ 0<
  IF ABORT THEN HERE COUNT TYPE ."  ? "
  GAP ( message) SP!  BLK F@ IF IN F@ BLK F@ THEN
  QUIT                                STOP

: ID. PAD BL ASCII _ FILL DUP N>C 2- OVER -
     PAD SWAP CMOVE PAD COUNT 1F AND TYPE SPACE ;
\ b/drv maxblk drive setu/p empty-buffers (  6  1 94 CRC 10:33 )
DECIMAL
| 360 VARIABLE 'B/DRV           719 VARIABLE 'MAXBLK
| 360 VARIABLE 'B/SIDE          \   359 for 1 drive

CODE MAXBLK VAR: 'MAXBLK  @#L S -[ MOV,  NEXT ;C
CODE B/DRV  VAR: 'B/DRV   @#L S -[ MOV,  NEXT ;C
CODE B/SIDE VAR: 'B/SIDE  @#L S -[ MOV,  NEXT ;C

: DRIVE  B/DRV  U* DROP OFFSET F! ;
HEX
CODE SETU/P          OFUSER 'FIRST DR0 MOV,
  DR0 OFUSER USE MOV,  DR0 OFUSER PREV MOV,  NEXT ;C

: EMPTY-BUFFERS FIRST LIMIT OVER - ERASE SETU/P ;

\ {compile] literal                       ( 30  6 93 CRC 22:54 )
: [COMPILE] -FIND 0= 0 ?ERROR DROP <COMP> ;  IMMEDIATE

: LITERAL   STATE F@ IF  DUP -80 7F WITHIN IF
    FF AND  7000 OR  W,  2700 W,  ELSE
 (  DUP HERE -  -8000 8000 WITHIN IF
      41FA W,  HERE - W,  2708 W,
      ELSE ) 273C W, ,  THEN  THEN ( THEN ) ;
IMMEDIATE







\ dliteral ?stack interpret               ( 31  8 91 CRC 10:24 )
: DLITERAL  STATE F@ IF SWAP [COMPILE] LITERAL
        [COMPILE] LITERAL  THEN ;                   IMMEDIATE

: ?STACK  S0 F@ SP@             U< 1 ?ERROR
                SP@ BOTSTACK F@ U< 7 ?ERROR ;
\ fixed so that tos & bos are user variables for multitasking

: INTERPRET   BEGIN -FIND  IF  ( found) STATE F@ <
    IF  <COMP>  ELSE  EXECUTE  THEN
    ELSE HERE NUMBER  DPL F@ 1+
    IF [COMPILE] DLITERAL ELSE DROP [COMPILE] LITERAL THEN
        THEN ?STACK AGAIN     STOP



\ vocabulary forth definitions (          ( 14  2 92 CRC  9:22 )
: VOCABULARY   CREATE  CURRENT F@ 4+ ,  81A00000  ,
  HERE  VOC-LINK F@ ,  VOC-LINK F!  ;CODE
  RP [+ OFUSER CONTEXT MOV,  NEXT ;C
FIXED   MUTATES *VOCAB*
\  Romable vocabulary !!!!!
CODE FORTH   U HEADPTR &[ AR0 LEA,  AR0 OFUSER CONTEXT MOV,
 NEXT  ;C       IMMEDIATE

CODE DEFINITIONS  OFUSER CONTEXT  OFUSER CURRENT MOV,  NEXT ;C

: (  ASCII ) WORD      ;                             IMMEDIATE
;s        headptr      vnfa       vclnk
  vocs: ptr->head | pseudoname | voc-link


\ compile (quit) (abort)                  ( 26  2 92 CRC 12:59 )
DECIMAL \ patch today's date into (abort). automated version ctl
(DATE)  BLK F@ BLOCK  682 + SWAP CMOVE  UPDATE   HEX

: COMPILE   { 'NF <COMPILE> CFA } LITERAL  <COMP>
  -FIND 0= 0 ?ERROR DROP , ;        IMMEDIATE

: (QUIT)   BLK OFF [COMPILE] [  BEGIN BEGIN
  RP! CR QUERY INTERPRET  STATE F@ 0= UNTIL ."  ok" AGAIN STOP

: (ABORT) SP! DECIMAL CR ." FastForth 3.0 30  3 19 "
  [COMPILE] FORTH  DEFINITIONS  QUIT  STOP

  SETNEW (GETTIME) W, SETOLD    LABEL TIMESTAMP


\ empt startup                            ( 28  9 93 CRC 10:30 )
| -1 VARIABLE EMPT      \ should be a constant when we rom

LABEL  STRTUP   cr ." strtup = " STRTUP 6 U.R

} RP!  SP!              \ install in the iob: the count.
  EMPT F@ IF EMPT OFF EMPTY-BUFFERS THEN
  -F8 +ORIGIN F@ -DUP IF  EXECUTE  THEN \ -1 BADMAP F!
  SETU/P  OFFSET OFF  ABORT {







\ ct->0 getcmd cmdboot                    (  4  8 91 CRC 12:53 )
CODE CT->0      \ addr ---  addr ct | count to next 0
  S [ AR0 MOV,  BEGIN,  AR0 [+ DR0 .B MOV,  EQ UNTIL,
  1 # AR0 SUBQ,  S [ AR0 SUB,  AR0 S -[ MOV,  NEXT ;C

| : GETCMD        \  --- addr ct | return addr & ct of cmd line
  -100 +ORIGIN F@  80 + DUP C@   \  desktop or msh?
  7F - IF  COUNT  ELSE  1+ CT->0  THEN ;

| : CMDBOOT       \  ---  | fetch & execute command line
  { 'NF (QUIT) CFA } LITERAL 'QUIT F!
  GETCMD  DUP IF  CR 2DUP TYPE  SPACE  2DUP + 4 ERASE  2DUP
  TIB F@ SWAP  1+  CMOVE  IN OFF  DROP 1- OFF  INTERPRET
  CTL G EMIT   ELSE  2DROP  THEN  QUIT STOP


\ ff.scr (clf)                            (  9 11 92 CRC 18:40 )
\ : FILE:   CREATE  0 ,  BL FWORD  HERE C@ 2+ ALLOT ?ALIGN
\   DOES> ;               FIXED

0 VARIABLE FF.SCR       TXT ff.scr"  0 HERE 1- C!

CODE (CLF) \ handle --- ec | close file at handle
  S [ DR0 MOV,  DR0 RP -[ .W MOV,
  3E # RP -[ .W MOV,  1 # TRAP,  4 # RP ADDQ,  DR0 S [ MOV,
  NEXT  ;C






\ lseek variables                         ( 13  6 93 CRC 19:13 )
        \ type: 0= from start 1= rel to current  2=from end
CODE LSEEK      \ faddr handle type --- fl |
  RP DR7 MOV,  S [+ DR0 MOV,  DR0 RP -[ .W MOV, \  type
  S [+ DR0 MOV,  DR0 RP -[ .W MOV,              \  handle
  S [ RP -[ MOV,  ( addr)  42 # RP -[ .W MOV,   1 # TRAP,
  DR7 RP MOV,  DR0 S [ MOV,  NEXT  ;C

0 VARIABLE (ATT)

'NF FF.SCR 2+ F@ DUP
        VARIABLE RHANDLE
        VARIABLE WHANDLE



\ openit (opf)                            ( 20 10 92 CRC  9:55 )
CODE (OPF) \ addr --- handle/ec | open file at addr
  'NF (ATT) 2+ F@ *+ RP -[ .W MOV,  S [ RP -[ MOV,
  3D # RP -[ .W MOV,  1 # TRAP,  8 # RP ADDQ,  DR0  S [ MOV,
  NEXT  ;C

: OPENIT
  { 'NF FF.SCR 2+ F@ 5 + } LITERAL  (OPF)
  DUP 0< IF  WARNING OFF ." *Can't find file  "
  { SETNEW CTL G  HERE 2- C! }
  { 'NF FF.SCR 2+ F@ 4+ } LITERAL COUNT TYPE
  ELSE  FF.SCR F!  FF.SCR  DUP RHANDLE F!  WHANDLE F!
  0 RHANDLE F@ F@ 2  LSEEK  0 B/BUF U/  1- 'MAXBLK F!  THEN
  DROP ;


\ rdf wtf                                 ( 13  6 93 CRC 19:44 )
CODE RDF   \ addr count handle --- ct/er | read from addr for
    \ count bytes to file/handle. Return count read or error.
  RP DR7 MOV,  S [+ DR0 MOV,
  S [+ DR1 MOV,  S [ RP -[ MOV, ( addr )  DR1 RP -[ MOV, ( ct)
  DR0 RP -[ .W MOV, ( handle)  3F # RP -[ .W MOV,
  1 # TRAP,  DR7 RP MOV,  DR0  S [ MOV,  NEXT  ;C

CODE WTF   \ addr count handle --- ct/er | read to addr for
    \ count bytes from file/handle. Return count read or error.
  RP DR7 MOV,  S [+ DR0 MOV,
  S [+ DR1 MOV,  S [ RP -[ MOV, ( addr )  DR1 RP -[ MOV, ( ct)
  DR0 RP -[ .W MOV, ( handle)  40 # RP -[ .W MOV,
  1 # TRAP,  DR7 RP MOV,  DR0  S [ MOV,  NEXT  ;C


\ auto-file time update code              (  3  8 93 CRC 20:45 )
CODE FDATE     \ hndl  ---  hndl | set time & date of file
  RP DR7 MOV,  S [ DR3 MOV,             \ save stack, handle
  2A # RP -[ .W MOV,  1 # TRAP,         \ get date
  DR0 S -[ .W MOV,                      \ date stored
  2C # RP -[ .W MOV,  1 # TRAP,         \ get time
  DR0 S -[ .W MOV,                      \ time stored
  1 # RP -[ .W MOV,                     \ flag
  DR3 RP -[ .W MOV,                     \ handle
  S RP -[ MOV,                          \ buffer addr
  57 # RP -[ .W MOV,  1 # TRAP,         \ do it
  4 # S ADDQ,                           \ drop storage space
  DR7 RP MOV,  NEXT  ;C                 \ restore stack



\ Memory setup                            (  1  9 93 CRC 20:51 )
\ do setup for memory here. Return highest addr in dr0
LABEL -SETSTUF-
ASSEMBLER  0 #L DR0 MOV,   -4 ALLOT
 \ this is done to leave the opcode of an #L MOV, in place. If
 \ the user wants to force a given high address, he can  !  it
 \ in over the next opcode, and patch the bsr in  COLD  to
 \ point to this opcode instead of to SETSTUF.

HEX  \ do setup for memory here. Return highest addr in dr0
LABEL SETSTUF     \ forth boot parameters in ar0.
-F4 FBASE + *+ DR0 MOV,        ;S

436 @# DR0 .L MOV,   \  _memtop, top of available memory


\ Memory setup                            (  1  9 93 CRC 20:51 )
    \ enter here with pre-calculated memory size in dr0
  FBASE *+ AR0 LEA,    DR0 DR1 MOV,
  TM   TOS - #L DR1 SUB,        DR1 AR0 1C &[ MOV, \ tos
  TOS  BOT - #L DR1 SUB,        DR1 AR0 84 &[ MOV, \ bos
  BOT  RTS - #L DR1 SUB,        DR1 AR0 20 &[ MOV, \ rts
  RTS TIBX - #L DR1 SUB,        DR1 AR0 24 &[ MOV, \ tib
  US #L DR1 SUB,  DR1 DR2 MOV,  DR1 AR0 18 &[ MOV, \ uarea
    VCLNK #L DR1 ADD,  \ get offset into users of forth vocab
                                DR1 AR0 38 &[ MOV, \ voc-link
  100        #L DR2 SUB,        DR2 AR0 74 &[ MOV, \ limit
  CO         #L DR2 SUB,        DR2 AR0 70 &[ MOV, \ first
  RTS,



















\ setsup                                  (  2  6 86 CRC 10:47 )
LABEL SETSUP
  18 FBASE + *+ U MOV, \ set user area pointer

  FBASE 10 + *+ AR1 LEA,  \ from addr
  U   AR0 MOV, \ to addrs
  AR1 DR2 ADD, \ limit of the move

BEGIN,  AR1 [+ AR0 [+ MOV,  AR1 DR2 .L CMP,  LT UNTIL,
\ move user area stuff out from cold start area

  RTS,  \ execute cold start orphan




\ cold                                    ( 15  7 92 CRC  9:23 )
CODE COLD
LABEL COLDSTART         \ supervisor code moved to loader
 SETSTUF *+ BSR,
 'NF RHANDLE 2+ F@ *+ AR5 LEA, AR5 [ AR0 MOV,  AR0 [ DR0 MOV,
 'NF (CLF) F@ 2+ *+ BSR,        AR5 [ CLR,
 AR5  'NF WHANDLE 2+ F@  'NF RHANDLE 2+ F@ -  &[ CLR,
 COLDS #L DR2 .L MOV,  FALSE IF,    \ forced

LABEL WARM   10 #L DR2 .L MOV,  THEN,
      SETSUP *+ BSR,    STRTUP *+ BRA, ;C       ;S

DR2 contains the number of words moved into the user area; by
the end of the setup it has the address of the last byte moved.
DR0 has the top address in memory placed in it.

\ +buf update +- d+- abs dabs             ( 16  5 86 CRC 15:48 )
CODE +BUF \ bufaddr --- bufaddr' | locate next buffer in ram
  DR1 CLR,  S [ DR0 MOV,  6 *B/BUF* + #L DR0 ADD,
  OFUSER 'LIMIT DR0 CMP,
     EQ IF,  OFUSER 'FIRST DR0 MOV,  THEN,  DR0 S [ MOV,
  OFUSER PREV DR0 CMP,  NE IF,  1 # DR1 ADDQ,  THEN,
  DR1 S -[ MOV,  NEXT   ;C

CODE UPDATE   \  ---  | flag most recent buffer as updated
  OFUSER PREV AR0 MOV,  7 # AR0 [ .B BSET,  NEXT ;C

CODE +-  S [+ TST, MI IF,               S [ NEG,  THEN, NEXT ;C
CODE D+- S [+ TST, MI IF,  4 S &[ NEG,  S [ NEGX, THEN, NEXT ;C

CODE ABS S [  TST, MI IF,  S [ NEG, THEN,               NEXT ;C
: DABS    DUP D+-  ;
\ arithmetic stuff -- min  to */          ( 22  5 86 CRC 16:56 )
CODE MIN  S [+ DR0 MOV,  S [ DR1 MOV,  DR0 DR1 CMP,
  PL IF,  DR0 S [ MOV,  THEN,  NEXT    ;C
CODE MAX  S [+ DR0 MOV,  S [ DR1 MOV,  DR0 DR1 CMP,
  MI IF,  DR0 S [ MOV,  THEN,  NEXT    ;C

: M/      OVER >R >R DABS
              R ABS U/ R> R XOR +- SWAP R> +- SWAP ;
: *       U* DROP ;
: /MOD    >R S->D R> M/ ;
: /       /MOD      NIP  ;
: MOD     /MOD      DROP ;
: */MOD   >R M* R> M/ ;
: */      */MOD NIP ;
: M/MOD   >R 0 R U/ R> SWAP >R U/ R> ;

\ numeric output                          ( 22  2 92 CRC  7:29 )
: SPACES  0 MAX -DUP IF 0 DO SPACE LOOP THEN ;

CODE <#   U OFUSER HLD MOV, NEXT ;C   \ must be moi to use w/
: #>    2DROP HLD F@ MOI   OVER - ; \ wp-forth &/or tasker !!!
: SIGN  ROT 0< IF ASCII - HOLD THEN ;
: #     BASE F@ M/MOD ROT 9 OVER < IF 7 + THEN ASCII 0 + HOLD ;
: #S    BEGIN # 2DUP OR 0= UNTIL ;
: D.R   >R SWAP  OVER  DABS  <#  #S  SIGN #>
        R> OVER  -  SPACES  TYPE ;
: D.    0 D.R SPACE ;
: .R    >R S->D R> D.R ;
: .     S->D D. ;               : ?       @ . ;
: W?    W@ . ;                  : C?      C@ . ;


\ vlist buffer r                          ( 17  2 92 CRC  7:18 )
: VLIST   CR  CONTEXT F@ F@  BEGIN OUT F@ C/L >   IF  CR THEN
     DUP ID. SPACE SPACE N>L  F@
     DUP 0=  ?TERMINAL OR UNTIL   DROP  ;

: BUFFER   USE F@ DUP >R BEGIN +BUF UNTIL  USE F!
  R F@  0< IF  R 4+  R F@  7FFFFFFF AND  0 R/W  THEN
  R F! R PREV F! R> 4+ ;

CODE R  OFUSER STATE TST,  NE IF, 2717 #L S -[ MOV,
  'NF W, CFA *+ BRA,  THEN,  4 RP &[  S -[ MOV,
  NEXT  ;C      IMMEDIATE




\ block (line) .line message load -->     ( 27 10 86 CRC 13:17 )
: BLOCK   PAUSE OFFSET F@ + >R PREV F@ DUP F@ R - DUP +
    IF BEGIN +BUF 0= IF DROP R BUFFER DUP R 1 R/W 4- THEN
       DUP F@ R - DUP + 0= UNTIL DUP PREV F!  THEN RDROP  4+ ;

: (LINE)  >R C/L B/BUF */MOD R>  + BLOCK + C/L ;
: .LINE   (LINE) -TRAILING TYPE ;

: MESSAGE WARNING F@ IF ( we have disk ) -DUP
       IF 1 OFFSET F@ - .LINE THEN ELSE  \ 4 is fig std.
          ." msg # " .  THEN ;

: LOAD  BLK F@ >R  IN F@ >R  IN OFF BLK F!  INTERPRET
        R> IN F!   R> BLK F! ;

: --> ?LOADING IN OFF BLK 1+! ;               IMMEDIATE
\ #bufs flush >r r>                       ( 19  3 92 CRC 10:47 )
: #BUFS  LIMIT FIRST -  { *B/BUF*  6 + } LITERAL  /MOD
     SWAP IF ." Bad buffers!"  EMPT ON COLD  THEN ;

: FLUSH  #BUFS  1+  0 DO 7FFFFFFF BUFFER DROP LOOP ;

CODE >R  OFUSER STATE TST,  NE IF, 2F1B #L S -[ MOV,
  'NF W, CFA *+ BRA,  THEN,  RP [ AR0 MOV,
  S [+ RP [ MOV,  AR0 [ JMP,    ;C     IMMEDIATE

CODE R>  OFUSER STATE TST,  NE IF, 271F #L S -[ MOV,
  'NF W, CFA *+ BRA,  THEN,  RP [+ AR0 MOV,
  RP [+ S -[ MOV,  AR0 [ JMP,   ;C     IMMEDIATE



















\ (r/w)                                   ( 31 12 92 CRC 18:27 )
: (R/W)         \ addr blk# r/w --- | r/w for a file once opened
  OVER MAXBLK > 6 ?ERROR  OVER  0< 6 ?ERROR
  RHANDLE F@ IFL >R  0a 2*s ( B/BUF * )
  R IF  RHANDLE F@ ELSE  WHANDLE F@ THEN  F@ 0 LSEEK
      dup 0< if  10 .r  space then    \  2019 02 07
      0< IF ."  File Seek Error " 0 ERROR THEN
      B/BUF R> IF  RHANDLE F@ F@ RDF
          ELSE  WHANDLE F@ F@  FDATE WTF  THEN
      dup 0< if  10 .r  space then    \  2019 02 07
      B/BUF - IF ."  File Size Overflow "  0 ERROR THEN
    ELSEL ."  File not open!!" 0 ERROR THENL ;




\ ' index list (list)                       25 12 84 CRC
: '   -FIND  0= 0 ?ERROR  DROP  [COMPILE] LITERAL  ; IMMEDIATE

: INDEX   CR  1+  SWAP    DO CR I  5 .R
   SPACE  0  I .LINE  ?TERMINAL  IF  LEAVE  THEN   LOOP ;

: LIST    'LIST @EXECUTE STOP

: (LIST)    DECIMAL
   CR  DUP  SCR F!  ." scr # "   .  10 0
   DO  CR I 3 .R SPACE I SCR F@ .LINE  LOOP CR ;





\ forget, multitasking version            ( 14  2 92 CRC  9:18 )
| : PFUI   TIB OVER U< IF TIB - THEN  ;
| : PFUI2  PFUI >R PFUI R>         U< ;
    \ filtre addresses outside our task.         \ multitasking
| CODE TASKFIX   VCLNK ( forth's voc link) U &[ AR0 LEA,
  S [ AR0 CMP,  LE IF,  AR0 S [ MOV,  THEN,  NEXT      ;C
: (FORGET) \ pfa ---  | can be compiled into definitions
  C>N  DUP FENCE F@ PFUI2 15 ?ERROR
   >R  VOC-LINK F@  TASKFIX         BEGIN
     R OVER PFUI2 WHILE [COMPILE] FORTH  DEFINITIONS
     F@ TASKFIX DUP VOC-LINK F!  REPEAT      BEGIN  PAUSE
        DUP 4- BEGIN N>L F@  TASKFIX  DUP R PFUI2  UNTIL
     OVER 4- N>L F!  F@ TASKFIX -DUP 0= UNTIL   R> N>L DP F! ;
: FORGET   [COMPILE] ' STATE F@ IF COMPILE (FORGET)
                                ELSE (FORGET) THEN ;  IMMEDIATE
;S Make  FORGET  smart enough to compile it!! Very useful!
\ wherenow                                (  3 10 93 CRC 20:47 )
: WHERENOW      ( line start & blk compressed for storage )
  BLK F@  OFFSET F@ +  5 2*s  IN F@  5 2/s  OR ;













\ (create) :                              (  3 10 93 CRC 20:47 )
: (CREATE)     FIRST HERE 0A0 + U< 2 ?ERROR
  ?ALIGN  0 ,  ( see: ) LATEST ,        \ link field
  -FIND IF DROP C>N ID.   4 MESSAGE SPACE THEN
  HERE  DUP C@ WIDTH F@ MIN 1+ =CELLS ALLOT
  DUP C0 TOGGLE HERE 1- 80 TOGGLE
  CURRENT F@ F!                 \ set voc to new name field
  WHERENOW LATEST 8 - F!        \ see: data
  0 W,                          \ len
  { *VARIABLE* F@ } LITERAL <SUB> ;

: :   ?EXEC !CSP  CURRENT F@ CONTEXT F!  CREATE  SMUDGE
  IMMEDIATE  REL ON  LATEST N>C  DP F!  ] ;



\ compiler directives                     ( 24  7 93 CRC 21:34 )
: DO    ?COMP  COMPILE (DO) HERE 3 ;           IMMEDIATE
: LOOP         3 ?PAIRS COMPILE (LOOP)  BACK ; IMMEDIATE
: +LOOP        3 ?PAIRS COMPILE (+LOOP) BACK ; IMMEDIATE

: 0BRAN 201B6700 , \ s [+ dr0 .l mov,  2 *+ eq bcc,
                        HERE  0 W, ;
: BRAN  60000000 ( 2 *+ bra, ) ,  HERE 2- ;
: RESOLVE       HERE OVER -  SWAP  W! ;

: IF    ?COMP  0BRAN 2 ;                        IMMEDIATE
: THEN   HERE LASTTHEN F!
        ?COMP  2 ?PAIRS  RESOLVE ;              IMMEDIATE

: ELSE  2 ?PAIRS  BRAN
        SWAP 2 [COMPILE] THEN  2 ;              IMMEDIATE
\ compiler directives                     (  9 10 91 CRC 12:41 )
: ENDIF [COMPILE]  THEN  ;                      IMMEDIATE
: BEGIN ?COMP HERE 1 ;                          IMMEDIATE

| : SBKWD  10000 /  HERE ROT SWAP - 2-   FF AND OR  W, ;
| : LBKWD           HERE ROT SWAP - 2- FFFF AND OR   , ;
| : BKWD  OVER HERE -  2-  -7F 7F WITHIN
        IF SBKWD ELSE LBKWD THEN ;

: UNTIL 1 ?PAIRS  201B W,  67000000 BKWD ;      IMMEDIATE
: AGAIN 1 ?PAIRS           60000000 BKWD ;      IMMEDIATE
: REPEAT        >R >R [COMPILE] AGAIN R> R> 2-
                [COMPILE] THEN  ;               IMMEDIATE
: WHILE [COMPILE] IF 2+ ;                       IMMEDIATE
: END   [COMPILE]  UNTIL ;                      IMMEDIATE

( good stuff to have in the nucleus       (  2 10 91 CRC 13:28 )
: EXECS   BEGIN -FIND  IF  ( found) STATE F@ <
    IF  ,  ELSE  EXECUTE  THEN
    ELSE  0 ?ERROR  THEN  ?STACK  STATE F@ 0= UNTIL  ;

: EXEC  COMPILE <EXEC>  EXECS ;    IMMEDIATE

: LEN   N>C 2- ;        ( nfa -- lnfa )

: LEN?   2- W? ;        ( cfa  --  | display moveable length )
(
: ?LEN:  [COMPILE] ' LEN? ; ( --  | len of next word in stream)

: SETLEN   LATEST LEN  W! ;

: FIXED    0 SETLEN ;   ( don't copy into new words. )
( good stuff to have in the nucleus       (  2 10 91 CRC 11:27 )
: (RES)         ( addr ---  | resolve bsr/jsr at addr )
  DUP W@  DUP 4EB9 =  SWAP 4EF9 =  OR IF  2+ F@  ELSE \ jsr/jmp
  DUP W@  FF AND IF  DUP 1+ C@  DUP 80 AND            \ bsr s
      IF  FFFFFF00 OR  THEN + 2+  ELSE
  2+ DUP  W@  DUP  8000  AND  IF  FFFF0000 OR  THEN + \ bsr l
                                           THEN   THEN ;

: C>P     ( cfa --- pfa  | find the parameter field )
  DUP W@ 6100 = IF  4+  ELSE  DUP W@ 4EB9 =
  OVER W@ 4EF9 =  OR  IF 6 +  ELSE  2+  THEN THEN ;

| : 6SR LASTSUB F@  W@ 4EB9
            = IF  4EF9  LASTSUB F@ W!  0  ELSE  1  THEN ;

| : DOBSR   = IF    60  LASTSUB F@ C!  0  ELSE  1  THEN ;
\ smart next code                         ( 26  2 92 CRC 12:08 )
| : 2SR LASTSUB F@  W@ FF00 AND 6100  DOBSR ;
| : 4SR LASTSUB F@  W@ 6100           DOBSR ;

        \ --- fl | 1 indicates failure to change bsr to bra, etc
| : LAST?  REL F@ 0=  HERE  LATEST N>C -    LENGTH F@ 1- >  OR
  IF  HERE LASTSUB F@ -
    DUP 2 = IF  DROP 2SR  ELSE    DUP 4 = IF  DROP 4SR  ELSE
        6 = IF  6SR  ELSE  1  THEN  THEN  THEN  ELSE 1 THEN ;

: SETL  REL F@ IF  HERE LATEST N>C  -  SETLEN  THEN  ;

: ;  ?COMP ?CSP    SETL HERE LASTTHEN F@ -
\  a         b             b            b     a              a
  IF  LAST?  IF  4E75 W,  ELSE  FIXED  THEN  ELSE  4E75 W, THEN
  SMUDGE [COMPILE] [ ;   IMMEDIATE
\ version checksum code                   ( 26  2 92 CRC 12:59 )
\ the checksum is the starting address exclusive ored with each
\ byte in the given range. Thus, the same data at different
\ addresses will give a different checksum.

CODE CHX        \ addr ct -- chk | accumulate checksum over area
  S [+ DR1 MOV,  1 # DR1 SUBQ,  S [ AR0 MOV,  AR0 DR0 MOV,
  DR1 FALSE DO,  AR0 [+ DR2 .B MOV,  DR2 DR0 .B EOR,  LOOP,
  DR0 S [ MOV,  NEXT  ;C

: SYSCHK        \  ---  chk | compute partial nucleus checksum
  0 +ORIGIN 7E  CHX
  { 'NF (ABORT) CFA  DUP } LITERAL
  { ASSEMBLER TIMESTAMP SWAP - } LITERAL  CHX  + ;


\ syscheck                                ( 26  9 93 CRC 17:19 )
: SYSCHECK      \ blk# --  fl | verify version of overlay
  BLOCK 2+  DUP  F@  HERE -   SWAP 4+ F@  SYSCHK -  + ;













( improved overlays                       ( 25  8 93 CRC 18:22 )
\ 0 VARIABLE >MEM      ( --> mem to pick up          )
\ 0 VARIABLE +HEAD     ( --> start in first block    )
\ |  D0 USER >MEM                 | D4 USER +HEAD now macros

| CODE HEAD@+   ( ofuser +head) D4 U &[ AR0 LEA,
  AR0 [ S -[ MOV,  4 # AR0 [ ADDQ,  NEXT  ;C

| : ADVANCE   DUP >MEM +!  CMOVE   ASCII . EMIT ;

| : NEWBLK    BUFFER  DUP B/BUF ERASE  UPDATE ;
    ;s
| : CHKORG   0 +ORIGIN - 1D ?ERROR ;
    ;s
| : HEAD@+    +HEAD F@  4 +HEAD +!  ;
| : ADVANCE   DUP >MEM +!  CMOVE   2E EMIT ;
( improved overlays                       ( 25  8 93 CRC 18:23 )
| : GETDICT   ( addr --- | build overlay restoration info )
  2+ +HEAD F!             ( set pointer past raw block flag  )
  [COMPILE] ' C>N N>L 4- DUP  ( starting point               )
    >MEM F!     HEAD@+ F!     ( starting point               )
\ 0 +ORIGIN     HEAD@+ F!     ( origin, for relocating kernel)
  SYSCHK        HEAD@+ F!     ( nucleus checkum              )
  HERE          HEAD@+ F!     ( top of dictionary            )
  CURRENT F@    HEAD@+ F!     ( current vocabulary           )
  CONTEXT F@    HEAD@+ F!     ( context                      )
  VOC-LINK DUP  F@ HEAD@+ F!  ( vocabulary chain start       )
             BEGIN  F@ -DUP   ( vocabulary chain             )
      WHILE  DUP N>L 4- F@ HEAD@+  F! REPEAT
  HEAD@+ OFF ;                ( end of data                  )

: VERCHK  SYSCHK - 1D ?ERROR ;
( improved overlays                       (  4  1 88 crc  8:24 )
| : SETDICT   ( addr ---  | build overlay restoration info     )
  2+ +HEAD F!               ( set pointer past raw block flag  )
  HEAD@+ F@        >MEM F!    ( starting point               )
\ HEAD@+ F@         CHKORG    ( check origin                 )
  HEAD@+ F@         VERCHK    ( nucleus checkum              )
  HEAD@+ F@          DP F!    ( top of dictionary            )
  HEAD@+ F@     CURRENT F!    ( current vocabulary           )
  HEAD@+ F@     CONTEXT F!    ( context                      )
  HEAD@+ F@    VOC-LINK F! ;  ( vocabulary chain start       )

| : SETVOCS   ( addr ---  | install vocabulary link pointers   )
  +HEAD F!                     ( set pointer                  )
  VOC-LINK   BEGIN  F@  -DUP   ( vocabulary chain             )
      WHILE  HEAD@+ F@  OVER 4- N>L F!  REPEAT  ;

( improved overlays                       (  4  1 89 crc  7:42 )
: SAVEOVER  ( blk# ---  | save overlays to blk# from given word)
  DUP NEWBLK  DUP >R  GETDICT    ( dict info stored            )
  >MEM F@  +HEAD F@  B/BUF OVER R> -  -  ( src, dest, ct )
  ADVANCE
  BEGIN  >MEM F@  HERE  U< WHILE
     1+  >MEM F@  OVER NEWBLK 2+
     { B/BUF 2- } LITERAL  ADVANCE  REPEAT
  DROP FLUSH ;







( improved overlays                       (  4  1 88 crc  8:25 )
: BRING     ( blk# ---  | restore overlays from blk#         )
  DUP  BLOCK  DUP SETDICT         ( set dictionary info      )
  +HEAD F@ OVER  - >R             ( offset to voc-link data  )
  +HEAD F@                        ( begin at voc-link data   )
  BEGIN  DUP F@ WHILE 4+ REPEAT 4+ ( skip voclinx for now     )
  OVER - >R  R +  ( src)  >MEM F@  ( dest                     )
     B/BUF R> -  ADVANCE  DUP     ( move first block to mem  )
  BEGIN  >MEM F@  HERE  U< WHILE
     1+  DUP BLOCK 2+  >MEM F@
     { B/BUF 2- } LITERAL  ADVANCE  REPEAT  DROP
  BLOCK R> + SETVOCS ;




\ 68000 : wdump for trials                (  1  9 91 CRC  8:59 )
HEX  : IF.  IF DROP ASCII . THEN ;
: (DUMP) \  from-address-2 cnt-1  ---  | memory displayed
   BOUNDS DO I W@ 0 5 D.R 2 +LOOP ;

: HEAD   CR 9 SPACES 0F AND 10 0  \ start  ---  | header
    DO DUP I + BASE F@ 1- AND 5 .R 2 +LOOP
    DROP ."  <<    ascii   >>" ;
: ASCI  -TRAILING BOUNDS    ( from-addr cnt ASCI)
   DO I C@ 7F AND  DUP ASCII ~ > IF.  DUP BL < IF. EMIT LOOP ;

: DUMP  \ from-addr  count ---  | dump
   OVER  DUP HEAD
   + SWAP   DO CR I 0 9 D.R I 10 2DUP (DUMP) SPACE
   ASCI  I  F0 AND F0 = IF I HEAD THEN
   ?TERMINAL  IF LEAVE  THEN  10 +LOOP CR ;
















































































































































































































































\ aim68k object file format utilities     ( 16  5 86 CRC 16:38 )
HEX 160 USER CHKSUM  164 USER LINECT  CHKSUM 8 ERASE
  \  checksum of line   line count
  \ This format is defined in the AIM 65 User's Guide, pg F-5
  \ to F-7

: ABYTE  0 # # 2DROP ;       : ACELL  0 # # # # 2DROP ;

: BUILDCHK  \  addr cnt  --- | checksum in chksum
  2DUP + CHKSUM F! BOUNDS      DO I TC@ CHKSUM +! LOOP ;

: BUILDBYTES  \ addr cnt --- | string construction
  SWAP 1- SWAP OVER + DO I TC@ ABYTE -1 +LOOP ;
BLK F@ 1+ LOAD


\ aim68k object file format utilities     ( 29  1 86 CRC       )
: ALINE  \ builds a line in the string construction area
         \ addr cnt ---  addr$ cnt$ ready for typing
  2DUP BUILDCHK  <# CHKSUM F@ ACELL  2DUP BUILDBYTES
  SWAP ACELL ( addr) ABYTE ( cnt)
  ASCII ; HOLD 0 0 #> LINECT 1+! ;

: LASTLINE  \  -- addr$ cnt$ | builds last line of file for ty
  <# LINECT F@ 1+ DUP ACELL ( chksum) ACELL ( lines)
  0 ABYTE ASCII ; HOLD 0 0 #> LINECT OFF TYPE CR ;

: LINES    \ addr cnt --    | dump contiguous memory
  BEGIN DUP 18 > WHILE 2DUP 18 MIN DUP >R ALINE TYPE CR
  R> DUP MINUS D+  REPEAT
  -DUP IF ALINE TYPE CR ELSE DROP THEN ;

















































































































\ 68000 : forward refs  1                 (  9  3 92 CRC  9:12 )
SETOLD SETNEW                   HEX
     0A      3 BYTE:IN (CR) C!
   0D        4 BYTE:IN (CR) C!

    0 BYTE:IN VARIABLE         REPLACED:BY CREATE
    4 BYTE:IN VARIABLE         REPLACED:BY ,
    8 BYTE:IN VARIABLE         REPLACED:BY IMMEDIATE
   0C BYTE:IN VARIABLE         REPLACED:BY (;CODE)
   14 BYTE:IN VARIABLE         REPLACED:BY LITERAL

   10 BYTE:IN VARIABLE  *DOES>* F@ 2- OVER DELTA - -
        FFFF AND  61000000 OR SWAP F!

60 14 BYTE:IN VARIABLE C!

\ 68000 : forward refs  2                 ( 18  2 92 CRC  8:54 )
HEX 0 BYTE:IN USER             REPLACED:BY CREATE
    4 BYTE:IN USER             REPLACED:BY W,
    8 BYTE:IN USER             REPLACED:BY IMMEDIATE
   0C BYTE:IN USER             REPLACED:BY (;CODE)

   24 BYTE:IN USER             REPLACED:BY W,
   28 BYTE:IN USER             REPLACED:BY W,
   32 BYTE:IN USER             REPLACED:BY W,







\ 68000 : forward refs  3                 (  5  2 92 CRC  8:36 )
HEX 0 BYTE:IN CONSTANT         REPLACED:BY CREATE
    4 BYTE:IN CONSTANT         REPLACED:BY IMMEDIATE
    8 BYTE:IN CONSTANT         REPLACED:BY ,
   0C BYTE:IN CONSTANT         REPLACED:BY (;CODE)
   18 BYTE:IN CONSTANT         REPLACED:BY LITERAL
60 18 BYTE:IN CONSTANT C!       \ make it a bra.

   10 BYTE:IN CONSTANT  *DOES>* F@ 2- OVER DELTA - -
        FFFF AND  61000000 OR SWAP F!






\ 68000 : forward refs  4                 (  3  3 92 CRC  9:43 )
HEX
    8 BYTE:IN ?ERROR           REPLACED:BY ERROR

   14 BYTE:IN ."               REPLACED:BY WORD
   2E BYTE:IN ."               REPLACED:BY WORD

   0C BYTE:IN WORD             REPLACED:BY BLOCK

   24 BYTE:IN ERROR            REPLACED:BY MESSAGE

80  'NF X CFA  DELTA +  4+  C>N 1+  C!  \ make it null




\ 68000 : forward refs  5                 ( 24 10 91 CRC 19:55 )
ASSEMBLER COLDSTART          2 BOOTPARAMETER
HEX       WARM               8 BOOTPARAMETER      FORTH
LAST F@ DELTA -       10 BOOTPARAMETER          \ 14 = backspace
EM US    -    18 BOOTPARAMETER          \  uarea
ASSEMBLER TOS 1C BOOTPARAMETER          \  TOS
RTS           20 BOOTPARAMETER          \  top of return stack
TIBX                         INITIALISES TIB
1F                           INITIALISES WIDTH
1                            INITIALISES WARNING
;S  fill in boot parameters





\ 68000 : forward refs  6                 (  3  3 92 CRC  9:43 )
DPNEW F@ DELTA -        DUP  INITIALISES FENCE
                             INITIALISES DP
EM US - VCLNK +              INITIALISES VOC-LINK \ for 4th voc
'NF (KEY)       CFA          INITIALISES 'KEY
'NF (EXPECT)    CFA          INITIALISES 'EXPECT
'NF (?TERMINAL) CFA          INITIALISES '?TERMINAL
'NF (EMIT)      CFA          INITIALISES 'EMIT
'NF (TYPE)      CFA          INITIALISES 'TYPE
'NF 2DROP       CFA          INITIALISES 'GOTOXY
'NF (PAGE)      CFA          INITIALISES 'PAGE
'NF (LIST)      CFA          INITIALISES 'LIST
'NF (CR)        CFA          INITIALISES 'CR



\ 68000 : forward refs  7                 ( 24 10 91 CRC 19:55 )
'NF (R/W)       CFA          INITIALISES 'R/W
'NF CMDBOOT     CFA          INITIALISES 'QUIT
'NF (ABORT)     CFA          INITIALISES 'ABORT
'NF (CREATE)    CFA          INITIALISES 'CREATE

TIBX      US - CO - 100 -    INITIALISES 'FIRST
TIBX      US -      100 -    INITIALISES 'LIMIT
4                            INITIALISES LENGTH

0 INITIALISES LASTTHEN
0 INITIALISES LASTSUB
1 INITIALISES REL



\ 68000 : forward refs  8                 ( 11  2 92 CRC 17:43 )
FORTH   \ N.B. placement of voc pseudoheader!
LAST F@ DELTA -       78 BOOTPARAMETER       \  headptr
81A00000              7C BOOTPARAMETER       \  vnfa
0                     80 BOOTPARAMETER       \  vclnk
     \ voc-link points to this guy.
BOT                   INITIALISES BOTSTACK
20002                 INITIALISES I/O   \ Atari special!
\ 'NF HARDDISK CFA ASSEMBLER SAFE 8 + DELTA + ! \ hard disk boot
FORTH  DPNEW F@  IMAGETOP OVER - ERASE
?CR SPEAK F@ IFTRUE  ."  Forward references resolved. "    CR
.HERE  .SIZE  CR  ?0S  IFEND    CR
12 BYTE:IN (ABORT)    COUNT TYPE   CR
WARNING ON  FORTH DEFINITIONS      ;s
\       headptr:4     vnfa:4     vclnk:4
\ vocs: ptr->head | pseudoname | voc-link
\ assemble special loaderfile for tos     ( 12  7 91 CRC 17:57 )
HEX DPNEW F@ COMPILE-ADDR - 2 +OVERHEAD F!
100  0A +OVERHEAD F!
  0  18 +OVERHEAD W!            \ stripped file flag

DPNEW F@  DELTA -   FBASE -  4+         4/
        ASSEMBLER CTDATA DELTA +  F!       FORTH









\ 68000      target compiler: load        ( 14  8 91 CRC 13:38 )
DECIMAL FORTH DEFINITIONS  FORGET TASK \ 480 ' ATARI C>P F!
DECIMAL FORTH DEFINITIONS       : TASK ;   QUIET
EDITOR FLUSH
: RLENGTH  LENGTH ;     RLENGTH F@ >R  16 RLENGTH F!
1 +BLK 2 +BLK THRU  \ 299 LOAD  \ 68K
: RLOAD DUP BLOCK W@
  IF DECIMAL  SPEAK F@ IF  CR DUP  7 .R SPACE  THEN  LOAD
  SPEAK F@ IF .S  THEN  ELSE DROP THEN ;
: RTHRU  1+ SWAP DO I RLOAD LOOP ;
HEX HERE FIRST OVER - ERASE DECIMAL
3 +BLK  31 +BLK RTHRU
CR  FORTH DEFINITIONS   pTODAY  R> RLENGTH F!  ;S

load  628 - 630 after  (loop)  and  (+loop)
have been defined in the target memory
\ Target compiler: set fundamentals       ( 27  6 91 CRC 18:12 )
BASE F@ HEX                     FORTH  DEFINITIONS
200  CONSTANT PREAMBLE          1C CONSTANT OVERHEAD
CREATE COMPILE-ADDR         \ work-space
COMPILE-ADDR  C000 DUP ALLOT  ERASE
HERE  CONSTANT IMAGETOP
\ 190100 PREAMBLE - CONSTANT BASE-ADDR     \ run time origin
   80100 PREAMBLE - CONSTANT BASE-ADDR     \ run time origin
COMPILE-ADDR CONSTANT WORKSPACE
COMPILE-ADDR BASE-ADDR - CONSTANT DELTA         DELTA FUDGE F!
78000 CONSTANT TM             400 CONSTANT   *B/BUF*
    20   *B/BUF*    6     +  *    CONSTANT CO
\ count  b/buf   overhead +  * == count of buffer space
                              200 CONSTANT US
BASE-ADDR PREAMBLE + CONSTANT FBASE

\ Target compiler: target memory          ( 27  1 92 CRC 12:32 )
              \ note the  non-standard memory map!
TM  40  -  CONSTANT TOS
TM 3A0  -  CONSTANT BOT
TM 410  -  CONSTANT RTS
TM 800  -  CONSTANT TIBX
TIBX       CONSTANT EM
1F         CONSTANT CTLMASK
0 VARIABLE CHOPLINE   0 , 0 ,
DELTA 0= IFTRUE  CODE TRIAL  FBASE @#L JMP,  ;C IFEND
BASE  F!
0 VARIABLE DOESWORD
: MUTATES  [COMPILE] '  DUP (RES)
  [ ' COMPILE-ADDR (RES) ] LITERAL
  - IF BELL ABORT" Can't mutate anything but a variable!" THEN
  C>P F! ;
\ Target compiler: compiler addrs         ( 30 10 91 CRC 20:01 )
FORTH  DEFINITIONS
  0 VARIABLE *(.")*             0 VARIABLE *USER*
  0 VARIABLE *DOES>*            0 VARIABLE *<COMPILE>*
  0 VARIABLE *(;CODE)*          0 VARIABLE *CONSTANT*
  0 VARIABLE *VARIABLE*         0 VARIABLE *VOCAB*
  0 VARIABLE *ABORT*            0 VARIABLE *QUIT*
  0 VARIABLE *@EXEC*
  0 VARIABLE *(LOOP)*           0 VARIABLE *(+LOOP)*

\ 0 VARIABLE OPT      \         0 VARIABLE RELS
  4 VARIABLE LENGTH

false constant debugging
\ TRUE  CONSTANT PRIVATE          \ version
\ true  constant files
\ Target compiler: disassembler           ( 23  8 91 CRC 20:33 )
: OPDS  (RES)  DUP  *(LOOP)* F@ =  SWAP  *(+LOOP)* F@ =  OR
  IF  2 IP +!  THEN  ;

: INST  IP F@  DUP 7 U.R  SPACE  DISASSEMBLER (INST)  DUP OPDS
  IP F@ OVER -  43 TAB  2DUP ASCI  54 TAB (WDUMP) ;

: (DIS)   BASE F@ HEX !CSP BEGIN ?STACK  CR  INST
    SP@  CSP F@ - IF .S THEN
    KEY DUP CTL T = IF  RANGE F@  IP F! ."  **" THEN
    LI = UNTIL BASE F! ;

: DISASSEM  DUP RANGE F!  IP F!  (DIS) ;



\ Target compiler: newforth               ( 23  8 91 CRC 20:34 )
VOCABULARY NEWFORTH IMMEDIATE   HEX
: OF/NF [COMPILE] NEWFORTH DEFINITIONS [COMPILE] FORTH ;
 0 VARIABLE DPOLD   COMPILE-ADDR   VARIABLE DPNEW
 0 VARIABLE O/N    \ old/new:  t=new, false=old
  1F  ( 0) VARIABLE TWIDTH   \ target width. 0 = headerless
  1F  ( 0) VARIABLE WID      \ width for a word. use | to make
                             \ an ophan out of it.
  1F       VARIABLE HEAD
: SETOLD   O/N  F@    IF  O/N OFF  HERE DPNEW F!
  DPOLD  F@ DP F!  THEN ;
: SETNEW   O/N  F@ 0= IF  O/N ON   HERE DPOLD F!
  DPNEW  F@ DP F!  THEN ;

DELTA VARIABLE LAST   \ addr of top of new dictionary

\ Target compiler: ?0s                    ( 14  5 86 CRC 16:57 )
: ?0S CR 15 [ BLK F@ ] LITERAL .LINE 80 OUT F! DPNEW F@ DELTA -
  FBASE DO 2 I T@ 0= IF ?CR I 6 U.R 2+ THEN
  ?TERMINAL IF LEAVE THEN  +LOOP  ;
                                                HEX
: TID. PAD BL ASCII _ FILL DUP N>C 2- OVER -
  PAD SWAP CMOVE PAD COUNT 1F AND
  1- 2DUP TYPE  + C@ 7F AND EMIT          SPACE ;
DECIMAL
: .HERE  DPNEW F@ DELTA - 13 [ BLK F@ ] LITERAL .LINE
  10 .R ;
: .SIZE  DPNEW F@ DELTA -  BASE-ADDR - 14 [ BLK F@ ] LITERAL
  .LINE         10  U.R ;                        ;S
       target here =
       target size =
       Addresses of long words containing 0 in them:
\ Target compiler: subroutine /smudged nff( 31  8 91 CRC 10:55 )
HEX     0 VARIABLE <IMMED> C0 ALLOT
<IMMED> HERE OVER - ERASE       <IMMED> 4+ <IMMED> F!
HERE CONSTANT LASTIMMED

: SUBROUTINE    \ addr --  | compile a subroutine to addr
(  HERE OVER DELTA + - FFFF8000  7FFF WITHIN )  ASSEMBLER
  HERE LASTSUB F! ( IF ) REL OFF  DELTA +  *+ BSR,
    (  ELSE  @#L JSR,  THEN ) ;

: /SMUDGE <IMMED> F@ <IMMED> 4+ 2DUP - IF
  DO  I F@  BL TOGGLE  4 +LOOP  ELSE  2DROP  THEN ;

: NFFIND BL WORD HERE DUP COUNT UPPER
  [ ' NEWFORTH C>P ] LITERAL  F@ (FIND) ;

\ Target compiler: 'nf byte:in nfsee:     ( 25  8 91 CRC  8:32 )
HEX
: 'NF  /SMUDGE  NFFIND DUP         \ new does> structure !!!
  IF SWAP DROP THEN      /SMUDGE 0=    \ use 4 + on old vocabs
  IF HERE COUNT TYPE SPACE ." NF?" QUIT THEN ;

: REPLACED:BY  'NF  F@  2- OVER DELTA -  -
  FFFF AND  61000000 OR SWAP F! ;
: BYTE:IN                  'NF F@ DELTA + + ;

: NFSEE:   'NF C>N N>L 4- F@ WHERETHEN  R# F! EDIT ;
: NFDUMP:  BASE F@ HEX   >R DELTA FUDGE F!  'NF F@ DUP
   6 U.R  10 - -10 AND C/L DUMP R> BASE F! ;



\ Target compiler: auto-disk buffer grabbe( 27  1 92 CRC 12:07 )
HEX
CREATE FILEHEADER  HERE OVERHEAD DUP ALLOT ERASE
: +OVERHEAD    FILEHEADER + ;   601A FILEHEADER W!

: SCAN  \ n  ---   | scan image for long word value n.
  DPNEW F@  COMPILE-ADDR
  DO  DUP I @  = IF  I DELTA - 8 .R THEN  ?STACK
     ?TERMINAL IF CR I 8 .R  LEAVE THEN  LOOP  DROP ;

: TRES  \ taddr --- taddr' | resolution of call at taddr
  DELTA + (RES) DELTA - ;
        \ tcfa ---  | copy in line or bsr to word at cfa
: SCARF   DUP DELTA + 2- W@  -DUP IF  LENGTH F@ 1+
          < IF  DELTA +  HERE  OVER 2- W@  DUP ALLOT  CMOVE
          ELSE  SUBROUTINE  THEN   ELSE SUBROUTINE THEN  ;
\ Target compiler: auto-disk buffer grabbe( 11  2 92 CRC 11:30 )
: <NFCOMPILE>   ?COMP R> DUP 4+ >R  F@
  O/N F@ IF  SCARF  ELSE  <COMP>  THEN ;

: TVLIST  CR BASE F@ >R  [ ' NEWFORTH C>P ] LITERAL  F@
  BEGIN  ?STACK   DUP TID.  3 SPACES  ?CR
  N>L F@ DUP 0=      \ is host link = 0 ?
  ?TERMINAL OR    UNTIL  DROP  R> BASE F! ;

: NFDIS:   DELTA FUDGE F!  'NF F@ DISASSEM ;
ASSEMBLER DEFINITIONS           BASE F@ HEX
: IFL,    IF, 0 LAY DROP 2+ 12 ;
: ELSEL,  ?EXEC 12 ?PAIRS 6000 ~ LAY  0 LAY
          HERE OVER - SWAP W!  HERE 2-  12 ;
: THENL,  ?EXEC 12 ?PAIRS HERE OVER - SWAP W! ~  SETLAST  ;
FORTH DEFINITIONS               BASE F!
\ Target compiler: create-old             ( 14  2 92 CRC 16:47 )
: NFCOMPILE   [ ' <NFCOMPILE> ] LITERAL <COMP>
  'NF F@ ,  ;        IMMEDIATE

HEX
: CREATE-OLD SETOLD FIRST ( TAREA ) PAD - 0< 2 ?ERROR
  [COMPILE] NEWFORTH DEFINITIONS
  ?ALIGN  0 ,  LATEST , HERE CURRENT F@ F!
  BL WORD HERE DUP  DUP C@ WIDTH F@ MIN 1+ =CELLS ALLOT
  SPEAK F@ IF  DUP COUNT TYPE SPACE  THEN
  80 TOGGLE HERE 1- 80 TOGGLE
  WHERENOW  SWAP N>L l>s F! \  installs scr & line #s
  0 W, ;        \ length field



\ Target compiler: create-new             (  3 10 93 CRC 20:43 )
HEX
: CREATE-NEW  SETNEW  ?ALIGN
  IMAGETOP DPNEW F@ [ PAD HERE - C/L + ] LITERAL - - 0< 2 ?ERROR
  ( ?-BUF)  WID F@ IF   \ if not headerless, make header
    0 ,                                         \ see: data
    LAST F@ DELTA - ,  HERE LAST F!             \ voc chain link
    BL WORD HERE DUP C@ TWIDTH F@ 1F AND MIN 1+ =CELLS ALLOT
        80 TOGGLE  HERE 1- 80 TOGGLE            \ assert bits 7
    0 W,  WHERENOW  LAST F@ 4- 4- F!  THEN      \ compile field
  SPEAK F@ IF  OUT F@ 30 >  IF CR 6 SPACES THEN
  BASE F@ HEX HERE DELTA - 5 U.R SPACE  BASE F! THEN  \ show add
  WID F@ HEAD F!                                \ header here ?
  TWIDTH F@ WID F! ;            ;S              \ permanent widt


\ initialises, bootparameter, smart ; setu(  5  2 92 CRC  8:08 )
: BOOTPARAMETER  FBASE +  DELTA +  F! ;
HEX
: INITIALISES  'NF \ F@ DELTA + \ warning: code dependent on
 0E + F@  10 + BOOTPARAMETER ; \  definition of  user

: 6SR LASTSUB F@  W@ 4EB9
          = IF  4EF9  LASTSUB F@ W!  0 ELSE  1  THEN ;
: 2SR LASTSUB F@  W@ FF00 AND 6100
          = IF  60 LASTSUB F@  C!  0  ELSE  1  THEN ;
: 4SR LASTSUB F@  W@ 6100
          = IF  60 LASTSUB F@  C!  0  ELSE  1  THEN ;
: LAST?  HERE LASTSUB F@ -
  DUP 2 = IF  DROP 2SR  ELSE    DUP 4 = IF  DROP 4SR  ELSE
      6 = IF  6SR  ELSE         1  THEN  THEN  THEN ;

\ Target compiler: nf: nf; ascii txt      ( 27  1 92 CRC 12:23 )
: NF: !CSP CREATE-OLD SMUDGE
  IMMEDIATE [COMPILE] FORTH ] ;

: NF; [COMPILE] ; ;       IMMEDIATE

: TXT ASCII " WORD  HERE C@ 1+ =CELLS ALLOT ( ?-BUF)  ;
   IMMEDIATE

: |  ?CR  WID OFF SPEAK F@ IF  ." <orphan> " THEN ;

: mf  CR mf BASE F@ HEX
  IMAGETOP DPNEW F@ - . ." Target bytes left. " BASE F! ;

: OFDUMP:   BASE F@ HEX   >R FUDGE OFF [COMPILE] ' DUP
   6 U.R  16 - -16 AND C/L DUMP R> BASE F! ;
\ Target/resident literal                 (  1  7 93 CRC 10:32 )
HEX     \ n # dr0 movq,  dr0 s -[ mov,     @#l s -[ mov,
: <LIT>   DUP  -80  7F WITHIN  IF
  FF AND 7000 OR W,  2700 W,  ELSE
( DUP DELTA + HERE -  -8000 8000 WITHIN IF  REL OFF  41FA W,
  SPEAK F@ IF CR  ." *+ variable "  THEN
  \ *+ ar0 lea,  ar0 s -[ mov,       @#l s -[ mov,
  DELTA + HERE - W,  2708 W,  ELSE ) 273C W, ,  THEN ( THEN ) ;
: LITERAL  STATE F@ IF
   O/N F@  IF DPL F@ 1+ IF
             SWAP  <LIT>   <LIT>         \ 64 bit target literal
             ELSE DROP  <LIT> THEN  ELSE \ 32 bit target literal
      DPL F@ 1+ IF        \ resident literal, any size
      [COMPILE] DLITERAL ELSE  [COMPILE] LITERAL
      THEN   THEN         \ interpretive literal
   ELSE DPL F@  1+ 0= IF DROP THEN  THEN  ;     IMMEDIATE
( optimizers: unary                       (  1  7 93 CRC 10:17 )
HEX
: UNARY  IN F@  CREATE-OLD  61000000 ,   SMUDGE  IN F!
  NFFIND  IF  DROP  F@ ,  ELSE  0 ERROR  THEN
  W, W, W, W,  SMUDGE  SETNEW  [COMPILE] FORTH
  DOES> SETNEW HERE OPT F@ -            \ not following a begin?
      IF  HERE 6 - W@  273C =           \ following a literal?
        IF  4 OPGET  HERE 6 - W!        \ yyy ** @#l xxx,
        ELSE  HERE 2- W@  2708 =        \ ar0 s -[ mov, eg user
          IF  -2 ALLOT  HERE 4- W@  41EE = \ user variable?
            IF  6 OPGET  HERE 4- W!     \ yyy u ** &[ xxx,
            ELSE  HERE 4- W@  41FA =    ( pc *+ variable?      )
              OVER 0A OPGET 273A =  AND ( f@ only!)
                IF 0A OPGET HERE 4- W! rel off ( a *+ s -[ mov )
              ELSE 8 OPGET W, THEN      \ yyy ar0 [ xxx,
            THEN        [
( optimizers: unary                       ( 30  8 93 CRC 20:13 )
HEX
]         ELSE  HERE 4- W@ 272E =       \ user f@ optimize
            IF  206E  HERE 4- W!  8 OPGET  W,
            ELSE  HERE 6 - W@  2739 =   \ literal f@ optimize
              IF  2079 HERE 6 - W!     8 OPGET W,
              ELSE    F@ SCARF       THEN  THEN  THEN  THEN
      ELSE  F@ SCARF       THEN     \ following br resolution
    ;

: BINARY  IN F@  CREATE-OLD  61000000 ,  SMUDGE  IN F!
  NFFIND  IF  DROP  F@ ,  ELSE  0 ERROR  THEN
  W, W,     SMUDGE  SETNEW  [COMPILE] FORTH
  DOES>  SETNEW  [                    ;s  only if compiling...


\ binary defining word                    ( 30  8 93 CRC 20:13 )
HEX     WARNING ON
]   HERE OPT F@ -                       \ not following a begin?
      IF  HERE 4- C@  70 =              \ byte literal?
        IF  HERE 4- E TOGGLE            \ xx # dr7 moveq,
          -2 ALLOT  4 OPGET W,          \ dr7 s [ xxx,
        ELSE  HERE 6 - W@ 273C =        \ large literal?
          IF  6 OPGET  HERE 6 - W!      \ yy #l s [ xxx,
          ELSE  HERE 4- W@  272E =      \ user f@ ??
            IF  HERE 4- 9 TOGGLE  4 OPGET W,  \ ofuser s [ add
            ELSE  HERE 6 - W@  2739 =   \ literal f@ ??
              IF  HERE 6 - 9 TOGGLE  4 OPGET W, \ lit dr7 mov,
              ELSE    F@ SCARF       THEN  THEN  THEN  THEN
      ELSE  F@ SCARF       THEN  ;  \ following br resolution

: ?FLAGS ?CR LATEST C? ;
\ Target compiler: literal -- interpret   ( 20  2 92 CRC  9:35 )
HEX
: IMMEDIATE   LAST F@ C/L TOGGLE   LATEST
  <IMMED> F@ F!  4 <IMMED> +!  SMUDGE
  <IMMED> F@ LASTIMMED = IF ABORT" Out of Immediate table space"
       THEN ;

: INTERPRET   BEGIN -FIND  IF  ( found) STATE F@ <
    IF  O/N F@  IF  F@ SCARF  ELSE  <COMP>  THEN
      ELSE  EXECUTE THEN
    ELSE HERE NUMBER [COMPILE] LITERAL  THEN   \    cr .s
        ?TERMINAL IF IN F@ R# F! BLK F@ SCR F! ABORT THEN
  ?STACK  AGAIN  STOP

: CNVT ( file offset -> addr )  OVERHEAD -  PREAMBLE -
  FBASE +  HEX ;
\ Target compiler: quit -- label          ( 13  5 86 CRC 14:51 )
: NFQUIT BLK OFF [COMPILE] [
     BEGIN BEGIN RP! CR QUERY INTERPRET OK STATE F@ 0= UNTIL
        .S ." NK"       AGAIN STOP
: LOAD  DUP BLOCK  W@ IF
  BASE F@ >R  SPEAK F@ IF  DECIMAL DUP CR 5 U.R SPACE  THEN
  HEX  BLK 2@ >R >R  C/L IN F! BLK F! INTERPRET
  R> R> BLK 2!  SPEAK F@ IF  ?CR 3 SPACES HEX .S  THEN
  R> BASE F!  ELSE DROP THEN  ;
: THRU  1+ SWAP DO I LOAD LOOP ;
: CFA  F@ ;
: ==       ?EXEC SETOLD CURRENT F@ >R
     [COMPILE] ASSEMBLER DEFINITIONS CONSTANT
     R> CURRENT F! [COMPILE] FORTH SETNEW ;
: LABEL SETOLD DPNEW F@ DELTA - ==
     [COMPILE] ASSEMBLER ;
\ Target compiler: code -- constant       ( 27  1 92 CRC 12:30 )
HEX
: CODE  !CSP  IN F@ ?EXEC  CREATE-NEW  REL ON
  IN F!  HERE DELTA -  CREATE-OLD ,  SMUDGE  SETNEW
  [COMPILE] ASSEMBLER  ASSEMBLER ~ ;

: CONSTANT   WID F@  IN F@  CREATE-NEW  IN F!
  IF  LAST F@ C/L TOGGLE  THEN
  *CONSTANT* F@ SUBROUTINE  HERE DELTA -  SWAP DUP ,
  NF:  [COMPILE] LITERAL   COMPILE <LIT>
  4 CSP +!  [COMPILE] NF;  ,
  ?STACK  SETNEW [COMPILE] FORTH ;




\ Target compiler: variable               (  9  3 92 CRC  9:21 )
HEX
: VARIABLE  WID F@ IN F@  CREATE-NEW  IN F!
  IF  LAST F@ C/L TOGGLE  THEN
  *VARIABLE* F@ SUBROUTINE  HERE DELTA -  SWAP  ,
  NF:  [COMPILE] LITERAL   COMPILE <LIT>
  4 CSP +!  [COMPILE] NF;
  ?STACK  SETNEW [COMPILE] FORTH ;

: VAR:          \  --- addr | returns target variable address
  'NF 2+ F@ ;





\ Target compiler: vocabulary -- user  68K(  7  9 91 CRC 15:42 )
HEX
\ : VOCABULARY IN F@ CREATE-NEW
\     IN F! HERE DELTA -  *VOCAB* F@ ,  A081 W,
\     LAST F@ DELTA - , 0 ,    \ new does>   !!
\     CREATE-OLD , SETNEW [COMPILE] FORTH ;

: USER     WID F@  IN F@  CREATE-NEW  IN F!
  IF  LAST F@ C/L TOGGLE  THEN
  *USER* F@ SUBROUTINE  DUP  W,
  NF:   41EE [COMPILE] LITERAL   COMPILE W,
        273C W,  ,  COMPILE W,  \ lit the hard way, so ofuser
        2708 [COMPILE] LITERAL   COMPILE W,     \ will work
     4 CSP +!    [COMPILE] NF;
  ?STACK  SETNEW [COMPILE] FORTH ;

\ assembler extensions for target compiler( 30 10 91 CRC 20:04 )
ASSEMBLER DEFINITIONS           HEX
: OFUSER  \  --  | assemble an access to a user: u off &[
  U 'NF  DUP 2+ F@  41EE - 0F ?ERROR    \ q&d test.
  0E + F@ &[ ;   \ def of user dependant!

: *+  DELTA + *+  REL OFF ;
: W     BELL ABORT"  'W' usage!!"  ;
: IP    BELL ABORT"  'IP' usage!!"  ;
FORTH DEFINITIONS

: +LOAD  +BLK LOAD ;

: +THRU  1+ SWAP DO I +LOAD LOOP ;


\ Target compiler: assembler extensions   ( 11 11 91 CRC 15:24 )
\ : LEN   N>C 2- ;        \ nfa -- lnfa

: SETLEN   LAST F@ LEN  W! ;

: ?LEN:   'NF F@ DELTA +  LEN? ;      \  --  |

: FIXED    0 SETLEN ;   \ don't copy into new words.

ASSEMBLER DEFINITIONS
: ;C ?EXEC ?CSP SMUDGE [COMPILE] FORTH  HEAD F@  REL F@  AND
      IF HERE  LAST F@ N>C - 2-  SETLEN THEN ;

: NEXT   RTS, ;         FORTH DEFINITIONS


\ chop target compiler                    ( 11 12 86 CRC 17:16 )
: GOLDEN  \ -- | saves data to chop xcompiler
  [ ' NEWFORTH  C>P ] LITERAL F@ CHOPLINE    F!
  [ ' ASSEMBLER C>P ] LITERAL F@ CHOPLINE 4+ F!
  HERE                           CHOPLINE 8 + F! ;

: CHOP   [COMPILE] FORTH DEFINITIONS   EDITOR FLUSH
  CHOPLINE 8 + F@ DP F!  DELTA FUDGE F!
  WORKSPACE IMAGETOP OVER - ERASE    ASSEMBLER ~ FORTH
  SETNEW  COMPILE-ADDR DP F!  SETOLD SETNEW  DELTA LAST F!
  <IMMED> 4+ <IMMED> F!
  CHOPLINE F@    [ ' NEWFORTH  C>P ] LITERAL F!
  CHOPLINE 4+ F@ [ ' ASSEMBLER C>P ] LITERAL F!  ;    ;S
WARNING:  no additions to any voc save  NEWFORTH  and  ASSEMBLER
after  GOLDEN  is invoked!!!!!!!!!!!!!!!

\ Target compiler: user -- vocabulary  68k( 24  8 91 CRC 16:21 )
HEX
: WHO DELTA + C>N ID. ;

: :     !CSP IN F@ ?EXEC CREATE-NEW
  IN F! HERE DELTA - CREATE-OLD , SMUDGE SETNEW
  REL ON  ]  ASSEMBLER ~ ;

NF: OF/NF [COMPILE] NEWFORTH DEFINITIONS [COMPILE] FORTH  NF;
\ ' NFQUIT 4- ' 'NF 40 + F! patch to use nfquit.
LATEST N>L OFF





\ Target compiler: nf: x -- [compile]     ( 14  8 91 CRC 14:22 )
HEX
NF: X BLK F@    IF ?EXEC THEN R> DROP NF;
80 LATEST 1+ C!                     \ rename it "null"

NF: \ [COMPILE] \ NF;

NF: GAP   0 ,  REL OFF NF;

NF: COMPILE  ?COMP   *<COMPILE>* F@ SUBROUTINE
    'NF CFA , NF;

NF: [COMPILE]  'NF F@ SUBROUTINE  NF;



\ Target compiler: nf: ;code -- ."        ( 22  8 91 CRC 16:38 )
HEX
NF: ;CODE       *(;CODE)* F@  SUBROUTINE
     HERE DELTA -  -4  CSP +!    \ adjust csp
     [COMPILE] ASSEMBLER   [COMPILE] [  NF;
\  HERE  is left on the stack. The programmer MUST manually
\ insert it into the proper *xxxxx* variable
\ e.g. : fred .... ;code ... next  mutates *fred*

NF: DOES>  *(;CODE)* F@ SUBROUTINE  HERE DELTA -  -4 CSP +!
  REL ON  DOESWORD ON
  *DOES>* F@ SUBROUTINE  NF;   \ in *xxx* variable

NF: ."  *(.")* F@ SUBROUTINE  [COMPILE] TXT  NF;


\ Target compiler: {         -- }         ( 16  1 87 CRC 18:59 )
NF: {  SETOLD   [COMPILE] FORTH     [COMPILE] [ NF;

NF: }  SETNEW ] [COMPILE] NEWFORTH              NF;

NF: ( [COMPILE] ( NF;

NF: FORTH                      NF;

NF: LITERAL              <LIT> NF;

NF: SEE:        SEE: NF;

NF: WHERE    OF/NF [COMPILE] WHERE   NF;


\ Target compiler: >r r> where            ( 23  4 92 CRC  8:51 )
HEX
NF: >R     2F1B W,  NF;         \ s [+ rp -[ mov,

NF: R>     271F W,  NF;         \ rp [+ s -[ mov,

NF: R      2717 W,  NF;         \ rp [ s -[ mov,

NF: RDROP  588F W,  NF;         \ 4 # rp addq,

NF: MOI  270E W,  NF;           \ headerless user variables
NF: S0     41EE000C ,  2708 W,  NF;
NF: >MEM   41EE00D0 ,  2708 W,  NF;     \ for the overlay
NF: +HEAD  41EE00D4 ,  2708 W,  NF;     \ code.

DECIMAL                                     GOLDEN
















































































































































































































\ Target compiler: ;                      ( 27 10 91 CRC 16:20 )
NF: ;  ?COMP ?CSP   HERE LASTTHEN F@ -
  IF  LAST?  IF  ASSEMBLER RTS,  FORTH  THEN
     ELSE  ASSEMBLER RTS, FORTH  THEN
  REL F@  DOESWORD F@ 0=  AND
         IF  HERE 2-  LAST F@ N>C  -  SETLEN  THEN
\       ." Relocatable : " CR BELL RELS 1+!  THEN
  SMUDGE [COMPILE] FORTH [COMPILE] [
  DOESWORD OFF                        NF;







\ Target compiler: nf: if -- while        ( 20 10 92 CRC  9:58 )
NF: IF          [COMPILE] [ ASSEMBLER ~  S [+ DR0 MOV,
                        NE IF, ] NF;
NF: THEN        HERE LASTTHEN F!        HERE OPT F!
                [COMPILE] [ ASSEMBLER ~  THEN, ] NF;
NF: DO          NFCOMPILE (DO)    HERE      NF;
NF: LOOP        NFCOMPILE (LOOP)  HERE - W, NF;
NF: +LOOP       NFCOMPILE (+LOOP) HERE - W, NF;
NF: BEGIN       HERE OPT F!
          [COMPILE] [ ASSEMBLER ~  BEGIN, ] NF;
NF: WHILE       [COMPILE] [ ASSEMBLER ~  S [+ DR0 MOV,
                        NE WHILE,  ] NF;
NF: UNTIL       [COMPILE] [ ASSEMBLER ~  S [+ DR0 MOV,
                        NE UNTIL,  ] NF;
NF: AGAIN       [COMPILE] [ ASSEMBLER ~  AGAIN,  ] NF;
NF: REPEAT      [COMPILE] [ ASSEMBLER ~  REPEAT, ] NF;
\ Target compiler: again  -- stop         ( 20 10 92 CRC  9:58 )
NF: ELSE        HERE LASTTHEN F!        HERE OPT F!
                [COMPILE] [ ASSEMBLER ~  ELSE,   ] NF;

NF: ASCII   BL WORD  HERE 1+ C@  0 [COMPILE] LITERAL NF;
NF: CTL     BL WORD  HERE 1+ C@  CTLMASK AND  0
                                 [COMPILE] LITERAL  NF;

NF: STOP    SMUDGE [COMPILE] FORTH [COMPILE] [ SETOLD NF;

NF: IFL         [COMPILE] [ ASSEMBLER ~  S [+ DR0 MOV,
                        NE IFL, ] NF;
NF: THENL       HERE LASTTHEN F!  HERE OPT F!
          [COMPILE] [ ASSEMBLER THENL, ] NF;
NF: ELSEL       HERE LASTTHEN F!  HERE OPT F!
          [COMPILE] [ ASSEMBLER ELSEL, ] NF;
































\ optimizers for : defs                   (  1  7 93 CRC 10:17 )
BASE F@ HEX
\ opget    0a   8    6     4
             0 5290 52AE  52B9  UNARY 1+!
             0 4290 42AE  42B9  UNARY OFF
             0 209B 2D5B  23DB  UNARY F!
          273A 2710 272E  2739  UNARY F@

\             l.w. lit  byte lit
                 693   DF93    BINARY +
                 493   9F93    BINARY -
                  93   8F93    BINARY OR
                 293   CF93    BINARY AND
                 A93   BF93    BINARY XOR
                BASE F!

















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































