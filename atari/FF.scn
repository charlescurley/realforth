**********************  fastForth  MODEL  **********************
*                                                              *
*                             by                               *
*                                                              *
*                        Charles Curley                        *
*                        P. O. Box 845                         *
*                    Thermopolis, WY 82443                     *
*                                                              *
*                                                              *
*                          RELEASE 3                           *
*         Fast JSR/BSR threaded Forth for the MC 680x0         *
*                                                              *
*                                                              *
*               Distributed by Charles Curley for              *
*              Atari ST and other 680x0 computers              *
*****  Further distribution must include the above notice. *****
     ERROR MESSAGES                         06 12 84 CRC
 Empty Stack
 Dictionary Full
 Has Wrong Addressing Mode
Isn't Unique
 Branch out of Range
 Disk Range ?
 Full Stack
 Disk Error !!!
Kilobytes of Dictionary space available.
 Not a valid database flag!
  Array out of room!
  This can't happen!! msg   12
Personal Data Base C. Curley       Confidential         16 11 95
     ?? Not in dictionary ??
fastForth on Atari ST              (c) 1985-96 by Charles Curley
     ERROR MESSAGES                       ( 28  7 18 CRC 10:32 )
 Compilation Only, Use in definitions
 Execution only
 Conditionals not paired
 Definitions not finished
 In protected dictonary
 Use only when loading
 Off Current Screen
 Declare Vocabulary
 Database full.
 Centronics Interface Printer Failure!!
 Steem: "Pause" button to recover mouse
 Steem: "Page Up" is help; "Page Down" is undo.
 Overlay invalid. Overlay is for a different nucleus.
  This can't happen!! msg   30
  This can't happen!! msg   31
( LOAD SCREEN -- serial -- Pre-compiled   ( 28  7 18 CRC 10:40 )
( ."  Please do a  9 LOAD  first!!" ABORT for new users        )
DECIMAL
  321 CONSTANT UTILITIES        6 LENGTH F!     UTILITIES BRING
  R# F@ ABS B/BUF MIN R# F!   PRINTER 1 RSCONF  WRAP  CURSOR
  ' (PQUIT) 'QUIT F!  CR  mf CR         LNCTR OFF
  ' (ERL) 'ERL F!   ' (BOT) 'BOT F!  ' (OK) 'OK F!
  ' NEWCREATE 'CREATE F! OK  PAD C/L 1+ BLANKS  TKEY
  EDITOR  BUILDSTAMP  ' (Q) 'Q F!  PROGRAMMER crc
  ENDER OFF     PLACEF OFF      TEMPUS OFF      CLEAR$S
  SCR F@ ABS MAXBLK MIN SCR F!  ' BLEU C>P GETPAL
  ' P?T '?TERMINAL F!   ' LNED 'EXPECT F!
  ' TASK C>N FENCE F!
  PTODAY  CR 15 MESSAGE CR \ 27 message cr 28 message cr \ steem
  ." F12 for Hatari controls." cr
  CLR.EOP quit
  real-FORTH decompiler: messages         ( 29  5 86 CRC 15:50 )
     Inline literal, value        = D
     Compiled inline string: "
in-line cfa = $
     User variable, current value = D
     Variable, current value      = D
     Constant = D
     Branch on 0 to:
     Unconditional branch to:
     Loop back to:
     +Loop back to:
     ?? Not in dictionary ??
 >>  Immediate  <<
  Disassembled:
  <primitive>
     (of) to:
\ 68000 assem: message screen!!!          ( 22  5 86 CRC 18:12 )
 Too many operands??
 Wrong argument count!
 Something too large here!!
 #L requires .L !!
 # requires .W !!
 No byte ops on addr regsisters!
 Has Wrong Addressing Mode
 Can't use byte!
 Byte only!
 Word only!
 Long only!
 Branch out of Range
 Data Register only
 PC Relative out of range!
 >> NOT a User Variable <<
\ reserved for more messages.             (  7 11 94 CRC 10:53 )
  This can't happen!! msg   81
  This can't happen!! msg   82
  This can't happen!! msg   83
  This can't happen!! msg   84
  This can't happen!! msg   85
  This can't happen!! msg   86
  This can't happen!! msg   87
  This can't happen!! msg   88
  This can't happen!! msg   89
  This can't happen!! msg   90
  This can't happen!! msg   91
  This can't happen!! msg   92
  This can't happen!! msg   93
  This can't happen!! msg   94
  This can't happen!! msg   95
\ reserved for more messages.             (  7 11 94 CRC 10:53 )
  This can't happen!! msg   97
  This can't happen!! msg   98
  This can't happen!! msg   99
  This can't happen!! msg  100
  This can't happen!! msg  101
  This can't happen!! msg  102
  This can't happen!! msg  103
  This can't happen!! msg  104
  This can't happen!! msg  105
  This can't happen!! msg  106
  This can't happen!! msg  107
  This can't happen!! msg  108
  This can't happen!! msg  109
  This can't happen!! msg  110
  This can't happen!! msg  111
\ reserved for more messages.             (  7 10 93 CRC 21:41 )















( LOAD SCREEN -- serial -- Recompiling    (  6 11 93 CRC 20:58 )
DECIMAL
  12 LOAD ( misc )       441 load ( atexit )      56 LOAD \ ctl
  24 LOAD ( case)        270 LOAD ( assem)        63 LOAD \ 2@
  13 LOAD ( wait) 18 LOAD ( vtab, ?crt )  20 LOAD \ nlist, l
  44 LOAD ( crt)  25 LOAD ( cursor )  CR  22 LOAD \ <cmove
 138 LOAD ( time)        630 LOAD ( ed)  128 LOAD \ see:
 368 LOAD ( p?t)  64 LOAD ( pntr) 17 LOAD  6 LENGTH F!
  57 62 THRU     130 LOAD \ keys
 300 LOAD ( disassem)    120 LOAD ( un:)  50 LOAD \ loaders
 191 LOAD ( try)  96 LOAD ( cal)  ( 27 LOAD )  35 LOAD
 104 LOAD ( present)      21 LOAD (  cx) 501 LOAD  \ lned
: ?DICT  FIRST HERE - 1024 / U.  9 MESSAGE  SPACE ;
' TASK C>N N>L L>S FENCE F!     UTILITIES SAVEOVER LI
CR 15 MESSAGE  CR MF CR         HERE FIRST OVER - ERASE
LNCTR OFF  EDITOR  PROGRAMMER crc PTODAY CR  CLR.EOP
\ editor help screen                      ( 14 12 18 crc  0:35 )
f1 - blanks left        f2 - merge up     f3 - blanks right
f4 - upper case left    f5 - upper right  f9 - home cursor
f6 - help               f7 - place date
ctl a - back up by len in pad   ctl d - delete current line
ctl e - erase current line      ctl j - insert contents of pad
ctl r - replace current line    ctl s - add a line at cursor
ctl z - hold current line       ctl c - del by length at pad
ctl k - stamp screen            ctl u - next line
ctl b - back up a screen        ctl n - forward a screen
ctl q - push a $ from scr       ctl l - copy to $ stack
ctl w - insert from $ stack     ctl p - overwrite to scr from $s
ctl y - clear $ stack           ctl o - "other" screen
Backsp - del to left of cursor  delete - del to right of cursor
Undo - abort this session       Insert - toggle placing mode
               <<Any key returns to editor!>>
\ q & d checksum routine                  (  7  4 86 CRC 16:00 )
CODE (CHECK) \ addr ct --- w | calculate checksum
 S [+ DR0 MOV,  S [ AR0 MOV,  DR1 CLR,  DR2 CLR,
 BEGIN,  AR0 [+ DR1 .B MOV,  DR1 DR2 ADD,  1 # DR0 SUBQ,
     EQ UNTIL,  DR2 S [ MOV,  NEXT

: CHECKDICT   0 +ORIGIN HERE OVER - (CHECK) . ;

: CHECKSCR    SCR F@ BLOCK B/BUF    (CHECK) . ;

CR ." Use a user variable to store the checksum!" CR





( util overlays misc. definitions         ( 21  5 92 CRC 10:15 )
   321 CONSTANT UTILITIES           27 CONSTANT LI
585 LOAD ( macros )
HEX
: \ ?LOADING  IN F@ C/L + -40 AND  IN F! ; IMMEDIATE

: THRU  1+ SWAP DO I LOAD LOOP ;

: | ;
                                \ rts,
: RDROP  STATE F@ IF  588F W,  [ 4E75 W, ] THEN
  \ rp [+ ar0 mov,  4 # rp addq,  ar0 [ jmp,
  [    205F W,       588F W,      4ED0 W,  SMUDGE  IMMEDIATE

SCR F@ ABS MAXBLK MIN SCR F!   DECIMAL

\ Multiuser hooks: very dangerous!        (  5 11 92 CRC 17:51 )
CODE MOI U S -[ MOV, NEXT ;C      8 USER MYLINK
BASE F@ HEX     MOI ON           D0 USER TEMPUS
CODE WAIT \  ct ---  | wait ct 200 hz cycles - atari specific
  S [+ DR0 MOV,  4BA @# DR0 ADD,  DR0 OFUSER TEMPUS MOV,
  BEGIN,  ' PAUSE <SUB>  OFUSER TEMPUS DR0 MOV,
    4BA @# DR0 CMP,  MI UNTIL,  NEXT    ;C

CODE SAFELINK{  \ save current link on return stack & delink
  RP [ AR0 MOV,  OFUSER MYLINK RP [ MOV,
  U OFUSER MYLINK MOV,  AR0 RP -[ MOV,  NEXT    ;C      FIXED

CODE (}RELINK)  \ restore link from return stack
  RP [+ AR0 MOV,  RP [ OFUSER MYLINK MOV,
  AR0 RP [ MOV,  ' PAUSE *+ BRA, ;C     FIXED   BASE F!
: }RELINK  COMPILE (}RELINK)  HERE LASTTHEN F! ;   IMMEDIATE
\ screen object editor -- byte patcher    ( 12  2 86 CRC 20:51 )
FORTH DEFINITIONS
: SEE \  start count --- | dump relative to current screen
  SCR F@ BLOCK FUDGE F! DUMP ;
: VIEW \ start end  --- | like index - 1st line dumped
  CR 1+ SWAP DO I DUP 4 .R SCR F! 0 C/L SEE
  ?TERMINAL IF LEAVE THEN LOOP ;
: T!  FUDGE F@ +  ! UPDATE ;  : TW! FUDGE F@ + W! UPDATE ;
: TC! FUDGE F@ + C! UPDATE ;
: TFILL ROT FUDGE F@ + ROT ROT FILL UPDATE ;
: TDIS   FUDGE F@ + DISASSEM ;
: NON0  BLOCK 0 B/BUF BOUNDS DO DUP I + C@ IF I 5 .R THEN
   LOOP DROP ;
: NON0S  1+ SWAP DO CR I 10 .R I NON0
  ?TERMINAL IF LEAVE THEN LOOP ;
EDITOR FLUSH
































\ Vectoring words: nec ok output          (  9  4 88 CRC 11:57 )
DECIMAL        FORTH  DEFINITIONS
: <OUTPUT> R>   'EMIT 24 CMOVE ;
: OUTPUT>   COMPILE <OUTPUT>  EXECS ;     IMMEDIATE
HEX             \ emit   type   gotoxy page    list   cr
: (OK)  20002  I/O F! \ safe against garbage in i/o variable
        OUTPUT> (EMIT)  (TYPE)  (GOTO) NPAGE   NLIST  (CR) STOP

E4 USER 'OK            : OK      'OK  @EXECUTE STOP
' (OK) 'OK F!

: PRINT   PRINTER LNCTR  OFF          \ See rf manual
                \ emit   type   gotoxy page    list   cr
        OUTPUT> (PNT)   (TYPE)  2DROP  PPAGE   NLIST  PCR  STOP
DECIMAL

  \ SPINWRITER controls                   ( 19 11 86 CRC 14:07 )
  BASE F@ HEX   FORTH  DEFINITIONS        \ See rf manual
: ?CRT    'EMIT F@ [ ' (EMIT) ] LITERAL  = ;

: VTAB  ( line count-1 VTAB)
    -DUP IF  CTL J                         \ version for printer
  \ -DUP IF  ?CRT IF CLT J ELSE CTL M THEN \ version for lsi 11
     SWAP  0 DO DUP EMIT LOOP DROP THEN ; \ w/o line feeds

BASE F!   ;S

: BYE   ." Did you put the system disk back its drive??  "
  SAFELINK{  KEY DUP EMIT ASCII _ AND ASCII Y =  IF BYE THEN
  }RELINK  QUIT STOP
  BASE F!

















  \ SPINWRITER    list                    ( 12  2 86 CRC 14:43 )
  BASE F@ HEX   FORTH  DEFINITIONS

: NLIST   BASE F@  SWAP  DECIMAL     \ See rf manual
  CR  DUP  SCR F! 1E  ?CRT 0= LI * + SPACES
  .SCR 10 SCR F@ BLOCK W@  IF
  0 DO  CR I 3 .R  SPACE I SCR F@ .LINE
    ( ?TERMINAL IF LEAVE ENDIF ) LOOP ELSE
  VTAB  THEN  CR BASE F! ;          ' NLIST  'LIST F!

  BASE F!
: L   SCR F@ LIST ;

: N   SCR 1+!  L ;

: B   -1 SCR +!  L ;
\ dx nx cx                                (  3  8 90 crc 12:50 )
FORGET TASK                BASE F@ DECIMAL
: DX  \  scr# ---  | show 60 line 0s from scr#
  DUP 60 + OVER  PAGE   DO  I OVER -  20 /MOD  26 * GOTOXY
     I 5 .R  I BLOCK W@ IF  SPACE  I BLOCK 20 -TRAILING TYPE
       ELSE  I BLOCK 2+ W@ 8224 -  IF  ."  Binary"  THEN THEN
     ?TERMINAL IF LEAVE THEN  LOOP  DROP  20 1 GOTOXY ;

: CX  \   ---   | dx for current volume
  SCR F@  60 /  60 *  DX ;
: NX  \   ---   | dx the next volume
  SCR F@  60 /  1+         60 *  SCR F!  CX ;
: BX  \   ---   | dx the last volume
  SCR F@  60 /  1-  0 MAX  60 *  SCR F!  CX ;

: TASK ;      BASE F!
\ <cmove in code                          ( 20  5 94 CRC 19:30 )
BASE F@ HEX

CODE <CMOVE   \ fr-3  to-2  cnt-1  ---  | See rf manual
  S [+ DR7 MOV,                 \ count
  S [+ AR0 MOV,                 \ source
  S [+ AR1 MOV,                 \ destination
  NE IF,                        \ count non-zero?
    DR7 AR0 ADD,                \ top of source
    DR7 AR1 ADD,                \ top of destination
    1 # DR7 SUBQ,  DR7 FALSE DO,  AR1 -[ AR0 -[ .B MOV,  LOOP,
  THEN,  NEXT    ;C

BASE F!


\ Documenting                             ( 14  8 87 CRC 20:26 )
FORTH DEFINITIONS FORGET TASK   : TASK ; DECIMAL        ptoday
VOCABULARY DOCUMENTING IMMEDIATE  DOCUMENTING DEFINITIONS
CREATE W  C/L ALLOT   HEX
: ?PAGE ?CRT 0= IF  \ page iff not crt and not top of form
  LNCTR F@ IF PAGE THEN THEN ;
: TRIAD  3 / 3 * 3 BOUNDS 2DUP DO I BLOCK W@ LOOP OR OR \ rf
  IF ?PAGE DO I LIST ?TERMINAL IF LEAVE THEN PAUSE LOOP
  CR 4 SPACES W C/L TYPE CR 4 SPACES pTODAY ELSE 2DROP THEN ;
: SHOW   3 / 1+ 3 * SWAP DO I TRIAD ?TERMINAL    \ See rf man
  IF LEAVE THEN 3 +LOOP ;
: INDEX   1+ SWAP DO I 3C MOD 0= IF ?PAGE THEN   \ See rf man
  CR I DUP 4 .R SPACE BLOCK W@ IF 0 I .LINE ELSE I BLOCK 2+ W@
  2020 - IF ." binary" THEN THEN ?TERMINAL IF CR LEAVE THEN
  LOOP CR ;  DECIMAL 181 182 THRU  DECIMAL
  67 68 THRU  170 LOAD DOCUMENTING DECIMAL
\  case statement  -- Eaker case from f.d.( 29  5 86 CRC 14:42 )
: CASE   ?COMP CSP F@ !CSP 4 ;  IMMEDIATE

: OF  4 ?PAIRS  COMPILE (OF) HERE 0 W,  5 ;   IMMEDIATE

: ENDOF  5 ?PAIRS  BRAN
  SWAP  2 [COMPILE] THEN  4  ;   IMMEDIATE

: ENDCASE   4 ?PAIRS  COMPILE DROP
  BEGIN SP@ CSP F@ - WHILE 2 [COMPILE] THEN REPEAT CSP F! ;
            IMMEDIATE          ;S
Case statement from Forth Dimensions. For an example of syntax,
see the screen editor word  Z . See also the real-FORTH User's
Guide.


\ Terminal specific io stuff here - VT52  ( 13 11 86 CRC 10:58 )
BASE F@ HEX     \ Line#-2   col-1  ---- | place cursor
: (GOTO)  SAFELINK{ ." 1Y" [ LI HERE 3 - C! ]
  BL DUP D+ SWAP EMIT EMIT }RELINK ;

: GOTOXY  'GOTOXY @EXECUTE STOP   ' (GOTO)    'GOTOXY F!

: (BOT)  13 0 GOTOXY  CLR.EOP  OUT OFF ;

EC USER 'BOT            : BOTTOM  'BOT @EXECUTE STOP
E8 USER 'ERL            : ERL     'ERL @EXECUTE STOP
' (ERL)  'ERL F!   ' (BOT)  'BOT F!

: CLS PAGE ;
BASE F! ;S  See rf manual

\ Pseudo-disk for atari w/ 1 meg          (  5 12 90 CRC 19:25 )
BASE F@ DECIMAL  FORGET TASK  HEX       EDITOR FLUSH
VOLSIZE 2/ CONSTANT MAXPSB   \ largest pseudoblock #  1+
FIRST MAXPSB 1+ B/BUF * - CONSTANT 0PSB \ psb = pseudoblock
0PSB HERE - 0<  IFTRUE ." Not enough Ram! "
FORGET MAXPSB  : TASK ;   ABORT  IFEND
MAXBLK MAXPSB + CONSTANT RMAX   'R/W F@ VARIABLE >R/W
            \  addr blk f    psr/w  f:  0 = write 1 = read
: PSR/W  >R  B/BUF * 0PSB +  \ get block wanted to TOS
   R>    IF SWAP THEN        \ get right direction
   B/BUF CMOVE ;             \ do the deed!

: NR/W  >R  RMAX OVER < 6 ?ERROR
   MAXBLK OVER < IF MAXBLK 1+ - R> PSR/W ;S
   THEN R> >R/W @EXECUTE STOP
BLK F@ 1+ LOAD    BASE F!    EDITOR
\ Pseudo-disk for atari w/ 1 meg          (  5 12 90 CRC 19:22 )
\ ' 0PSB  ' ?DICT 8 + F!  \ patch dict size.

\  blk#  ---  blk# | disk moving words:
: BACKUP   CR \ read disk(s) into pseudo disk
  DUP EMPTY-BUFFERS FLUSH RMAX 1+ MAXBLK 1+ DO  I OVER
  BLOCK 4- F! UPDATE DUP 5 .R 1+ LOOP DROP EDITOR FLUSH ;

\  blk#  ---   |
: BACKDOWN CR \ write a pseudo disk to disk(s)
  MAXPSB 0 DO DUP I +  DUP 5 .R  I MAXBLK 1+ + BLOCK 4- F!
  UPDATE  LOOP DROP EDITOR FLUSH ;

: OLDDISK >R/W F@                 'R/W F! ;

: RAMDISK [ ' NR/W ] LITERAL 'R/W F! ;
\ register access: ar4                    ( 29 10 93 CRC 21:39 )
forth definitions debug
forget task

code reg@  ar4 s -[ mov,  next ;c

code reg!  s [+ ar4 mov,  next ;c

code regpush{  ar4 rp -[ mov,  next  ;c

code }regpop  rp [+ ar4 mov,  next  ;c

: task ;
decimal editor flush


















\ test screen for pseudocontant           ( 29  8 02 CRC 12:09 )
0 variable 'foo
code foo  'foo *+ s -[ mov, rts, ;c

editor flush











































































\ hard disk raw access: +blk, +load, +thru( 17  7 88 CRC 11:37 )
FORGET TASK                     EDITOR DEFINITIONS
: FINDBLNK  \  -- blk# | find next empty block from here
  SCR F@ 1+  BEGIN DUP BLOCK W@ WHILE  1+ REPEAT ;

: INSERTSCR \  --  | insert an empty screen by moving scrs up 1
  FORTH FLUSH  EDITOR FINDBLNK  BEGIN  1-  DUP 2DUP 1+  COPY
      SCR F@ = UNTIL  DROP ;
FORTH DEFINITIONS

CODE +BLK   OFUSER BLK DR0 MOV,
 EQ IF,  OFUSER SCR DR0 MOV,  THEN,  DR0 S [ ADD,  NEXT   ;C

: +LOAD  +BLK LOAD ;
: +THRU  +BLK SWAP  +BLK SWAP  THRU ;
: TASK ;
\ Auto size screen                        (  9  2 87 CRC 11:28 )
107 NEEDED IFTRUE
IN BLK -  CONSTANT CELL

: CELL+  [ CELL 4 = IFTRUE ] 4+ [ OTHERWISE ] 2+ [ IFEND ] ;

: CELL-  [ CELL 4 = IFTRUE ] 4- [ OTHERWISE ] 2- [ IFEND ] ;

: CELL*  [ CELL 4 = IFTRUE ] 4* [ OTHERWISE ] 2* [ IFEND ] ;

: CELL/  [ CELL 4 = IFTRUE ] 4/ [ OTHERWISE ] 2/ [ IFEND ] ;





\ Auto size: examples                     (  9  2 87 CRC 11:42 )
CODE EXEC  S [+ DR0 MOV,  CELL 2/ # DR0 ASL,   DR0 IP ADD,
  IP [ W ADD,  RP [+ IP ADD,  W [+ AR0 MOV,  AR0 [ JMP,

  ;S Used for a execution table case statement. E.g:

: .ONE  1 . ;      : .TWO  2 . ;   etc.

: ACASE   0 MAX  5 MIN  .ZERO .ONE .TWO .THREE .FOUR .FIVE STOP

N.b. The phrase  CELL 2/  is a nasty trick based on the fact
that  CELL  is either 2 or 4. If  CELL  is ever 8, this code
won't work correctly.
N.b: This assumes that the correct default data size is used by
the assembler. See next screen.

\ Auto size: examples                     (  9  2 87 CRC 11:53 )
ASSEMBLER DEFINITIONS
 \ Automating the default assembler size for 68000:
 \ either  .W  or  .L  is used.
: 1ST  CLEARVAR CLEARVAR1

  [ cell 4 = iftrue ' .l otherwise ' .w  ifend  cfa , ]

  (QUIET) @ IF BASE @ DECIMAL CR .SCR&LINE 52 TAB    \ etc.







\ size memory routine                     ( 12  2 87 CRC 12:16 )
FORGET TASK                     : TASK ;
BASE @ HEX   ASSEMBLER HERE
   AR1 S -[ MOV,  DR7 RP MOV,  DR0 2 4* @# MOV,  NEXT

CODE SIZEMEM  \  --- addr | addr is first failed read.
   2 4* @# DR0 MOV,  RP DR7 MOV,
   *+ AR0 LEA,  AR0 2 4* @# MOV,
   AR1 AR1 SUB,  BEGIN,  AR1 [+ DR1 MOV,  DROP *+ BRA,
   4 CSP +!  ;C

BASE !    EDITOR FLUSH      ;S
 How much memory does the HARDWARE think you have?



\ size memory routine                     ( 12  2 87 CRC 12:16 )
FORGET TASK                     : TASK ;
hex
: read  \ addr ct ---   | read every 16 k from addr for ct
  bounds  cr do   i ctl m emit  erl 8 .r
    i f@
    i f@  0a .r
    i off  i on
    i f!
    4000 +loop ;


          EDITOR FLUSH



















\ some utilities: 2*s 2/s wfill lfill     ( 22 10 85 CRC       )
CODE 2/S \ n ct -- n | shift right count times
  S [+ DR0 MOV,  S [ DR1 MOV,  DR0 DR1 LSR,  DR1 S [ MOV,  NEXT
;C
CODE 2*S \ n ct -- n | shift left count times
  S [+ DR0 MOV,  S [ DR1 MOV,  DR0 DR1 LSL,  DR1 S [ MOV,  NEXT
;C  ;S
CODE WFILL \ addr ct val --  | fill memory w/ word.
 S [+ DR0 MOV,  S [+ DR1 MOV,  S [+ AR0 MOV,  1 # DR1 LSR,
 BEGIN,  DR0 AR0 [+ .W MOV,  1 # DR1 SUBQ,  EQ UNTIL,  NEXT ;C

CODE LFILL \ addr ct val --  | fill memory w/ long word.
 S [+ DR0 MOV,  S [+ DR1 MOV,  S [+ AR0 MOV,  2 # DR1 LSR,
 BEGIN,  DR0 AR0 [+ MOV,  1 # DR1 SUBQ,  EQ UNTIL,  NEXT  ;C


\ some utilities: 8* 8/ xtend w* uw*      (  7  4 86 CRC 12:23 )
CODE XTEND S [ DR0 MOV,  DR0 EXT,  DR0 S [ MOV,  NEXT    ;C

CODE 8/  S [ DR0 MOV,  3 # DR0 LSR,  DR0 S [ MOV,  NEXT  ;C
CODE 8*  S [ DR0 MOV,  3 # DR0 LSL,  DR0 S [ MOV,  NEXT  ;C
;S
CODE UW*   \ w w --- n | 16bit x 16bit --> 32bit prod
  S [+ DR0 MOV,  S [ DR1 MOV,  DR1 DR0 MULU,  DR0 S [ MOV,  NEXT

CODE W*    \ w w --- n | 16bit x 16bit --> 32bit prod
  S [+ DR0 MOV,  S [ DR1 MOV,  DR1 DR0 MULS,  DR0 S [ MOV,  NEXT

CODE -ROT  S 4 &[ DR0 MOV,  S 8 &[ S 4 &[ MOV,
  S [ S 8 &[ MOV,  DR0 S [ MOV,  NEXT


\ cursor configuration                    ( 31  5 91 CRC  9:46 )
BASE F@ DECIMAL     \ this screen by C. Curley
CODE CURSCONF  \ cmd op --- (n) | configure cursor
  S [+ DR0 MOV,  DR0 RP -[ .W MOV,
  S [+ DR1 MOV,  DR1 RP -[ .W MOV,
  21 # RP -[ .W MOV,  14 # TRAP,  6 # RP ADDQ,
  5 # DR1 .W CMP,  EQ IF,  DR0 S -[ MOV,  THEN,  NEXT ;C
BLK F@ 1+ DUP 4+ HEX THRU        BASE F!      ;S
     Use the following commands:
   0   Hide cursor                 1   Show cursor
   2   Set cursor to blink
   3   Set cursor to steady (non-blink)
   4   Set cursor blink to operand
   5   Return cursor blink timer value
     Except for # 4, a dummy operand must be provided.
E.g.   1 0 CURSCONF  will force the cursor to be shown.
\ screen colour stuff                     ( 31  5 91 CRC  9:20 )
HEX  \ see screen 49 for more information
CODE SETCOLOUR \ colval colour# --- colorval | set a colour
  S [+ DR0 MOV,  S [ DR1 MOV, \ get c#, then val
  DR1 RP -[ .W MOV,  DR0 RP -[ .W MOV,  \ push val, then c#
  7 # RP -[ .W MOV,  0E # TRAP,  6 # RP ADDQ,
  FFFF #L DR0 AND,  DR0 S [ MOV,  NEXT ;C
\  0: lo res  1: medium res  2: hi (monochrome) res.
CODE SETSCREEN \ res phybase logbase --- | set screen parameters
  S [+ DR4 MOV,  S [+ DR2 MOV,  S [+ DR3 MOV,
  RP DR7 MOV,  4 # RP -[ .W MOV,  0E # TRAP,
  2 # DR0 .W CMP,  EQ IF,  DR3 CLR,  1 # DR3 SUBQ,  THEN,
  DR3 RP -[ .W MOV,  DR2 RP -[ MOV,  DR4 RP -[ MOV,
  5 # RP -[ .W MOV,  0E # TRAP,  DR7 RP MOV,  NEXT ;C  ;S
SETSCREEN  will set the screen resolution iff the current
resolution is not high.
\ terminal stuff                          ( 13 11 86 CRC 11:15 )
: TERMSTUFF  CREATE BL WORD HERE 1+ C@ C,
  DOES> ?CRT IF SAFELINK{  C@ LI (EMIT) (EMIT) }RELINK
  ELSE  DROP  THEN ;
TERMSTUFF REV.ON p              TERMSTUFF REV.OFF q
( TERMSTUFF ORGN H    )            TERMSTUFF NPAGE E
TERMSTUFF UP A                  TERMSTUFF DN B
TERMSTUFF RIGHT C               TERMSTUFF LEFT D
TERMSTUFF SV.CUR j              TERMSTUFF RST.CUR k
( TERMSTUFF -INDEX I     )         TERMSTUFF CLR.EOP J
TERMSTUFF (ERL) K            \   TERMSTUFF +LINE L
TERMSTUFF -LINE M            \   TERMSTUFF CLR.LINE 1
( TERMSTUFF CLR.SOL o )           TERMSTUFF WRAP v
TERMSTUFF NO.WRAP w             TERMSTUFF CLR.SOS f
TERMSTUFF NO.CURSOR f           TERMSTUFF CURSOR e
CURSOR WRAP             \ see note next screen
\ terminal stuff                          (  8  5 87 CRC 20:18 )
: FOREGROUND  \ c --- | set colour, 0-15, lo res; 0-3, med res
  ?CRT IF SAFELINK{  LI EMIT ASCII b EMIT 0F AND EMIT
  -3 OUT +! }RELINK ELSE  DROP  THEN ;
: BACKGROUND  \ c --- | set colour, 0-15, lo res; 0-3, med res
  ?CRT IF SAFELINK{  LI EMIT ASCII c EMIT 0F AND EMIT
  -3 OUT +! }RELINK ELSE  DROP  THEN ;
 ( 2 BACKGROUND )       ;S
\      Screens 47 & 48 are adapted from Antic Magazine for
\ February, 1986. Code by Dr. Timothy Huang. Their code appears
\ to be copyright 1986, Antic Magazine. Now, will they mind if
\ you use it?    For the pallete:
\ colour 0 sets the frame around the screen; 1 the cursor. For
\ MEDIUM resolution, in any word:
 0F  0E  0D  0C  0B  0A   9   8   7   6   5   4   3   2   1   0
  X   X   X   X   X  |   red    | X |   green   | X |   blue   |
\ set colour pallete                      ( 23  1 92 CRC  8:30 )
                \ c: ---  |  compile table for pallete def
: PALLETESET    \ r: ---  |  set pallete
  CREATE     ;CODE    6 # RP -[ .W MOV,
  0E # TRAP,  6 # RP ADDQ,  NEXT ;C   \ more by C. Curley
         \ colour  0      1      2      3
PALLETESET VERT    0 W, 700 W,   0 W,  70 W, \ medium res!
  HERE 10 4 - 2* DUP ALLOT ERASE  \ set unused colours to black
PALLETESET BLEU    7 W, 700 W,  70 W, 777 W, \ medium res!
  HERE 10 4 - 2* DUP ALLOT ERASE  \ set unused colours to black
PALLETESET BLANC 777 W, 700 W,  70 W,   0 W, \ medium res!
  HERE 10 4 - 2* DUP ALLOT ERASE  \ set unused colours to black
PALLETESET ROUGE   0 W, 700 W,   0 W, 700 W, \ medium res!
  HERE 10 4 - 2* DUP ALLOT ERASE  \ set unused colours to black
' BLEU VARIABLE 'DISPLAY
: DISPLAY  'DISPLAY  @EXECUTE STOP
\ save colors on entry, restore on exit   (  6 11 93 CRC 21:26 )
HEX     0 VARIABLE DESKS 1C ALLOT       \ default pallete

: GETPAL        \ get the sixteen colors already in the pallete
  10 0 DO       \  addr ----   | set to pallete at addr
  DUP  I 2* + W@  I SETCOLOUR  I 2*  DESKS + W!  LOOP  DROP ;

        \ restore from original colours
: PALCOLD   DESKS GETPAL   CR ;
ATCOLD: PALCOLD         ATEXIT: PALCOLD

'DISPLAY F@ C>P GETPAL




\ Loader screen                           ( 19 11 93 CRC 20:15 )
: LOADER  \  scr#-1   ---  <name>  defines screen to load
   CREATE ,      \ See the real-Forth manual
   DOES> ( WARNING F@ >R WARNING OFF)  F@ ( OFFSET F@ - ) LOAD
      ( R> WARNING F!) ;
    23 LOADER DOCUMENTING            53 LOADER DISKING
   174 LOADER RECITE                690 LOADER CREF
   150 LOADER TOWERS                516 LOADER BLANKing
   201 LOADER TERM              \   702 LOADER XFER
   450 LOADER DEBUG                 207 LOADER SHOWOFF
   450 LOADER FILING                 87 LOADER CHECKBOOK
  1960 loader calcpi               1443 loader life

: NEEDED  \ scr# ---  | compiles scr if not already loaded.
  -FIND IF  2DROP DROP  ELSE  ( OFFSET F@ - ) LOAD  THEN ;

\ fibonacci numbers                       ( 26  2 86 CRC 15:54 )
filing
CODE FIB \ n1 n2 --- n2 n3 | generate the next number in series
  S [+ DR0 MOV,  S [ DR1 MOV,  DR0 DR1 ADD,  DR0 S [ MOV,
  DR1 S -[ MOV,  NEXT   ;C

: FIBS   \  ---  | print 'em
  CR 1 1 2DUP 14 .R COL 14 .R
  BEGIN FIB DUP 0< 0= WHILE COL DUP 14 ,.R REPEAT 2DROP ;

FIBS ;S
: FIB    \ n1 n2 --- n2 n3 | generate the next number in series
  2DUP + ROT DROP ;



 (  BULK INITIALISER -- int, init         ( 13  9 87 CRC 16:08 )
BASE F@  HEX               0 VARIABLE SINGLE
CODE (FMT) \ bufaddr dev# trk side  --- fl | format a track
  RP DR7 MOV,  E5E5 # RP -[ .W MOV,  87654321 #L RP -[ MOV,
  2 # RP -[ .W MOV,  S [+ DR0 MOV,  DR0 RP -[ .W MOV, \ side
  S [+ DR0 MOV,  EQ IF,  RP 8 &[ .W CLR,  THEN, \ 0 virgin
                 DR0 RP -[ .W MOV,  ( trk) 0A # RP -[ .W MOV,
  S [+ DR0 MOV,  DR0 RP -[ .W MOV,  ( dev)  \ spt: 9 is tos std!
  RP -[ CLR,  ( fil)  S [ RP -[ MOV,  ( addr) 0A # RP -[ .W MOV,
  0E # TRAP,  DR0 S [ MOV,  DR7 RP MOV,  NEXT   ;C
: FMT  \ bufaddr dev# trk side  ---    | format a track
  PAUSE (FMT) -DUP IF HEX  8 .R ABORT"  Formatting error!"
  THEN PAUSE ;      DECIMAL
: CYL  \ bufaddr dev# trk       ---    | format a cylinder
  81 MIN >R 2DUP R 0 FMT  R> 1 FMT ;   \ double sided only!
BASE F!
 (  BULK INITIALISER -- int, init         (  3  9 88 CRC 14:10 )
FORTH DEFINITIONS FORGET TASK   : TASK ;
BASE F@ DECIMAL VOCABULARY DISKING IMMEDIATE  655 NEEDED COPIES
102 NEEDED ABORT"    DISKING DEFINITIONS  52 LOAD
0 VARIABLE FORMATTED
: (INIT)  \ trkfr trkto  ---  | format a cylinder
  CR PAD FORMATTED F@  2SWAP 1+ SWAP DO 2DUP I
  SINGLE F@ IF 0 FMT ELSE CYL THEN  I 5 .R LOOP 2DROP ;
: INIT5  0 40  (INIT) ;
: INIT   0 81  (INIT) ;
: 10INIT  9 0 DO INIT I 4 .R KEY DROP LOOP INIT ;
  DECIMAL 108 LOAD 110 LOAD            116 LOAD  157 LOAD
127 LOAD FORTH DEFINITIONS DISKING   BASE F! ;S
N.B. Use  INIT  to init a new disk. However, it must be cleaned
out and set to blanks. For this purpose, use  CLEARDISK  or
BACKUP  ( for an entire disk ).
\ for next code                           ( 30 11 91 CRC 19:26 )
BASE F@ HEX CODE (NEXT)   RP [+ AR0 MOV,   DR5 TST,
  NE IF,  AR0 [ AR0 .W ADD,  1 # DR5 SUBQ,  AR0 [ JMP,  THEN,
   2 # AR0 ADDQ,  RP [+ DR5 MOV, AR0 [ JMP, ;C  FIXED
CODE ?FINAL  \ fl --  | leave for ... next loop conditionally
  S [+ TST,  NE IF,  DR5 CLR, THEN,  NEXT ;C
HERE  ASSEMBLER  DR5 RP -[ MOV,  S [+ DR5 MOV,
: FOR  [ 4 CSP +! ] LITERAL  HERE 4 CMOVE  4 ALLOT
  HERE 6 ;  IMMEDIATE    BASE F!
: NEXT   6 ?PAIRS COMPILE (NEXT) BACK ;   IMMEDIATE    ;S
: T  DUP FOR DUP I - drop  NEXT DROP ;
  EDITOR FLUSH \   20 DUP T   \ up count, then down count
: T1     FOR  I DROP I 5 = ?FINAL  NEXT ;   ;S
Concept from Chuck Moore's FORTH chip, the Novix 4000. FOR ...
NEXT  is equialent to  n 1+ 0  DO  LOOP  but faster. Also, n may
greater than -1 2/ .
 ( Timer words: ms sec minutes,           ( 27 10 86 CRC 13:06 )
   BASE  F@  DECIMAL

: MS  ?STACK  5 / WAIT ;

: SEC  0  DO  1000  MS   LOOP ;

   BASE  F!    ;S
: MINUTES  0  DO   60000  MS   LOOP ;

   BASE  F!    ;S

: MS  0  DO  70  0  DO  LOOP  LOOP ;



\ Assembler extensions to FORTH           (  4  8 91 CRC 15:39 )
BASE F@ >R HEX  SP@ .
: CTL   BL WORD HERE 1+ C@ 1F AND [COMPILE] LITERAL ; IMMEDIATE
     \ see the real-Forth manual
: ASCII BL WORD HERE 1+ C@        [COMPILE] LITERAL ; IMMEDIATE

: .SCR    ." Scr #"   6 .R ;

: TAB  OUT F@ -  SPACES  ;

: >COL BEGIN OUT F@ 14 MOD OVER - 0< WHILE SPACE REPEAT DROP ;

: ?CR  OUT F@ IF CR THEN ;
                                        \ See RF manual
: STOP ( compilation) ?CSP SMUDGE [COMPILE] [       ; IMMEDIATE
HEX SP@ . DUP . R> BASE F! CR
 ( :: , the immediate compilation mode  WFR 26 05 81 CRC )
      FORTH  DEFINITIONS
:  ::   \ compile and execute nameless FORTH.  rf manual
    HERE  >R
    !CSP  ]     ( enter compile state )
    BEGIN  INTERPRET   STATE   F@
         WHILE   CR  QUERY
       REPEAT
    SMUDGE  R EXECUTE   R>  DP F!  ;
 CR  ."   ::  is loaded."  ;S
The above definition  ::  will accept and compile FORTH
words until the next  ; . the code will then be executed
once and forgotten. This is a method to execute conditionals
from the terminal for testing or repetitive functions.


\ stack printing words: .s depth u.r      ( 18  2 86 CRC 14:09 )
: U.R  0 SWAP D.R ;             : U.   0      D.  ;
12 USER SP0              \      16 USER RP0
: DEPTH  SP0 F@ SP@ - 4/ 1- ; \ gets the depth of the stack

: .S \ prints out contents of stack non-destructively. rf manual
  DEPTH  -DUP  IF 6 .R ASCII : EMIT  SP@ 4-  SP0 F@ 4-
    DO I F@ 9 U.R -4 +LOOP   ELSE ." Empty" THEN SPACE ;
;S    don't use .rs very often
CODE RP@   RP S -[ MOV,  NEXT

: RDEPTH RP0 F@ RP@ - 4/ 1- ; \ gets the depth of return stack
    \ .rs may not be working exactly right yet.
: .RS \ prints out contents of stack non-destructively.  rf man
  RDEPTH -DUP  IF 6 .R ASCII : EMIT  RP@ 4-  RP0 F@ 4-
    DO I F@ 9 U.R -4 +LOOP   ELSE ." Empty" THEN SPACE ;
 (  New, a full screen  editor   by WFR     26 05 81 CRC )
;S      FORTH  BASE  F@   DECIMAL
: NEW    ( line  #  -----   builds from this line downward )
    BASE F@ SWAP DECIMAL 16  0  PAGE  CR  ." SCR " SCR F@  3 .R
 DO CR I 3 .R SPACE C/L SPACES 124 EMIT C/L 1+ 0 DO 8 EMIT LOOP
       I  OVER   =
       IF [  DROP ] ( error )  QUERY  1  TEXT  PAD  1+  C@
           IF  ( not at null )  I  EDITOR  R  FORTH  1+
              ELSE  ( before  or after )  8  EMIT  [  ROT  2 ]
        THEN   I   SCR  F@  .LINE   THEN
  LOOP   DROP  BASE F! CR ;
   CR  ." NEW is loaded. "  BASE  F!  ;S
  This editor builds a NEW screen. Either list the screen or
set SCR manually. Then give: 'n  NEW ' where  n  is the first
new line.  Previous lines are listed; an empty line will
terminate building the new screen.
 ( Hex dump                               ( 28  4 91 CRC 16:28 )
BASE F@ HEX : IF.  IF DROP ASCII . THEN ;  0 VARIABLE FUDGE
 \ see the real-Forth manual
: TC@ FUDGE F@ + C@ ; : T@ FUDGE F@ + @ ; : TW@ FUDGE F@ + W@ ;
: (WDUMP) \  from-address-2 cnt-1  ---  | memory displayed
  BOUNDS  DO I TW@ 5 .R 2 +LOOP ;
: WHEAD   CR 9 SPACES  \ start  ---  | header
   10 0 DO DUP I + BASE F@ MOD 5 .R 2 +LOOP DROP
   ."  <<    ascii   >>" ;
: ASCI  BOUNDS ( from-addr cnt ASCI )
   DO I TC@ 7F AND  DUP BL ASCII ~ WITHIN 0= IF. EMIT LOOP ;
: DUMP  OVER  DUP WHEAD \ from-addr  count ---  | dump
   + SWAP   DO CR I 9 U.R I 10 2DUP (WDUMP) SPACE
   ASCI I F0 AND F0 = IF I WHEAD THEN
   ?TERMINAL  IF LEAVE  THEN  10 +LOOP CR ;
 BASE F!  FORTH  ."  Word hexdump loaded." CR \ : DUMP WDUMP ;
 ( Vlist col tab id.                      ( 10 12 91 CRC 17:15 )
 BASE F@ HEX            \ Address ID.
: AID.  BASE F@ HEX SWAP  PAD BL ASCII _ FILL
  DUP N>C DUP  6 U.R SPACE  DUP LEN?  2-  OVER -
  PAD SWAP CMOVE  PAD COUNT  01F AND  TYPE  BASE F! SPACE ;

: COL  OUT F@  [ 3 ( columns 1- ) 14 ( width) * 1- ] LITERAL >
       IF  CR  ELSE  OUT F@ 14 / 1+ 14 * TAB  THEN ;

: (VLST)    80 OUT F!   \ addr --- | vlist of given voc
  BEGIN  COL  DUP AID.  N>L F@  DUP 0=  ?TERMINAL OR UNTIL
  DROP  CR ;

: VLIST    CONTEXT F@ F@  (VLST) ;  \ see the real-Forth manual

: CURLIST  LATEST         (VLST) ;        BASE  F!
\ nec-safe  quit                          (  1  9 93 CRC 21:32 )

\ 1 VARIABLE STACKPRINT

: (PQUIT)    \   see the real-Forth manual
  BLK OFF  [COMPILE] [  OK  BEGIN BEGIN
  RP! CR  QUERY INTERPRET  OK  \ Reset output vectors
( STACKPRINT F@ IF ) DEPTH IF  .S  THEN \ THEN
  STATE F@ 0= UNTIL ."  ffok"  AGAIN  STOP

' (PQUIT) 'QUIT F!


: MF  BASE F@  FIRST HERE -  B/BUF /  DECIMAL U.
  9 MESSAGE  BASE F!  SPACE ;

\ Assembler extensions to FORTH           ( 26  2 86 CRC 14:41 )
BASE F@ HEX        ." Double Precison handlers..."
     \ see the real-Forth manual
CODE 2/  S [ DR0 MOV,  1 # DR0 LSR,  DR0 S [ MOV,  NEXT  ;C
CODE 2*  S [ DR0 MOV,  1 # DR0 LSL,  DR0 S [ MOV,  NEXT  ;C

CODE 2SWAP S [+ DR0 MOV,  S [+ DR1 MOV,  S [+ DR2 MOV,
  S [ DR3 MOV,  DR1 S [ MOV,  DR0 S -[ MOV,  DR3 S -[ MOV,
  DR2 S -[ MOV,  NEXT ;C

CODE 2@  S [ AR0 MOV,  AR0 4 &[ S [ MOV,  AR0 [ S -[ MOV,
    NEXT ;C
CODE 2!  S [+ AR0 MOV,  S [+ AR0 [+ MOV,  S [+ AR0 [ MOV,
    NEXT ;C
   ."  loaded " BASE F!

\      driver for parallel printer        ( 21  3 91 CRC 10:11 )
FORTH DEFINITIONS               VOCABULARY PRINTER IMMEDIATE
BASE F@ HEX >R
D4 USER LNCTR     \ shared w/ mptr in overlay code
DECIMAL  61 8 * VARIABLE LN/PG  HEX

PRINTER DEFINITIONS
0 VARIABLE SERIAL \ output device -- cent. printer: 0; serial: 1
7F VARIABLE MASK  \ outgoing data are anded with this mask.
0 VARIABLE FLOW \ flow: 0: - none 1: xon/xoff 2: rts/cts 3: both

BLK F@ 1+ LOAD  DECIMAL 69 LOAD  HEX
FORTH DEFINITIONS
: ?PRINT 'EMIT F@ [ PRINTER ' (PNT) ] LITERAL = ;
R> BASE F!   FORTH DEFINITIONS

\      driver for parallel printer        ( 21  3 91 CRC 10:12 )
HERE >R ASSEMBLER  HEX    OFUSER LNCTR AR0 LEA,
  0C # DR4 .W CMP,  EQ IF,      AR0 [ CLR,   ELSE,
  0A # DR4 .W CMP,  EQ IF,  8 # AR0 [ ADDQ,  THEN,  THEN,
  DR4 S -[ .W MOV,  \ save data -- no regs preserved in  pause
  BEGIN,  ' PAUSE <sub>
     SERIAL 2+ *+ RP -[ .W MOV,  8 # RP -[ .W MOV,
     0D # TRAP,  4 # RP ADDQ,  DR0 TST,  NE UNTIL,
  S [+ RP -[ .W MOV, ( data)  SERIAL 2+ *+ RP -[ .W MOV,
  3 # RP -[ .W MOV, ( funct)  0D # TRAP,  6 # RP ADDQ,  RTS,

CODE (PNT)   S [+ DR4 MOV,   MASK *+ DR4 AND,
   R> *+ BSR,  NEXT     ;C      FIXED



\ text shipping words: send to other compu(  4 10 86 CRC 18:28 )
DECIMAL  FORGET TASK
: SEND   PRINTER
        OUTPUT> (PNT)  slTYPE   2DROP  PPAGE   NLIST  (CR) STOP

: ABLOCK BLOCK DUP W@ IF B/BUF TYPE ELSE
     LI EMIT DROP 400 MS THEN ;
: ABLOCKS   2DUP SEND BOUNDS      DO I ABLOCK
    ?TERMINAL IF LEAVE THEN LOOP + ;

: APPLE" 0 WORD SEND HERE COUNT TYPE CTL M EMIT ;
EDITOR DEFINITIONS
: XFER  SCR F@ ABLOCK ;    FORTH DEFINITIONS
\ : TERM
\       BEGIN KEY DUP CTL Q - WHILE PRINTER (PNT) REPEAT DROP ;
: TASK ;   DECIMAL
\ Documentor code: since                    14  2 84 CRC
0 VARIABLE (SINCE)           \ holds todays address
: STARTDATE \ starting address of date in block
  SCR F@ BLOCK 43 + ;
: ?BL  1+ DUP C@ BL = IF DUP 16 TOGGLE THEN 1- ;

: GETDATE  \ addr --- d | accumulate 3 numbers into one
  PAD 9 CMOVE 0 0 PAD 6 + DUP 1+ C@ BL = + ?BL (NUMBER) DROP
  >R  DUP 60 < IF 100 + THEN R>  \ turn of century proviso
  PAD 3+ ?BL (NUMBER) DROP  PAD ?BL (NUMBER) 2DROP  ;

: GETSINCE   \  ---   | stores since's date in since
  BL WORD 0 0 HERE (NUMBER)  DROP               \ day
  BL WORD 0 0 HERE (NUMBER) 2DROP   100 M*  D+  \ month
  BL WORD 0 0 HERE (NUMBER) 2DROP  DUP 60 < IF 100 + THEN
  10000 M* D+  ( year)  DROP (SINCE) F! ;
\ Documentor code: since                  ( 20 10 86 CRC 23:36 )
: ASCR   \  --- fl  | screen more recent than since?
  SCR F@ BLOCK W@ IF STARTDATE GETDATE MINUS (SINCE) F@ + 0<
  ELSE 0 THEN ;         \ See the real-Forth manual

: SINCE  \ fr to ---  | print out screens over range given
\ fr to SINCE (d)d (m)m (y)y<ret>  n.b. max of 2 chars. per!!
  PAD C/L 1+ BLANKS  SWAP SCR F! GETSINCE
  BEGIN  ASCR IF SCR F@ DOCUMENTING TRIAD THEN  SCR 1+!
  ?TERMINAL IF  DUP SCR F! THEN
  SCR F@ OVER - 0< 0= PAUSE UNTIL DROP ;

FORTH DEFINITIONS       ;S
N.B.  SINCE  ignores screens updated the day of the date given.
To print out every screen updated during September, use:
0 B/DRV SINCE 0 9 84
\      driver for parallel printer        (  4  7 86 CRC 18:38 )
BASE F@ HEX   PRINTER DEFINITIONS   0 VARIABLE LEFT
CODE RSCONF   (  ---  | Reconfigure rs-232 port )
  RP DR7 MOV,  RP -[ CLR,  1 # RP [  SUBQ, \ scr, tsr unaffected
  RP [ RP -[ MOV, ( rsr, usr unaffected)  S [+ DR0 MOV,
  FLOW 2+ *+ RP -[ .W MOV,  ( flow)  DR0  RP .W -[ MOV, \ speed
  0F # RP -[ .W MOV, ( function call ) 0E # TRAP, ( doit)
  DR7 RP MOV,  NEXT ;C  BASE F!         1 RSCONF        FIXED
\ speeds: 0: 19200  1: 9600  etc to 9: 300  0A: 200 0B: 150
\ 0C: 134  0D: 110  0E: 75  0F: 50 baud  see scr 200 also
\ use rsconf only if going to the serial port!!!!

: LMRGN LEFT F@ SPACES OUT OFF ; : LEFTS  LEFT F! ;

: PPAGE    (PAGE) LMRGN ;
: PCR  (CR) LNCTR F@ LN/PG F@ >  IF  PPAGE  ELSE LMRGN  THEN ;
\ aim object file format utilities        ( 22  3 93 CRC 10:53 )
DECIMAL 201 NEEDED >HOST ( term)    FORGET TASK
HEX        0 VARIABLE CHKSUM  0 VARIABLE LINECT
  \         checksum of line   line count
  \ This format is defined in the AIM 65 User's Guide, pg F-5
  \ to F-7  Modified to use 32 bit addresses for 68k.
: ABYTE  0 # # 2DROP ;       : ACELL  0 # # # # 2DROP ;

: ALW  0  8 0 DO # LOOP  2DROP ;

: BUILDCHK  \  addr cnt  --- | checksum in chksum
  2DUP + CHKSUM F! BOUNDS      DO I TC@ CHKSUM +! LOOP ;

: BUILDBYTES  \ addr cnt --- | string construction
  SWAP 1- SWAP OVER + DO I TC@ ABYTE -1 +LOOP ;
BLK F@ 1+ DUP 2+ THRU     DECIMAL   : TASK ;
\ aim object file format utilities        (  3  5 87 CRC 15:38 )
: DOT   OUTPUT W@  OUTPUT >LOCAL  ASCII . (EMIT)  OUTPUT W! ;
: ALINE  \ builds a line in the string construction area
         \ addr cnt ---  addr$ cnt$ ready for typing
  2DUP BUILDCHK  <# CHKSUM F@ ALW  2DUP BUILDBYTES
  SWAP ALW ( addr) ABYTE ( cnt) ASCII ; HOLD 0 0 #>
  1 LINECT +! ;

: LASTLINE  \  -- addr$ cnt$ | builds last line of file for ty
  <# LINECT F@ 1+ DUP ALW ( chksum) ACELL ( lines)
  0 ABYTE ASCII ; HOLD 0 0 #> LINECT OFF SLTYPE CTL M EMIT ;

: LINES    \ addr cnt --    | dump contiguous memory
  BEGIN DUP 18 > WHILE 2DUP 18 MIN DUP >R ALINE SLTYPE  DOT
  CTL M EMIT  R> DUP MINUS D+  REPEAT
  -DUP IF ALINE SLTYPE  DOT  CTL M EMIT  ELSE DROP THEN ;
\ aim object file format utilities        ( 22  3 93 CRC 10:54 )
: CHAR    \  addr n1 --  addr+1 n2 | decode one char into n
  10 * OVER C@ 10 DIGIT 0= 0 ?ERROR + SWAP 1+ SWAP ;

: DECODEBYTE  \ addr --  addr  n | decode two chr at addr
  0 CHAR CHAR ;
: DECODECELL  \ addr --  addr  n | decode four chr at addr
  0 CHAR CHAR CHAR CHAR ;
: DECODELW    \ addr --  addr  n | decode four chr at addr
  0  8 0 DO  CHAR  LOOP ;

FIRST B/BUF - CONSTANT TAREA

: DOCHKSUM  \ addr --- addr+4 | decode & compare against chksum
    DECODELW CHKSUM F@ - IF ." checksum error !! " CR  QUIT
        THEN  ;
\ aim object file format utilities        ( 22  3 93 CRC 10:55 )
HEX
: DECODELINE  \ addr ---  | line of text decoded & placed
  DUP C@ ASCII ; - 0 ?ERROR  \ first char
  1+ DECODEBYTE   DUP CHKSUM F!  \ count
  DUP IF  \ if not the last line
    SWAP DECODELW DUP CHKSUM +! \ addr
    ROT BOUNDS      DO DECODEBYTE DUP CHKSUM +! I C! LOOP
  ELSE  \ do last line
    DROP DECODECELL DUP CHKSUM F!
    LINECT F@ - IF ." Bad record count!" CR QUIT THEN
    DOCHKSUM  LINECT OFF  THEN DROP ;

: DECODELINES    LINECT  OFF
    BEGIN LINECT 1+! PAD DUP  60 (EXPECT)
    DECODELINE LINECT F@ 0= UNTIL ;
\ Unlink utility                          (  2  2 87 CRC 12:10 )
FORTH DEFINITIONS
FORGET TASK                     : TASK ;

: FLINK  \ nfa addr ---  addr'/fl | find word pointing to given
  SWAP >R
  BEGIN F@  DUP N>L F@ DUP 0=  SWAP  R =  OR
    0= WHILE  N>L  REPEAT
  N>L  DUP F@ R>  - ;

: UNLINK:  \  --  | remove given word from dict. linx.
  -FIND 0= 0 ?ERROR  DROP  DUP C>N
  CONTEXT F@  FLINK  IF DROP DUP C>N  CURRENT F@ FLINK DROP
  THEN  >R  C>N N>L F@  R> F! ;
;S
  : foo ;         : bar ;         : baz ;
\ text shipping words: send to lsi-11     ( 29  9 86 CRC 13:25 )
DECIMAL 201 NEEDED BUGOFF ( get terminal prgm)
FORGET TASK   197 NEEDED SAFEOUTS
  : SEND      printer    serial on
        OUTPUT> (PNT)   slTYPE  2DROP  PPAGE   NLIST  (CR) STOP
\ : SEND   PRINT ;
: ABLOCK 16 0 DO I OVER (LINE) TYPE  CTL M EMIT
  6000 0 DO 2 DROP LOOP                         LOOP DROP ;

: BLOCKS  SEND  2DUP BOUNDS DO SAVEOUTS OK I 5 .R RESTOREOUTS
  I ABLOCK  ?TERMINAL IF LEAVE THEN LOOP + ;

: HOST" 0 WORD SEND HERE COUNT TYPE 13 EMIT ;

: TX   ." Sending" SEND  SCR F@ ABLOCK OK TERM ;
: TASK ;
\ Mix machine and forth code              ( 16  9 91 CRC 13:20 )
ASSEMBLER DEFINITIONS
: ]]  ~ CURRENT F@ CONTEXT F! ] ;

FORTH DEFINITIONS
: [[ [COMPILE] ASSEMBLER  [COMPILE] [  ASSEMBLER ~ ; IMMEDIATE
;S
CODE DEMO2   4 # DR0 MOVQ,  DR0 S -[ MOV,
      ]] . 5 . 6 . [[ NEXT ;C
: DEMO1 1 . [[  2 # DR0 MOVQ,  DR0 S -[ MOV,  ]]
      . 3 . ;
    This code is from a handout by Martin Tracy at a Los Angeles
fig meeting, with many improvements by CRC. It is public domain.
It may be used to intermix high level and assembly code, as
these two examples show.
    Greatly simplified by going to jsr threaded code.
\ Transient code support                  ( 19  5 86 CRC  8:27 )
: TRANSIENT  HERE TP F@ DP F! ;  \  --  here | change dict.

: PERMANENT  HERE TP F! DP F! ;  \ here  --  | restore dict.

: PFUI   TIB OVER U< IF TIB - THEN  ;

: PFUI2  PFUI >R PFUI R>         U< ;
;S
: P>C   \ vnfa --- cfa | jump from pseudonfa of a voc
                                \ to its code field
  DUP 2- W@ FF00 AND 6100 = IF  2-  ELSE
    DUP 4- W@  6100 = IF  4-  ELSE
      DUP 6 - W@  4EB9 = IF  6 -  ELSE ABORT" bad link"
           THEN THEN THEN ;

\ Transient code support                  ( 30 11 91 CRC 14:38 )
      BASE F@ HEX                FIRST 4000 - CONSTANT TAREA
     \ set size as needed! Beware of moving disk buffers!
TAREA VARIABLE TP

: ;   [COMPILE] ;  HERE TAREA > IF  0 SETLEN  THEN ;  IMMEDIATE
-1 BLK F@ + LOAD

: DISPOSE  \  --  | get rid of transients
  TAREA TP F!  VOC-LINK    BEGIN DUP   BEGIN F@
    DUP TAREA PFUI2 UNTIL DUP ROT F! DUP 0=  UNTIL  DROP
  VOC-LINK F@ BEGIN DUP 4- F@
     BEGIN  DUP BEGIN N>C C>L F@ DUP TAREA PFUI2
     UNTIL DUP ROT N>C C>L F! DUP 0= UNTIL  DROP
  F@ DUP 0= UNTIL  DROP [COMPILE] FORTH DEFINITIONS ;
BASE F!          EDITOR FLUSH
\ Transient: ~:                           ( 30 11 91 CRC 14:30 )
BASE F@ DECIMAL          78 NEEDED TRANSIENT
: ~: ?EXEC !CSP  CURRENT F@ CONTEXT F!
   TRANSIENT  CREATE  SMUDGE  PERMANENT  REL OFF
   HERE  TRANSIENT  SWAP ,  PERMANENT  ]  \  IMMEDIATE
   DOES>  F@  STATE F@ IF  <SUB>  ELSE  EXECUTE  THEN ;

BASE F!  ;S
Extensions to the transient word set. ~: allows compiling the
head of a word into the transient area, with the body in the
permanent area. They may NOT be immediate words; declare those
transient explicitly anyway.

~: TEST1     1 2 3 4 . . . . ;

: FRED   5 . TEST1  0 . ;
\ More transient code support             ( 30 11 91 CRC 14:37 )
BASE F@  DECIMAL         78 NEEDED TRANSIENT   HEX
: (T;CODE)  IMMEDIATE  R> F@ LATEST N>C REPLACE ;
\ TRANSIENT \ if you wish.
: ;CODE  ?CSP TAREA HERE U< IF COMPILE (T;CODE) DUP , PERMANENT
  4 CSP +!  [COMPILE] ASSEMBLER  [COMPILE] STOP ASSEMBLER ~
  SMUDGE  ELSE  [COMPILE] ;CODE  THEN ; IMMEDIATE
: DOES>  ?CSP TAREA HERE U< IF COMPILE (T;CODE) DUP , PERMANENT
  [ ' DOES> 0A + F@ ] LITERAL <COMP>  FORTH 4 CSP +!
  ELSE  [COMPILE] DOES>  THEN ;  IMMEDIATE  ( PERMANENT) BASE F!
 ;S  These defining word modifiers are used to make the  create
portion of a defining word transient, with the  does>  portion
permanent. N.B. The definitions so produced will finish in the
permanent memory!!!! If the next defintion is to be transient,
this must be explicitly stated!!!!!!  See scr 79.
  N.B: it is the user's responsibilty to set the length to 0!
\ s   object file format utilities          24 01 85 CRC
BASE F@ HEX 0 VARIABLE CHKSUM  C/L VARIABLE (NLL)
  \         checksum of line   nulls count
  \ This format is defined SYS 68K monitor firmware manual, page
  \ D-1 and D-2. Only builds 16 bit address for now. 24 later.

: ABYTE  0 # # 2DROP ;       : ACELL  0 # # # # 2DROP ;

: BUILDCHK  \  addr cnt  --- | checksum in chksum
  2DUP CHKSUM F! ( cnt) 100 /MOD CHKSUM +! CHKSUM +! \ addr
  BOUNDS DO I C@ CHKSUM +! LOOP CHKSUM F@ MINUS 1- CHKSUM F! ;

: BUILDBYTES  \ addr cnt --- | string construction
  SWAP 1- SWAP OVER + DO I C@ ABYTE -1 +LOOP ;
BLK F@ 1+ DUP 1+ THRU BASE F!

\ s   object file format utilities          24 01 85 CRC
: STARTREC  \  -- 0 0 | start record construction
  ASCII S HOLD  0 HOLD  CTL J HOLD  CTL M HOLD ;

: HEADER C/L SPACES ;

: NLL (NLL) F@ 0 DO 0 EMIT LOOP ;

: NULLS (NLL) F! ;

: LASTLINE  \   --   | builds last line of file for type
  <# FC ABYTE 0 ACELL 3 ABYTE  0 ABYTE \ rec type
  STARTREC 0 0 #> NLL TYPE ;

HEX 10 CONSTANT MAXBYTES

\ s   object file format utilities          24 01 85 CRC
: ALINE  \ builds a line in the string construction area
         \ addr cnt ---  addr$ cnt$ ready for typing
  2DUP BUILDCHK  <# CHKSUM F@ ABYTE  2DUP BUILDBYTES
  SWAP ACELL ( addr) 3+ ABYTE ( cnt)
  ASCII 1 HOLD STARTREC 0 0  #> ;

: LINES    \ addr cnt --    | dump contiguous memory
  BEGIN DUP MAXBYTES > WHILE
  2DUP MAXBYTES MIN DUP >R ALINE NLL TYPE  ASCII . (EMIT)
  R> DUP MINUS D+  REPEAT  ?TERMINAL IF DROP MAXBYTES 2/ THEN
  -DUP IF ALINE TYPE ASCII . (EMIT) ELSE DROP THEN ;
;S  download actually in target compiler, scr 250.

: DOWNLOAD  HEX BASE-ADDR DPNEW F@ DELTA - OVER -
  HEADER LINES LASTLINE ;
\  Wordstar Compatible Editor: BJR          20  3 85 CRC
BASE F@ HEX : (Q) BEGIN CURSOR KEY DUP CASE  \ continuous stream
 CTL s OF    -1  M                  ENDOF   \ <-----
 CTL h OF    -1  M                  ENDOF   \ <-----
 CTL d OF     1  M                  ENDOF   \ ----->
 CTL e OF                  1 UP     ENDOF \  up
 CTL x OF                  1 DN     ENDOF \ down
 CTL m OF  #LAG      M        DROP  ENDOF   \ beginning next lin
 CTL n OF  #LOC  DUP  S PL          ENDOF   \ spread screen
 CTL u OF  #LOC  E RSTR             ENDOF   \ erase current line
 CTL y OF  #LOC  DUP  D        PL   ENDOF   \ delete a line
 CTL t OF  #LOC  H                  ENDOF   \ hold current line
 CTL p OF  #LOC     R RSTR          ENDOF   \ replace current li
 CTL b OF  #LOC  DUP  I PL          ENDOF   \ insert contents pa
 CTL r OF     LAST                  ENDOF   \ back a screen
 CTL c OF     NEXT           ENDOF -->  \ next screen forward
\  Wordstar Compatible Editor: BJR          20  3 85 CRC
 CTL o OF      SWAP    O   SWAP     ENDOF   \ other screen
 CTL v OF                   PLACING ENDOF \ keying
 CTL l OF                   MERGE   ENDOF \ bump ln
 CTL q OF KEY CASE  CTL e OF      TOP      ENDOF \ home
                    CTL y of      BLR      ENDOF \ blanks right
                    CTL u OF      UNDO     ENDOF
                       7F OF      BLL      ENDOF \ blanks left
                  ENDCASE       ENDOF
    7F OF      (DEL)                ENDOF \ del
\             ASCII ,  OF KEY DROP .PAD    ENDOF \ f, - show pad
        DUP  DUP  DUP  7F <  SWAP  1F   >  AND
  IF DUP EMIT PLACE ELSE DROP THEN  ENDCASE CTL Z = UNTIL
  BOTTOM ;                                      BASE F!


\ Transient demo stuff                    ( 30 11 91 CRC 14:09 )
DECIMAL   79 NEEDED ~:  80 NEEDED (T;CODE)      EDITOR FLUSH
TRANSIENT
: EQUATE  CREATE  , IMMEDIATE DOES> F@ [COMPILE] LITERAL ;
0 SETLEN                        TRANSIENT
9 3+ 2/ 1- EQUATE FIVE          6 EQUATE SIX

: NEWCON   CREATE  , ;CODE  RP [+ AR0 MOV,
   AR0 [ S -[ MOV,  NEXT  ;C    0 SETLEN

: DEMO3 FIVE . ;                : DEMO4 FIVE SIX + . ;
0 NEWCON ZERO                   1 NEWCON ONE

~: TEST1     1 2 3 4  . .  . .  ;

: FRED   5  .  TEST1  ZERO . ;
\ checkbook language: start                 22  3 85 CRC
DEBUG FORGET TASK
: TASK ;   DECIMAL              VOCABULARY CHECKS IMMEDIATE

: 2CONSTANT  CREATE , , DOES> 2@ ;

CHECKS DEFINITIONS
0 VARIABLE LAST 0 ,

: 10*S  -DUP IF 3 AND 0  \ adjust for decimal point, in cents
  DO 0 SWAP BASE F@ U* DROP ROT BASE F@ U* D+ LOOP THEN ;

: PFLOAT \ pseudo floating point version of number
  NUMBER DPL F@ 1+ IF  2 DPL F@ -  ELSE 2 THEN
  10*S 2DUP LAST 2! ;
EDITOR FLUSH CHECKS  88 91 THRU
\ checkbook language                        24  3 85 CRC
: PFINTERPRET  BEGIN -FIND  IF  ( found)  STATE F@ <
  IF <COMP> ELSE  EXECUTE THEN
     ELSE HERE PFLOAT [COMPILE] DLITERAL
     THEN ?STACK AGAIN     STOP

: $.R  \ d ct ---  | money formatted print
  >R SWAP OVER DABS
  <# # # ASCII . HOLD #S SIGN BL HOLD ASCII $ HOLD #>
  R> OVER  -  SPACES  TYPE ;

:  .S     \ prints out contents of stack non-destructively
  DEPTH  2/ -DUP IF 4 .R ASCII : EMIT  SP@ 8 - SP0 F@ 8 -
  DO  I 2@ 15 $.R -8 +LOOP  ELSE ."    Empty" THEN
  SPACE ;

\ checkbook language                      ( 25 11 92 CRC 10:52 )
: QUIT   [ 'ABORT F@ ] LITERAL  'ABORT F!  WARNING ON
  [COMPILE] FORTH DEFINITIONS SP! CR ."   Bye" QUIT STOP

: 2*   2DUP D+ ;

: X       BLK F@ IF ?EXEC THEN RDROP ;         IMMEDIATE
0 SETLEN                                \ for the esthetics
BASE F@ HEX 80 ' X C>N 1+ C! BASE F!    \  make it "null"

: SEE: [COMPILE] FORTH DEFINITIONS [COMPILE] CHECKS SEE:
  QUIT STOP

: HELP VLIST ;

: OVER  >R >R  2DUP R> R> 2SWAP ;
\ checkbook language                        22  3 85 CRC
: +     D+    ;

: SWAP  2SWAP ;

: DROP  2DROP ;

: DUP   2DUP  ;

: - DMINUS D+ ;

0 0 2CONSTANT 0

\ : UN:  UN: ;


\ checkbook language                        24  3 85 CRC
: R LAST 2@ ;

FORTH DEFINITIONS
: CHECKBOOK -1 WARNING F! SP! DECIMAL CR
   [ LATEST N>C ] LITERAL 'ABORT F!
   ."  real-forth Checkbook Language"
   BLK OFF   [COMPILE] [  [COMPILE] CHECKS DEFINITIONS  CHECKS
   BEGIN RP! CR ." > " QUERY PFINTERPRET  CR .S AGAIN  STOP

FORTH CHECKS ' QUIT FORTH C>N N>L OFF  \ seal vocabulary
CHECKBOOK




\ lower -- change a string to lower case  ( 15  5 93 CRC 14:27 )
BASE F@ HEX

CODE LOWER  S [+ DR0 MOV,  S [+ AR0 MOV,
  ASCII A # DR2 .B MOVQ,  ASCII Z # DR3 .B MOVQ,  DR0 FALSE DO,
  AR0 [ DR1 .B MOV,  DR1 DR3 .B CMP,  HS IF,  DR1 DR2 .B CMP,
    LS IF,  20 # AR0 [ .B EOR,  THEN,  THEN,   1 # AR0 ADDQ,
    LOOP, NEXT   ;C

BASE F!






















\ experimental: is                        ( 30 11 91 CRC 15:33 )
DEBUG  \ e.g.  ' (emit) is 'emit
BASE F@ DECIMAL  102 NEEDED ABORT"       BASE F!

: (IS)   R> DUP 4+ >R  F@ EXECUTE F! ;

: ISOK   DUP (RES) DUP  [ ' FLD (RES) ] LITERAL  -
  SWAP [ ' IP (RES) ] LITERAL -  AND
  IF HERE COUNT TYPE  ABORT"  isn't a proper Vector!" THEN ;

: IS   -FIND  IF  DROP  ISOK
    STATE F@ IF  COMPILE (IS)  ,  ELSE  EXECUTE F!  THEN
    ELSE  0 ERROR  THEN ;               IMMEDIATE

: FRED  ' (EMIT) IS FLD ;
EDITOR FLUSH
\ data swap in memory                     ( 28  6 90 CRC 20:07 )
DEBUG  FORGET TASK                FORTH DEFINITIONS  : TASK ;

CODE DSWAP  \ src dst ct  ---  | swap data bet. two locs
  S [+ DR7 MOV,  S [+ AR0 MOV,  S [+ AR1 MOV,
  1 # DR7 SUBQ,  DR7 FALSE DO,
     AR1 [ DR1 .B MOV,  AR0 [ AR1 [+ .B MOV,
     DR1 AR0 [+ .B MOV,  LOOP,  NEXT  ;C

BASE F@ HEX
FIRST 100 - CONSTANT FOO    FOO 100 ERASE
FOO   100 - CONSTANT BAR    BAR 100 BLANKS
BASE F!
EDITOR FLUSH    FORTH


\ Will Baden Calendar Code                ( 26  6 94 CRC 14:02 )
DECIMAL FORTH DEFINITIONS  FORGET TASK    102 NEEDED ABORT"
\ : task ;
CODE UNDER+     \ a b c --- a+c b | ROT + SWAP ;
  S [+ DR0 MOV,  DR0 S 4 &[ ADD,  NEXT ;C

: >DAY  -3 UNDER+   OVER 0< IF 12 UNDER+ 1- THEN   \ dd mm yy
  ( 1900 MOD ) 1461 4 */   SWAP 153 * 2+ 5 / + + ; \ -- d.o.c.

: NEW/FULL      \ day --- semi-lunation age
  1700 25101 OVER >R  */MOD  SWAP R> / ;

: D/MP          \ centday monthday ---   | Print day/phase
  OVER NEW/FULL IF DROP 3 .R
  ELSE SPACE 1 AND IF ASCII F ELSE ASCII N THEN EMIT
       ASCII M EMIT DROP THEN ;         -->
\ Will Baden Calendar Code                ( 26  6 94 CRC 14:02 )
: >DATE  4 U*   -1. D+ 1461 M/MOD DROP
  SWAP 4 / 1+ 5 * 3 - 153 /MOD   SWAP 5 / 1+  SWAP 3+
  ROT OVER 12 >  IF -12 UNDER+ 1+ THEN ;

: DOW ( day of cent. --- day of week ) 3+ 0 7 M/MOD 2DROP ;

: MNTH \ y m | build a month name, print it centered in calendar
  CREATE ASCII " WORD HERE C@ 1+ ALLOT
  DOES> COUNT 17 OVER - 2/ TAB TYPE ASCII , EMIT 1900 + 5 .R ;

MNTH JAN January"    MNTH FEB February"    MNTH MAR March"
MNTH APR April"      MNTH MAY May"         MNTH JUN June"
MNTH JUL July"       MNTH AUG August"      MNTH SEP September"
MNTH OCT October"    MNTH NOV November"    MNTH DEC December"
                 -->
\ Will Baden Calendar Code                ( 18 10 94 CRC 14:29 )
: +DAYS  >R >DAY R> + >DATE ;

: APART  >DAY >R  >DAY R> - ;

MSSG .SU Sun"  MSSG .MO Mon" MSSG .TU Tues"  MSSG .WE Wednes"
MSSG .TH Thurs" MSSG .FR Fri"  MSSG .SA Satur"

: .DOW    EXEC .SU .MO .TU .WE .TH .FR .SA  STOP

: .MONTH  SWAP 1- EXEC  JAN FEB MAR APR MAY JUN
        JUL AUG SEP OCT NOV DEC STOP  -->
This code treats March as the first day of the year. Thus, 1900
"starts" on 1 March, 1900, and the 0th day of the century is 28
February, 1900. From a handout at Orange County fig, 3, 85.

\ Will Baden Calendar Code                ( 26  6 94 CRC 14:01 )
: CALENDAR  \ m y ---  | print out calendar
  LNCTR F@ [ 487 7 8 * - ] LITERAL > IF PAGE THEN
  CR OVER 1 12 WITHIN 0= IF ABORT" Month Out of Range" THEN
  2DUP .MONTH CR  2DUP 1 ROT ROT >DAY  DUP DOW 3 * SPACES
  1 2SWAP 1 UNDER+ >DAY   OVER - 1+ 1
  DO  I D/MP  1+ DUP DOW 0= IF CR THEN LOOP DROP ;

: MONTHS  0 DO  2DUP CALENDAR
  SWAP 1+ DUP 13 = IF DROP 1+ 1 THEN SWAP
  ?TERMINAL IF LEAVE THEN  LOOP 2DROP ;

: YEAR   1 SWAP 12 MONTHS ;  \  y -- year printed out

: WEEKS  7 * ;
-->
\ Will Baden Calendar Code                ( 26  6 94 CRC 14:02 )
CODE 3DUP  \ a b c --- a b c a b c
  S [+ DR0 MOV,  S [+ DR1 MOV,  S [ DR2 MOV,
  DR1 S -[ MOV,  DR0 S -[ MOV,
  DR2 S -[ MOV,  DR1 S -[ MOV,  DR0 S -[ MOV,
  NEXT ;C

: TODAY  SYSDATE  1900 -
  >DAY DOW .DOW ." day " TEMPORES SPACE ;

: MONTH  SYSDATE  1900 -  SWAP
  1-  DUP 0= IF  12 +  -1 UNDER+  THEN  SWAP 3 MONTHS  DROP ;

( : SETDATE SETDATE PTODAY ;)
-->

\ Will Baden Calendar Code                ( 26  6 94 CRC 14:01 )
: PDATE      \ d m y ---  | date pretty printed
  BASE F@ DECIMAL >R  ROT  <# 0 $SIZE #> TYPE   \ day
  1900 - .MONTH  R> BASE F! ;

: .DAY  3DUP 1900 -  >DAY DOW .DOW ." day "
  PDATE  SPACE .TIME SPACE ;

: PTODAY  sysDATE  .DAY ;

ATEXIT: PTODAY                  ATCOLD: PTODAY
DECIMAL CR PTODAY CR : TASK ;




\ ," seq abort"                           ( 17  9 88 CRC 11:56 )
: ,"  ASCII " WORD HERE C@ 1+ ALLOT ;
\ : (,")  R DUP C@ 1+  =CELLS  R> + >R ;
\ : ,"  COMPILE (,") ASCII " WORD HERE C@ 1+ =CELLS ALLOT ;
\                                                   IMMEDIATE
: SEQ     \ build a control sequence the hard way
  CREATE   DOES> COUNT TYPE ;

: (ABORT")  OK  R> COUNT TYPE  SP! DECIMAL
  BLK F@ IF IN F@ BLK F@ THEN
  [COMPILE] FORTH  DEFINITIONS ( OFFSET OFF ) QUIT  STOP
LATEST N>C   DECOMPILER  '(ABORT") F!
: ABORT"  COMPILE (ABORT") ASCII " WORD
  HERE C@ 1+ =CELLS ALLOT ;  IMMEDIATE  ;S examples of useage:
: T   IF ABORT" Non-zero number!"  THEN ;
MSSG HI Hi, my name is Fred. "   : HELLO HI ;
\ Conditional interpretation test screen    17  4 85 CRC
CR ." This is always executed."

IFTRUE    CR ." This is the true part of the screen."
OTHERWISE CR ." This is the false part of the screen."
IFEND

CR ." This is always executed."








\ disk blocks present in memory           ( 10  6 92 CRC 12:34 )
FORGET TASK   BASE F@ HEX   FORTH DEFINITIONS
: .BLK  DUP 7FFFFFFF AND  MAXBLK OVER <  IF ."    flushed"
  DROP  ELSE  0A .R  THEN  0< IF ."  updated" THEN ;
: PRESENT    \  ---  |lists current blocks in memory
  BASE F@ DECIMAL CR  PREV F@  BEGIN  DUP F@  .BLK  COL
  +BUF  0= UNTIL DROP ?CR BASE F! ;
: ?PRESENT (  -- addr or 0 | is given blk here?) OFFSET F@ + >R
  0 PREV F@  BEGIN  SWAP OVER F@ 7FFFFFFF AND  R =
  IF  R OFFSET F@ - BLOCK  ELSE  0  THEN  OR
  SWAP  +BUF 0=  UNTIL  R> 2DROP  ;
CODE UNUPDATE \  --   | flag current buffer as not updated
  OFUSER PREV AR0 MOV,  7 # AR0 [ .B BCLR,  NEXT  ;C
: EMPTY-BUFFERS   EMPTY-BUFFERS    PREV F@
  BEGIN 7FFFFFFF OVER F!  +BUF 0= UNTIL  DROP ;
DECIMAL  PRESENT  BASE F!                : TASK ;
\ will baden's square root                ( 13  6 86 CRC  9:14 )
: SQRT \ n1 --- n2 | calculate square root of n1
  -1 SWAP OVER DO 2+ DUP +LOOP 2/ ;













\ module creation code -- internal externa( 20 10 85 CRC       )
1 CONSTANT TRUE                 : FALSE 0 ;

: INTERNAL \   --- dest | begin code to hide later on
  ?EXEC     LATEST    ;   IMMEDIATE

: EXTERNAL \   --- src  | end code to hide
  ?EXEC     HERE   4+ ;   IMMEDIATE \ skip see: field

: MODULE   \ dest src ---  | hide the stuff
  ?EXEC     F! ;   IMMEDIATE
;S      \ moved to kernel
: ON       \ addr ---  | turn a flag on
  TRUE  SWAP F! ;

: OFF  FALSE SWAP F! ;
\ Conditional interpretation              ( 30  7 90 CRC 21:28 )
DECIMAL FORTH DEFINITIONS 106 NEEDED MODULE
INTERNAL 0 VARIABLE FLAG     LATEST
: IFEND     FLAG ON ;        ' IFEND C>N N>L
: OTHERWISE IFEND   ;
: X        23  ERROR ;     \ all nulls are off screen!!
  128 LATEST 1+ C! \ makes it into the null word!!
LATEST ROT CURRENT F@ F! SWAP OFF \ instant hidden vocabulary!
EXTERNAL SWAP   \ pointer to nfa of of null on top of stack
: OTHERWISE  \  ---  | scan until terminator found
  FLAG OFF BEGIN [ ROT ] BEGIN [ ROT ]  BL WORD   HERE LITERAL
  (FIND) UNTIL DROP EXECUTE FLAG F@ UNTIL  [ 4 CSP +! ] ;
: IFTRUE \ fl --- | scan if false, else interpret
  0= IF OTHERWISE THEN ;
: IFEND  ; (  placeholder )      MODULE   \ hide it!
: DEF:  -FIND  DUP IF  NIP NIP  THEN ;
\ disk re-arrangement code                ( 10  6 86 CRC 10:51 )
BASE F@ DECIMAL  DISKING DEFINITIONS
B/DRV    VARIABLE TOBLK         \ disk re-arrangement: see the
: SKIP   EDITOR NEXT BOTTOM ;   \ real-Forth manual
: SEND SCR F@ TOBLK F@ EDITOR COPY TOBLK 1+! SKIP ;
: REP   DUP B/DRV  + EDITOR COPY ;
: ALLOT  TOBLK +! ;             : START B/DRV + TOBLK F! ;
: STDBUFS  FLUSH 112 +ORIGIN F@ 'FIRST F! SETU/P ;
: MAXBUFS  LIMIT DUP PAD - B/BUF 6 + / B/BUF 6 + *
  - 'FIRST F! EMPTY-BUFFERS FLUSH ;   \ from-2 to-1  | backup
: BACKING FLUSH ( MAXBUFS) 1+ SWAP CR DO FORTH I DUP DUP
   ?TERMINAL IF LEAVE THEN       \  back up given screens
   #BUFS  MOD 0= IF FLUSH THEN  4 .R REP
   OUT F@ C/L > IF CR THEN LOOP ( STDBUFS) FLUSH ;
: BACKUP   0 B/DRV 1- BACKING ;
FORTH DEFINITIONS   DISKING BASE F!
\ Memo  Application                       ( 13  6 86 CRC 15:00 )
FORTH DEFINITIONS  BASE F@ DECIMAL
: DOSCREEN  \ screen  DOSCREEN
  16 1 DO DUP I SWAP 7 SPACES .LINE CR LOOP DROP ;

: MEMO     \ Prints three screens a memo     ( screen-1 -- )
  5 VTAB CR 3 / 3 * DUP 3+ SWAP
  DO I DOSCREEN LOOP CR ?crt 0= if PAGE then ;

: REVIEW   \ Prints three screens for review ( screen-1 -- )
  ?CRT IF PAGE 5 VTAB CR
  3 / 3 * DUP 2+ SWAP BEGIN DUP
  DOSCREEN 2DUP - WHILE DUP  4 .R ."   continue " KEY DROP
  1+ 15 0 DO 8 EMIT LOOP EDITOR ERL REPEAT CR 2DROP THEN ;
BASE     F!

\ Disking Extensions: Bulkclear           ( 24 10 85 CRC       )
BASE F@ DECIMAL DISKING DEFINITIONS     \ See the real-Forth
: BULKCLEAR  CR   \  from-2  to-1  wipe-screens          manual
   FIRST HERE - 1094 U< 2 ?ERROR 0 PAD DUP B/BUF BLANKS W!
   1+  SWAP DO PAD FORTH I DUP 6 .R OFFSET F@ + 0 R/W
   OUT F@ C/L > IF CR THEN  LOOP  ;

: CLEARDISK  B/DRV MAXBLK BULKCLEAR ;

        FORTH DEFINITIONS        DISKING       BASE F!  ;S
     Use  BULKCLEAR to put sector information on a new disk or
to clean out a series of screens on an otherwise useful disk.
To put new sector information on a new disk, first initialise it
using  INIT , then (while it is still in 1 drive), type:
   CLEARDISK

\ More Will Baden Calendar: New Moon      (  5  7 86 CRC 12:25 )
: NEW/FULL      \ day --- semi-lunation age
  1700 25101 OVER >R  */MOD  SWAP R> / ;

: D/MP          \ centday monthday ---   | Print day/phase
  OVER NEW/FULL IF DROP 3 .R
  ELSE SPACE 1 AND IF ASCII F ELSE ASCII N THEN EMIT
       ASCII M EMIT DROP THEN ;                 ;S

: CALENDAR      \ m y ---  | print out calendar
  DO I NEW/FULL 1+ DUP DOW 0= IF CR THEN LOOP DROP ;
  DO I 3 .R 1+ DUP DOW 0= IF CR THEN LOOP DROP ;

: TUCK  SWAP OVER ;

obsolete screen
\ Hard disk support                       ( 26 10 86 CRC 14:11 )
FILING                          FILING DEFINITIONS
  \  open file & set lseek first. Close when done!
: >FILE  \ blk# ct  ---  | write to file from disk
  EMPTY-BUFFERS FLUSH
  BOUNDS CR DO  I 5 .R  I BLOCK B/BUF HANDLE F@ WTF
  DUP B/BUF - IF 6 .R ABORT"  Disk Error! "  ELSE DROP THEN
  ?TERMINAL IF LEAVE THEN ?STACK  LOOP ;

: FILE>  \ blk# ct  ---  | write to disk from file
  EMPTY-BUFFERS FLUSH
  BOUNDS CR DO  I 5 .R  I OFFSET F@ + BUFFER B/BUF HANDLE F@ RDF
  DUP B/BUF - IF 6 .R ABORT"  Disk Error! "  ELSE DROP THEN
  ?TERMINAL IF LEAVE THEN ?STACK  UPDATE LOOP  FLUSH ;
FORTH DEFINITIONS               EDITOR FLUSH FILING

\ times code: repeat a given word         ( 30 11 91 CRC 19:59 )
DECIMAL FORTH DEFINITIONS   54 NEEDED FOR   76 NEEDED [[
CODE I'  8 RP &[ S -[ MOV,  NEXT        ;C      FIXED
fix for index & limit in registers!
CODE R>DROP    4 # RP ADDQ,  NEXT       ;C

: (TIMES) \ ct ---  | execute next cfa ct times
  [[ RP [ AR0 MOV,  4 # RP [ ADDQ,  AR0 [ RP -[ MOV, ]]
  1- FOR  I' EXECUTE  NEXT R>DROP  ;

: TIMES         \ --- | compile working word for times
  COMPILE (TIMES)
  -FIND  IF DROP , ELSE  0 ERROR THEN ; IMMEDIATE FIXED

: T  1 5 TIMES 2* ;           EDITOR FLUSH   FORTH

































\ Disking: check  range  verify           ( 14  4 19 crc 16:31 )
DISKING DEFINITIONS
: CHECK \  scr-2 scr-1 --   | check a screen against another
  2dup block w@  swap block w@  or if \ silent on blanks
  2DUP BLOCK B/BUF  ROT BLOCK
  EDITOR -CSTEXT  IF  9 .R 7 .R  ELSE  2DROP  THEN
  else 2drop then ;
: VERIFY CR  \ St-3 Compareto-2 cnt-1 | over a range of scrs
  BOUNDS DO  I #BUFS 2/ MOD 0= IF  I  #BUFS 2/  BOUNDS
  DO I BLOCK DROP LOOP  THEN    \ look-ahead to cut head motion
  I OVER CHECK 1+ ?TERMINAL IF LEAVE THEN  ?STACK  LOOP  DROP ;

: VERIFYDISK   EDITOR FLUSH DISKING  0 B/DRV DUP VERIFY ;
CODE 3DUP  S [+ 7 # MOVM, 7 # S -[  MOVM, 7 # S -[  MOVM,  NEXT
        ;C
: COPIES  3DUP COPIES 2DROP VERIFY ;  \ requires hdisk util!!
\ Brodie Doer/Make code                   ( 23 11 91 CRC 12:02 )
\ From Brodie, Thinking FORTH, pg 276 et seq. Public domain.
DECIMAL DEBUG       \ real-FORTHed by CRC.
0 VARIABLE MARKER   \ N.B. This stuff is not ROMable.
: DOER  CREATE  ' | , DOES> F@ >R  ;

CODE (MAKE)  RP [+ AR0 MOV,  AR0 [+ DR1 MOV,
  NE IF,  DR1 RP -[ MOV,  THEN,
  AR0 [+ AR1 MOV,  AR0 AR1 [ MOV,  NEXT  ;C  FIXED
: MAKE  STATE F@  IF COMPILE (MAKE)  HERE MARKER F!  0 ,
    -FIND  IF  DROP C>P  ,  ELSE
       HERE COUNT TYPE  ABORT" : can't find!" THEN
    ELSE HERE [COMPILE] ' F! SMUDGE [COMPILE] ] THEN ; IMMEDIATE

: ;AND  ASSEMBLER RTS,  HERE MARKER F@ F! ; IMMEDIATE
: UNDO  ' |  [COMPILE] ' C>P F! ;   -->
\ Brodie Doer/Make code                   ( 23 11 91 CRC 12:12 )
DOER <WHY?>
: RECITAL
  CR ." Your daddy is standing on the table. Ask him 'Why?' "
  MAKE <WHY?> ." To change the lightbulb."
       BEGIN
  MAKE <WHY?> ." Because it's burnt out."
  MAKE <WHY?> ." Because it was old."
  MAKE <WHY?> ." Because it was in there a long time ago."
  MAKE <WHY?> ." Because it was dark!"
  MAKE <WHY?> ." Because it was night time!!"
  MAKE <WHY?> ." Stop saying WHY?"
  MAKE <WHY?> ." Because it's driving me crazy."
  MAKE <WHY?> ." Just let me change this light bulb!"
     AGAIN  STOP
: WHY?  <WHY?> QUIT STOP        RECITAL         EDITOR FLUSH
\ Other Brodie useful code                ( 23  4 93 CRC  9:01 )
DEBUG
: EXIT  ;     2 SETLEN

: \S  B/BUF IN F! ;

: FH   BLK F@ -DUP 0= IF SCR F@ THEN + ;  \ same as rf's +blk

CODE LEAP   8 # RP ADDQ,   NEXT   ;C     4 SETLEN
                         \ the instruction in ;s
EDITOR FLUSH  \S
: TST 10 0 DO I . I 5 = IF LEAP THEN LOOP ;




\ real-FORTH decompiler: load             ( 23 10 91 CRC  9:45 )
VOCABULARY DECOMPILER IMMEDIATE DECOMPILER DEFINITIONS

BASE F@ HEX                     0 VARIABLE '(ABORT")

: !QUIT!  ?QUIT ON ;

: .$  IP F@ C>P  DUP IP F!
  COUNT  DUP 1+ =CELLS  IP +!  TYPE  ASCII " EMIT  ;

: .label  4 .line  space ;

: PDOTQ   2 .label  .$ ;

HEX     -->
CODE SEXT  S [ DR0 MOV,  DR0 AR0 .W MOV,  AR0 S [ MOV,  NEXT ;C
\ real-FORTH decompiler: pdotq .lit  .word( 24  2 92 CRC 10:49 )
: N.  BASE F@ SWAP DUP DECIMAL 12 .R HEX ."  $ " 9 U.R BASE F! ;

: DISP  DUP T@ N. 3 SPACES 4 ASCI ;

: B/JSR?        \  -- fl | is there a call here?
  IP F@ W@  DUP 4EB9 =   OVER 4EF9  =
  ROT  FF00 AND  6100 =  OR OR ;

: .WORD         \ given a cfa, display name field, if any
  IP F@  DISASSEMBLER INST  CR 6 TAB
  DUP  (RES) DUP  3 - TC@ 80 AND
  IF C>N AID.  ELSE  7 .R ."  <orphan>"  THEN
  W@  4EF9 = IF !QUIT! THEN ;

: DOABORT"  9 SPACES  ." Abort" ASCII " EMIT  SPACE  .$ ; -->
\ real-FORTH decompiler: comp  .pscode var( 18 10 91 CRC 20:00 )
: .BRANCH       \ calculate the target address & show it
  IP F@ C>P  DUP  DUP TW@ XTEND  + 7 U.R  2+  IP F! ;

: ENDER  .WORD !QUIT! ;

: COMP   .WORD   3 .label  IP F@  4 IP +!
  T@ C>N AID. ;

: .PSCODE  IP F@  C>P (RES)  [ ' DOES> 0A + T@ ] LITERAL =
  IF  5 SPACES ." does>"  IP F@  C>P C>P  IP F!  ELSE
    ENDER  IP F@ DISASSEM THEN ;

: CONST    CR   6 .label  C>P      DISP  ;  -->


\ real-FORTH decompiler: begin (un:)      ( 16  9 91 CRC  9:23 )
: USERV    CR   4 .label   EXECUTE  DISP  ;

: VAR      CR   5 .label   EXECUTE  DISP  ;

: <UN:>   \ cfa ---   | decompiled code
  B/JSR? IF IP F@
  DUP 0< OVER FIRST > OR IF !QUIT! DROP ELSE  (RES) CASE
[ ' (LOOP)    ] LITERAL OF  9 .label     .BRANCH       ENDOF
[ ' (+LOOP)   ] LITERAL OF 0A .label     .BRANCH       ENDOF
[ ' (OF)      ] LITERAL OF 0F .label     .BRANCH       ENDOF
[ ' (.")      ] LITERAL OF               PDOTQ         ENDOF
[ ' <COMPILE> ] LITERAL OF               COMP          ENDOF
[ ' (;CODE)   ] LITERAL OF               .PSCODE       ENDOF
   -->

\ real-FORTH decompiler:  end (un:)       ( 23 11 91 CRC 12:33 )
[ ' QUIT      ] LITERAL OF               ENDER         ENDOF
[ ' ABORT     ] LITERAL OF               ENDER         ENDOF
[ ' @EXECUTE  ] LITERAL OF               ENDER         ENDOF
  '(ABORT") F@          OF               DOABORT"      ENDOF
  .WORD  ENDCASE THEN   ELSE
  IP F@ W@ [ 4E75 ( rts, ) ] LITERAL = IF  !QUIT! THEN
  DISASSEMBLER INST  THEN  CR ;

: (UN:)   \ cfa ---   | decompiled code
  ?QUIT OFF   IP F!   CR  BEGIN  ?STACK  <UN:>
  ?QUIT F@ ?TERMINAL OR  UNTIL ;
-->



\ real-FORTH decompiler: defined testcfa  ( 16  9 91 CRC 17:02 )
: DEFINED  \  cfa ---   | decompile does> portion of defining.
  DUP C>P  30 DUMP  ." Defined Word Does>" (RES) C>P (UN:) ;

: TESTCFA   \   cfa ---  | check for type of word
  DUP (RES) CASE
[ ' IP   (RES) ] LITERAL OF             VAR             ENDOF
[ ' C/L  (RES) ] LITERAL OF             CONST           ENDOF
[ ' BASE (RES) ] LITERAL OF             USERV           ENDOF
(RES) [ EDITOR ' PROGRAMMER (RES) (RES) ] LITERAL
   OF             DEFINED         ENDOF  SWAP (UN:) ENDCASE ;

-->



\ real-FORTH decompiler:  un: vectors     ( 16  9 91 CRC 17:02 )
DECIMAL FORTH DEFINITIONS       \  See User's Guide
: UN:   DECOMPILER  FUDGE OFF
  BASE F@ HEX  -FIND IF C/L AND IF  12 .label   THEN
    DUP C>N  CR AID.  13 .label   TESTCFA
    ELSE  11 .label   THEN  BASE F!  ;

: VECTORS  \ addr ---  | print out name of word in vector
  F@ C>N AID. ;

BASE F!





\ disking: exercise redisk                (  3  7 90 CRC 18:45 )
  BASE F@  DECIMAL   DISKING DEFINITIONS

: EXERCISE  0 DO  I BLOCK DROP UPDATE
    ?TERMINAL IF LEAVE THEN LOOP FLUSH ;


FORTH DEFINITIONS   BASE   F!   ;S


: REDISK ( MAXBUFS) B/DRV 0 CR DO I DUP BLOCK DROP UPDATE 4 .R
     ?TERMINAL IF LEAVE THEN LOOP FLUSH STDBUFS ;




( Substitute CREATE for auto sourcecode li( 18  4 94 CRC 10:25 )
   BASE F@ HEX       ' (CREATE) 'CREATE F!
: WHERETHEN     ( unpack line# & blk :   ---  r#-2  scr-1 )
  DUP  -20 AND  5 2/S OFFSET F@ -  SWAP 1F AND  5 2*S  ;
: L>S   4- ;                    DECIMAL

: NEWCREATE   (CREATE)
    C/L OUT F@ < IF CR THEN ;     ' NEWCREATE 'CREATE F!

: SEE:  -FIND IF DROP  C>N N>L L>S F@   \ See real-Forth manual
       WHERETHEN R# F! -DUP IF EDIT ELSE ." terminal "  THEN
  ELSE 14 MESSAGE 4 SPACES THEN ;

: FORGET  [COMPILE] FORGET STATE F@ IF -4 [COMPILE] LITERAL
  COMPILE ALLOT ELSE -4 ALLOT THEN ; IMMEDIATE
               HERE FENCE F!    BASE F!
\ pick & roll in code                     ( 13  2 89 CRC 16:42 )
BASE F@ HEX  >R
CODE PICK   S [ DR0 MOV,  ( PL IF,)  2 # DR0 ASL,
            0 S 0 &D[ S [ MOV,  ( THEN,)  NEXT ;C

CODE ROLL   S [ DR0 MOV,  DR0 DR1 MOV,  1 # DR1 SUBQ,
  PL IF,  2 # DR0 ASL,  S DR0 ADD,  DR0 AR0 MOV,  AR0 [ S [ MOV,
  AR0 4 &[ AR1 LEA,  FALSE DR1 DO,  AR0 -[ AR1 -[ MOV,  LOOP,
      AR1 S MOV,  ELSE,  4 # S ADDQ,  THEN,  NEXT ;C

CODE 4DUP  4 1- # DR0 MOVQ,
  FALSE DR0 DO,  S 0C &[ S -[ MOV,  LOOP,  NEXT ;C

CODE TUCK  S [+ AR0 MOV,  S [ S -[ MOV,  AR0 S -[ MOV,  NEXT ;C

R> BASE F!
\ (tkey)                                  ( 10  2 92 CRC 12:35 )
BASE F@   0 VARIABLE KEYCODE HEX
CODE ?KEY  \   --- fl | is there a key ready?
 2 # OFUSER I/O .W CMP,  EQ IF,  DROP \   Unstructured!!
 KEYCODE @#L .W TST,  NE IF,  1 # DR0 MOVQ,  ELSE,  ROT 2 THEN,
 OFUSER I/O RP -[ .W MOV,
 1 # RP -[ .W MOV,  0D # TRAP,  4 # RP ADDQ,  THEN,
 DR0 S -[ MOV,  NEXT ;C

CODE <KEY> \  --- key/code | get the key; return it
 KEYCODE *+ AR5 LEA,  AR5 [ .W TST,  EQ IF,
 OFUSER I/O RP -[ .W MOV,  2 # RP -[ .W MOV,  0D # TRAP,
 4 # RP ADDQ,  DR0 .W TST,  EQ IF,  DR0 DR1 MOV,  DR1 .W SWAP,
 DR1 AR5 [ .W MOV,  THEN,  ELSE,
 AR5 [ DR0 .W MOV,  AR5 [ .W CLR,  THEN,
 FF #L DR0 AND,  DR0 S -[ MOV,  NEXT ;C   DECIMAL  -->
\ trial hi level (?terminal)              ( 28  7 87 CRC 20:56 )
CODE KEYMODE  \ mode ---  stat | get/set keyboard mode
  S [ DR0 MOV,  DR0 RP -[ .W MOV,  11 # RP -[ .W MOV,
  13 # TRAP,  4 # RP ADDQ,  DR0 S [ MOV,  NEXT ;C

: .CLOCK DUP (GETTIME) - IF OUT F@  \ oldtime --- new | showtime
  SV.CUR NO.CURSOR REV.ON  0 72 GOTOXY .TIME  1 72 GOTOXY .DATE
  2 72 GOTOXY   ." Caps o"
      -1 KEYMODE 16 AND IF ." n " ELSE ." ff" THEN
  REV.OFF CURSOR RST.CUR OUT F! DROP (GETTIME) THEN  ;

: (TKEY) KEYCODE 2+ W@ BEGIN PAUSE .CLOCK ?KEY UNTIL
  KEYCODE 2+ W! <KEY> ;

: OKEY  [ ' (KEY)   ] LITERAL 'KEY F! ;
: TKEY  [ ' (TKEY)  ] LITERAL 'KEY F! ;   TKEY   BASE F!
\ clock stuff: primitives                 (  9  7 86 CRC 15:27 )
BASE F@ HEX
CODE (GETTIME) \   ---  n | n is bit packed time from rtc
  2C # RP -[ .W MOV,  1 # TRAP,  2 # RP ADDQ,
  DR1 CLR,  DR0 DR1 .W MOV,  DR1 S -[ MOV,  NEXT ;C

\ CODE (SETTIME) \ n  --- | n is bit packed time to rtc
\ S [+ DR0 MOV,  DR0 RP -[ .W  MOV,  DR0 CLR,
\ 2D # RP -[ .W MOV,  1 # TRAP,  4 # RP ADDQ, DR0 S -[ MOV, NEXT
\   ;C
CODE (GETDATE) \   ---  n | n is bit packed date from rtc
  2A # RP -[ .W MOV,  1 # TRAP,  2 # RP ADDQ,
  DR0 S -[ MOV,  NEXT ;C

F0 USER (STAMP)
BLK F@ 1+ DUP 2+ THRU BASE F!
\ clock stuff: settime                    (  9  7 86 CRC 15:29 )
\ CODE (SETDATE) \ n  --- | n is bit packed time to rtc
\ S [+ DR0 MOV,  DR0 RP -[ .W  MOV,
\ 2B # RP -[ .W MOV,  1 # TRAP,  4 # RP ADDQ,  NEXT ;C

: SEXTAL  DECIMAL # 6 BASE F! # ASCII : HOLD 2DROP ;

: H/M  0 0 ROT (NUMBER) DUP C@ ASCII : - 0 ?ERROR ;

\ : SETTIME  \  ---  | n is packed time for rtc
\ BASE F@ >R DECIMAL BL WORD HERE H/M H/M
\    0 0 ROT (NUMBER) 2DROP 2/ NIP SWAP BL * OR
\    NIP SWAP  800 * OR  R> BASE F! (SETTIME)
\ 0 ?ERROR ;

: $SIZE  BL HOLD OVER 0A < >R #S R> IF BL HOLD THEN ;
\ clock stuff: (date) stampdate setdate   (  4  6 86 CRC 11:28 )
: <DATE>     \   ---  addr ct | date ready for printing
  BASE F@ DECIMAL >R  <# 200 /MOD 50 + 64 MOD 0 # #
  2DROP BL /MOD 0 $SIZE 2DROP 0 $SIZE #> R> BASE F! ;
: (date)  (getdate) <date> ;

: STAMPDATE (DATE) (STAMP) 2+ SWAP CMOVE ;
      \          | <--------  optional  ---------> |
: .DATE  (DATE)  OVER ASCII / SWAP 2+ 2DUP 3 + C! C! TYPE ;
;S
: SETDATE  \  ---   | date is packed for rtc
  BASE F@ DECIMAL
  BL WORD 0 0 HERE (NUMBER) 2DROP               \ day
  BL WORD 0 0 HERE (NUMBER) 2DROP   BL  *  +  \ month
  BL WORD 0 0 HERE (NUMBER) 2DROP  DUP 50 < IF  64 + THEN
  50 - 200 * +  ( year)   (SETDATE) BASE F! ;
\ clock stuff: gettime .time stamptime    ( 21  6 94 CRC 12:26 )
: <GETTIME>    \ n  ---  addr ct | time ready for printing
  BASE F@ >R DECIMAL  <# BL /MOD SWAP 2* 0 SEXTAL C/L /MOD
  SWAP 0 SEXTAL DECIMAL DUP 0A < >R 0 #S R> IF BL HOLD THEN #>
  R> BASE F! ;
: GETTIME  (GETTIME) <GETTIME> ;

: .TIME  GETTIME TYPE ;

: STAMPTIME GETTIME 3 - (STAMP) 0F + DUP 5 BLANKS SWAP CMOVE ;

: SETSTAMP   STAMPDATE STAMPTIME ;

: TEMPORES   .DATE SPACE .TIME ;
;s debugging tools
: TEMPUS  BEGIN CR tempores ?TERMINAL UNTIL ;
































\ clock stuff: primitives                 (  9  7 86 CRC 15:27 )
BASE F@ HEX
CODE (GETTIME) \   ---  n | n is bit packed time from rtc
  2C # RP -[ .W MOV,  1 # TRAP,  2 # RP ADDQ,
  DR1 CLR,  DR0 DR1 .W MOV,  DR1 S -[ MOV,  NEXT ;C

\ CODE (SETTIME) \ n  --- | n is bit packed time to rtc
\ S [+ DR0 MOV,  DR0 RP -[ .W  MOV,  DR0 CLR,
\ 2D # RP -[ .W MOV,  1 # TRAP,  4 # RP ADDQ, DR0 S -[ MOV, NEXT
\   ;C

: SEXTAL  DECIMAL # 6 BASE F! # ASCII : HOLD 2DROP ;

: H/M  0 0 ROT (NUMBER) DUP C@ ASCII : - 0 ?ERROR ;
F0 USER (STAMP)
BLK F@ 1+ DUP 3 + THRU BASE F!
\ clock stuff: primitives                 ( 18 10 94 CRC 17:06 )
CODE EXPANDDATE         \ w --- d m y | expand from packed word
  S [+ DR0 MOV,  BEGIN,  >R >R
  DR0 DR1 MOV,  1F # DR1 .W AND,  DR1 S -[ MOV, \ day
  5 # DR0 LSR,  DR0 DR1 MOV,
  0F # DR1 .W AND,  DR1 S -[ MOV,               \ month
  4 # DR0 LSR,  DECIMAL 1980 # DR0 .W ADD,
  DR0 S -[ MOV,  NEXT ;C                        \ year

HEX
CODE SYSDATE    \   ---  d m y | n is bit packed date from rtc
  2A # RP -[ .W MOV,  1 # TRAP,  2 # RP ADDQ,
  R> R>  AGAIN,  ;C             DECIMAL

: $SIZE  BL HOLD OVER 10 < >R #S R> IF BL HOLD THEN ;

\ clock stuff: settime                    (  9  7 86 CRC 15:29 )
: <DATE> \  d m y  ---  addr ct | date ready for printing
  BASE F@ DECIMAL >R  <#  1900 -  0 # #  2DROP
  0 $SIZE 2DROP 0 $SIZE #> R> BASE F! ;

: (DATE)  sysDATE <DATE> ;
;s
\ CODE (SETDATE) \ n  --- | n is bit packed time to rtc
\ S [+ DR0 MOV,  DR0 RP -[ .W  MOV,
\ 2B # RP -[ .W MOV,  1 # TRAP,  4 # RP ADDQ,  NEXT ;C

\ : SETTIME  \  ---  | n is packed time for rtc
\ BASE F@ >R DECIMAL BL WORD HERE H/M H/M
\    0 0 ROT (NUMBER) 2DROP 2/ NIP SWAP BL * OR
\    NIP SWAP  800 * OR  R> BASE F! (SETTIME)
\ 0 ?ERROR ;
\ clock stuff: stampdate setdate          (  4  6 86 CRC 11:28 )
: STAMPDATE (DATE) (STAMP) 2+ SWAP CMOVE ;
      \          | <--------  optional  ---------> |
: .DATE  (DATE)  OVER ASCII / SWAP 2+ 2DUP 3 + C! C! TYPE ;

: <GETTIME>    \ n  ---  addr ct | time ready for printing
  BASE F@ >R DECIMAL  <# BL /MOD SWAP 2* 0 SEXTAL C/L /MOD
  SWAP 0 SEXTAL DECIMAL DUP 10 < >R 0 #S R> IF BL HOLD THEN #>
  R> BASE F! ;
;S
: SETDATE  \  ---   | date is packed for rtc
  BASE F@ DECIMAL
  BL WORD 0 0 HERE (NUMBER) 2DROP               \ day
  BL WORD 0 0 HERE (NUMBER) 2DROP   BL  *  +  \ month
  BL WORD 0 0 HERE (NUMBER) 2DROP  DUP 50 < IF  64 + THEN
  50 - 200 * +  ( year)   (SETDATE) BASE F! ;
\ clock stuff: gettime .time stamptime    ( 21  6 94 CRC 12:26 )
: GETTIME  (GETTIME) <GETTIME> ;

: .TIME  GETTIME TYPE ;

: STAMPTIME GETTIME 3 - (STAMP) 15 + DUP 5 BLANKS SWAP CMOVE ;

: SETSTAMP   STAMPDATE STAMPTIME ;

: TEMPORES   .DATE SPACE .TIME ;
;s debugging tools
: TEMPUS  BEGIN CR tempores ?TERMINAL UNTIL ;




































































































\ 3dup                                    ( 18 10 94 CRC 17:52 )
code 3dup  \ a b c --- a b c a b c
  s [+ dr0 mov,  s [+ dr1 mov,  s [ dr2 mov,
  dr1 s -[ mov,  dr0 s -[ mov,
  dr2 s -[ mov,  dr1 s -[ mov,  dr0 s -[ mov,
  next ;c










\ TOWERS OF HANOI C. 1979 PETER MIDNIGHT  (  8  2 89 CRC 16:19 )
FORTH DEFINITIONS DECIMAL   PRESENT DEBUG
( OPENING: STP 60 + NEEDED TASK:
MOI MAINTASK = IFTRUE  OPENING: STP 97 + NEEDED FLIPPER  IFEND
) 55 NEEDED MS   320 NEEDED 0DO
129 NEEDED PICK  \  pick in code : PICK SP@  SWAP 4* + F@ ;
: MYSELF \ In definition this is a recursive use of a new word
  COMPILE PAUSE  COMPILE ?STACK  LATEST N>C <SUB> ; IMMEDIATE
\ : 4DUP 4 PICK 4 PICK 4 PICK 4 PICK ; \ code scr 129
0 VARIABLE PALLETE              LENGTH F@   16 LENGTH F!
DECIMAL   12 CONSTANT NMAX \ max permissable number of rings
: BLNK 0 BACKGROUND BL ;        NMAX VARIABLE (N)
CODE N (N) @#L S -[ MOV,  NEXT ;C \ can't ' constants any more
: COLOR 1 BACKGROUND 3 FOREGROUND  189 ;
   0 VARIABLE RING N 4- ALLOT \ array 1 ... n
0 VARIABLE (TIME)  -->
( TOWERS OF HANOI C. 1979 PETER MIDNIGHT    17 01 81 CRC )
CODE N+ S [ DR0 MOV, (N) @#L DR0 ADD, DR0 S [ MOV, NEXT ;C

: DELAY ( ideally, centiseconds delay )    100 *  MS ;
CODE POS   ( location pos -> co-ordinate ) (N) *+ DR0 MOV,
  1 # DR0 LSL,  1 # DR0 ADDQ,  S [ DR1 MOV,  DR0 DR1 MULU,
  (N) *+ DR1 ADD,  DR1 S [ MOV,  NEXT ;C   FIXED
\  N 2* 1+ * N + ;
: HALFDISPLAY ( color size HALFDISPLAY )
  0DO  DUP EMIT  LOOP  DROP ;
: <DISPLAY>  ( line color size <DISPLAY> )
  2DUP HALFDISPLAY   ROT 3 <  IF BLNK  ELSE ASCII |
  THEN EMIT   HALFDISPLAY  ;
: DSPLY ( size pos line color DSPLY )
  SWAP >R ROT ROT OVER - R ( color size pos-size line )
  SWAP GOTOXY R> ( color size line ) ROT ROT <DISPLAY> ; -->
( TOWERS OF HANOI C. 1979 PETER MIDNIGHT  ( 12  2 86 CRC 21:15 )
: PRESENCE    ( tower ring PRESENCE -> boolean )
  RING + C@ = ;
: LINE   ( tower LINE - > display line of top )
  4 SWAP N 0DO DUP I PRESENCE 0= ROT + SWAP LOOP DROP ;
: RAISE           ( size tower RAISE )
  DUP  POS SWAP LINE 1 SWAP DO
  2DUP I BLNK DSPLY  2DUP I 1-  COLOR DSPLY
  -1  +LOOP  2DROP ;
: SHOTIME  (TIME) F@ (GETTIME) - IF (GETTIME) (TIME) F!
  SV.CUR  0 N 3 * 7 - 0 MAX GOTOXY REV.OFF
  0 BACKGROUND tempores REV.ON RST.CUR THEN ;
: LOWER  ( size tower LOWER )
  DUP POS SWAP LINE 1+ 2 DO
  2DUP  I 1-  BLNK DSPLY   2DUP I COLOR DSPLY
  LOOP  2DROP  ;     -->
( TOWERS OF HANOI C. 1979 PETER MIDNIGHT  ( 26 11 86 CRC 17:47 )
: MOVELEFT  ( size source-tower destiny tower MOVELEFT )
  POS  1- SWAP POS 1- DO DUP I 1+ 1  BLNK DSPLY
  DUP I 1 COLOR DSPLY  -1 +LOOP DROP ;
: MOVERIGHT ( size source-tower destiny-tower MOVERIGHT )
  POS 1+  SWAP POS 1+ DO DUP I 1- 1 BLNK DSPLY
  DUP I 1 COLOR DSPLY   LOOP  DROP ;
: TRAVERSE  ( size source-tower destiny-tower TRAVERSE )
  2DUP >  IF MOVELEFT ELSE MOVERIGHT THEN ;
: MOVE    ( size source-tower destiny-tower MOVE 0)
  ?TERMINAL IF 9 N+ 0 GOTOXY \ [ MOI MAINTASK = IFTRUE ]
  CURSOR REV.OFF 0 BACKGROUND DISPLAY \ FLIPPER OFF [ IFEND ]
  ABORT THEN ROT ROT 2DUP RAISE   >R 2DUP R> ROT TRAVERSE
  2DUP RING + 1- C!  SWAP LOWER   SHOTIME  ;
: .CLINE (LINE) -TRAILING 80 OVER - 2/ >R ROT R> GOTOXY
  TYPE ;  --> center a given line on the screen at given row
( TOWERS OF HANOI C. 1979 PETER MIDNIGHT  ( 13 11 86 CRC 17:49 )
: MULTIMOV   ( size source destiny spare MULTIMOV )
  ( ?SLEEP)  4 PICK 1 =  IF DROP MOVE  ELSE
  >R >R SWAP 1- SWAP R> R>  4DUP SWAP MYSELF
  4DUP DROP  >R >R  1+  R> R>  MOVE
  ROT ROT SWAP   MYSELF THEN ;
: MAKETOWER    ( tower MAKETOWER )
  POS 4 N+ 3  DO  I OVER GOTOXY  ASCII | EMIT  LOOP  DROP ;
: MAKEBASE   REV.ON  ( no arguements )
  4 N+ 0 GOTOXY  N 6 * 3+  0DO  ASCII - EMIT  LOOP  REV.OFF ;
: MAKERING   ( tower size  MAKRING )
  2DUP RING + 1- C!   SWAP LOWER ;
: SALESPITCH    ( no paramters )
  1 FOREGROUND 6 N+  14  155 .CLINE 3 FOREGROUND
  8 N+  13  155 .CLINE  ; -->

( TOWERS OF HANOI C. 1979 PETER MIDNIGHT  ( 26 12 88 CRC  7:30 )
: SETUP  ( no arguements ) PAGE SALESPITCH
  1 N+ 0DO  1 RING I + C!  LOOP  3 0DO I MAKETOWER LOOP
  MAKEBASE 0 N DO  0 I MAKERING  -1 +LOOP ;
: TOWERS   ( quantity TOWERS )
\ [ MOI MAINTASK = IFTRUE ] FLIPPER ON NO.CURSOR [ IFEND ]
  ABS 1 MAX 1- NMAX MOD  1+ (N) F!  SETUP
  EDITOR FLUSH FORTH REV.ON  N 2 0 1  BEGIN
  OVER POS  4 N+ SWAP GOTOXY  N 0DO  7 EMIT 5 DELAY LOOP
  ROT 4DUP  \ [ MOI MAINTASK = IFTRUE ]
  PALLETE DUP F@ IF OFF VERT ELSE ON BLEU THEN   [ IFEND ]
  MULTIMOV AGAIN  STOP
LENGTH F!                             WARNING ON   TOWERS  ;S
True multi-user & multitasking
real-FORTH quick & cheap graphics!!
( remember, these are bit mapped characters! )
















( Screen cleaning code                    ( 27  6 87 CRC 12:23 )
BASE F@ HEX     \ See the real-Forth manual
: CLEAN     ( Check & clear out a screen.  )
  BLOCK B/BUF 0 DO DUP C@ ASCII ~ MIN BL MAX OVER C! 1+ LOOP
  DROP UPDATE ;

: CLEANERS    ( Clean out over a range of screens )
  1+  SWAP DO I CLEAN LOOP ;
BASE F! ;S

: BACKDOWN:   \  ---  | back a hard disk volumne down to 1 drive
  OFFSET OFF  OPENING:   B/DRV   2 DISKS COPIES ;
BASE F! ;S



\ hosted terminal routine                 ( 27  2 86 CRC 16:32 )
: CKEY   2 I/O W! (KEY) ;       \ atari specific -- from console

: SKEY   1 I/O W! (KEY) ;       \ atari specific -- from serial

: CEMIT  2 I/O 2+ W! (EMIT) ;   \ atari specific -- to console

: SEMIT  1 I/O 2+ W! (EMIT) ;   \ atari specific -- to serial

: HEMIT  SKEY  DUP CEMIT . 0 ;

: HKEY   CKEY  SEMIT 0 ;

: H?TERM   2 ?SKEY 0= 0= SEMIT 0 ;
-->

\ hosted terminal routine                 ( 27  2 86 CRC 17:00 )
BASE F@ HEX
   \ byte swap on stack
CODE ><   S [ DR0 MOV,  DR0 DR1 MOV,
  8 # DR0 LSL,  8 # DR1 LSR,
  DR1 DR0 .B MOV,  FFFF #L DR0 AND,  DR0 S [ MOV,  NEXT
BASE F!
: HREAD   SKEY >< (KEY) OR BLOCK  B/BUF  1 I/O 2+ W! TYPE 0 ;

: HWRITE  SKEY >< (KEY) OR BLOCK  B/BUF  1 I/O 2+ W!
  BOUNDS DO (KEY) I C! LOOP  UPDATE 0 ;




-->
\ hosted terminal routine                 ( 28  2 86 CRC  9:05 )
: HTERM  I/O F@ >R \ hosted terminal routine
  BL SEMIT     \ tell target we're on line
  BEGIN 1 ?SKEY \ any keys from host?
    IF SKEY  BL - 10 MIN 0 MAX EXEC
    HEMIT  HKEY   H?TERM   HREAD    HWRITE   1       0       0
    0      0      0        0        0        0       0       0
    1  [ ( force exec compiler to stop ) ]
    ELSE 0 THEN ?STACK  ?TERMINAL OR UNTIL R> I/O F! ;







;S editor softkey definitions             (  9  5 86 BJR 21:43 )
                                                    ;S  ( key 1)
EDITOR TOP L                                        ;S  ( key 2)
-15 SCR +! L                                        ;S  ( key 3)
 15 SCR +! L                                        ;S  ( key 4)
                                                    ;S  ( key 5)
                                                    ;S  ( key 6)
                                                    ;S  ( key 7)
                                                    ;S  ( key 8)
WIPE L                                              ;S  ( key 9)
#LEAD UPPER  ( force to upper case)  L              ;S  ( key J)
#LAG  UPPER                          L              ;S  ( key K)
                                                    ;S  ( key L)
                                                    ;S  ( key M)
                                                    ;S  ( key N)
                                                    ;S  ( key O)
\        hosted terminal code             ( 28  5 86 BJR 20:18 )
VOCABULARY TERMINAL IMMEDIATE TERMINAL DEFINITIONS
CODE NYBBL   \ n -- nlo nhi | encode byte into two bytes
   S [ DR0 MOV,  DR0 DR1 .W MOV,  4 # DR1 .W LSR,
   HEX 0F #L DR0 AND,  30 # DR0 .W OR,  DR0 S [ MOV,
   0F #L DR1 AND,  30 # DR1 .W OR,  DR1 S -[ MOV,   NEXT ;C

CODE DENYBBL   \ blo bhi -- b | reverse nybbl
   S [+ DR0 MOV,  0F #L DR0 AND,  4 # DR0 .W LSL,
   S [  DR1 MOV,  0F #L DR1 AND,  DR0 DR1 .W OR,
   DR1 S [ MOV,  NEXT ;C

CODE ?SKEY  \ dev --- fl | is there a key ready?   1=port 2=kbd
 RP DR7 MOV,  S [ DR0 MOV,  DR0 RP -[ .W MOV,
 1 # RP -[ .W MOV,  0D # TRAP,  DR0 S [ MOV,
 DR7 RP MOV,  NEXT       -->
\        hosted terminal code             ( 10  5 86 BJR 19:59 )
: RXB   (KEY) (KEY) DENYBBL ;        \ rcvd lo,hi
: RXW   RXB 100 * RXB OR ;           \ rcvd hibyte,lobyte
: XMITB  NYBBL SWAP (EMIT) (EMIT) ;  \ send lo,hi
: XMITW  DUP 100 / XMITB XMITB ;     \ send hibyte,lobyte
: HREAD   BLOCK B/BUF BOUNDS DO  I C@ XMITB  LOOP ;       \ n --
: HWRITE  BLOCK B/BUF BOUNDS DO  RXB I C!  LOOP UPDATE ;  \ n --

: MODEMRX 1 I/O W!    ;  : LOCALRX 2 I/O W!    ;
: MODEMTX 1 I/O 2+ W! ;  : LOCALTX 2 I/O 2+ W! ;
\ entered after receipt of a '1f' request code; must be modemrx!
: DOREQUEST   (KEY) DUP CASE      \ get fcn code from target
   30 OF  DROP          RXW HWRITE ENDOF   \ target -> disk
   31 OF  DROP  MODEMTX RXW  HREAD ENDOF   \ disk -> target
   ( default)   LOCALTX (EMIT) ENDCASE ;
-->
\        hosted terminal code             ( 29  9 86 CRC 13:20 )
0 VARIABLE EXITING     decimal 166 load hex \ get new <key>
: DOKEY   LOCALRX <KEY> DUP CTL O = IF EXITING F!       \ --
          else dup 100 and if modemtx femit
          ELSE MODEMTX (EMIT) then THEN ;  \ note that rx = loca
: DORX    MODEMRX (KEY) 7F and DUP 1F = IF DROP DOREQUEST  \ --
          ELSE LOCALTX (EMIT) THEN ;  \ note that rx = modem
FORTH DEFINITIONS
: TERM   EDITOR FLUSH   TERMINAL
  I/O F@  ." target> "  EXITING OFF  BEGIN
  1 ?SKEY IF  DORX  THEN    \ any keys from host?
  2 ?SKEY IF  DOKEY THEN    \ anyone at keyboard?
  EXITING F@ UNTIL   I/O F! ." atari> " ;

: term  no.wrap terminal vt52keys on term vt52keys off wrap ;
-->
\        upload from remote system        ( 29  5 86 BJR 17:41 )
\ requires upload support program running in remote system
\ or, this may be the remote system's "target" for hosted term

: UPLOAD   \ hisscr myscr -- | get hisscr (remote), put in myscr
  dup offset f@ + buffer drop     \ pre-fetch buffer!
  I/O F@ >R   terminal MODEMTX MODEMRX 1F (EMIT) 31 (EMIT)
  SWAP XMITW HWRITE R> I/O F! ;   \ get screen from remot

: UPLOAD-SCREENS   \ 1st last -- | upload screens 1:1
  1+ SWAP DO I DUP . DUP UPLOAD LOOP ;

DECIMAL ;S



\ vt52 keyboard emulator -- <key>         ( 12  5 86 BJR 15:21 )
0 VARIABLE VT52KEYS   \ select applcation keypad

CODE <KEY>  HEX   \  -- key/code | get key or atari code
   RP DR7 MOV,  U ' I/O C>P W@ &[ RP -[ .W MOV, \ get key in dr
   2 # RP -[ .W MOV,  0D # TRAP,  DR7 RP MOV,
   VT52KEYS @#L TST,  NE IF,          \ remap numeric keypad?
      DR0 DR1 MOV,  DR1 .W SWAP,  53 # DR1 .W CMP,  NE IF,
      3B # DR1 .W CMP,  GE IF,
      DR0 .W CLR,  THEN, THEN, THEN,  \ yes...force fcn key
   DR0 .W TST,  EQ IF,                \ if function key,
      DR0 .W SWAP,  100 # DR0 .W OR,  \ return scancode+100
   THEN,  FFFF #L DR0 AND,  DR0 S -[ MOV,  NEXT ;C

-->

\ vt52 keyboard emulator -- femit         ( 13  5 86 BJR 16:00 )
: escm   <builds w, does> w@ li (emit) (emit) ;
   ascii A escm pfu    ascii B escm pfd    ascii C escm pfr
   ascii D escm pfl    ascii P escm pf1    ascii Q escm pf2
   ascii R escm pf3    ascii S escm pf4
: esc?m  <builds w, does> w@ li (emit) ascii ? (emit) (emit) ;
   ascii p esc?m ap0   ascii q esc?m ap1   ascii r esc?m ap2
   ascii s esc?m ap3   ascii t esc?m ap4   ascii u esc?m ap5
   ascii v esc?m ap6   ascii w esc?m ap7   ascii x esc?m ap8
   ascii y esc?m ap9   ascii m esc?m ap-   ascii l esc?m ap,
   ascii M esc?m ape   ascii n esc?m ap.
: femit   0ff and 47 max 73 min 47 - exec   |     \ keycode --
   pfu  |  ap- pfl  |  pfr ap,  |  pfd  |   |   |    \ 48-53
    |   |   |   |   |   |   |   |   |   |   |   |    \ 54-5f
    |   |   |  pf1 pf2 pf3 pf4 ap7 ap8 ap9 ap4 ap5   \ 60-6c
   ap6 ap1 ap2 ap3 ap0 ap. ape  |     ;              \ 6d-73
































\ Empties: Code to detect empty screens   ( 22  2 87 CRC 13:00 )
DOCUMENTING DEFINITIONS   BASE F@ HEX
     \  from-2  to-1  |  list out empty blocks within range
: EMPTIES CR   1+ SWAP   ." Empties:" CR
      DO  I 0F MOD 0= IF CR I 5 .R ASCII : EMIT THEN
          I BLOCK W@ IF  ."    ."  ELSE  I BLOCK 2+ W@  2020 -
        IF ."    *" ELSE I 4 .R    THEN THEN
           ?TERMINAL   IF  LEAVE THEN  ?STACK  LOOP  CR ;

HEX  1 BLOCK  B/BUF C/L - + W C/L CMOVE
\ (DATE) W 34 + SWAP CMOVE

BASE F!  FORTH DEFINITIONS



















































\   The Theory that Jack Built            ( 16  8 85 CRC       )
\  From The Space Child's Mother Goose by Frederick Winsor
BLK F@ 2+ LOADER RECITE ( say this poem ) DECIMAL
: THE  ." the "  ;      : CR  ERL CR ERL ;
: THAT         CR   ." That "                       ;
: THIS  0 0 gotoxy  ." This is "    THE   ERL       ;
: JACK              ." Jack built."                 ;
: SUMMARY           ." Summary"                     ;
: FLAW              ." Flaw"                        ;
: MUMMERY           ." Mummery"                     ;
: K                 ." Constant K"                  ;
: HAZE              ." Erudite Verbal Haze"         ;
: PHRASE            ." Turn of a Plausible Phrase"  ;
: BLUFF             ." Chaotic Confusion and Bluff" ;
: STUFF             ." Cybernetics and Stuff"       ;
: THEORY            ." Theory "               JACK  ;  -->
\   The Theory that Jack Built              19 01 85 CRC
: BUTTON        ." Button to Start the Machine"     ;
: CHILD         ." Space Child with Brow Serene"    ;
: DEMOL         ." And Demolished "  THE            ;
: HIDING    CR  ." Hiding "       THE  FLAW         ;
: LAY      THAT ." lay in "       THE  THEORY       ;
: BASED     CR  ." Based on "     THE  MUMMERY      ;
: SAVED    THAT ." saved "        THE  SUMMARY      ;
: CLOAK     CR  ." Cloaking "          K            ;
: THICK IF THAT ELSE CR ." And " THEN ." Thickened " THE HAZE ;
: HUNG     THAT ." Hung on "      THE  PHRASE       ;
: COVER IF THAT ." Covered " ELSE CR ." To Cover " THEN BLUFF ;
: MAKE      CR  ." To make with " THE  STUFF        ;
: REST  15 SPACES KEY LI = IF WARNING ON TKEY CURSOR ABORT THEN
 ;  : WITHOUT   CR  ." Without Confusion, exposing the Bluff" ;
: PUSHED    CR  ." Who pushed "   THE  BUTTON       ;  RECITE
\   The Theory that Jack Built              17 01 81 CRC
EDITOR FLUSH FORTH  OKEY PAGE NO.CURSOR THIS  THEORY  REST
 THIS  FLAW  LAY                                           REST
 THIS  MUMMERY  HIDING  LAY                                REST
 THIS  SUMMARY  BASED  HIDING  LAY                         REST
 THIS  K  SAVED  BASED  HIDING  LAY                        REST
 THIS  HAZE  CLOAK  SAVED  BASED  HIDING  LAY              REST
 THIS  PHRASE 1 THICK CLOAK SAVED BASED HIDING LAY         REST
 THIS  BLUFF HUNG 1 THICK CLOAK SAVED BASED HIDING LAY     REST
 THIS  STUFF 1 COVER HUNG 0 THICK CLOAK SAVED BASED HIDING
     LAY                                                   REST
 THIS BUTTON  MAKE 0 COVER  HUNG 0 THICK  CLOAK SAVED
    BASED  HIDING  LAY  REST            THIS  THE  CHILD
 PUSHED CR ." That made with " THE STUFF WITHOUT HUNG
 CR ." And, shredding " THE HAZE CLOAK CR ." Wrecked "  THE
 SUMMARY BASED HIDING CR DEMOL THEORY REST CR CR CURSOR  tkey
















\ Slurp source from 11                    ( 23  2 95 CRC 14:33 )
FORGET TASK
BASE F@ DECIMAL 55 NEEDED MS HEX  FORTH DEFINITIONS
: RXBLK  \  n ---  | read a block in from the host computer
  I/O F@ >R 10001 I/O F!  OFFSET F@ + BUFFER BL EMIT
  2 OUTPUT W! B/BUF 2DUP EXPECT
  -TRAILING 0= IF 0 SWAP W! ELSE DROP THEN
  UPDATE  R> I/O F! ;

: RXBLKS  \ st ct  --- nxt | read ct blocks starting at st from
  2DUP BOUNDS DO CR I 5 .R I RXBLK    \  host, leaving next blk
  I #BUFS MOD 0= IF EDITOR FLUSH THEN
  ?TERMINAL IF LEAVE THEN      LOOP + FLUSH ;
: PURGE   INPUT >HOST  BEGIN ?KEY  WHILE
     0 WAIT  (KEY) DROP REPEAT  INPUT >LOCAL ; PURGE
: TASK ;  BASE F! EDITOR FLUSH
















\ word wide math operators                ( 30  5 86 CRC 13:34 )
CODE UW*   \ w w --- n | 16bit x 16bit --> 32bit prod
  S [+ DR1 MOV,  S [ DR0 MOV,  DR1 DR0 MULU,  DR0 S [ MOV,  NEXT

CODE W*    \ w w --- n | 16bit x 16bit --> 32bit prod
  S [+ DR1 MOV,  S [ DR0 MOV,  DR1 DR0 MULS,  DR0 S [ MOV,  NEXT


CODE W/    \ n w --- w | 32bit / 16bit --> 16bit quotient
  S [+ DR1 MOV,  NE IF,  S [ DR0 MOV,  DR1 DR0 DIVS,  DR0 EXT,
  DR0 S [ MOV,  ELSE,  S [ CLR,  THEN,  NEXT

CODE UW/   \ n w --- w | 32bit / 16bit --> 16bit quotient
  S [+ DR1 MOV,  NE IF,  S [ DR0 MOV,  DR1 DR0 DIVU,  DR0 EXT,
  DR0 S [ MOV,  ELSE,  S [ CLR,  THEN,  NEXT
  \ we arbitrarily define division by 0 as producing 0.
\ Documentor code: doc 3doc                 31 12 84 CRC

: SHADOW  B/DRV + ;        HEX

: DOC BASE F@ SWAP DECIMAL CR DUP SCR F! 3F  SPACES
   ." SCR #  " 5 .R 10 0  SCR F@ BLOCK W@  IF
   DO  CR  I 3 .R  SPACE I SCR F@ .LINE
   [ C/L 7 + ] LITERAL TAB I SCR F@ SHADOW .LINE
   ?TERMINAL IF LEAVE ENDIF LOOP ELSE
   DROP VTAB  THEN  CR BASE F! ;

: 3DOC  3 / 3 * 3 BOUNDS      2DUP DO I BLOCK F@ LOOP OR OR
   IF ?PAGE DO CR I DOC  ?TERMINAL IF LEAVE THEN LOOP CR
   [ 6 BL + ] LITERAL SPACES W C/L TYPE CR ELSE 2DROP THEN ;


\ Documentor code: showoff                  10 06 84 CRC

: SHOWOFF   3 / 1+ 3 *  SWAP
   DO I 3 / 3 * 3 BOUNDS      2DUP DO I BLOCK F@ LOOP OR OR
   IF ?PAGE DO CR I DOC  ?TERMINAL IF LEAVE THEN LOOP CR
   [ 6 BL + ] LITERAL SPACES W C/L TYPE  CR ELSE 2DROP THEN
   ?TERMINAL IF  LEAVE THEN   3  +LOOP  ;

: NECPAGE ?CRT 0= IF ?PAGE THEN ;  \ force page on printer only







\   STRING HANDLERS --                    ( 16  8 85 CRC       )
FORGET TASK : TASK ;    BASE  F@     \ Hi level 79 std upgrades

DECIMAL 129 NEEDED ROLL  HEX

: R@   R  ;                : ?DUP  -DUP ;

BASE F!  -->








  ( STRING HANDLERS --                      06 12 81 CRC )
 BASE  F@ HEX
: (")   R@ COUNT DUP 1+ R> + =CELLS >R  ;

: TEXT   PAD 1+ 40  BLANKS WORD HERE  COUNT
     DUP PAD C!  ?DUP
     IF PAD 1+ SWAP CMOVE
     ELSE  DROP    THEN ;
: " ASCII " STATE F@ IF COMPILE (")
     WORD HERE C@ 1+ =CELLS ALLOT
     ELSE TEXT PAD COUNT    THEN ;   IMMEDIATE

: STRING     (  n-max   -> )
     CREATE   1   MAX   0FE  MIN  =CELLS
          DUP  C,  0 C, ALLOT
     DOES>   1+  COUNT ;      -->
  ( STRING HANDLERS --                      29 01 81 CRC )
: S!    DROP  DUP  2- C@
     ROT  MIN  DUP  3 PICK  1- C!  CMOVE ;

: LEN  SWAP  DROP  ;       : MLEN  DROP  2- C@ ;

: MID$   >R  OVER  MIN  1 MAX  1-
     SWAP  OVER   - R>   MIN   >R  +  R>  ;

: RIGHT$   OVER  1+  SWAP  - 0FF  MID$ ;

: LEFT$  1 SWAP  MID$ ;

: SUB!    ROT MIN  0  MAX CMOVE  ; -->


  ( STRING HANDLERS --                      29 01 81 CRC )
: S=    ROT  OVER  =
    IF  ?DUP
     IF 1 SWAP  0
      DO  DROP  OVER  C@  OVER  C@  =
       IF  1+  SWAP  1+  SWAP  1
       ELSE  0 LEAVE
       THEN
      LOOP
     ELSE  1
     THEN
    ELSE DROP  0
    THEN  NIP NIP ; -->



  ( STRING HANDLERS --                      29 01 81 CRC )
: S<   ROT  OVER MIN  SWAP  OVER  >  >R   -DUP
     IF -1  SWAP 0
      DO  DROP  OVER  C@  OVER  C@  =
       IF  1+  SWAP  1+  SWAP  -1
       ELSE  C@  SWAP  C@  >  LEAVE
       THEN
      LOOP  DUP  0<
      IF DROP  DROP  DROP R>
      ELSE  RDROP
      THEN
     ELSE DROP DROP R>
     THEN ;

: S+  >R  OVER  R@  + OVER  2- C@  MIN 2DUP
     SWAP  1- C!  R> 1+  0FF MID$  SUB! ;  -->
  ( STRING HANDLERS --                      04 02 81 CRC )
: CHR$ PAD F!  PAD 1 ;         : ASC  DROP  C@  ;

: IN$   DUP 4 PICK - DUP 0  >
     IF SWAP OVER -  IF 0 SWAP 2+ 1
       DO  DROP 3 PICK  C@  OVER C@ =
        IF 3 PICK 3 PICK 3 PICK OVER S=
         IF  I LEAVE
         ELSE 1+ 0  THEN
        ELSE 1+ 0  THEN
       LOOP
      ELSE DROP 0
      THEN
        >R  DROP  DROP  DROP R>
     ELSE DROP  S=  THEN ;           -->

  ( STRING HANDLERS --                      07 02 81 CRC )
: VAL  DROP  0. ROT  1- (NUMBER) DROP ;

: SVAL  VAL DROP ;      (  fig-FORTH only? CRC )

: STR$  SWAP  OVER  DABS <#  #S  SIGN #> ;

: SSTR$  S->D  STR$ ;   ( fig-FORTH only ? CRC )

: STRING-ARRAY
     CREATE  0 DO  DUP C,  0 C, DUP  ALLOT LOOP  ?ALIGN
     DOES>  DUP  C@  2+  ROT  *  +  1+  COUNT ;
                       ( Blanks out an array )
: BLANK  DROP DUP DUP 0 ROT 1- C!  2- C@ BLANKS ;
 -->

  ( STRING HANDLERS --                      04 02 81 CRC )
: ACCEPT    SWAP  1+  DUP  ROT  EXPECT 0
     BEGIN  2DUP  + C@
     WHILE  1+
     REPEAT  SWAP  1- C! ;

: GET$  PAD  SWAP  ACCEPT  PAD  COUNT ;

: INPUT$     40 GET$ ;

: GET  GET$  VAL ;            : INPUT  40   GET ;

1 STRING NULL$                : $  STRING ;



\ Some programming aids: TRY, etc         ( 19  5 86 CRC 10:52 )
FORTH DEFINITIONS       \ See the real-Forth manual
: RETRY  IN F@ >R -FIND IF DROP DUP [ LATEST 4- ] LITERAL >
   IF C>N N>L l>s F@ WHERETHEN R IN F! [COMPILE] FORGET
       BLK 2@ >R >R  IN F! BLK F! INTERPRET  R> R> BLK 2!
   ELSE ." kernel " DROP THEN
   ELSE 14 MESSAGE  4 SPACES THEN RDROP ;

: TRY SCR F@ LOAD ;

: TASK ;





\ terminal emulator code:                 (  9  4 89 CRC 10:02 )
: (S.")  R COUNT DUP 1+ =CELLS  R> + >R  SLTYPE ;
: S."  ASCII " STATE F@ IF  COMPILE (S.")  WORD HERE C@ 1+
  =CELLS ALLOT ELSE  WORD HERE COUNT SLTYPE THEN ; IMMEDIATE
: FTN  CREATE BL WORD HERE 1+ C@ LI C, C, DOES> 2 SLTYPE ;
  \ all are shifted function keys
: FN1 s."  3 LOAD  " ;         : FN2 s."  NEC NECHO"    ;
: FN3 S." DIR SY:/FU/BL/VO"  ; : FN4 S." DIR DY1:/FU/BL/VO"  ;
: FN5 s." TIME " GETTIME SLTYPE ;
: FN6 s." COPY DY0: DY1: /WAIT" ;
: FN7 s." HHH"    CTL M EMIT   ;
: FN8 S." XTX07722,JJPHRDBQ" ctl m emit ;
: FN10  0 (EMIT) 0 (EMIT) ;   \ send a break
BASE F@ DECIMAL
390 LOADER SETSERIAL BASE F!  FTN FN9 C   -->
this is acreen 203 w/ RT-11 commands!
\ special modem goodies                   (  3  3 93 CRC 20:44 )
: MSG  CREATE  ASCII " WORD HERE C@ 1+ =CELLS ALLOT
  DOES>  COUNT SLTYPE  CTL M EMIT CTL J EMIT ;

\ d.c. Hayes modem conditioning.
MSG SPEAKERON ATM2"             MSG STATUS AT&V"
MSG SPEAKERLOUD ATL3"

: MODEM 2400 BAUD  CR
  I/O F@  OUTPUT >HOST  CTL M EMIT  SPEAKERON SPEAKERLOUD
  100 WAIT  STATUS
  I/O F!  TERM ;




















































\ saveoutputs: save & restore output vecto( 30  5 86 CRC 14:29 )
BASE F@ DECIMAL

0 VARIABLE SAFEOUTS   28 ALLOT      SAFEOUTS 30 ERASE

: RESTOREOUTS  SAFEOUTS 'EMIT 24 CMOVE  SAFEOUTS 24 + DUP
  F@ OUT F! 4+ F@ I/O F! ;

: SAVEOUTS     'EMIT SAFEOUTS 24 CMOVE  OUT F@ SAFEOUTS 24 + F!
  I/O F@  SAFEOUTS 28 + F!  [ HEX ] 20002 I/O F! ;
BASE F!





\ terminal emulator: auxilary stuff       ( 28 10 49 CRC 13:09 )
106 NEEDED MODULE  FORGET TASK  BASE F@ HEX
CODE (IOREC)  \ dev# --- addr | return address of i/o record
  \ 0: rs-232  1: keyboard  2: midi
  S [ DR0 MOV,  DR0 RP -[ .W MOV,  0E # RP -[ .W MOV,
  0E # TRAP,  4 # RP ADDQ,  DR0 S [ MOV,  NEXT ;C

: IOREC   \  ---  | dump i/o record of serial port
  CR 0 (IOREC) 0E 2DUP (WDUMP) CR + 0E (WDUMP) ;

: SEEBUF IOREC 0 (IOREC) DUP F@ ( 8000 - ) SWAP 4+ W@  DUMP ;
: MORE?  0 (IOREC) 6 +  DUP 2+ W@  SWAP W@ - ;

\ 17FFF CONSTANT BUFSIZE           FFFF CONSTANT RINGSIZE

( BLK F@ 1+ LOAD )  HERE FENCE F! : TASK ; BASE F!
\ terminal emulator: auxilary stuff       (  6 11 93 CRC 21:27 )
\ : H" I/O F@ 1 I/O 2+ W!  ASCII " WORD HERE COUNT TYPE
\   CTL M EMIT  I/O F! ;
\ n.b.  buffer is 33k below FORTH. It may step on desktop accs
\ 0 +ORIGIN BUFSIZE - 100 - CONSTANT RXBUF   RXBUF BUFSIZE ERASE
0 VARIABLE RXBUF     BUFSIZE 3 - ALLOT     RXBUF BUFSIZE ERASE
0 VARIABLE SAVESTRUC  0A ALLOT    0 (IOREC) SAVESTRUC 0E CMOVE
: INSTALLBUF     \ install larger input buffer for serial port
  DEBUG SR@ >R 2700 SR!    \ disable incoming interrupts
  RXBUF BUFSIZE ERASE  \ set up buffer
  0 (IOREC) 6 + OFF     \ kill any pending text
  RXBUF 8000 + 0 (IOREC) F! \ install
  F000  0 (iorec) 0C + C!  C000 0 (iorec) 0A + W! \ hi, lo h2o
  RINGSIZE 0 (IOREC) 4+ W! R> SR! ; \ INSTALLBUF
: COLDSTRUC  SAVESTRUC 0 (IOREC) 0E CMOVE ;
ATEXIT: COLDSTRUC       ATCOLD: COLDSTRUC
\ external console code: set baud rates   ( 14  7 86 CRC 14:53 )
BASE F@ DECIMAL  FORTH DEFINITIONS   DEBUG  FORGET TASK
102 NEEDED ABORT"               106 NEEDED MODULE   DECIMAL
INTERNAL    \ table of legal bauds. No others are supported
-1 VARIABLE BAUDS -2 ALLOT  19200 W,  9600 W,  4800 W,  3600 W,
           2400 W,  2000 W,  1800 W,  1200 W,   600 W,   300 W,
            200 W,   150 W,   134 W,   110 W,    75 W,    50 W,

: -BAUD    \ baudrate ---  baud#1+/0 | find baud# in table
  0 ( fl) [ 17 2* BAUDS + ] LITERAL ( lim) BAUDS ( start)
  DO OVER I W@ = IF DROP I LEAVE THEN 2 +LOOP  NIP
  DUP IF BAUDS - 2/ ( addr -> index ) THEN ;
EXTERNAL
: BAUD  -BAUD DUP 0= IF ABORT" Bad Baud Rate" THEN 1-
  PRINTER RSCONF ;              MODULE
DECIMAL 9600 BAUD ( default!) BASE F! : TASK ;
\ terminal emulator code: start bugoff    ( 19 11 86 CRC 12:37 )
BASE F@ DECIMAL FILING  200 NEEDED BAUD  198 NEEDED IOREC
FORGET TASK  107 NEEDED IFTRUE   55 NEEDED MS
217 220 THRU                    HEX
0 VARIABLE HOFFSET              0 VARIABLE HALFDUPLEX
0 VARIABLE FOLLOW               0 VARIABLE TERMTIME
0 VARIABLE CAPTURE              0 VARIABLE POINTER
0 VARIABLE ?FUN                 0 VARIABLE NOCLOCK
: CENTERED 50 R C>P C@ - 2/ 0 MAX -DUP IF 0 DO RIGHT LOOP THEN ;

: BUGOFF 0 0 CURSCONF INPUT W@ >R 44E F@ FIRST 8000 - 8000 CMOVE
  SV.CUR 10 0 GOTOXY 1 FOREGROUND REV.ON CENTERED
  ."   Touch this and you die -- slowly.  " REV.OFF RST.CUR
  3 FOREGROUND   TERMTIME F@   BEGIN
  .CLOCK ?KEY INPUT 1+ 3 TOGGLE UNTIL R> INPUT W!
  TERMTIME F!  FIRST 8000 - 44E F@ 8000 1 0 CURSCONF CMOVE ; -->
\ terminal emulator code: filtre capt kill(  9  4 89 CRC 10:02 )
: KILL  PAD POINTER F! ;
CODE CAPT  \ c --- c | to capture buffer if flag is asserted
  S [ DR0 MOV,  CAPTURE @#L TST,
     NE IF,  POINTER *+ AR0 MOV,  DR0 AR0 [+ .B MOV,
     AR0 POINTER @#L MOV,  THEN,  NEXT   ;C       ( HERE
     0 C,   0 C,   0 C,   0 C,    0 C,    0 C,    0 C,    7 C,
     8 C,   9 C,  0A C,   0 C,    0 C,   0D C,    0 C,    0 C,)
CODE FILTRE  S [ DR0 MOV,  NOCLOCK *+ DR1 MOV,
  \  BL # DR0 .W CMP,  LT IF, ROT 0 &D*+ DR0 .B MOV,  THEN,
  LI # DR0 .W CMP,  EQ IF,  3 # DR1 MOVQ,  ELSE, 1 # DR1 SUBQ,
     MI IF,  DR1 CLR, THEN,  THEN,  DR1 NOCLOCK @#L MOV,
  DR0 S [ MOV,  NEXT  ;C -->

\ DUP CTL R = IF CAPTURE F!       ;S THEN  \ Compuserve dc2/dc4
\ DUP CTL T = IF CAPTURE OFF DROP ;S THEN  \ download protocol
\ terminal emulator code:                 (  9  4 89 CRC 10:02 )
: (S.")  R COUNT DUP 1+ =CELLS  R> + >R  SLTYPE ;
: S."  ASCII " STATE F@ IF  COMPILE (S.")  WORD HERE C@ 1+
  =CELLS ALLOT ELSE  WORD HERE COUNT SLTYPE THEN ; IMMEDIATE
: FTN  CREATE BL WORD HERE 1+ C@ LI C, C, DOES> 2 SLTYPE ;
  \ all are shifted function keys
: FN1 s."  3 LOAD  " ;         : FN2 s."           "    ;
: FN3 S."                 "  ; : FN4 S."                  "  ;
: FN5 s."                     " ;
: FN6 s."                     " ;
: FN7 s."    "    CTL M EMIT   ;
: FN8 S."                             " ;
: FN10  0 (EMIT) 0 (EMIT) ;   \ send a break
: TARGET  ; \  XP SET OFFSET F@ HOFFSET F! ;
FTN FN9 C   -->

\ terminal emulator code: hostkey local   (  3  3 93 CRC 19:54 )
: HEMIT   HALFDUPLEX F@ IF  OUTPUT >LOCAL  DUP CAPT (EMIT)
  OUTPUT >HOST  THEN  (EMIT) ;
: DOFNS  0 SWAP  ?FUN OFF  ASCII T -
  EXEC  FN1 FN2 FN3 FN4 FN5 FN6 FN7 FN8 FN9 FN10 STOP
: FUNCTIONS  \ key --- fl | function key executed
  DUP ASCII G =  ?FUN F@  AND  0= IF
  DUP ASCII T ASCII ] WITHIN ?FUN F@ AND  IF  DOFNS
    ELSE ?FUN F@ IF LI HEMIT THEN HEMIT THEN 0 THEN ?FUN OFF ;
: HOSTKEY \  ---  | process key in from host
  (KEY)  OUTPUT >LOCAL   7F AND  DUP 1F = IF DOREQUEST ELSE
  FILTRE -DUP IF FOLLOW F@ IF PRINTER DUP (PNT) THEN
  CAPT (EMIT) THEN   THEN  (GETTIME) TERMTIME F! ;
: LOCALKEY \ --- | process key from user
  OUTPUT >HOST  <KEY>  DUP  IF FUNCTIONS  ELSE ?FUN ON THEN
  ?QUIT F!  (GETTIME) TERMTIME F! ;   -->
\ terminal emulator code: term            ( 29  1 89 CRC 11:39 )
: TERM   SAFELINK{  POINTER F@ PAD U< IF KILL THEN ?QUIT OFF
\ 'TYPE F@ >R   ' SLTYPE 'TYPE F!
  OFFSET F@ >R  HOFFSET F@  OFFSET F!
  (GETTIME) TERMTIME F!  EDITOR FLUSH FORTH  vert I/O F@ >R
  BEGIN ?STACK INPUT >HOST ?KEY \ any keys from host?
    IF  HOSTKEY THEN
  INPUT >LOCAL ?KEY   \ anyone at keyboard??
    IF LOCALKEY THEN
    R I/O F!  TERMTIME F@ (GETTIME) - 80 + 0<  IF  BUGOFF THEN
    NOCLOCK F@ 0= IF KEYCODE 2+ W@ .CLOCK KEYCODE 2+ W! THEN
    ?QUIT F@ UNTIL R> I/O F!  DISPLAY
  R> OFFSET F! ( R> 'TYPE F! )  }RELINK ;

: TASK ; DECIMAL  178 LOAD  214 LOAD  390 needed pc
   BASE F!  KILL  EDITOR FLUSH
( code to slurp in from a host )          ( 26 10 86 CRC 14:12 )
BASE F@ HEX
: ABLOCK  \  blk#  ---  | Get a block from host
  OFFSET F@ + BUFFER B/BUF INPUT >HOST EXPECT UPDATE
  INPUT >LOCAL ;

: ABLOCKS  ( start ct -- | get in a bunch of blocks )
  BOUNDS  DO I ABLOCK CR I 4 .R CR LOOP ;
BASE F!







\ Quick & dirty colour demonstrator       (  6  7 86 CRC 18:42 )
FORTH DEFINITIONS   DECIMAL \ OPENING: STP 97 + NEEDED FLIPPER
DEBUG  DECIMAL 104 NEEDED UNUPDATE EDITOR FLUSH 55 NEEDED MS
: RAW  5 I/O 2+ W! ;          : COOKED 2 I/O 2+ W! ;
: ATARI  CTL N EMIT CTL O EMIT ;   HEX  40 VARIABLE AWAIT
HEX 777 VARIABLE OLDC         777 VARIABLE OLDB DECIMAL
: ATARIS  RAW 0 DO 2 SPACES ATARI LOOP COOKED ;
: LOGO 7 BACKGROUND
  REV.ON 4 FOREGROUND ASCII r EMIT  5 FOREGROUND ASCII g EMIT
  6 FOREGROUND ASCII b EMIT REV.OFF 3 FOREGROUND 0 BACKGROUND ;
: DOBG  ( colour --  colour ) DUP 0 SETCOLOUR  DROP
  DUP 1911 XOR 3 SETCOLOUR DROP ;
: PATTERN  11 0 DO 10 ATARIS CR LOOP  [ HEX ] 700 4 SETCOLOUR
  70 5 SETCOLOUR 2DROP 7 6 SETCOLOUR ." Foreground: " LOGO
  ."  Background: " LOGO OLDB F@ 0 SETCOLOUR  2DROP CR ;
: DELAY  AWAIT F! ;      -->
\ Quick & dirty colour demonstrator       ( 22 11 86 CRC 16:26 )
CODE +COLOUR  HEX  S [ DR0 MOV,  1 # DR0 ADDQ,
   3 # DR0 BTST,  NE IF,   8 # DR0    ADDQ,  THEN,
   7 # DR0 BTST,  NE IF,  80 # DR0 .W ADD,   THEN,
  0B # DR0 BTST,  NE IF,       DR0    CLR,   THEN,
  DR0 S [ MOV,  NEXT   ;C DECIMAL
\ CODE WVBL 37 # RP -[ .W MOV,  14 # TRAP,  2 # RP ADDQ, NEXT ;C
\ CODE SCRDUMP  20 # RP -[ .W MOV,  ' WVBL 4+ *+ BRA, ;C FIXED
: SHOWOFF  0 -1 DUP SETSCREEN  WRAP EDITOR FLUSH FORTH
  BASE F@ HEX  OLDB F@ DOBG  PATTERN 31 .R \  FLIPPER ON
  OLDC F@ 15 >R BEGIN DUP R SETCOLOUR DROP DUP CTL M EMIT 15 .R
  DUP 0= IF OLDB F@ +COLOUR DOBG DUP OLDB F! 16 .R  THEN  PAUSE
  +COLOUR AWAIT F@ MS \ ?SLEEP  \ dup 21 = if scrdump then
( WVBL) ?TERMINAL UNTIL RDROP OLDC F! 1 -1 DUP SETSCREEN
  BASE F! WRAP 0 BACKGROUND DISPLAY PAGE CURSOR \ FLIPPER OFF
  ;  EDITOR FLUSH     SHOWOFF
































































\ Documentation runnoff screen            ( 29  5 88 CRC 12:08 )
BASE F@ DECIMAL SCR F@ >R
PRINTER LEFT F@ >R  10 LEFTS   DOCUMENTING \ See real-Forth man
   \ 10.DS working disk
  0 B/DRV 1-    3 / 3 *          SINCE 10  9 87
  OPENING: STP  dup  2 disks +   SINCE 10  9 87
  14960   LASTBLK 3 / 1- 3 *     SINCE 10  9 87
  OPENING: DBMS      59 OVER +   SINCE 10  9 87
  OPENING: DIESELS   74 OVER +   SINCE 10  9 87

PRINTER  R> LEFTS  DOCUMENTING
NECPAGE   R> SCR F! BASE F! ;S

do hard disk with 9.ss disk installed to keep screens consistent


\ file handlers for terminal stuff        (  1 11 87 CRC 12:08 )
FORGET TASK   DECIMAL FILING FORTH DEFINITIONS
: .CAPTURED  PAD POINTER F@ OVER - -DUP IF TYPE ELSE DROP THEN ;

: SAVEFILE:  \  ---  | file saved out | Needs file name.
  POINTER F@ PAD - 1- 0< IF BL WORD KILL DROP ELSE
  FILING MKF:  HANDLE F@ IF PAD POINTER F@ OVER - HANDLE F@ WTF
  DUP 0< IF 5 .R HANDLE OFF ABORT"  File write Error"
    ELSE  DROP  THEN  CLf THEN THEN ;

: HDRIVE   B/DRV *  HOFFSET F! ;

: TASK ; EDITOR FLUSH



\ reset ver@ tosver@ get tos version      (  4  3 19 crc 12:59 )
forth definitions  forget task  \ may not work under emutos
Base f@ >r hex                  editor flush
code ver@  \  -- ver | get current gemdos version (??)
  30 # rp -[ .w mov,  1 # trap,
  2 # rp addq,  dr0 s -[ mov,  next   ;c

4f2 constant _sysbase
: tosver@  \  -- ver | TOS version, packed.
  _sysbase f@ 2+ w@ ;

code reset  _sysbase @#l ar0 mov,  ar0 [ jmp,  ;c
r> base f!      forth definitions : task ;  ;s
http://toshyp.atari.org/en/00500e.html#Sversion
http://toshyp.atari.org/en/003004.html#_sysbase

\ Book label printer                        28 07 83 CRC
FORTH DEFINITIONS FORGET TASK : TASK ;  BLK F@ CONSTANT THISBLK
DECIMAL   : (LN) (LINE) DROP BL ;
: .CLINE  (LN) 2DUP -TRAILING -DUP IF NIP OVER
       SWAP - 2/ SPACES -TRAILING TYPE ELSE DROP 2DROP THEN ;
: LABEL  VMARGIN F@ VMARGIN OFF 4 0 DO CR  \  vmargin reset
       I 12 + THISBLK .CLINE  LOOP CR CR
       ?NEC IF VMOVER THEN   VMARGIN F!   ;
LABEL  EDITOR ;S

ten                             |  <-- right side of label
eleven                          |
                                |
This is a test                  |
of the label printer            |
                                |
\        hosted terminal code             ( 10  6 86 CRC 14:27 )
' I/O C>P W@ DUP USER INPUT     2+ USER OUTPUT

CODE NYBBL   \ n -- nlo nhi | encode byte into two bytes
   S [ DR0 MOV,  DR0 DR1 .W MOV,  4 # DR1 .W LSR,
   HEX 0F #L DR0 AND,  30 # DR0 .W OR,  DR0 S [ MOV,
   0F #L DR1 AND,  30 # DR1 .W OR,  DR1 S -[ MOV,   NEXT ;C

CODE DENYBBL   \ blo bhi -- b | reverse nybbl
   S [+ DR0 MOV,  0F #L DR0 AND,  4 # DR0 .W LSL,
   S [  DR1 MOV,  0F #L DR1 AND,  DR0 DR1 .W OR,
   DR1 S [ MOV,  NEXT ;C

: RXB   (KEY) (KEY) DENYBBL ;        \ rcvd lo,hi
: RXW   RXB 100 * RXB OR ;           \ rcvd hibyte,lobyte

\        hosted terminal code             ( 26 10 86 CRC 14:14 )
: XMITB  NYBBL SWAP (EMIT) (EMIT) ;  \ send lo,hi
: XMITW  DUP 100 / XMITB XMITB ;     \ send hibyte,lobyte

: HREAD   BLOCK B/BUF BOUNDS DO  I C@ XMITB  LOOP ;       \ n --

: HWRITE  DUP ?PRESENT  -DUP IF NIP  ELSE OFFSET F@ +
  BUFFER THEN  B/BUF BOUNDS DO  RXB I C!  LOOP UPDATE ;  \ n --

: DOWHERE \ perfrom  where fun for target
  RXW R# F!  RXW SCR F! [COMPILE] EDITOR  ?QUIT ON ;

: FWRITE  DUP ?PRESENT  -DUP IF  NIP  ELSE OFFSET F@ +
  BUFFER THEN  B/BUF BOUNDS DO (KEY) I C!  LOOP UPDATE ;  \ n --
DECIMAL
: HBAUD  RXW  9600 = IF 1 ELSE 0 THEN PRINTER RSCONF ; HEX
\        hosted terminal code             ( 21  3 93 CRC 14:08 )
: FREAD   DUP BLOCK W@
  IF BL (EMIT) BLOCK B/BUF -TRAILING BOUNDS  (KEY) DROP
  DO I C@ (EMIT) LOOP 1F (EMIT) ELSE 21 (EMIT) HREAD THEN ;
                          \ addr ---  | set accordingly
CODE >HOST   S [+ AR0 MOV,  1 # AR0 [ .W MOV,  NEXT     ;C

CODE >LOCAL  S [+ AR0 MOV,  2 # AR0 [ .W MOV,  NEXT     ;C
: SLTYPE -DUP \ addr ct --  | send out slowly
  IF BOUNDS DO I C@ EMIT  3  WAIT LOOP  ELSE DROP  THEN ;
' SLTYPE 27 + CONSTANT SPEED    \ c@ access only!
: DOSTAMP SETSTAMP  (STAMP) 16 BOUNDS DO I C@ (EMIT) LOOP ;
: doexpect  pad  input >host  rxb
  input >local  expect  output >host
  pad ct->0 1+ dup xmitb  bounds do  i c@ xmitb  loop ;

\        hosted terminal code             (  1 11 87 CRC 12:19 )
: DOREQUEST   (KEY) CASE      \ get fcn code from target
   30 OF  DROP          RXW HWRITE ENDOF   \ target -> disk
   31 OF  DROP  OUTPUT >HOST
                        RXW  HREAD ENDOF   \ disk -> target
   32 OF  DROP  EDITOR FLUSH FORTH ENDOF   \ target flush
   33 OF  DROP  DOWHERE            ENDOF
   34 OF  DROP          RXW FWRITE ENDOF   \ target -> disk
   35 OF  DROP  OUTPUT >HOST               \ fast!!
                        RXW  FREAD ENDOF   \ disk -> target
   36 OF  DROP  HBAUD              ENDOF   \ set baud from targ
   37 OF  DROP  PRESENT            ENDOF   \ local present
   38 OF  DROP  OUTPUT >HOST
                        DOSTAMP    ENDOF   \ send stamp to tar
   39 of  drop  doexpect           endof   \ line edit locally
   ( default) OUTPUT >LOCAL  (EMIT) ENDCASE ;
















\   cross reference utility. Ken Bell     (  6  2 92 CRC  9:38 )
FORTH DEFINITIONS  FORGET TASK ( : TASK ;) BASE F@ >R DECIMAL
VOCABULARY CREF IMMEDIATE   \   CREF DEFINITIONS
5 +BLK NEEDED P>C

: GETWD         \ cfa --- | if relocatable, add cfa to table
  DUP 2- W@ IF  , ELSE  DROP THEN ;

: GETVOC        \ vhead ---  | get relocatable wds in this voc
  BEGIN  DUP N>C GETWD  n>L F@
    DUP LIMIT U< 0=  OVER 0=  OR UNTIL  DROP ;

: GETLOCS       \  ---  | build list of relocatable words
  VOC-LINK BEGIN  F@ -DUP  WHILE  DUP 8 - F@ GETVOC  REPEAT ;

1 4 +THRU      : TASK ;    R> BASE F!            EDITOR FLUSH
\   cross reference utilities             ( 23  2 92 CRC 15:20 )
CREATE RELOCS  GETLOCS  HERE CONSTANT LASTLOC

: .RELOCS   LASTLOC RELOCS  DO COL I F@  C>N ID.
  ?TERMINAL IF LEAVE THEN  4 +LOOP ;

: SCAN      0  LASTLOC RELOCS  DO  OVER  I F@ =
  IF 2DROP I I LEAVE THEN  4 +LOOP  DROP ;

: FOUND         \ relocaddr ---  | handle found in line code
  F@ DUP C>N ID. 2- W@  IP +!  cr ;

: TEST          \ relocaddr --- fl | check a reloc against targ
  F@  DUP 2- W@  IP F@  EDITOR -CSTEXT  0= ;


\   cross reference utilities             ( 23  2 92 CRC 15:01 )
: SRCH    1 LASTLOC RELOCS  DO  I TEST
    IF  1-  I FOUND  LEAVE THEN  4 +LOOP  ;

: DISM   CR IP F!
  BEGIN SRCH  IF  DECOMPILER <UN:>  THEN
  KEY LI = UNTIL ;

0 VARIABLE COUNTEM

: .CT COUNTEM F@ -DUP IF DECIMAL 6 .R COUNTEM OFF THEN  ?CR ;





\   cross reference utilities             ( 23  2 92 CRC 14:17 )
: LOC   \ nfa  ---      | print out screen & line # if can
  BASE F@ DECIMAL SWAP
  ( DUP ' WHERETHEN > IF ) SPACE N>L l>s F@ WHERETHEN  C/L /
  ."  Line " 3 .R SPACE .SCR SPACE ( ELSE DROP THEN ) BASE F! ;

DECIMAL
: .VOC  \ vla ---   | print out name of vocabulary
  ."  vocabulary is: "  DUP LIMIT  U< IF  P>C
     ELSE  DROP  ' FORTH  THEN  C>N  dup ID.  col loc ;

FORTH DEFINITIONS
: .CON  ."  Context" CONTEXT F@ CREF .VOC ;

: .CUR  ."  Current" CURRENT F@ CREF .VOC ;

\   cross reference utilities             ( 23  2 92 CRC 14:17 )
: ?LIKE   [COMPILE] '  (RES) >R  CR  CONTEXT F@ F@
  CREF  COUNTEM OFF  BEGIN  N>C DUP  (RES) R  =
    IF CR DUP C>N ID.  COUNTEM 1+!
    R  [ ' BASE (RES) ] LITERAL  =
        IF COL  DUP  C>P W@ 10 U.R  THEN
    R  [ ' BL   (RES) ] LITERAL  =
        IF COL  DUP C>P  F@ 10 U.R  THEN
    THEN  C>N N>L F@  DUP 0= ?TERMINAL OR  UNTIL
  R> 2DROP  .CT ;

: .VOCS   CR    \ print out all vocabularies
  CREF  COUNTEM OFF   VOC-LINK F@
  BEGIN  -DUP WHILE  DUP 8 - .VOC  Cr   F@  COUNTEM 1+!  REPEAT
  .CT ;
\ : foo 4+ 4- ;                   ' foo ip F!
\   cross reference utilities             ( 27 12 91 CRC 21:03 )
BASE F@ >R  DECIMAL 102 NEEDED MSSG

HEX
: P>C   \ nfa --- cfa | jump from name field to code field
  DUP 2- W@ FF00 AND 6100 = IF  2-  ELSE
    DUP 4- W@  6100 = IF  4-  ELSE
      DUP 6 - W@  4EB9 = IF  6 -  ELSE  ABORT" bad link"
           THEN THEN THEN ;
R> BASE F!






( leo-forth editor: load                  ( 20 10 85 CRC       )
   : THRU  1+ SWAP DO I LOAD LOOP ;
BASE F@ DECIMAL  HERE
VOCABULARY LEO IMMEDIATE          LEO DEFINITIONS
229 232 THRU 239 LOAD 234 238 THRU
HEX  HERE  SWAP  -  6 .R  SPACE
BASE F! FORTH DEFINITIONS LEO       ;S



FORGET TASK                          : TASK ;





( leo-forth editor: line text delim cursor  20 12 83 CRC       )
: LINE     ( line#  --- addr | get the addr of a given line #  )
    SCR F@ (LINE) DROP ;

: TEXT     ( c ---  | put text until 'c' into pad              )
    HERE 65 BLANKS  WORD  HERE PAD 65 CMOVE ;

0 VARIABLE DELIM     ( Text delimiter                          )

: .CURSOR  (  --   | send out blinking delimiter as cursor     )
( plain vanilla )         DELIM C@ EMIT                 ;

: USE      ( Set delimiter                                     )
    BL WORD HERE 1+ C@ DELIM C! ;  USE ^ ;S
( H1420)  27 EMIT  1 EMIT DELIM C@ EMIT 27 EMIT 25 EMIT ;
( plain vanilla )         DELIM C@ EMIT                 ;
( leo-forth editor: #locate  -- insert-buf  07 12 83 CRC       )
: #LOCATE                ( Leave cursor offset-2, line -1      )
        R#  F@  C/L  /MOD  ;
: #LEAD               ( Line address -2, offset-1              )
        #LOCATE  LINE  SWAP  ;
: #LAG           ( Cursor addr-2, count-1 after cursor         )
        #LEAD  DUP  >R  +  C/L  R>  -  ;
: -MOVE         ( Move in block buffer addr from-2, line-1     )
        LINE  C/L  CMOVE  UPDATE  ;
: BUF-MOVE ( addr --- | move pad to addr, if not null          )
   PAD 1+ C@ IF  PAD  SWAP 65  CMOVE ELSE DROP THEN ;
: >LINE#   (   ---- line# | give line# of cursor pos.          )
   #LOCATE NIP ;
: FIND-BUF         PAD  80 +    ;
: INSERT-BUF       PAD 160 +    ;

( leo-forth editor: {hold}  --  >>        ( 25  7 86 CRC 20:22 )
: (HOLD)   ( line# ---  | move line to insert buffer           )
     LINE INSERT-BUF 1+ C/L DUP INSERT-BUF C! CMOVE ;
: (KILL)   ( line# ---  | erase line to blanks                 )
     LINE C/L BLANKS UPDATE ;
: (SPREAD) (   ---   | spread block at cursor line             )
     >LINE# DUP 1- 14
     DO I LINE I 1+ -MOVE   -1 +LOOP  (KILL) ;
: ?       (   ---   | display current line                     )
     CR SPACE #LEAD TYPE .CURSOR #LAG TYPE >LINE# . ;
: (DELETE) ( # ---   | zap # characters before cursor          )
     -DUP IF  >R #LAG + R -   #LAG R MINUS R# +!
     #LEAD + SWAP CMOVE    R> BLANKS  UPDATE  THEN ;
: >>       ( # ---   | move cursor # characters                )
     R# +! ? ;

( leo-forth editor: x, t, l, n, b, top, r, p07 12 83 CRC       )
: X       (  ---  | delete current line, save in buffer        )
     >LINE# DUP (HOLD)  15 DUP ROT
     DO I 1+ 15 MIN LINE I -MOVE LOOP  (KILL) ;
: T        ( line# ---  | move cursor to line & type it        )
     6 2*s R# F!   ? ;
: L        (  ---  |  list current screen                      )
     SCR F@ LIST ;
: TOP   R# OFF ;         ( home cursor                         )
: N     SCR 1+! TOP ;    ( move to next screen                 )
: B   -1 SCR +! TOP ;    ( move to last screen                 )
: (PUT)    (  ---  |  replace cusror line w/ i-buf             )
     >LINE#  INSERT-BUF 1+ SWAP -MOVE  ;
: P        (  ---  |  put text to current line & i-buf         )
     DELIM C@ TEXT  INSERT-BUF  BUF-MOVE  (PUT)  ;

(  STRING EDITING COMMANDS: -text            1  3 85 CRC       )
BASE F@  HEX  (  addr1  count  addr2  --- f                   )
CODE -TEXT
  1 # DR1 MOVQ,  ( set up flag                                 )
  S [+ AR0 MOV,  S [+ DR0 MOV,  S [ AR1 MOV,
  BEGIN,  AR0 [+ AR1 [+ .B CMP,   ( Unstructured! Unstructured!)
     EQ IF,  DROP ROT ROT 1 # DR0 SUBQ,  EQ UNTIL,  2
     DR1 CLR,  ELSE,
     CC IF,  DR1 NEG,  THEN, THEN,  DR1 S [ MOV,  NEXT  ;C

                                            BASE F! ." ." ;S
  flag:  1 means the $ at addr1 is less than the $ at addr2
         0 means the $ at addr1 is  equal to the $ at addr2
        -1 means the $ at addr2 is less than the $ at addr1


( leo-forth editor: match seek-error 1line( 10 11 86 CRC 21:33 )
: MATCH               ( addr1 count1 addr2 count2  --- f n3    )
   >R >R   2DUP R> ROT ROT R> ROT ROT BOUNDS   DO
      2DUP FORTH I -TEXT 0= IF >R 2DROP R> - FORTH I SWAP -
         0 SWAP 0 0 LEAVE  THEN LOOP 2DROP SWAP 0= SWAP ;

: SEEK-ERROR   (  ---  | error exit on searches                )
   TOP  FIND-BUF  COUNT TYPE  ."   ?" QUIT ;

: 1LINE  (  --- fl | scan for find buf, flag sucess            )
   #LAG  FIND-BUF  COUNT  MATCH  R#  +! ;

: (SEEK) (  ---  | search an entire screen                     )
   BEGIN  1023 R# F@ <  IF SEEK-ERROR THEN  1LINE UNTIL ;


( leo-forth editor: wipe till f (f          07 12 83 CRC       )
: (F)    (  ---  | find given text                             )
     DELIM C@ TEXT  PAD 1+ C@ IF FIND-BUF  BUF-MOVE THEN
      (SEEK) ;

: F      (  ---  | find given text and display                 )
     (F)  ? ;

: WIPE     (  ---  | kill current block                        )
   0 SCR F@ BLOCK DUP B/BUF BLANKS W!  UPDATE  ;

: TILL ( delete on cursor line from cursor to end of given text)
   #LEAD + DELIM C@ TEXT   FIND-BUF BUF-MOVE
   1LINE 0= IF SEEK-ERROR THEN  #LEAD + SWAP - (DELETE) ? ;


( more editor: u e d k                       3  6 85 CRC       )
: U        (  ---  | put text under current line               )
    C/L R# +! (SPREAD) P ;

: E        (  ---  | erase backwards from cursor               )
    FIND-BUF C@ (DELETE) ? ;

: D        (  ---  | find it, kill it, show results            )
    (F) E ;

: K        (  ---  | swap find & insert buffers                )
    FIND-BUF PAD 65 CMOVE   INSERT-BUF FIND-BUF 65 CMOVE
    INSERT-BUF  BUF-MOVE ;



( leo-forth editor: i, r, m                 07 12 83 CRC       )
: I       (  ---  | insert text within a line                  )
    DELIM C@ TEXT  INSERT-BUF BUF-MOVE
    INSERT-BUF COUNT  #LAG ROT  OVER  MIN >R
    R R# +!  R - >R
    DUP HERE R CMOVE   HERE #LEAD +  R> CMOVE
    R> CMOVE UPDATE     ? ;

: R       (  ---  | replaced matched w/ insert                 )
    E I ;

: M        ( scr# line ---  | move line under given destination)
    SCR F@ >R  R# F@ >R    >LINE#  (HOLD)
    SWAP SCR F!   1+ 6 2*s R# F! (SPREAD)   (PUT)
    R> C/L + R# F!   R> SCR F! ;

( leo-forth editor: where, o                07 12 83 CRC       )
: O        ( nscr --- oscr | toggle between two screens        )
  SCR F@ SWAP LIST ? ;

FORTH DEFINITIONS

: WHERE    ( in blk ---  | point the editor after an error     )
  DUP  B/SCR  /  DUP  SCR F!  DECIMAL  ."  SCR " . SWAP
  DUP R# F! C/L  /MOD  6 2*s  ROT  BLOCK  +  CR  C/L  -TRAILING
  TYPE CR HERE C@ - SPACES LEO .CURSOR   [COMPILE] LEO QUIT [
  SMUDGE





( -text in high level code.               ( 26  7 85 CRC       )
: -TEXT      (  addr1  count  addr2  --- f                     )
   (DO)       0 R> R> BOUNDS   ( uses knowledge of system stuff)
   DO OVER C@ I C@ -  OR
      DUP IF LEAVE ELSE SWAP 1+ SWAP THEN LOOP SWAP DROP ;






                                                             ;S
   SWAP >R >R 0 R> R> BOUNDS  ( straight high level stuff      )
flag:  0 means the $ at addr1 is equal to the $ at addr2
   non 0 means the $ at addr1 is not equal to the $ at addr2
useful in leoforth editor but not for database stuff.
\ begin trap grabbing stuff               ( 31  8 91 CRC 13:55 )
BASE F@ FORTH DEFINITIONS  PRESENT  FORGET TASK  DECIMAL
76 NEEDED [[    102 NEEDED MSSG     106 NEEDED MODULE
VOCABULARY DEBUG IMMEDIATE          241 NEEDED IX
DEBUG DEFINITIONS       HEX
0 VARIABLE INSTRS       14 ALLOT        INSTRS 18 ERASE
0 VARIABLE REGISTERS    50 ALLOT        REGISTERS 54 ERASE
FIRST 20000 - FFFF0000 AND  DUP CONSTANT STARTRP
10000 - dup CONSTANT STARTUSP  10000 - CONSTANT STARTS
\ 0 VARIABLE *W                   0 VARIABLE *IP
0 VARIABLE STPS                 FORTH DEFINITIONS
DECIMAL 243 253 HEX THRU
DECIMAL 256 268 HEX THRU
\ DECIMAL 242 load     \ trial stuff
BASE F!   DEBUG  SAVETRAPS  INSTALLTRAPS
EDITOR FLUSH FORTH DEFINITIONS  : TASK ;
\ assm defs for debug                     (  9  7 86 CRC 16:20 )
BASE F@ HEX
\ CODE I! ( i=indivisable) S [+ AR0 MOV,  S [+ AR0 [ MOV,  NEXT
ASSEMBLER DEFINITIONS
CODE E! \ v# addr ---   | store addr in exception vector #
 S [+ RP -[ MOV,  ( addr to stack )
 S [+ DR0 MOV,  DR0 RP -[ .W MOV,  ( vect. # )
 5 # RP -[ .W MOV, ( func # ) 0D # TRAP,  8 # RP ADDQ,  NEXT
 ;C    DECIMAL
: EXP!  \ addr chk vec#  ---    | install addr in vector
 ?EXEC SWAP 3 ?PAIRS DUP 24 2*S ROT OR E! ;
BASE F!               \ very sneaky!!!!
: TRAP!   BL + EXP! ;
FORTH DEFINITIONS
: IX  ASSEMBLER BEGIN, 2+ ~ [COMPILE] ASSEMBLER ;

\ test debugger with code here            ( 31 12 88 CRC 13:26 )
DEBUG FORTH DEFINITIONS    FORGET TASK         : TASK ;   HEX
HERE ASSEMBLER  AR0 AR1 MOV,  6 # AR0 ADDQ,  RTS,
CODE TRIAL  \  ---  | a test word for the debugger.
  4 # DR0 MOVQ,  5 # DR0 SUBQ,  4 # DR0 ADDQ,  14 # DR0 MULU,
 DUP *+ BSR,  NEXT  ;C  FIXED
: TEST  EDITOR FLUSH DEBUG TRACING  TRIAL NOTRACE ;   HEX
: FNORD 1234 DUP 2* SWAP + DROP ;
HERE ASSEMBLER
  1234 #L DR0 MOV,  3 # DR0 ASL,  DR0 S -[ MOV,  RP [ DR0 MOV,
  700 # SR OR,   \ must be in supervisor!
  S [+ DR1 MOV,  DR0 DR1 CMP,  NE IF,  DR2 CLR,  THEN,
  SWAP *+ BSR,  F3FF # SR AND,  RTS,
CONSTANT TESTCODE  HEX  FORTH DEFINITIONS EDITOR FLUSH DEBUG


\ trap grabbing stuff: mssgs              ( 23  6 86 CRC 12:56 )
CODE SR@   DR0 CLR,  SR DR0 .W MOV,  DR0 S -[ MOV,  NEXT ;C

DEBUG DEFINITIONS
    \ VERY dangerous!!! This can shut off keyboard, etc, ix
CODE SR!   S [+ DR0 MOV,  DR0 SR .W MOV,  NEXT  ;C

MSSG WAS  was: "                MSSG PTR  Pointer"
MSSG EXP  Exception"            MSSG IOWA  I/O"
MSSG ADDR  Address "            MSSG INSTR Instruction"
MSSG PGC  Program Counter"      MSSG USR  User Stack"
MSSG BSER Buss Error  "         ctl g here 2- c!
MSSG ADDRER Address Error  "    ctl g here 2- c!
MSSG ILL Illegal Instruction"   MSSG ZERO/ Zero Divide"
MSSG CHK CHK Instruction"       MSSG TRAPV TRAPV"
MSSG .IN  In"                   MSSG .BAS  Base"
\ trap grabbing stuff: mssgs              ( 27 11 88 CRC 10:29 )
MSSG PRIV Privilege Viloation"  MSSG TRC Trace"
MSSG 1010L Line 1010"           MSSG 1111L Line 1111"
MSSG RESV Reserved"             MSSG UNINT Uninited Interrupt"
MSSG SPUR Spurious Interrupt"

: .EXCPT \ exception# ---  | print out the name of the exception
  0 MAX 19 MIN  EXEC
 \   0      1      2      3      4      5      6      7
     |      |   BSER ADDRER    ILL  ZERO/    CHK  TRAPV
 \   8      9     0A     0B     0C     0D     0E     0F
  PRIV    TRC  1010L  1111L   RESV   RESV   RESV  UNINT
 \  10     11     12     13     14     15     16     17
  RESV   RESV   RESV   RESV   RESV   RESV   RESV   RESV
 \  18     19     1A     1B     1C     1D     1E     1F
  SPUR      |       STOP
\ register printout stuff                 ( 18  9 88 CRC  8:48 )
: (.REGS)  \ addr/da addr/names  ---   | print out 8 registers
  SWAP 8 0 DO  ?STACK 2DUP I ROT EXECUTE  4 >COL
  DUP 4 ASCI  7 >COL F@ 09 U.R  COL  4+ LOOP 2DROP ;

: .REGISTERS  \ addr  ---  | show as cpu registers
  CR DUP BL + [ DISASSEMBLER ' .ADDREG  ] LITERAL (.REGS)
              [ DISASSEMBLER ' .DATAREG ] LITERAL (.REGS) ;

: SHOWREGS     \    ---   | show processor at time of ix
  REGISTERS 0C + .REGISTERS ;

REGISTERS 0A + CONSTANT SR      REGISTERS 50 + CONSTANT USP
REGISTERS  6 + CONSTANT PC      SR@ VARIABLE HSR


\ Trace capability                        ( 24  1 92 CRC  9:17 )
: ADREG  CREATE  W,  DOES> W@     REGISTERS 2C + + ;

 0 ADREG AR0     4 ADREG AR1     8 ADREG AR2    0C ADREG AR3
10 ADREG AR4    14 ADREG AR5    18 ADREG AR6    1C ADREG AR7
0C ADREG SP                     18 ADREG U      1C ADREG RP

: DAREG  CREATE  W,  DOES> W@     REGISTERS 0C + + ;

 0 DAREG DR0     4 DAREG DR1     8 DAREG DR2    0C DAREG DR3
10 DAREG DR4    14 DAREG DR5    18 DAREG DR6    1C DAREG DR7
                14 DAREG INDEX  18 DAREG LIMIT

: SHOWRETURN   RP F@ 10 - 30 DUMP ;
: SHOWSTACK    SP F@ 10 - 30 DUMP ;
: SHOWSTACKS   SHOWSTACK SHOWRETURN ;
\ status register help words              ( 11  2 89 CRC  9:01 )
: .BIT  \  d c -- d'  | add c to $ under const iff d is odd
  >R 2 M/MOD ROT R> SWAP 0= IF DROP BL THEN HOLD ;

: .STAT         \ n --  | status printed out
  BASE F@ SWAP  HEX  0
  <#  ASCII C .BIT  ASCII V .BIT  ASCII Z .BIT  ASCII N .BIT
  ASCII X .BIT  BL HOLD >R 3 2/S R>  #  BL .BIT  ASCII S .BIT
  BL .BIT  ASCII T .BIT #>  TYPE  BASE F! ;

: WHERE  INSTRS 0C + DUP 4+ F@ OVER F@
  ROT 8 + F@ BASE F! WHERE STOP

: ?NEXT  \ addr ---  fl | is a copy of next at addr?
  W@ 4E75 = ;

\ trap grabbing stuff: showregs savetraps ( 10 11 87 CRC 22:47 )
: SR?  SR@ .STAT ;

0 VARIABLE TRAPBUF   B/BUF 4- ALLOT

: SAVETRAPS  0 TRAPBUF B/BUF CMOVE ;

: MOVETRAPS     \ addr ---  | install all traps
  SR@ >R  2700 SR!  8 + 8 [ B/BUF 8 - ] LITERAL CMOVE  R> SR! ;

: RESTORETRAPS  \ re-install all Tos's traps
  TRAPBUF  MOVETRAPS ;




\ trap grabbing stuff: showregs savetraps ( 31 12 88 CRC 13:06 )
: SHOWALL  BASE F@ HEX  CR  fudge off \ io pointer restored
  SPACE INSTRS 0C + DUP F@ .SCR   .IN WAS  4+ DUP F@ 7 U.R
  4+ F@  .BAS WAS  3 U.R   USR WAS USP F@ 8 .R  CR
  REGISTERS 4C + F@ IOWA WAS 12 .R
  EXP WAS REGISTERS   C@ DUP 4 .R SPACE  .EXCPT  CR pgc was
  PC F@ 6 .R  ."  SR" WAS SR W@ .STAT  ."  Steps: " STPS  ?
\ REGISTERS C@ 9 = IF  *W F@ -DUP  IF CR ."  Tracing " aID.
\     THEN   *IP F@ -DUP  IF ."  In " aID.  THEN  THEN
  REGISTERS C@ DUP 3 = SWAP 2 = OR IF INSTRS 2+ ADDR F@ 8 U.R
  INSTRS    8 + F@ FORTH IP F! CR DISASSEMBLER INST DEBUG ELSE
  REGISTERS C@ 9 = IF PC F@ FORTH IP F! CR  DISASSEMBLER INST
\   DEBUG  PC F@ ?NEXT 0= IF  RP F@ @ C>N *W F! THEN
\   PC F@ [ ' QUIT ] LITERAL = IF W F@ C>N *IP F! THEN
\   PC F@ [ ' ;S   ] LITERAL = IF RP F@ @ C>N *IP F! THEN
  THEN THEN  SHOWREGS  BASE F! ;
\ breakpoint.stuff: start                 (  3  6 87 CRC 10:36 )
DEBUG DEFINITIONS HEX
      \ each breakpoint needs: address = 4 bytes
0 VARIABLE BREAKS    \ allow 8 breakpoints
  8 4* 4- ALLOT  BREAKS HERE OVER - ERASE

CODE >BREAK   \ brk#  -- addr of storage | pointer to table
  S [ DR0 MOV,  2 # DR0 LSL,  BREAKS 0 &D*+ .LR AR0 LEA,
  AR0 S [ MOV,  NEXT  ;C

: ENABLE   >BREAK 0 SWAP C! ;

: DISABLE  >BREAK 1 SWAP C! ;

0 VARIABLE TRACESTEPS            0 VARIABLE SPARE
0 VARIABLE USERTEST
\ breakpoint.stuff:                       ( 18  9 91 CRC 11:12 )
: .BREAKS   8 0 DO I >BREAK F@ -DUP IF  FFFFFF AND CR I 3 .R
  I >BREAK C@ IF ."  Disabled " ELSE 0A SPACES THEN
  FORTH IP F! DISASSEMBLER INST DEBUG THEN LOOP ;

: KILL   \ brk# ---  | restore a given breakpoint
  >BREAK OFF  .BREAKS ;

: BREAKPOINT    \ addr br#  ---   | install breakpoint
  >BREAK F! .BREAKS ;

: ?BREAKPOINT?  \   ---   | have we got a breakpoint?
  USERTEST F@ DUP IF EXECUTE THEN  \ perform user's test
  IF  TRACESTEPS OFF ." User Break"  ELSE  \ stop if user test
  8 0 DO I >BREAK F@ PC F@ =  IF TRACESTEPS OFF  ."  Breakpoint"
     I 4 .R  I >BREAK F@ ."  at" 9 .R LEAVE THEN LOOP THEN ;
\ breakpoint.stuff:                       ( 25  7 86 CRC 13:39 )
: MASSACRE  BREAKS [ 8 4* ] LITERAL ERASE ;    MASSACRE

: ?SUPER  SR C@ BL AND ;

: RETURN  ?SUPER IF RP ELSE USP THEN ;

: (SUBROUTINE)   RETURN F@ SPARE F@ > ;

: USERTEST:  [COMPILE] ' USERTEST F! ;

: SKIPSUB   [ ' (SUBROUTINE) ] LITERAL USERTEST F!
  RETURN F@ 4- SPARE F! ;



\ breakpoint.stuff:                       (  9  7 91 CRC  7:15 )
: >next         \ --- fl | break when we hit next
  pc f@  disassembler ?next  0= ;

: tonext   ' >next  usertest f! ;



























\ REloading screen                        ( 20  6 86 CRC 12:34 )
editor flush forth definitions
debug restoretraps
' unupdate nfa fence f!
forget debug
: task ;
debug









\ Trace capability: save host             ( 24  7 93 CRC 17:29 )
0 VARIABLE HOST  C/L ALLOT

: SUPERVISOR  SR BL TOGGLE  SR W@ .STAT ;
: DOTRACE     SR 80 TOGGLE  SR W@ .STAT ;

: TAKE   DISASSEMBLER  RANGE F@  PC F!  SHOWALL ;
;S
Stack words as seen from the return stack on an exception:
       Program Counter low
       Program Counter high
rp --> Status register
       Instruction Register    ( on buss or addr exception)
       Access address low      ( on buss or addr exception)
       Access address high     ( on buss or addr exception)
rp --> Access information      ( on buss or addr exception)
\ trap grabbing stuff: stuff regs         ( 23  6 86 CRC 13:07 )
CODE (RCVR)  AR0 RP -[ MOV,  REGISTERS 50 + #L AR0 MOV,
 OFUSER I/O AR0 -[ MOV,  ( i/o value)  FFFF # AR0 -[ MOVM,
 RP [+ REGISTERS 2C + @#L MOV, \ put old ar0 in place!
 RP [+ AR0 -[ .W MOV,  \ old sr
 RP  [ AR0 -[    MOV,  \ old program counter
 INSTRS 0C + *+ AR0 LEA,
 OFUSER BLK AR0 [+ MOV,  OFUSER IN AR0 [+ MOV,
 OFUSER BASE AR0 [ MOV,
 ]] RP! SP!  SHOWALL  ABORT [  ;C       FIXED






\ trap grabbing stuff: generic traps      ( 12  3 91 CRC  9:29 )
  \ Generic trap vector -- use if no special handling required
IX  HERE 4 + *+ BSR,  NOP,  RP [+ REGISTERS @#L MOV,
  ' (RCVR) *+ BRA,
DROP  >R

: INSTALLGENERICS   [ R> ] LITERAL  3  ASSEMBLER
  2DUP  4 EXP! ( illegal in)    2DUP  5 EXP! ( 0 division)
  2DUP  6 EXP! ( Check)         2DUP  7 EXP! ( Trapv)
  2DUP  8 EXP! ( priviledge)    2DUP  9 EXP! ( trace )
\ 2DUP 0A EXP! ( line 1010)     2DUP 0B EXP! ( line 1111)
  2DUP 0F EXP! ( neophyte)           18 EXP! ( Spurious)    ;
;S   Since GEM uses line 0A, we can't....



\ addr & buss exceptions                  ( 12  3 91 CRC  9:30 )
IX  HERE 4 + *+ BSR,  NOP,  RP [+ REGISTERS @#L MOV,
  RP  [+ INSTRS     @#L    MOV,  \ access data, addr hi
  RP  [+ INSTRS 4+  @#L    MOV,  \ access add lo, instr reg
  AR1 RP -[ MOV,  DR0 RP -[ MOV,  INSTRS 6 + *+ DR0 .W MOV,
  RP 0A &[ AR1 MOV,  \ pc at time of exception: -> next one
  BEGIN,  AR1 -[ DR0 .W CMP,  EQ UNTIL,
  AR1 INSTRS  8 + @#L MOV,  RP [+ DR0 MOV,  RP [+ AR1 MOV,
  ' (RCVR) *+ BRA,              DROP >R

: INSTALLBUSSES   [ R> ] LITERAL  3  ASSEMBLER
  2DUP 2 EXP! ( buss error)  3 EXP! ; \ addr err
BASE F@ DECIMAL
: HELP SCR F@ 269 LIST SCR F! ;
BASE F!

\ trap grabbing stuff: trap 1 intercept   ( 12  3 91 CRC  9:27 )
;S BASE F@ HEX  \ detects & queries term trap from user or super
 IX  5 # RP [ BTST,  EQ IF,  USP AR0 MOV,  AR0 [ .W TST,  ELSE,
    RP 6 &[ .W TST,  THEN,  EQ IF,  ]]
 CR ." Are you sure you want to leave FORTH? " KEY DUP EMIT
 ASCII _ AND ASCII Y - IF  ABORT  THEN  CR
    EDITOR FLUSH  DEBUG RESTORETRAPS  [[ THEN,
 84 TRAPBUF + F@ @#L JMP,  DROP >R   HERE 4- >R
: INSTALLTERM  84 F@  [ R> ] LITERAL F!
  [ R> ] LITERAL  ASSEMBLER 3 21 EXP! ;     BASE F! ;S
  This code is Atari ST specific. It intercepts the "term" trap
handler. If TOS can't figure out what else to do with an error,
it will eventually wind up here. This interception gives you
the option of trying again. On the other tentacle, if FORTH got
clobbered in the process of the error, this code will crash. You
must then hit reset. Oh well.
\ Trace capability: trabort vars          ( 16  7 92 CRC 11:07 )
: TRABORT  [COMPILE] FORTH DEFINITIONS [COMPILE] DEBUG HEX
  SHOWALL  ." real-FORTH Trace Facility "
( STACKPRINT F@ IF) DEPTH IF .S THEN ( THEN )  QUIT STOP

0 VARIABLE SPEAKER
0 VARIABLE TRACECOUNT      ' | VARIABLE SETSUP

DEBUG DEFINITIONS     HEX
: ISSETUP: [COMPILE] ' SETSUP F! ;

HERE FENCE F!




\ Trace capability: step steps notrace    ( 15  7 86 CRC 23:03 )
CODE STEP     TRACESTEPS @#L CLR,
 FFFF # HOST @#L MOVM, \ save host system
 SR DR0 MOV,  DR0 HSR @#L MOV,
 REGISTERS 0C + @#L FFFF # MOVM,
 PC *+ AR0 LEA,               \ install target
 AR0 [+ RP -[    MOV,         \ old program counter
 AR0 [+ RP -[ .W MOV,         \ old sr
 REGISTERS 50 + @#L AR0 MOV,  \ user rp
 AR0 USP MOV,                 \ set user stack accordingly
 REGISTERS 2C + *+ AR0 MOV,  RTE,        ;C             FIXED

CODE S ' STEP *+ BRA,  ;C  FIXED
CODE STEPS  \ ct ---   | step through ct steps, then stop
 S [+ DR0 MOV,  1 # DR0 SUBQ,
 DR0 TRACESTEPS @#L MOV,  ' STEP 6 + *+ BRA,  ;C        FIXED
\ Trace capability: trace ix              ( 20  6 86 CRC 14:56 )
IX 7 # SPEAKER @#L BCLR,  NE IF,  TRACESTEPS @#L CLR,
   2FFF # RP [ .W AND,              \ end of tracing
   2000 # RP [ .W  OR,  THEN,       \ return to supervisor

 HERE 4 + *+ BSR,  NOP,  RP [+ REGISTERS @#L MOV,   \ save pc
 AR0 RP -[ MOV,                \ hold target ar0 for a while

 REGISTERS 50 + #L AR0 MOV,    \ shove target registers
 OFUSER I/O AR0 -[ MOV,   FFFF # AR0 -[ MOVM,  \ to debug array
 RP [+ REGISTERS 2C + @#L MOV, \ put old ar0 in place!

 RP [+ AR0 -[ .W MOV,          \ old sr
 RP [+ AR0 -[    MOV,          \ old program counter
 RP REGISTERS 48 + @#L MOV,    \ adjusted rp

\ Trace capability: trace ix              ( 12  3 91 CRC  9:34 )
 INSTRS 0C + *+ AR0 LEA,
 OFUSER BLK AR0 [+ MOV,  OFUSER IN AR0 [+ MOV,
 OFUSER BASE AR0 [ MOV,

 USP AR0 MOV,  AR0 REGISTERS 50 + @#L MOV, \ save usp
 HSR *+ DR0 MOV,  DR0 SR MOV,      \ host status register
 HOST @#L FFFF # MOVM,             \ restore host environment
 ]] ?BREAKPOINT? [[    1 # STPS @#L ADDQ,
 1 # TRACECOUNT @#L ADDQ,  EQ IF,  ]] SETSUP F@ EXECUTE [[ THEN,
 TRACESTEPS @#L TST,  NE IF,  SPEAKER @#L TST,
   NE IF,  TRACECOUNT @#L TST,  GT IF, ]] SHOWALL [[ THEN, THEN,
   1 # TRACESTEPS @#L SUBQ,  ' STEP 6 + *+ BRA,
 THEN,  ]]     TRABORT [ ASSEMBLER      DROP  >R

: INSTALLSTEP  [ R> ] LITERAL  3 9  ASSEMBLER EXP!  ;
\ Trace capability: trace setup           (  7 11 91 CRC 11:05 )
DEBUG DEFINITIONS  ASSEMBLER HERE            HEX
  DR1 STPS @#L MOV,                     \ count of steps
\ *W @#L CLR,  *IP @#L CLR,
  FFFF # HOST @#L MOVM,                 \ Save the universe
\ SR DR0 MOV,  DR0 HSR @#L MOV,         \ save our status
  FFFF # REGISTERS 0C + @#L MOVM, \ needed for first tracing
  DR0 TRACESTEPS @#L MOV,     \ Set count of steps to skip
  DR0 NOT,  DR0 TRACECOUNT @#L MOV,  \ & steps before setup
  RP [ FF # MOVM,             \ grab last 8 return addresses
  OFUSER 'FIRST AR0 MOV,      \ set user stack
  400 #L AR0 SUB,             \   to below first
  AR4 AR4 SUB,  AR4 AR5 MOV,  \  Clear them out


\
\ Trace capability: trace setup           ( 31  8 91 CRC 13:53 )
  FF # AR0 [ MOVM,            \ put return stack stuff out there
  AR0 REGISTERS 50 + @#L MOV, \ get user stack pointer
  AR0 USP MOV,
  8000 # SR  OR,              \ A tracing we will go!!
  AFFF # SR AND,  RTS,        \ in user mode

CODE TRACING   FD # DR1 MOVQ,
               4 # DR0 MOVQ,  DUP *+ BSR,  NEXT ;C      FIXED
CODE TRACE    \  addr  ---    |  trace it out
  FD # DR1 MOVQ,
  2 # DR0 MOVQ,  S [+ AR2 MOV,  DUP *+ BSR,  AR2 [ JMP, ;C
FIXED

CODE NOTRACE  !CSP  SPEAKER @#L TAS,  ]] ABORT  STOP \ SMUDGE
fixed
\ Trace capability: trace notrace         (  7 11 91 CRC 10:36 )
CODE :TRC     \  addr  ---    |  trace it out
  FD # DR1 MOVQ,
  2 # DR0 MOVQ,  S [+ AR2 MOV,  *+ BSR,
  AR2 [ Jsr,  4 CSP +! rts,     ;C       FIXED
\ rts added so gemulator won't bomb. It still won't trace, tho

FORTH DEFINITIONS
: TRACE:  [COMPILE] ' DEBUG [COMPILE] DEBUG :TRC ;
                 DEBUG DEFINITIONS

CODE >STACK \ ct  ---  | move ct items from host stack to target
   S [+ DR0 MOV,  DEBUG SP ASSEMBLER *+ AR0 MOV,
   DR0 DR1 MOV,  2 # DR1 LSL,  DR1 AR0 SUB,  AR0 AR1 MOV,
   1 # DR0 SUBQ,  DR0 FALSE DO,  S [+ AR0 [+ MOV,  LOOP,
   AR1 DEBUG SP ASSEMBLER @#L MOV,  ' SHOWALL *+ BRA,  ;C
\ Trace capability: skip tracing          ( 17  9 88 CRC 14:15 )
: SKIP   \ Skip execution of the next instruction.
  PC F@ DISASSEMBLER IP F! CR INST IP F@ CR INST DEBUG PC F! ;

: SETUP   DEBUG  starts SP F!  STARTrp RP F!  STARTUSP USP F!
  DR0 SP OVER - ERASE ;
ISSETUP: SETUP

CODE CONTINUE  \ continue, until breakpoint, you hope
 DR0 CLR,  1 # DR0 SUBQ,  DR0 TRACESTEPS @#L MOV,
  ' STEP 6 + *+ BRA,    ;C FIXED

: T STEP STOP
             \ install all our traps
: INSTALLTRAPS  [ HERE ] LITERAL FENCE F!
  INSTALLGENERICS  INSTALLBUSSES ( INSTALLTERM) INSTALLSTEP ;
;S debugger help screen                   ( 26  6 86 CRC 13:01 )
>STACK       -- move  ct  items from host to target stack
sr w@ .STAT  -- print out the most recent status register.
AR0  DR0   SP  RP , etc. -- select registers by name.
NOTRACE      -- Stop trace in a compiled word.
SR@  &  SR!  -- for playing with the status register.
       --> VERY dangerous!!! This can shut off keyboard, etc,!!
SHOWALL      -- display all registers in the debugger.
SKIP         -- skip over the next instruction in the trace.
SPEAKER      -- show the processor after each instruction while
                 doing a multi-step trace. Turn  ON  &  OFF .
STEP         -- execute one step in the current trace.
STEPS        -- execute n steps in the current trace.
TRACING      -- start tracing in a compile word.
TRACE        -- start tracing at a given address.
WHERE        -- points the editor to the error source
\ 68000 assem: load, user variables       ( 26  2 86 CRC 18:11 )
FORTH DEFINITIONS  BASE F@ HEX  VOCABULARY ASSEMBLER IMMEDIATE
ASSEMBLER DEFINITIONS           1 VARIABLE SIZE
130 USER DP2                    134 USER (QUIET)
138 USER OP#
13C USER REG                    150 USER REG1
140 USER MODE                   154 USER MOD1
144 USER EXT                    158 USER EXT1
148 USER EXTL                   15C USER EXTL1
14C USER ADTYPE                 160 USER ADTYPE1
DP2 EXTL1 OVER - 4+ ERASE      REG1 REG - CONSTANT VARLEN
  DECIMAL 271 296 HEX THRU      BASE F! FORTH DEFINITIONS
: CODE  CREATE SMUDGE ASSEMBLER ~ [COMPILE] ASSEMBLER
  IMMEDIATE  LATEST N>C  DP F!  !CSP  REL ON  ;
: ;CODE  ?CSP COMPILE (;CODE)  [COMPILE] ASSEMBLER
  [COMPILE] [ ASSEMBLER ~ FORTH ; IMMEDIATE     CR
\ 68000 assem: clearvar, sizes, .scr&line ( 12  9 85 CRC       )
: CLEARVAR     REG  VARLEN ERASE  0F REG  F! ;    CLEARVAR

: CLEARVAR1    REG1 VARLEN ERASE  0F REG1 F! ;    CLEARVAR1

: 0U.  0 <# # # # # #> TYPE ;

: .SCR&LINE  \ print current line
  BLK F@ DUP .SCR SPACE IN F@ C/L / DUP 3 .R 10 TAB SWAP .LINE ;

: .SIZE CREATE , DOES> F@ SIZE F! ;

0 .SIZE .B        1 .SIZE .W     2 .SIZE .L
DECIMAL
\ : .MSG    -DUP IF 297 (LINE) -TRAILING TYPE THEN ;
HEX
\ 68000 assem: 1st, error, (operand), v!  ( 17  7 86 CRC 11:33 )
: 1ST ( !CSP)  CLEARVAR CLEARVAR1   .L  \ set to cell size
  (QUIET) F@ IF BASE F@ DECIMAL CR .SCR&LINE 52 TAB
  HEX HERE  0U. ( ASCII |) 7C EMIT BASE F! THEN ;
: 2ND REG  REG1 VARLEN CMOVE          CLEARVAR ;
: ~  OP# OFF CLEARVAR  CLEARVAR1 ;   \ reset operand info
: error   ~ [compile] error stop
\ : ERROR ~  HERE COUNT TYPE ."  ? "  .MSG  \ custom error stuff
\     SP!  BLK F@ IF IN F@ BLK F@ THEN  QUIT [ SMUDGE
: ?ERROR    SWAP IF ERROR ELSE DROP THEN ;
: (OPERAND)  OP# F@ -DUP IF  \ operand storage setup
      1-  1 ?ERROR   2ND ELSE 1ST THEN OP# 1+! ;
: ^ ;  IMMEDIATE    \ maintain compatibility
: SIZECK  -1 XOR OVER AND  43 ?ERROR ;
: V!  ADTYPE F! MODE F! 7 SIZECK REG F! ;
: { [COMPILE] [ ;   IMMEDIATE
\ 68000 assem: registers, .lr               11 02 85 CRC
: .LR   EXT F@ 800 OR EXT F! ;  \ make index reg long

: INDEXREG   7 SIZECK 0c 2*s  EXT F@ OR SWAP FF SIZECK OR ;

: DATAREG   CREATE W,  DOES> (OPERAND)  W@  0 1 V! ;
: ADDREG    CREATE W,  DOES> (OPERAND)  W@  1 2 V! ;

  0 DATAREG DR0  1 DATAREG DR1  2 DATAREG DR2  3 DATAREG DR3
  4 DATAREG DR4  5 DATAREG DR5  6 DATAREG DR6  7 DATAREG DR7

  0  ADDREG AR0  1  ADDREG AR1  2  ADDREG AR2  3  ADDREG AR3
  4  ADDREG AR4  5  ADDREG AR5  6  ADDREG AR6  7  ADDREG AR7
                                3  addreg sp   3  ADDREG S
                                6  ADDREG U    7  ADDREG RP
 \ These just happen to be the "C" registers, ay - yup!!
\ 68000 assem: addressing modes           ( 29  5 86 CRC 14:53 )
: DOL  DUP EXT F! EXTL F! ; \ do longs
 \ register indirect            register indirect w/ postinc.
:  [ REG F@ 2 4  V! ;           : [+ REG F@ 3 8  V! ;
 \ addr indirect w/ predec      register indirect w/ displace .w
: -[ REG F@ 4 10 V! ;           : &[ REG F@ 5 20 V!  EXT F! ;
 \ address reg indirect w/ index ( and displacement)
: &D[ REG F@ 6 40 V!  INDEXREG 7FFF AND EXT F! ; \ # ar dr# &d[
 \ e.g.  4 ar0 3 &d[: disp 4 + ar0 + dr3  disp: 8 bits s. ext.
: &A[ REG F@ 6 40 V!  INDEXREG 8000 OR  EXT F! ; \ # ar ar# &a[
 \ absolute short address
: @#  (OPERAND)  0 7  80 V!       EXT F!       ; \ absolute
 \ absolute long address
: @#L (OPERAND)  1 7 100 V!  DOL ;   \   r# mod adtype
: ?PCREL  \ addr --- offset for pc relative & indexed modes
  HERE - 2- DUP 100 -100 WITHIN 4E ?ERROR FF AND  REL OFF ;
\ 68000 assem: more addressing modes      (  2  4 86 CRC 15:37 )
: *+    (OPERAND)  2 7  200 V! HERE - 2- EXT F! ;
  \ pc w/ index ( and displacement) -- data register
: &D*+  (OPERAND)  3 7  400 V! SWAP ?PCREL SWAP
         INDEXREG 7FFF AND EXT F!  ; \ disp dr &D*+
  \ pc w/ index ( and displacement) -- addr register
: &A*+  (OPERAND)  3 7  400 V! SWAP ?PCREL SWAP
         INDEXREG 8000 OR  EXT F! ; \ disp ar &A*+
  \ immediate data ( word)
: #     (OPERAND)  4 7  800 V!  EXT F! ;
  \ immediate data ( long)
: #L    (OPERAND)  4 7 1000 V! DOL ;
: SR    (OPERAND)  4 7 4000 V!  .W ;
: CCR   (OPERAND)  4 7 2000 V!  ;
: USP   (OPERAND)  4 7 8000 V!  ;

\ 68000 assem: lay, odds&ends, bad        (  7  8 86 CRC 12:34 )
: LAY    DUP W, (QUIET) F@ IF BASE F@ HEX SWAP 0U. BASE F!
      2 SPACES ELSE DROP THEN ;

: ODDS&ENDS   \ SP@ CSP F@ - -DUP IF 6 .R   43 ERROR
  ADTYPE1 F@ 1000 = IF SIZE F@ 2-    44 ?ERROR THEN
\ ADTYPE1 F@  800 = IF SIZE F@ 2 AND 45 ?ERROR THEN
  ADTYPE  F@ 2 AND ADTYPE1 F@ 2 AND OR SIZE F@ 0= AND
  47 ?ERROR ;  \ reset for next instruction.

: BAD  47 ERROR   { SMUDGE

: LOUD    (QUIET) ON  ;

: QUIET   (QUIET) OFF ;

\ 68000 assem: layext, finish             ( 19  1 86 CRC       )
: LAYEXT        ADTYPE1  F@  0EE0 AND
   IF  \ &[  &D[ &A[  @#  *+  &D*+  &A*+  #
     EXT1 F@ LAY    ELSE  ADTYPE1 F@  1100 AND
   IF  ( @#L  #L ) EXTL1 W@ LAY EXT1 F@ LAY   THEN THEN
                ADTYPE   F@  0EE0 AND
   IF  \ &[  &D[ &A[  @#  *+  &D*+  &A*+  #
     EXT  F@ LAY    ELSE  ADTYPE  F@  1100 AND
   IF  ( @#L  #L ) EXTL  W@ LAY EXT F@ LAY    THEN THEN    ;

: FINISH  ODDS&ENDS LAY  LAYEXT ~ ;     ;S
     rather than play around with how this code works, I split
long word operands into two parts, as per the 16 bit version.
But the division is done between the  F!  in  DOL  and the  W@
here.

\ 68000 assem: condition codes, ?bytebr   (  5  2 92 CRC  9:24 )
: BRCH CREATE W,  DOES> W@  ;

  0 BRCH TRUE   100 BRCH FALSE   200 BRCH HI     300 BRCH LS
400 BRCH CC     500 BRCH CS      600 BRCH NE     700 BRCH EQ
400 BRCH HS     500 BRCH LO   \ synonyms
800 BRCH VC     900 BRCH VS      A00 BRCH PL     B00 BRCH MI
C00 BRCH GE     D00 BRCH LT      E00 BRCH GT     F00 BRCH LE

: ?BYTEBR  ( n --- n f )  DUP -80 7F WITHIN  >R FF AND R> ;

FORTH DEFINITIONS
: ;C   ?EXEC ?CSP  SMUDGE  [COMPILE] FORTH
  REL F@ IF  HERE  LATEST N>C - 2- SETLEN  THEN ;
ASSEMBLER DEFINITIONS

\ 68000 assem: typesfit, case stuff       ( 20 10 85 CRC       )
: TYPESFIT?  \ caseval1, caseval2 --- fl
        ADTYPE  F@ -DUP IF AND 0= THEN SWAP
        ADTYPE1 F@ -DUP IF AND 0= THEN OR 0= ;

: TYPESOF    \ executes if operand1 & operand2 types are in
             \ caseval pairs.
        4 ?PAIRS COMPILE TYPESFIT?   0BRAN
        5 ; IMMEDIATE

: ENDTYPESCASE  4 ?PAIRS COMPILE BAD
       \ does bad if mode illegal; adds finish at end
         BEGIN  SP@ CSP F@ -
         WHILE 2 [COMPILE] THEN  REPEAT
         CSP F! COMPILE FINISH ;   IMMEDIATE

\ 68000 assem:  1manip --  6manip, 11-14  ( 12  9 85 CRC       )
:  1MANIP   REG1 F@ OR ;              \ 0-2R1
:  2MANIP   REG  F@ OR ;              \ 0-2R1

:  3MANIP   REG1 F@ 9 2*s OR ;        \ 9-11R1
:  4MANIP   REG  F@ 9 2*s OR ;        \ 9-11R1

:  5MANIP   1MANIP  MOD1 F@  3 2*s  OR ;  \  EA1
:  6MANIP   2MANIP  MODE F@  3 2*s  OR ;  \  EA1

: 11MANIP   SIZE F@ 0=  48 ?ERROR ;
: 12MANIP   SIZE F@     49 ?ERROR ;
: 13MANIP   SIZE F@ 1-  4A ?ERROR ;
: 14MANIP   SIZE F@ 2-  4B ?ERROR ;


\ 68000 assem:  7manip -- 10manip, 15-17  ( 18  3 86 CRC 20:48 )
:  7MANIP   SIZE F@  6 2*s OR ;         \ 6-7 size
:  8MANIP   11MANIP  SIZE F@ 2 / 6 2*s OR ;
:  9MANIP   11MANIP  SIZE F@ 2 / 8 2*s OR ;

10003000 VARIABLE MSIZE 2000 W, 3000 W,            \ movesi
: 10MANIP   MODE F@  6 2*s  OR SIZE F@ 1 2*s MSIZE + W@ OR ;

: 15MANIP   EXT F@ ?BYTEBR       \ bra, bsr
      IF ( 8 bit) ADTYPE OFF OR ELSE DROP  THEN ;

: 16MANIP   SWAP F00 SIZECK OR ;  \  branch
: 17MANIP   ROT  F00 SIZECK OR  SWAP 7 SIZECK OR ;  \ dbcc



\ 68000 assem: 18manip -- 22manip         ( 23  7 85 CRC       )
         \ addq
: 18MANIP   ADTYPE1 OFF  EXT1 F@ 1- 7 SIZECK 1+ 7 AND 9 2*s OR ;

: 19MANIP   ADTYPE1 OFF ADTYPE OFF EXT1 F@ FF SIZECK OR ; \ move

: 20MANIP   MOD1 F@ 0= IF 20 OR REG1 F@  \ shift
            ELSE EXT1 F@ 1- 7 SIZECK 1+ 7 AND
            ADTYPE1 OFF THEN  9 2*s OR ;

: 21MANIP   ADTYPE OFF EXT F@ 0F SIZECK OR ;  \ trap

                               \ movem
: 22MANIP   EXT F@ EXT1 F@ EXT F! EXT1 F!  EXTL1 F@ EXTL F!
            ADTYPE F@ ADTYPE1 F@ ADTYPE F! ADTYPE1 F! ;

\ 68000 assem: 23manip -- manip           ( 22  5 86 CRC 18:15 )
: 23MANIP   ADTYPE F@ 10 = ( reverse mask?)
  IF EXT1 F@ 10 0 DO  0 2 U/ LOOP
     1 10 0 DO  ROT OVER * ROT OR SWAP 1 2*s LOOP
     DROP EXT1 F! THEN ;
: MANIP  DUP 0< 47 ?ERROR  19 MIN   EXEC
  |       1MANIP  2MANIP  3MANIP  4MANIP  5MANIP  6MANIP  7MANIP
  8MANIP  9MANIP 10MANIP 11MANIP 12MANIP 13MANIP 14MANIP 15MANIP
 16MANIP 17MANIP 18MANIP 19MANIP 20MANIP 21MANIP 22MANIP 23MANIP
 .B      BAD   { SMUDGE

: OFUSER  \  --  | assemble an access to a user: u off &[
  U [COMPILE] '
  DUP (RES) { ' BASE (RES) ] LITERAL -  4F ?ERROR
  C>P W@ &[ ;   \ e.g:
\ code definitions  ofuser context ofuser current mov, next
\ 68000 assem: saveset, getlegal, forminst( 20 10 85 CRC       )

: SAVESET W, ( 3rd manip) W, ( 2nd) W, ( 1st) \ make , to
           W, ( instruction basis)     \ use on pdp 11 - word!!
      W, W,  ( bit mapped set of 1st & 2nd legal modes) ;

: GETLEGALTYPESET \ ptr -- ptr modset modset
\     DUP  7 +  @ OVER 5 +  @ ;                       \ byte
      DUP 0A + W@ OVER 8 + W@ ;                       \ 11, 68k
: FORMINST  \ ptr -- instruction word                \ 11:
      DUP 6 + W@   \ get basis                        \  6 +
      OVER 4+ W@ MANIP   \ modify basis by 1st manip \  4 +
      OVER 2+ W@ MANIP   \ modify basis by 2nd manip \  2+
      SWAP    W@ MANIP   \ modify basis by 3rd manip
   ;

\ 68000 assem: savesets, 1mi, 2mi         ( 20 10 85 CRC       )
:  SAVESETS \ tos has count, number of sets to save.
   0 DO SAVESET  LOOP ;

: 1MI CREATE   SAVESET   DOES> CASE
        GETLEGALTYPESET  TYPESOF FORMINST ENDOF
           ENDTYPESCASE ;

: 2MI CREATE 2 SAVESETS  DOES> CASE
        GETLEGALTYPESET  TYPESOF FORMINST ENDOF
  0C +  GETLEGALTYPESET  TYPESOF FORMINST ENDOF \ 11 version
           ENDTYPESCASE ;

\  9 +  GETLEGALTYPESET  TYPESOF FORMINST ENDOF \ byte ver


\ 68000 assem: 4mi, 6mi                   ( 20 10 85 CRC       )
: 4MI CREATE 4 SAVESETS  DOES> CASE
        GETLEGALTYPESET  TYPESOF FORMINST ENDOF
  0C +  GETLEGALTYPESET  TYPESOF FORMINST ENDOF \ 11 version
  0C +  GETLEGALTYPESET  TYPESOF FORMINST ENDOF \ 11 version
  0C +  GETLEGALTYPESET  TYPESOF FORMINST ENDOF \ 11 version
           ENDTYPESCASE ;
: 6MI CREATE 6 SAVESETS  DOES> CASE
        GETLEGALTYPESET  TYPESOF FORMINST ENDOF
  0C +  GETLEGALTYPESET  TYPESOF FORMINST ENDOF \ 11 version
  0C +  GETLEGALTYPESET  TYPESOF FORMINST ENDOF \ 11 version
  0C +  GETLEGALTYPESET  TYPESOF FORMINST ENDOF \ 11 version
  0C +  GETLEGALTYPESET  TYPESOF FORMINST ENDOF \ 11 version
  0C +  GETLEGALTYPESET  TYPESOF FORMINST ENDOF \ 11 version
           ENDTYPESCASE ;

\ 68000 assem: instructions adbc -- and   ( 23  7 85 CRC       )
\    1     1 C100    1    4   0C
\   10    10 C108    1    4   0C     2MI ADBC,
  1FFF     2 D0C0    4    5    9               \ adda,
  1800   1FD  600    0    6    7               \ addi,
   7FF     1 D000    4    5    7
     1   1FC D100    3    6    7     4MI ADD,
   800   1FF 5000    6    7   12     1MI ADDQ,
     1     1 D100    1    4    7
    10    10 D108    1    4    7     2MI ADDX,
  1800  41FD  200    0    6    7               \ andi,
     1   1FC C100    3    6    7
   7FD     1 C000    4    5    7
   7FD     1 C000    4    5    7     4MI AND,


\ 68000 assem: instructions asl  -- bsr   ( 12  9 85 CRC       )
   801     1 E100    2    7   14
     0   1FC E1C0    0    6   13     2MI ASL,
   801     1 E000    2    7   14
     0   1FC E0C0    0    6   0D     2MI ASR,
     0   200 6000    0   0F   10     1MI BCC,
     1   1FD  140    0    3    6
   800   1FD  840    0    0    6     2MI BCHG,
     1   1FD  180    0    3    6
   800   1FD  880    0   18    6     2MI BCLR,
     0   200 6000    0    0   0F     1MI BRA,
     1   1FD  1C0    0    3    6
   800   1FD  8C0    0   18    6     2MI BSET,
     0   200 6100    0    0   0F     1MI BSR,


\ 68000 assem: instructions btst -- eor   ( 23  7 85 CRC       )
     1   1FD  100    0    3    6
   800   1FD  800    0   18    6     2MI BTST,
   FFD     1 4180    4    5   0D     1MI CHK,
     0   1FD 4200    0    6    7     1MI CLR,
  1FFF     2 B0C0    4    5    9               \ cmpa,
  1800   1FD  C00    0    6    7               \ cmpi
     8     8 B108    1    4    7               \ cmpm
   7FF     1 B000    4    5    7     4MI CMP,
     0   200 50C8    0    0   11     1MI DBCC,
   FFD     1 81C0    0    4    5     1MI DIVS,
   FFD     1 80C0    0    4    5     1MI DIVU,
  1800  41FD  A00    0    6    7               \ eori
     1   1FD B100    3    6    7     2MI EOR,


\ 68000 assem: instructions exg  -- lsr   ( 11  9 85 CRC       )
     1     1 C140    2    3   0E
     2     2 C148    2    3   0E
     1     2 C188    1    4   0E
     2     1 C188    2    3   0E     4MI EXG,
     0     1 4880    0    2    8     1MI EXT,
     0   7E4 4EC0    0    0    6     1MI JMP,
     0   7E4 4E80    0    0    6     1MI JSR,
   7E4     2 41C0    4    5   0E     1MI LEA,
\    2   800 4E50    0    0    1     1MI LINK,
   801     1 E108    2    7   14
     0   1FC E3C0    0    6   0D     2MI LSL,
   801     1 E008    2    7   14
     0   1FC E2C0    0    6   0D     2MI LSR,


\ 68000 assem: instructions mov  -- mulu  ( 19  3 86 CRC 14:33 )
  1FFF   1FF    0    4    5   0A               \ mov, incl mova
   FFD  2000 44C0    0    5   0C               \ mov, to ccr
   FFD  4000 46C0    0    5   0D               \ mov, to sr
  4000   1FD 40C0    0    6   0D               \ mov, from sr
     2  8000 4E60    0    1   0E               \ mov, to usp
  8000     2 4E68    0    2   0E     6MI MOV,  \ mov, from usp
   7EC   800 4C80    5    8   16
   800   1F4 4880    6    8   17     2MI MOVM,
     1    20  188    2    3    8
    20     1  108    1    4    8     2MI MOVP,
   800     1 7000    0    4   13     1MI MOVQ,
   FFD     1 C1C0    0    4    5     1MI MULS,
   FFD     1 C0C0    0    4    5     1MI MULU,


\ 68000 assem: instructions nbcd -- rol   ( 23  7 85 CRC       )
\    0   1FD 4800    0    6   0C     1MI NBCD,
     0   1FD 4400    0    6    7     1MI NEG,
     0   1FD 4000    0    6    7     1MI NEGX,
     0     0 4E71    0    0    0     1MI NOP,
     0   1FD 4600    0    6    7     1MI NOT,
  1800  41FD    0    0    6    7               \ ori,
     1   1FC 8100    3    6    7
   7FD     1 8000    4    5    7
   7FD     1 8000    4    5    7     4MI OR,
     0   7E4 4840    0    0    6     1MI PEA,
\    0     0 4E70    0    0    0     1MI RESET,
   801     1 E118    2    7   14
     0   1FC E7C0    0    6   0D     2MI ROL,


\ 68000 assem: instructions ror  -- stop  ( 23  7 85 CRC       )
   801     1 E018    2    7   14
     0   1FC E6C0    0    6   0D     2MI ROR,
   801     1 E110    2    7   14
     0   1FC E5C0    0    6   0D     2MI ROXL,
   801     1 E010    2    7   14
     0   1FC E4C0    0    6   0D     2MI ROXR,
     0     0 4E73    0    0    0     1MI RTE,
\    0     0 4E77    0    0    0     1MI RTR,
     0     0 4E75    0    0    0     1MI RTS,
\    1     1 8100    1    4   0C
\   10    10 8108    1    4   0C     2MI SBCD,
     0   1FD 50C0    6   0C   10     1MI SCC,
\    0   800 4E72    0    0   0D     1MI STOP,


\ 68000 assem: instructions sub  -- unlk  (  2  9 85 CRC       )
  1FFF     2 90C0    4    5    9               \ suba,
  1800   1FD  400    0    6    7               \ subi,
   7FF     1 9000    4    5    7
     1   1FC 9100    3    6    7     4MI SUB,
   800   1FF 5100    6    7   12     1MI SUBQ,
     1     1 9100    1    4    7
    10    10 9108    1    4    7     2MI SUBX,
     0     1 4840    0    2   0D     1MI SWAP,
     0   1FD 4AC0   18    6   0C     1MI TAS,
     0   800 4E40    0    0   15     1MI TRAP,
\    0     0 4E76    0    0    0     1MI TRAPV,
     0   1FD 4A00    0    6    7     1MI TST,
\    0     2 4E58    0    0    2     1MI UNLK,


\ 68000 assem: next, fillbr, condbr       ( 26  2 92 CRC 12:08 )
: NEXT   SETL RTS, ;

: BYTEBRCHK  ?BYTEBR 0= 4C ?ERROR ;
: FILLBR   HERE OVER - 2- BYTEBRCHK OVER W@ OR SWAP (QUIET) F@
  IF 2DUP  4 SPACES 0U.  ( ASCII |) 7C EMIT 0U. THEN W! ;

: CONDBR  F00 SIZECK 100 XOR 6000 OR ; \ cond --- 6x00
: ENDBR   SWAP HERE - 2- ?BYTEBR IF OR ~
   ELSE SWAP ~ LAY THEN  LAY ;   \ addr 6x00  ---

: IF,  ?EXEC CONDBR ~ LAY HERE 2- 2 ;
: ELSE,   ?EXEC 2 ?PAIRS 6000 ~ LAY FILLBR HERE 2- 2 ;
: SETLAST HERE LASTTHEN F! ;
: THEN,   ?EXEC 2 ?PAIRS FILLBR  SETLAST  ;
: BEGIN,  ?EXEC HERE 1 ~ ;
\ 68000 assem: conditionals               (  2  1 91 CRC 20:50 )
: AGAIN,  ?EXEC 1 ?PAIRS 6000 ENDBR  ;
: UNTIL,  ?EXEC SWAP 1 ?PAIRS CONDBR ENDBR ;
    \  --- whileaddr beginaddr 1 |
: WHILE,  ?EXEC SWAP 1 ?PAIRS CONDBR ~ LAY HERE 2- SWAP 1 ;
: REPEAT, AGAIN, FILLBR ;
\ : IFL,    IF, 0 LAY DROP 2+ 12 ;
\ : ELSEL,  ?EXEC 12 ?PAIRS 6000 ~ LAY 0 LAY  HERE OVER -
\           SWAP W!   HERE 2- 12 ;
\ : THENL,  ?EXEC 12 ?PAIRS HERE OVER - SWAP W! ~  SETLAST  ;
\ : WHILEL, WHILE, 0 LAY ;
\ : REPEATL, AGAIN, 2+ HERE OVER - SWAP W! ;
: DO,    \ cc  ---  cc reg addr chk | mark start of  dbcc  loop
  ADTYPE F@ 1-  4D ?ERROR REG F@ BEGIN, 4+  ~ ;
: LOOP,  \ cc reg addr chk ---  | assemble  dbcc  loop
  5 ?PAIRS *+ DBCC, ;   \ e.g. NE DR0 DO, ...  LOOP,
































\ PDP 11 target compiler: dump              24 01 85 CRC
  BASE F@ HEX       : OCTAL  8 BASE F! ;

: (WDUMP) \  from-address-2 cnt-1  ---  | memory displayed
   OVER + SWAP DO I T@ 7 U.R 2 +LOOP ;

: WHEAD   CR 6 SPACES 0F AND 10 0  \ start  ---  | header
   DO DUP I + BASE F@ 1- AND 7 .R 2 +LOOP
   DROP ."  <<    ASCII   >>" ;

: WDUMP  \ from-addr  count ---  | dump
   BASE F@ >R HEX   OVER  DUP WHEAD
   + SWAP   DO CR I 6 U.R I 10 2DUP (WDUMP) SPACE
   ASCI  I  F0 AND F0 = IF I WHEAD THEN
   ?TERMINAL  IF LEAVE  THEN  10 +LOOP CR R> BASE F! ;
  BASE F!
\ 68k disassembler. start here            ( 15  5 91 CRC 16:20 )
BASE F@ DECIMAL  ( 42 LOAD)     43 LOAD FORTH DEFINITIONS
VOCABULARY DISASSEMBLER IMMEDIATE
0 VARIABLE ?QUIT                0 VARIABLE IP
0 VARIABLE SZ                   0 VARIABLE RANGE

: IP@+   IP F@ 4 IP +! ;        : IP@+W IP F@ 2 IP +! ;
: MSSG  CREATE  ASCII " WORD HERE C@ 1+ =CELLS ALLOT
  DOES>  COUNT TYPE ;
DISASSEMBLER DEFINITIONS
: .DATAREG  ." DR" 7 AND . ;
MSSG A0 AR0 "   MSSG A1 AR1 "   MSSG A2 AR2 "   MSSG A3 S "
MSSG A4 ar4 "   MSSG A5 ar5 "   MSSG A6 U "     MSSG A7 RP "
: SADDREG  7 AND EXEC A0 A1 A2 A3 A4 A5 A6 A7 STOP
: NSADDREG ." AR" 7 AND . ;
301 319 THRU  BASE F!
\ 68k disassembler. mode printing         ( 23 10 91 CRC  9:33 )
' SADDREG VARIABLE 'ADDREG
: .ADDREG  'ADDREG @EXECUTE STOP
MSSG .[ [ "      MSSG .[+ [+ "  MSSG .-[ -[ "   MSSG .@# @# "
MSSG .@#L @#L "  MSSG .L .L "   MSSG .W .W "    MSSG .B .B "
MSSG .&D[ &D[ "                 MSSG .&A[ &A[ "
MSSG .A* &A*+ "                 MSSG .D* &D*+ "
: ADDRI   .ADDREG .[ ;
: ADDRI+  .ADDREG .[+ ;         : ADDRI- .ADDREG .-[ ;
: .ADDR+D .ADDREG IP@+W TW@ XTEND U. ." &[ " ;

: BEXTEND       255 AND  DUP 128 AND  IF  -256 OR  THEN ;
: DOINDEX \  -- fl off | index register + displacement
  IP@+W  TW@ DUP BEXTEND >R
  DUP 12 2/S OVER 32768 AND IF .ADDREG ELSE .DATAREG THEN
  DUP 2048 AND IF .L ELSE .W THEN 32768 AND  R> ;
\ 68k disassembler. mode printing         ( 18  7 87 CRC  9:40 )
: .ADDR+I  .ADDREG  DOINDEX . IF .&A[ ELSE .&D[ THEN ;

: .ABSW IP@+W TW@ . .@# ;        : .ABSL  IP@+ T@ U. .@#L ;

: .*+   IP@+W TW@ XTEND IP F@ + 2- U.  ." *+ " ;

: .&X*+  DOINDEX  IP F@ 4- + U.  IF .A* ELSE .D* THEN ;

: .OOPS  HEX CTL G EMIT ."   Oops!!" 10 SPACES
   CR CR QUIT STOP

: #B   IP@+W TW@  255 AND .  ." # "  ;

: #W   IP@+W TW@ . ." #W " ; : #L   IP@+ T@ U. ." #L " ;

\ 68k disassembler. mode printing         ( 22 10 85 CRC       )
: IMMED  SZ F@ 7 AND EXEC #B #W #L .OOPS .OOPS #B #L #W STOP

: DOREG  EXEC .ABSW      .ABSL    .*+      .&X*+
              IMMED      .OOPS    .OOPS    .OOPS   STOP

: DOMODE EXEC .DATAREG   .ADDREG   ADDRI    ADDRI+
              ADDRI-     .ADDR+D   .ADDR+I  DOREG  STOP

: EFFECTIVE 63 AND 8 /MOD DOMODE ;

: SIZE 3 AND EXEC .B .W .L .OOPS STOP

: R/EA  DUP EFFECTIVE 9 2/S .DATAREG ;


\ 68k disassembler. gp0 movep             ( 22 10 85 CRC       )
: R/OPMOD/EA  DUP 6 2/S 7 AND  4 /MOD
  IF   SWAP DUP 9 2/S .DATAREG EFFECTIVE
  ELSE SWAP DUP EFFECTIVE  9 2/S .DATAREG THEN  SIZE ;

MSSG .CHG CHG," MSSG .TST TST," MSSG .CLR CLR," MSSG .SET SET,"
MSSG .MOV MOV"  MSSG CCR  CCR " MSSG SR  SR "   MSSG .# # "

: BITSTUFF 3 AND ASCII B EMIT EXEC .TST .CHG .CLR .SET STOP

: MVPADDR .ADDR+I ;             : MVPDATR  9 2/S .DATAREG ;

: MOVP  DUP 6 2/S 3 AND 2 /MOD
   IF  OVER MVPDATR SWAP MVPADDR
   ELSE  OVER MVPADDR SWAP MVPDATR THEN
   IF .L ELSE .W THEN  .MOV ." P," ;
\ 68k disassembler. gp0 bits getsz        ( 12  2 86 CRC 21:09 )
: DYNAMBIT DUP 9 2/S .DATAREG DUP EFFECTIVE 6 2/S BITSTUFF ;

: STATBIT  IP@+W TW@ 31 AND . .#  DUP EFFECTIVE
  6 2/S BITSTUFF ;

: BIT DUP 8 2/S 1 AND IF DYNAMBIT ELSE STATBIT THEN ;

: BIT/MOVP  DUP 3 2/S 7 AND 1 = IF MOVP ELSE BIT THEN ;

MSSG .OR OR"    MSSG .AND AND"  MSSG .SUB SUB"  MSSG .ADD ADD"
MSSG .EOR EOR"  MSSG .CMP CMP"  MSSG .NOP NOP,"
MSSG .RTE RTE,"
: NMON 7 AND EXEC .OR  .AND .SUB .ADD .OOPS .EOR .CMP .OOPS STOP

: GETSZ  6 2/S 3 AND DUP SZ F! ;
\ 68k disassembler. gp0 mov               ( 22 10 85 CRC       )
: GROUP0  DUP 256 AND IF BIT/MOVP ELSE DUP 9 2/S 7 AND
  4 = IF STATBIT  ELSE DUP 6 2/S 3 AND SZ F! IMMED
  DUP 2 2/S 16 /MOD SWAP 15 = IF IF SR ELSE CCR THEN
  ELSE DROP  DUP EFFECTIVE  DUP GETSZ SIZE THEN
  9 2/S NMON ." I," THEN THEN ;

: MOVSZ 12 2/S 3 AND 4 OR SZ F! ;

: MOVSIZE  EXEC .OOPS .B .L .W  STOP

MSSG .RST RESET,"    MSSG .TRP TRAPV,"    MSSG ., ,"

: MOVE  DUP MOVSZ DUP EFFECTIVE
  DUP 6 2/S 63 AND 8 /MOD SWAP DOMODE
  12 2/S MOVSIZE .MOV ., ;
\ 68k disassembler. gp4 lastch jmp/jsr lin( 12  2 86 CRC 21:09 )
: .STOP  IP@+W TW@ . ." STOP," ;

MSSG .RTS RTS,"  MSSG .RTR RTR,"  MSSG .PRV  Priviledged"

: LASTCH 7 AND EXEC .RST  .NOP  .STOP .RTE
                    .OOPS .RTS  .TRP  .RTR  STOP

: JMP/JSR  DUP EFFECTIVE 6 2/S 1 AND IF ." JMP,"
    ELSE ." JSR,"  THEN ;

: LINK/UNLK  DUP 4 2/S 3 AND
  IF DUP .ADDREG 3 2/S 1 AND IF ." UNLK,"
    ELSE IP@+W TW@ . ." LINK," THEN
  ELSE 15 AND . .# ." TRAP,"  THEN ;

\ 68k disassembler. gp4 movusp 2ndch ext  ( 13  2 86 CRC  9:58 )
: MOVEUSP  15 AND 8 /MOD SPACE
  IF ."  USP " .ADDREG SPACE ELSE .ADDREG ."  USP " THEN
  .MOV ., .PRV ;

: 2NDCH DUP 7 2/S 1 AND    IF JMP/JSR   ELSE
        DUP 5 2/S 1 AND 0= IF LINK/UNLK ELSE
        DUP 4 2/S 1 AND    IF LASTCH    ELSE MOVEUSP
     THEN THEN THEN ;
BASE F@ HEX
: NEGX  DUP 4AFC = IF ." The ILLEGAL insturuction" DROP ELSE
  DUP GETSZ 3 = IF SR EFFECTIVE .MOV .,
  ELSE DUP EFFECTIVE GETSZ SIZE ." NEGX," THEN THEN ;
BASE F!
: CLR   DUP EFFECTIVE GETSZ SIZE ." CLR," ;

\ 68k disassembler. gp4 neg movem swap    ( 13  2 86 CRC  9:56 )
: EXT   DUP .DATAREG C/L AND IF .L ELSE .W THEN ." EXT," ;

: NEG DUP GETSZ 3 = IF  SZ ON EFFECTIVE CCR .MOV .,
  ELSE DUP EFFECTIVE GETSZ SIZE ." NEG," THEN ;

: NOT DUP GETSZ 3 = IF  SZ ON EFFECTIVE SR  .MOV .,
  ELSE DUP EFFECTIVE GETSZ SIZE ." NOT," THEN ;

: MOVEMEA  DUP 1024 AND IF ." m-->r " ELSE  ." r-->m " THEN
  IP@+W TW@ OVER EFFECTIVE ." Mask = "  .
  C/L AND IF .L ELSE .W THEN .MOV ." M," ;

: SWAPI .DATAREG .W ." SWAP," ;

: PEA  EFFECTIVE ." PEA," ;
\ 68k disassembler. gp4 tst 3rdch group4  ( 22 10 85 CRC       )
: TST  DUP GETSZ 3 = IF EFFECTIVE ." TAS,"
  ELSE DUP EFFECTIVE GETSZ SIZE ." TST," THEN ;

: CHK/LEA  DUP C/L AND IF DUP EFFECTIVE 9 2/S .ADDREG
  ." LEA," ELSE ." CHK," DROP THEN ;

: 3RDCH  DUP 7 2/S 1 AND IF DUP 3 2/S 7 AND
  IF MOVEMEA ELSE EXT THEN  ELSE DUP 6 2/S 1 AND
   IF DUP 3 2/S 7 AND IF PEA ELSE SWAPI THEN
  ELSE  EFFECTIVE ." NBCD," THEN THEN ;

: GROUP4  DUP 256 AND IF CHK/LEA ELSE
  DUP 9 2/S 7 AND EXEC  NEGX  CLR  NEG  NOT  3RDCH
     TST MOVEMEA  2NDCH THEN ;

\ 68k disassembler. gp5 ccs dbcc scc      ( 12  2 86 CRC 21:10 )
MSSG .RA RA,"   MSSG .SR SR,"   MSSG .T T,"     MSSG .F F,"
MSSG .HI HI,"   MSSG .LS LS,"   MSSG .CC CC,"   MSSG .CS CS,"
MSSG .NE NE,"   MSSG .EQ EQ,"   MSSG .VC VC,"   MSSG .VS VS,"
MSSG .PL PL,"   MSSG .MI MI,"   MSSG .GE GE,"   MSSG .LT LT,"
MSSG .GT GT,"   MSSG .LE LE,"   MSSG .EXG EXG,"

: DOCC 15 AND EXEC .T  .F  .HI .LS .CC .CS .NE .EQ
                   .VC .VS .PL .MI .GE .LT .GT .LE STOP

: DBCC DUP .DATAREG IP F@ IP@+W TW@ XTEND + U. 8 2/S ." DB"
  DOCC ;

: SCC  DUP EFFECTIVE 8 2/S ." S" DOCC ;

: .ADD/SUB 16384 AND IF ." ADD" ELSE ." SUB" THEN ;
\ 68k disassembler. gp5 group5 branches   ( 23 10 91 CRC  9:35 )
: ADDQ/SUBQ  DUP 9 2/S 7 AND DUP 0= IF DROP 8 THEN . .#
  DUP EFFECTIVE DUP GETSZ SIZE
  8 2/S 1 AND IF ." SUBQ," ELSE ." ADDQ," THEN ;

: GROUP5  DUP GETSZ 3 AND 3 = IF DUP 3 2/S 7 AND 1- IF SCC
  ELSE DBCC THEN  ELSE ADDQ/SUBQ THEN ;

: BRANCHES DUP 255 AND IF DUP BEXTEND
  ELSE IP@+W TW@ XTEND 2- THEN IP F@ +
  DUP RANGE F!  .  8 2/S 15 AND  ." *+ B"
  DUP 1 > IF DOCC ELSE IF .SR ELSE .RA THEN THEN ;

: MOVQ   DUP BEXTEND U. .#
  9 2/S .DATAREG .L .MOV ." Q," ;

\ 68k disassembler. gp6                   ( 22 10 85 CRC       )
: (SBCD)  DUP DUP 8 AND IF .DATAREG 9 2/S .DATAREG ELSE
                           ADDRI-   9 2/S ADDRI-   THEN ;

: SBCD   (SBCD) ." SBCD," ;

: ABCD   (SBCD) ." ABCD," ;

: GROUP8 DUP 4 2/S 31 AND 16 = IF SBCD  ELSE
   DUP GETSZ 3 = IF SZ ON
    DUP R/EA 256 AND IF ." DIVS," ELSE ." DIVU," THEN
  ELSE R/OPMOD/EA ." OR," THEN THEN ;

MSSG WRDOP  WORD ADDR "         MSSG LOP  LONG ADDR "

: CMPOPMD 7 AND EXEC .B .W .L WRDOP .OOPS .OOPS LOP STOP
\ 68k disassembler. add/sub               ( 22 10 85 CRC       )
: ADD/SUB DUP GETSZ 3 = IF
  DUP 256 AND IF 2 ELSE 1 THEN SZ F!
  DUP EFFECTIVE DUP 9 2/S .ADDREG
  DUP 256 AND IF .L ELSE .W THEN .ADD/SUB .,
  ELSE DUP 8 2/S 1 AND OVER 4 2/S 3 AND 0= AND
  IF DUP 8 AND 2DUP IF ADDRI+ ELSE .DATAREG THEN
  OVER 9 2/S SWAP IF ADDRI+ ELSE .DATAREG THEN
  DUP GETSZ SIZE .ADD/SUB ." X,"
  ELSE DUP 9 2/S OVER 256 AND IF .DATAREG DUP EFFECTIVE
    ELSE OVER EFFECTIVE .DATAREG THEN
  DUP GETSZ SIZE .ADD/SUB ., THEN THEN ;

: EXG? DUP DUP 8 AND IF .ADDREG 9 2/S .ADDREG .EXG
  ELSE .DATAREG 9 2/S .DATAREG .EXG THEN ;

\ 68k disassembler. group0b               (  4  8 91 CRC 15:43 )
: GROUP0B DUP GETSZ 3 = IF 2 OVER 256 AND 0= + SZ F!
  DUP EFFECTIVE 9 2/S .ADDREG SZ F@ SIZE ." CMPA,"
  ELSE DUP 256 AND 0= IF DUP R/EA 6 2/S CMPOPMD .CMP .,
  ELSE DUP 3 2/S 7 AND 1- IF R/OPMOD/EA .EOR .,
  ELSE DUP EFFECTIVE DUP 9 2/S ADDRI+
  GETSZ SIZE ." CMPM,"  THEN THEN THEN ;

: MULTS SZ ON DUP R/EA 256 AND
  IF ." .MULS" ELSE ." MULU" THEN ;






\ 68k disassembler. exgm group0c l/r      ( 22 10 85 CRC       )
: EXGM DUP 256 AND IF
  DUP .ADDREG 9 2/S .DATAREG .EXG ELSE .OOPS THEN ;

: -AND DUP 6 2/S 3 AND EXEC ABCD EXG? EXGM .OOPS STOP

: GROUP0C DUP 6 2/S 3 AND 3 = IF MULTS ELSE
  DUP 4 2/S 3 AND OVER 8 AND 0= OR
  IF R/OPMOD/EA .AND ., ELSE -AND THEN THEN ;

MSSG .AS AS"    MSSG .LS LS"    MSSG .RX ROX"   MSSG .RO RO"

: L/R IF ." L," ELSE ." R," THEN ;

: .TYPE 3 AND EXEC .AS .LS .RX .RO STOP

\ 68k disassembler. line0a                ( 15  7 86 CRC 19:21 )
MSSG LA0 Initgem,"              MSSG LA1 Putpixel,"
MSSG LA2 Getpixel,"             MSSG LA3 Line,"
MSSG LA4 Hline,"                MSSG LA5 Rectangle,"
MSSG LA6 Polygon,"              MSSG LA7 bitblt,"
MSSG LA8 Textblt,"              MSSG LA9 Showmouse,"
MSSG LAA Hidecursor,"           MSSG LAB Changemouse,"
MSSG LAC Unsprite,"             MSSG LAD Sprite,"
MSSG LAE Rastercopy,"

: LINE0A   15 AND EXEC  \ opcode ---  | print line a(tari) ops
  LA0 LA1 LA2 LA3 LA4 LA5 LA6 LA7
  LA8 LA9 LAA LAB LAC LAD LAE   |   STOP           ;S

     These are the Atari specific graphics "opcodes" for GEM.

\ 68k disassembler. group0e inst          ( 19  4 91 CRC 12:37 )
: GROUP0E DUP 2DUP 6 2/S 3 AND 3 = IF EFFECTIVE 9 2/S .TYPE
  256 AND L/R ELSE
  BL AND IF 9 2/S .DATAREG ELSE 9 2/S 7 AND DUP 0=
  IF DROP 8 THEN . .# THEN DUP .DATAREG DUP GETSZ SIZE
  DUP 3 2/S .TYPE 256 AND L/R THEN ;

: (INST)  IP@+W TW@ DUP 12 2/S 15 AND EXEC
  GROUP0  MOVE  MOVE  MOVE    GROUP4   GROUP5   BRANCHES MOVQ
  GROUP8 ADD/SUB LINE0A GROUP0B  GROUP0C ADD/SUB GROUP0E .OOPS
  STOP

: INST  IP F@  DUP 7 U.R  SPACE  (INST)
  IP F@ OVER -  45 TAB  2DUP ASCI  56 TAB (WDUMP) ;


\ 68k disassembler. (dis)                 ( 15  5 91 CRC 16:19 )
FORTH DEFINITIONS
: (DIS)   BASE F@ HEX !CSP BEGIN ?STACK  CR DISASSEMBLER INST
    SP@  CSP F@ - IF .S THEN
    KEY DUP CTL T = IF  RANGE F@  IP F! ."  **" THEN
  LI = UNTIL BASE F! ;

: DISASSEM  DUP RANGE F!  IP F!  (DIS) ;

: SYMBOLIC   DISASSEMBLER [ ' SADDREG  ] LITERAL 'ADDREG F! ;

: NON-SYMBOLIC  DISASSEMBLER
  [ ' NSADDREG ] LITERAL 'ADDREG F! ;



\ trial area for 0do, i'                  ( 27  2 92 CRC 11:11 )
\       dr5: index                      dr6: limit
CODE (0DO)  \ lim ---   | equivalent of  0 (do)
  RP [ AR0 MOV,  DR5 RP [ MOV,  DR6 RP -[ MOV,
  DR5 CLR,  S [+ DR6 MOV,  AR0 [ JMP, ;C FIXED

: 0DO  COMPILE (0DO)  HERE 3 ;      IMMEDIATE           ;s

CODE I'   DR6 S -[ MOV,  NEXT   ;C

\ : TST     10  0DO  I' DROP  I DROP  LOOP ;  editor flush ;s
  : TST  CR 10  0DO  I' 6 .R  I 4 .R  LOOP ;  editor flush ;s
: DISASSEMBLY  \ addr  ct   ---  | dis for ct lines at addr
  SWAP IP F! 0 DO CR DISASSEMBLER INST LOOP ;
: DISASSEMBLES  \ start end  ---  | dis over range of addrs
 SWAP IP ! BEGIN DISASSEMBLER CR INST DUP IP @ - 0< UNTIL DROP ;
































































































































































































































































































































































































































































































































































































































































































































\ get printer setup                       ( 23  2 89 CRC 17:01 )
DEBUG FORGET TASK      FORTH DEFINITIONS
: TASK ; BASE F@ >R DECIMAL

CODE PRINT@  \ mask -- mask' | set new mask unless -1, ret. old
  S [ DR0 MOV,  DR0 RP -[ .W MOV,     \ mask
  33 # RP -[ .W MOV,                  \ function number
  14 # TRAP,  4 # RP ADDQ,            \ XBIOS call
  HEX FFFF #L DR0 AND,                \ mask hi order out
  DR0 S [ MOV,   NEXT                 \ results

R> BASE F! EDITOR FLUSH




















\ 83 standard expect                      ( 22  3 89 CRC 18:52 )
DEBUG FORGET TASK      FORTH DEFINITIONS
: TASK ; BASE F@ >R HEX
0 VARIABLE #TIB                 0 VARIABLE SPAN

: 83EXPECT
  OVER DUP #TIB F! + OVER    \ add for atari/ibm pc keyboard
     DO KEY DUP 14 +ORIGIN W@ =   OVER 16 +ORIGIN W@ = OR
        IF DROP 08 OVER I = DUP i 2- + i! - ELSE
          DUP 0D = IF LEAVE DROP BL 0 ELSE  DUP THEN I C!
        0 I 1+ C! THEN  EMIT  I OVER - SPAN F!  LOOP  DROP ;

R> BASE F! EDITOR FLUSH



\ Pausing ?terminal                       (  5  8 89 crc 10:06 )
                 FORTH DEFINITIONS   \    FORGET TASK
  FORTH DEFINITIONS ( : TASK ;    PRESENT )
BASE F@ HEX    >R               EDITOR FLUSH

' (?TERMINAL) '?TERMINAL F!

: P?T   (?TERMINAL) IF  (KEY) LI =  ELSE  0  THEN ;

' P?T         '?TERMINAL F!


R>   BASE F!  FORTH DEFINITIONS  ( : TASK ;) EDITOR FLUSH  ;S
  If this is built into the overlays, add line 9 to screen 3.


\ stomp on all-blank screens              ( 21 11 92 CRC 12:24 )
forth definitions               forget task
forth definitions               : task ;

: stomp  block dup b/buf blanks  2 erase update ;

: ?stomp  block  w@ ;

: doablk  dup ?stomp if  drop else  dup  stomp  8 .r  then ;

: doblks  bounds  cr
  do  i doablk  ?terminal if leave then  loop ;
editor flush



































\ ?do implementation 1                    ( 16  1 93 CRC 23:17 )
DEBUG   FORTH DEFINITIONS   \   FORGET TASK
FORTH DEFINITIONS           \   : TASK ;
CODE (?DO)
   S 4 &[ TST, NE IF,  2 # AR7 [ ADDQ,  ' (DO) @#L JMP,  THEN,
   8 # S ADDQ,   AR7 [ AR0 MOV,  AR0 [ AR0 .W MOV,
   AR7 [+ AR0 ADD,  AR0 [ JMP,  ;C   FIXED

: ?DO  ?COMP  COMPILE (?DO)  0 W,  HERE  13  ;  IMMEDIATE

: LOOP    DUP 3 = IF  [COMPILE] LOOP  ELSE
  DUP 13 = IF  OVER 3 [COMPILE] LOOP  DROP
      2- HERE OVER -  SWAP W!  THEN  THEN ; IMMEDIATE

\ : TEST  ?DO [ CR .S ]  DUP DROP  LOOP [ CR .S ] ;
EDITOR FLUSH
\ ?do implementation 2                    ( 17  1 93 CRC 11:27 )
DEBUG   FORTH DEFINITIONS       FORGET TASK
FORTH DEFINITIONS               : TASK ;





 1 3 +THRU






EDITOR FLUSH
\      (loop)                             ( 17  1 93 CRC 11:32 )
ASSEMBLER BEGIN,  2DUP  >R >R   2 # AR0 ADDQ,
  RP [+ DR6 MOV,  RP [+ DR5 MOV,  AR0 [ JMP,
\       dr5: index                      dr6: limit
CODE (LOOP)     RP [+ AR0 MOV,  1 # DR5 ADDQ,
( LABEL LP2 )   here DR5 DR6 CMP,
                R> R> GT UNTIL,      >r
( LABEL LP5 )   here >r AR0 [ AR0 .W ADD,
                AR0 [ JMP,  ;C        FIXED
\ 'NF (LOOP) CFA  MUTATES *(LOOP)*

r> constant lp2         r> constant lp5




\ (+loop) (do)                            ( 17  1 93 CRC 11:32 )
>R >R CODE (+LOOP)  RP [+ AR0 MOV,
  S [+ DR0 MOV,  DR0 DR5 ADD,  DR0 TST,  PL LP2 *+ BCC,
  DR5 DR6 CMP,  LT LP5 *+ BCC,   R> R> AGAIN,    ;C   FIXED
\       dr5: index                      dr6: limit
\ 'NF (+LOOP) CFA  MUTATES *(+LOOP)*

CODE (DO)  RP [ AR0 MOV,  DR5 RP [ MOV,  DR6 RP -[ MOV,
  S [+ DR5 MOV,  S [+ DR6 MOV,  AR0 [ JMP, ;C FIXED







\ (?do)                                   ( 17  1 93 CRC 11:51 )
CODE (?DO)
   S 4 &[ TST, NE IF,  2 # AR7 [ ADDQ,  ' (DO) *+ BRA,  THEN,
   8 # S ADDQ,   AR7 [ AR0 MOV,  AR0 [ AR0 .W MOV,
   AR7 [+ AR0 ADD,  AR0 [ JMP,  ;C   FIXED

CODE (LEAVE)
  RP [+ AR0 MOV,  RP [+ DR6 MOV,  RP [+ DR5 MOV,
  AR0 [+ AR1 .W MOV,  AR1 AR0 ADD,  AR0 [ JMP,  ;C FIXED







\ unloop: clean out loop parameters       (  2  4 19 crc 15:11 )
\ unloop: clean out loop parameters before bailing
editor flush  forget task       : task ;

code (unloop)   \  --- | pull return stack to (do) registers
  RP [+ DR6 MOV,  RP [+ DR5 MOV,  AR0 [ JMP, ;c

: unloop        \  --- | prepair to bail
  compile (unloop) ;    immediate

\ may not work the way you want it to. The word you exit *must*
\ be fixed & entered via a subroutine call.
code exit rts, next ;c

\ : test  10 0 do  i drop i 5 = if unloop exit then loop ;

















































































\ INCLUDE text files: BJR 7 2 92          ( 22  2 92 CRC  8:01 )
FILING FORTH DEFINITIONS        0 VARIABLE TXHDL        HEX
: WORDZ   BL WORD  HERE COUNT  OVER + 4 ERASE ;
0 VARIABLE 'N           : N   'N @EXECUTE  STOP
: Z             \ hdl blk ofs tib --- tib | end of file action
  >R TXHDL F@  FILING (CLF) DROP  BLK 2! TXHDL F!  BLK F@ 0=
  IF  TXHDL F@ IF  N  ELSE  TIB F@ OFF IN OFF  THEN THEN  R> ;
: N TIB F@ 50 0 DO   DUP 1 TXHDL F@ FILING RDF
   1 < IF  LEAVE  [COMPILE] Z  ELSE
     DUP C@ 0D = IF  BL OVER C!  THEN
     DUP C@ 0A = IF  LEAVE  THEN  1+  THEN
   LOOP  4 ERASE  IN OFF BLK OFF ;      ' N 'N F!
: INCLUDE:      \ --- hdl blk ofs | read & interpret a file.
  TXHDL F@ BLK 2@  WORDZ  FILING (OPF)  DUP  0< IF  TXHDL OFF
  ." can't open!"  ELSE TXHDL F!  N THEN ; EDITOR FLUSH
  FORTH 8A ' N C>N 1+ C!  DECIMAL
\ from                                    ( 21  2 93 CRC 19:22 )
FORTH DEFINITIONS  FORGET TASK  \ : TASK ;
: FROM   -FIND  IF  DROP
    DUP (RES)  [ ' ASSEMBLER (RES) ] LITERAL =
    IF  C>P F@  BL WORD  HERE COUNT UPPER
      HERE  SWAP  (FIND)  0= 0 ?ERROR
      STATE F@ <  IF  <COMP>  ELSE  EXECUTE  THEN
    ELSE  HERE COUNT TYPE  ABORT"  Not a Vocabulary!"  THEN
  ELSE  0 ERROR  THEN ;         IMMEDIATE
: TASK ;                        ;S

   It finds a given word in the indicated vocabulary, and either
compiles it or executes it, according to its immediate bit, and
the contents of  STATE .
   N.B. Will also find words in the  FORTH  vocabulary.
   Use it as follows:   ...    FROM DESKJET BOLD     ...
















































































\ serial port controller: load            (  9  4 89 CRC 10:13 )
DEBUG FORGET TASK      FORTH DEFINITIONS      BASE F@ DECIMAL
102 NEEDED ABORT"                                   BASE F!
( : TASK ; ) BASE @ >R DECIMAL  201 NEEDED HALFDUPLEX
HEX

1 0A +THRU

SCR @  0E +BLK LIST SCR F!


R> BASE F!
forth definitions : TASK ;



\ serial port controller                  (  1  4 89 CRC 15:06 )
create MFPSCR  6 2* ALLOT
MFPSCR HERE OVER - -1 FILL     0F W, \ the function number!

MFPSCR 2+ DUP CONSTANT MFPTSR   2+ DUP CONSTANT MFPRSR
       2+ DUP CONSTANT MFPUCR   2+ DUP CONSTANT MFPCTRL
       2+     CONSTANT MFPBAUD

  \ now set our copies to current values of the real thing.
FFFA00  DUP  2D + C@  MFPTSR W! DUP 2B + C@ MFPRSR W!
        DUP  29 + C@  MFPUCR W!     27 + C@ MFPSCR W!


: SEE   BASE F@ HEX  MFPSCR 10 DUMP  BASE F! ;
SEE

\ serial port controller                  ( 26  3 89 CRC  8:39 )
CODE RSCONF   (  ---  | Reconfigure rs-232 port )
  MFPSCR *+ AR0 LEA,  RP DR7 MOV,  7 1- # DR0 MOVQ,
  DR0 FALSE DO,  AR0 [+ RP -[ .W MOV,  LOOP,
  0E # TRAP, ( DOIT)  DR7 RP MOV,  NEXT ;C      FIXED

: GETKEY  \ max  ---  keystroke | get a conditioned keystroke
  SPACE  ASCII : EMIT  KEY  DUP EMIT  BL OR  ASCII a -
  2DUP <  OVER 0<  OR  IF ABORT"  Outside range!"  THEN  NIP ;

: DOCONTROL   CR
  ."  a) no control  b) xon/xoff  c) RTS/CTS   d) both (??)"
  CTL c GETKEY   MFPCTRL W! ;



\ serial port controller                  ( 26  3 89 CRC  9:24 )
DECIMAL   \ table of legal bauds. No others are supported
-1 VARIABLE BAUDS -4 ALLOT  19200 W,  9600 W,  4800 W,  3600 W,
           2400 W,  2000 W,  1800 W,  1200 W,   600 W,   300 W,
            200 W,   150 W,   134 W,   110 W,    75 W,    50 W,

: DOBAUD  CR      BASE F@ DECIMAL
  ."  a) 19200   b)  9600   c)  4800   d)  3600" CR
  ."  e)  2400   f)  2000   g)  1800   h)  1200" CR
  ."  i)   600   j)   300   k)   200   l)   150" CR
  ."  m)   134   n)   110   o)    75   p)    50"
  CTL o GETKEY   DUP  2* BAUDS + W@ 8 .R ."  Baud"
  MFPBAUD W!  BASE F! ;
HEX


\ serial port controller                  ( 26  3 89 CRC 10:19 )
: INSTALL  \ shift left by ct, mask n bits into loc.
           \ c:  loc, ct, mask   | r: n , which is installed
  CREATE   OVER 2*S  W,  W,  ,  ;CODE   \ make compiler do work
  S [+ DR1 MOV,  RP [+ AR0 MOV,         \ data to install
  2 AR0 &[ DR3 .W MOV,  DR3 DR1 LSL,    \ shift by ct.
  4 AR0 &[ AR1 MOV,  AR1 [ DR0 .W MOV,  FF # DR0 .W AND, \ exta
  AR0 [ DR2 .W MOV,  DR2 DR1 .W AND,    \ mask
  -1 # DR2 .W EOR,  DR2 DR0 .W AND,
  DR1 DR0 .W OR,  DR0 AR1 [ .W MOV,  NEXT   ;C   ;S
registers:      ar0: data
ar1: the location at which to install
dr0: the data at ar0  ( any change means strip hi 8 bits.)
dr1: the data to be installed
dr2: the mask for installing
dr3: the count for shifting
\ serial port controller                  ( 26  3 89 CRC 10:45 )
\ loc  ct mask
MFPUCR  1  1  INSTALL ODD/VN
MFPUCR  2  1  INSTALL PTY
MFPUCR  3  3  INSTALL STRT/STP
MFPUCR  5  3  INSTALL WDLN
MFPUCR  7  1  INSTALL CLK

MFPRSR  0  1  INSTALL RENABLE
MFPRSR  1  1  INSTALL STRIP

MFPTSR  0  1  INSTALL TENABLE
MFPTSR  1  3  INSTALL H,L
MFPTSR  3  1  INSTALL BRK
MFPTSR  5  1  INSTALL AT

\ serial port controller                  ( 26  3 89 CRC 11:46 )
: PARITY
  CR  ."  a) No parity check  b) Parity check"
  CTL a GETKEY  DUP  PTY
  IF  CR  ."  a) Odd parity  b) Even parity"
      CTL A GETKEY  ODD/VN  THEN ;

: MODE      \ N.b: call after user sets clock if he does.
  CR  ."     mode: start stop"
  CR  ."  a) Synch"
  CR  ."  b) Asynch,  1    1"
  CR  ."  c) Asynch,  1    1.5"
  CR  ."  d) Asynch,  1    2  "
  CTL c GETKEY DUP STRT/STP
    2 = IF 1 CLK THEN  ;

\ serial port controller                  ( 26  3 89 CRC 11:46 )
: WORDLEN
  CR  ."  a) 8 bits  b) 7 bits  c) 6 bits  d) 5 bits"
  CTL c GETKEY  WDLN ;

: DOUCR  PARITY MODE WORDLEN  1 CLK ;

: RCVR
  CR  ."  a) Receiver disabled  b) Receiver enabled"
  CTL a GETKEY  RENABLE ;






\ serial port controller                  ( 26  3 89 CRC 12:36 )
: DOTSR
  CR ."  a) Tansmitter disabled  b) Transmitter enabled"
  CTL A GETKEY  DUP  TENABLE  0= IF
  CR ."  a) High Impedance  b) Low state"
  CR ."  c) High state  d) Loopback     "
  CTL c GETKEY  H,L  THEN
  0 BRK   0 AT ;  \ user doesn't muck w/ these!

: DIGIKEY  \ get key, barf on invalid hex
  BEGIN  ?STACK  (KEY)  DUP EMIT
    DUP ASCII a  ASCII z WITHIN IF  BL XOR  THEN
    10 DIGIT  0=  WHILE  CTL G EMIT  CTL H EMIT  REPEAT ;



\ serial port controller                  (  9  4 89 CRC 10:12 )
: GETCHAR  DIGIKEY 10 * DIGIKEY + ;

: SYNCHSTRIP   MFPUCR  W@  18 AND IF  0  0
  ELSE CR ."  a) Strip synch char  b) Receive synch char"
  CTL a GETKEY
  CR ." Two HEX characters for the Synch char: xx"
  CTL H EMIT  CTL H EMIT  GETCHAR
  THEN  MFPSCR W!  STRIP ;

: DUPLEX  CR  ."  a) Full Duplex b) Half Duplex"
  CTL A GETKEY  HALFDUPLEX F! ;

: SETSERIAL   SCR F@  [ 5 +BLK ] LITERAL LIST  SCR F!  purge
  DOUCR  RCVR SYNCHSTRIP  DOTSR
  DOBAUD  DOCONTROL  RSCONF  DUPLEX ;
\ serial port controller                  ( 15  2 95 CRC 11:56 )
: AUTO  \  baud ctrl ucr rsr tsr scr dplx
  CREATE 7 0 DO W,  LOOP
  DOES> purge  DUP W@ HALFDUPLEX F! 2+
  MFPSCR 0C CMOVE  RSCONF ;

\  baud ctrl ucr rsr tsr scr dplx      in hex!
      9    0  88   1  81   0    0  AUTO GENIE
      0    0  98   1  81   0    0  AUTO DEFAULT
      1    0  98   1  81   0    0  AUTO OSI
      9    0  98   1  81   0    0  AUTO BBS
      0    2  88   1  81   0    0  AUTO pc
      1    2  88   1  81   0    0  auto windows
\ to run windows, first: mode com2 96 n 8 1 p at DOS command.
\ yes, the hardware will go to 19,200. DOS's MODE command won't
      0    1  88   1  81   0    0  AUTO gem
















































\ serial port controller                  ( 29  4 89 CRC  6:50 )










To set the serial port for a new setup, use  SETSERIAL

Otherwise, use  GENIE ,  DEFAULT ,  BBS , PC or OSI , depending
on your target.

\ import files from pc                    (  6 10 94 CRC 15:27 )
decimal 201 needed >local       forget task
cd: p:\work
forth definitions hex : task ;
0 variable len
0 variable date
0 variable time

1 5 +thru

editor flush





\ import files from pc                    (  6 10 94 CRC 15:27 )
: ?terminal
  i/o f@ >r  input >local  ?terminal  r> i/o f! ;

: lemit
  i/o f@ >r  output >local  (emit)  r> i/o f! ;

: xemit  i/o f@ >r  output >host  (emit)  r> i/o f! ;

: gettxt        \ addr ---  | get text until cr or terminal ix
  begin  (key) dup  ctl m =  if drop  0  then
      dup  while  over c!  1+  repeat
  2drop ;

: getfile       \ get file name from host into file
  filing  file  40 erase  file  gettxt ;
\ import files from pc                    (  6 10 94 CRC 15:27 )
: RECEIVE
  FILING HANDLE F@ IF ABORT"  File Open " THEN
  INPUT >HOST
  GETFILE  FILE (CRF)
  DUP 0< IF  .FILEERR  THEN  HANDLE F!
  ASCII A XEMIT
  BEGIN  ?KEY  UNTIL
  BEGIN  ?KEY  WHILE
     (KEY) PAD C!  PAD 1 HANDLE F@ WTF
     1-  IF  ABORT"  file write problem on output! " THEN
  REPEAT  CLF ;




\ import files from pc                    (  9 10 94 CRC 14:02 )
: GETDATA       \ -- fl | get data on file from host
  filing  FILE (CRF)   FILE CT->0  2DUP LOWER  TYPE
  DUP 0< IF  ASCII O XEMIT  .FILEERR  THEN  HANDLE F!
  ASCII M XEMIT  PAD GETTXT
  ASCII N XEMIT  PAD GETTXT  PAD 1- NUMBER  DROP  LEN F!
  ASCII O XEMIT  PAD GETTXT  PAD 1- NUMBER  DROP  TIME F!
  ASCII P XEMIT  PAD GETTXT  PAD 1- NUMBER  DROP  DATE F! ;

: GETFL         \  fl ---  | get file from host
  if  FILING  INPUT >HOST
  LEN F@  0 DO  BEGIN  ?KEY  UNTIL
     (KEY)   PAD C!  PAD 1 HANDLE F@ WTF
     1-  IF  ABORT"  file write problem on output! " THEN
     I B/BUF MOD 0= IF ASCII . LEMIT  THEN
  LOOP then ;
\ import files from pc                    (  9 10 94 CRC 14:02 )
CODE  DATEFL  \ hndl  ---  | set time & date of file
  RP DR7 MOV,  S [+ DR3 MOV,            \ save stack, handle
  DATE 2+ *+ S -[ .W MOV,               \ date stored
  TIME 2+ *+ S -[ .W MOV,               \ time stored
  1 # RP -[ .W MOV,                     \ flag
  DR3 RP -[ .W MOV,                     \ handle
  S RP -[ MOV,                          \ buffer addr
  57 # RP -[ .W MOV,  1 # TRAP,         \ do it
  4 # S ADDQ,                           \ drop storage space
  DR7 RP MOV,  NEXT  ;C                 \ restore stack





\ import files from pc                    ( 16 10 94 CRC 11:53 )
: GET
  FILING HANDLE F@ IF ASCII O XEMIT  ABORT"  File Open " THEN
  INPUT >HOST  BASE F@ >R  HEX
  BEGIN  (KEY)  ASCII A =
      WHILE  getfile  GETDATA  GETFL
      FILING  HANDLE F@ DATEFL  CLF  CR REPEAT
  INPUT >LOCAL  R> BASE F! ;








\ Filing: multiple screen files           ( 23  7 88 crc 15:07 )
FILING FORTH DEFINITIONS        FORGET TASK
FORTH DEFINITIONS : TASK ;      FILING DEFINITIONS
BASE F@ >R DECIMAL

BLK F@ 1+ DUP 1+   HEX THRU




R> BASE F!  FILING DEFINITIONS EDITOR FLUSH





\ Filing: multiple screen files           ( 23  7 88 crc 15:14 )
0 VARIABLE MHANDLE
0 VARIABLE MMAXBLK
0 VARIABLE MFILE       3E ALLOT  MFILE HERE OVER - ERASE

: (2FR/W)   \ addr blk# r/w ---  | r/w for a file once opened
  MHANDLE F@ IF >R 0A 2*s ( B/BUF * ) MHANDLE F@ 0 LSEEK
      0< IF ABORT"  File Seek Error" THEN
      B/BUF MHANDLE F@ R> IF RDF ELSE WTF THEN
      B/BUF - IF ABORT"  File Size Overflow" THEN
    ELSE ABORT"  File not open!!" THEN ;

: (MR/W)   \ addr blk# r/w ---  | select a file on block #
  OVER MMAXBLK F@ U< IF  (FR/W) ;S  THEN
  >R  MMAXBLK F@ 1+ -  R>  (2FR/W) ;

\ Filing: multiple screen files           ( 23  7 88 crc 16:57 )
: ADDING:  FILING
  MHANDLE F@ IF ABORT"  File already open" THEN
  R-W  PARSEFILE:  FILE MFILE C/L CMOVE  FILE C/L ERASE
  MFILE (OPF) DUP 0< 0= IF MHANDLE F!
  [ ' (MR/W) ] LITERAL  'R/W F!
  0 MHANDLE F@ 2 LSEEK B/BUF /
  MAXBLK  MMAXBLK F!  1+ 'MAXBLK +!  THEN ;

: -ADDED   FILING  MHANDLE F@ -DUP IF (CLF) -DUP IF ." Oops! "
  ELSE  MHANDLE OFF  MFILE C/L ERASE
  MMAXBLK 'MAXBLK F!  MMAXBLK OFF  THEN THEN
  [ ' (R/W) ] LITERAL  'R/W F! ;



















\ Compile Database Query                  ( 22  3 91 CRC 10:52 )
DECIMAL 107 NEEDED IFTRUE  FORTH DEFINITIONS
: ?Y/N   \ Ask if this is required result
  CTL G EMIT ."  y/n " KEY DUP EMIT  ASCII _ AND ASCII Y =
  SPACE ;

: ?DB  CR ." Do you want the data base?" ?Y/N ;

?DB     IFTRUE  CR  DATABASE OTHERWISE

  : ?DBG CR ." Do you want the debugger or filing?" ?Y/N ;

  ?DBG    IFTRUE  CR  DEBUG     IFEND

HERE 200 ERASE

















































\ from: get a word from a vocabulary      ( 26  4 92 CRC 16:33 )
DEBUG   FORTH DEFINITIONS       EDITOR FLUSH
FORGET TASK                     : TASK ;
: FROM   [COMPILE] '
  DUP  (RES)  [ ' ASSEMBLER (RES) ] LITERAL
  - IF  HERE COUNT TYPE BELL
    ABORT"  Not a vocabulary!" THEN
  BL WORD  HERE COUNT UPPER
  HERE  SWAP C>P F@ (FIND)  0= 0 ?ERROR
  STATE F@ <  IF  <COMP>  ELSE  EXECUTE  THEN  ;
IMMEDIATE





\ begin multiple file handler             (  1  1 93 CRC 19:15 )
FILING  FORGET TASK
BASE F@ DECIMAL         227 NEEDED P>C  BASE !
FORTH DEFINITIONS     ( : TASK ;  )     ' (R/W) 'R/W F!
VOCABULARY SCREENS IMMEDIATE    SCREENS DEFINITIONS
BASE F@ >R      DECIMAL

1 12 +THRU              FORTH DEFINITIONS

R> BASE !               EDITOR FLUSH
  : TASK ;              SCREENS





\ multi-files: variables descriptors field( 30 12 92 CRC 20:19 )
0 VARIABLE HNDL         \ holds addr of file to be accessed.
0 VARIABLE FLINK        \ linked list of file descriptors

\ : +HNDL   HNDL F@ + ;

: DESCRIPTOR  CREATE W,  DOES> W@ HNDL F@ + ;
\            0       4        6      8       10     12
\ descriptor:  link | handle | pend | delta | lend | name....
: LINK  HNDL F@ ;       \ 0 DESCRIPTOR LINK
 4 DESCRIPTOR HANDLE
 6 DESCRIPTOR PEND
 8 DESCRIPTOR DELTA
10 DESCRIPTOR LEND
12 DESCRIPTOR NAME

\ multi-files: scrfile:                   ( 31 12 92 CRC 10:50 )
\            0       4        6      8       10     12
\ descriptor:  link | handle | pend | delta | lend | name....
: SCRFILE:      \ c: pend delta  ---
                \ r:   --- addr
  CREATE  HERE HNDL F!  FLINK F@ ,  LINK FLINK F!       \ link
  2dup + 1-  maxblk max  'maxblk f!
  0 , ( handle)  W, ( pend)  1- W,  ( delta)
  FILING BL FWORD  HERE C@ 2+ ALLOT ?ALIGN \ file name
  HERE FENCE F!
  DOES> ;





\ multi-files: .des .files                ( 30 12 18 crc 18:29 )
\            0       4        6      8       10     12
\ descriptor:  link | handle | pend | delta | lend | name....
: .DES  \ addr ---  | descriptor described
  HNDL F@ >R  CR DUP P>C C>N ID.  HNDL F!  10 TAB
  handle   w@       ."  Handle"          3 .r
  DELTA    W@  DUP  ."  Start: "         6 .R
  LEND     W@  +    ."  End: "           6 .R
  NAME     SPACE COUNT TYPE
  R> HNDL F! ;

forth definitions
: FLIST         \ print out the files and their places
  screens FLINK BEGIN  F@ -DUP WHILE  DUP .DES  REPEAT  CR ;
screens definitions

\ multi-files: closefl closeall disks     (  6 11 93 CRC 21:29 )
: CLOSEFL       \ addr ---  | close file at given descriptor
  4+ DUP  W@  DUP IF  (CLF) -DUP IF  FILING .FILEERR  THEN
  OFF  ELSE  2DROP  THEN ;

\ this should be done <only> after a flush!
: CLOSEALL      \ close all files currently open
  FLINK BEGIN  F@ -DUP WHILE  DUP CLOSEFL  REPEAT ;

FORTH DEFINITIONS
: DISKS         360 * ;
SCREENS DEFINITIONS




\ multi-files: openfl openall             ( 30 12 92 CRC 10:12 )
\            0       4        6      8       10     12
\ descriptor:  link | handle | pend | delta | lend | name....
: OPENFL        \ addr ---  | open file at given descriptor
  4+ DUP >R  W@ IF  R> DROP  ELSE
    R 9 +  (OPF) DUP 0< IF  FILING .FILEERR  THEN
    0 OVER 2 LSEEK  B/BUF /  R 2+ W!      \ length
    R 4+ W@  R 6 + W@  +  MAXBLK MAX  'MAXBLK F!
    R> W!  THEN ;







\ multi-files: exercise                   ( 18  9 93 CRC 22:26 )
BASE F@ DECIMAL
: EXERCISE      \ open, then close all files.
  FLINK F@  ?cr
  BEGIN  dup hndl f!  name count type col
      DUP OPENFL  CLOSEFL  link f@  -dup 0= until ?cr ;

: COPIES        \ src dest ct ---  src' dest' | screen copier
  BASE F@ 10 - IF  7 EMIT  ABORT" Try this in decimal!"  THEN
  BEGIN  >R 2DUP  EDITOR COPY FORTH  1 DUP D+
    R  #BUFS MOD 0= IF  FLUSH  THEN     \ cut drive head motion
    R> 1-  DUP 0=  ?TERMINAL OR  UNTIL DROP FLUSH ;
BASE !



\ multi-files: files defined              ( 26  3 19 crc 12:03 )
FORTH DEFINITIONS       SCREENS
\ lsize     delta       forth name      path\filename
   2 DISKS  0 DISKS   SCRFILE: MAINF    \ff\ff.scr  \ this file
   2 DISKS  2 DISKS   SCRFILE: FFX      \ff\ffx.scr \ source
\  2 DISKS  4 DISKS   SCRFILE: GLOS     \ff\glossary.scr
\  2 disks  6 disks   scrfile: goodies  d:\ff\goodies.scr
\  2 disks  8 disks   scrfile: xferff   \ff\xferff.scr \ xfer
\  2 disks 10 disks   scrfile: xferffx  \ff\xferffx.scr \ xfer







\ multi-files: select correct?            ( 19  9 93 CRC 14:17 )
SCREENS DEFINITIONS
: CORRECT?      \ blk# -- fl | is current hndl correct?
  DELTA W@ -  0 LEND W@  WITHIN ;

: SELECT        \ blk# --  | sets hndl to correct descriptor
  DUP CORRECT? 0= IF  HNDL F@ CLOSEFL  1 SWAP
    FLINK F@ BEGIN  HNDL F!
      LINK F@  0= IF  NIP  0 SWAP  THEN
      DUP CORRECT? IF  NIP  0 SWAP  THEN
      OVER  WHILE  LINK F@  REPEAT  DROP
    HNDL F@ OPENFL  THEN  DROP ;

: FSEEKERR  ABORT"  File Seek Error" ;

: OVRFLW  ABORT"  File Size Overflow" ;
\ multi-files: onemore                    ( 20  3 93 CRC 15:01 )
: ONEMORE       \ addr blk# r/w  --- fl
                \ if last + 1, build it else error out.
  OVER  DELTA W@ -  PEND W@ =  IF       \ End 1+ ?
    IF                                  \ do on reads:
      DROP  DUP B/BUF  BLANKS  2 ERASE  \ build it
    ELSE                                \ on writes:
      DELTA W@ -                        \ loc in file
      10 2*s ( B/BUF * ) HANDLE W@ 0 LSEEK \ go to spot in file
      0< IF  FSEEKERR  THEN             \ Error out?
      B/BUF  HANDLE W@  FDATE  WTF      \ Write it to disk
      B/BUF - IF OVRFLW  THEN  THEN     \ Out of disk space?
    PEND W@ 1+ PEND W!  0               \ Adjust file descriptor
  ELSE  1 THEN ;                        \ Nope, do regular

: FNOPN  ABORT"  File not open!!" ;
\ multi-files: (mr/w)                     ( 31 12 92 CRC 10:14 )
         \ r/w for a file, descriptor in hndl
: (MR/W) \ addr blk# r/w  ---  | select file, then read or write
  OVER MAXBLK >  6 ?ERROR       \ No accesses past maxblk
  OVER SELECT                   \ Set to correct file
  ONEMORE  IF                   \ Read to eof + 1 blk?
    >R  DELTA W@ -              \ Otherwise, read or write.
    DUP  PEND W@ > 6 ?ERROR  DUP  0< 6 ?ERROR   \ Range check
    HANDLE W@ IF  10 2*s ( B/BUF * )    \ Set up for seek
      HANDLE W@ 0 LSEEK                         \ in file
        0< IF  FSEEKERR  THEN           \ Error out?
        B/BUF  HANDLE W@  R> IF  RDF    \ Read or write?
          ELSE  FDATE  WTF  THEN        \ Date it on write only
        B/BUF - IF OVRFLW  THEN         \ Out of disk space?
      ELSE  FNOPN  THEN  THEN  ;        \ File open?

\ multi-files: set      mr/w +vol:        ( 18  6 19 crc 11:40 )
FORTH DEFINITIONS
: MR/W  SCREENS  EXERCISE  MAINF  OPENFL
  ' (MR/W) 'R/W F!  MAINF HNDL F! ;

: OR/W  SCREENS ' (R/W)  'R/W F!  CLOSEALL ;

: +VOL:         \ blk# -- blk#' | index into a file
  [COMPILE] ' DUP  (RES)  SCREENS  [ ' MAINF (RES) ] LITERAL
  - IF  BELL ABORT" Not a valid file name! "  THEN
  C>P 8 + W@ +  ( OFFSET F@ + ) ;
: OPENING:      0 +VOL: ;
\ set a given file to be our current disk.
: SETVOL: OPENING:  OFFSET OFF  OFFSET ! ;


\ multi-files: loaders                    ( 26  3 19 crc 12:04 )
\  22 +VOL: STP  LOADER DISKING
\ 302 +VOL: STP  LOADER DESKJET
\   3 +VOL: DBMS LOADER DATABASE
\   0 +VOL: GLOS LOADER ~~~
\   3 +VOL: STP  LOADER LIFE
\ 660 +VOL: STP  LOADER DIALER









\ multi-files: files defined              ( 23  2 19 crc 15:52 )
forget task
FORTH DEFINITIONS    SCREENS    flush

\ lsize     delta         forth name    path\filename
\  2 DISKS 32 DISKS     SCRFILE: rfold  c:\ff\rf.old
\  2 DISKS 34 DISKS     SCRFILE: rfnew  c:\ff\rfx.scr
\  2 disks  8 disks     scrfile: xfer   d:\ff\xfer.scr

\  2 disks 36 disks     scrfile: sudoku c:\ff\sudoku.scr
\  2 disks 36 disks     scrfile: pqerr  d:\disks\pqerror.scr
: task ;




















































































































\ atexit: emulate ANSI C function         (  6 11 93 CRC 20:21 )
base f@         hex
vocabulary exits immediate      exits definitions

40 constant outfuncs

create exitfuncs        exitfuncs outfuncs 4*  dup allot  erase

create coldfuncs        coldfuncs outfuncs 4*  dup allot  erase
-->






\ atexit: emulate ANSI C function         (  7 11 93 CRC 20:58 )
: addto         \ cfa  array  ---   | add cfa to array
  [ outfuncs 4* ] literal  bounds  do
  i f@  0= if  i f!  0  then  4 +loop  0b  ?error ;

forth definitions
: atexit:       \  --- | add following function to exit funcs
  exits  [compile] '  exitfuncs addto ;

: atcold:       \  --- | add following function to cold funcs
  exits  [compile] '  coldfuncs addto ;
-->




\ atexit: emulate ANSI C function         (  6 11 93 CRC 20:21 )
exits definitions
: doarray       \ addr  ---  | execute all funcs in array
  4-  [ outfuncs 4* ] literal  bounds  swap  do
  i f@  -dup if   execute  then  -4 +loop ;

forth definitions
: bye           \ leave the system, doing list as we go.
  exits  exitfuncs  doarray  bye ;

: cold          \ reset the system, doing list as we go.
  exits  coldfuncs  doarray  cold ;
base f!



\ atexit: emulate ANSI C function         ( 18 11 93 CRC 21:45 )
forth definitions               forget task
forth definitions               : task ;

exits definitions
: .array  ?cr   \ addr  ---  | show all funcs in array
  4-  [ outfuncs 4* ] literal  bounds  swap  do
  i f@  -dup if  c>n id.  col  then  -4 +loop  ?cr ;

forth definitions
: .byes         \ show all exit functions
  exits  exitfuncs  .array ;

: .colds        \ show all cold start functions
  exits  coldfuncs  .array ;
editor flush                    .byes           .colds
















































\ Drive map: what drives do we have?      ( 27  3 19 crc 16:44 )
editor flush            decimal
code drvmap     \ --- bitmap | bit map where 1 represents a driv
  10 # rp -[ .w mov,  13 # trap,  2 # rp addq,  dr0 s -[ mov,
  next  ;c

: drives        \ --- | show which drives we have
  drvmap  ascii a
  begin  over 1 and  if  space  dup emit  ascii : emit  then
  1+  swap 2/ swap  over 0=  until  2drop ;

drives




















\ tos interface: loader screen            ( 24  8 02 CRC 18:06 )
BASE F@ DECIMAL  FORGET TASK  107 NEEDED IFTRUE
540 SYSCHECK IFTRUE
  1 +LOAD        76 NEEDED [[           102 NEEDED MSSG
241 NEEDED IX    92 NEEDED LOWER        598 NEEDED ,.R
  2 +LOAD                       FORTH DEFINITIONS  : TASK ;
240 LOAD        420 LOAD  ( screens files )     498 load \ hist
CR  540 SAVEOVER (")    SCREENS  MR/W  FLIST   OTHERWISE
540 BRING  ( SETDRIVE: C )      DEBUG  SAVETRAPS INSTALLTRAPS
SCREENS         MR/W FLIST      EXPECTING GETHISTORY
IFEND   LNCTR OFF   \ 516 NEEDED TBKEY  \ screen blanking
EXPECTING ATEXIT: SAVEHISTORY   ATCOLD: SAVEHISTORY
SCREENS ATCOLD: CLOSEALL
DEBUG   ATCOLD: RESTORETRAPS    ATEXIT: RESTORETRAPS
FILING  ATEXIT: COLDFILING      ATCOLD: COLDFILING      setdta
( 660 +vol: stp needed dial: )  46 +blk load    base f! forth
\ (") "  String embedding                 (  1 11 87 CRC 15:26 )
: (")  \  --  addr | return address of literal $
  R> DUP  COUNT + 1+ =CELLS  >R ;   FIXED

: "    \  --   | compile literal $ in line for later use
  ASCII "  STATE F@ IF  COMPILE (")  WORD  0 HERE COUNT + C!
      HERE C@ 2+ =CELLS ALLOT  ELSE  WORD  THEN ;  IMMEDIATE

\ : FRED   " fred"   COUNT 2DUP DUMP TYPE ;

\ : FRED1  " fred1"  COUNT 2DUP DUMP TYPE ;





\ tos interface: constants, variables     (  4  8 91 CRC 15:14 )
VOCABULARY FILING  IMMEDIATE FILING DEFINITIONS  BASE F@ HEX
0 VARIABLE DTA 28 ALLOT         DTA 1E + CONSTANT DTANAME
0 VARIABLE PATH 3C ALLOT        \ 0 VARIABLE (ATT)
0 VARIABLE HANDLE                 0 VARIABLE FLSZ
0 VARIABLE FILE 3C ALLOT          0 VARIABLE SFILE 3C ALLOT
\ 0 VARIABLE RHANDLE                0 VARIABLE WHANDLE

DECIMAL  1 36 HEX +THRU  DECIMAL ( 112 LOAD)

: ZAPOVER  540 BLOCK OFF UPDATE  EDITOR FLUSH ;
FORTH DEFINITIONS   79 +BLK LOADER XCOPY

\ 118 +blk loader whereis
EDITOR FLUSH FILING DEFINITIONS            BASE F!

\ (setdef) fword fnam ttype               ( 23  8 95 CRC 21:30 )
CODE (SETDEF) \  n (0-15) --- n | set the default drive
  S [ DR0 MOV,  DR0 RP -[ .W MOV,  0E # RP -[ .W MOV,
  1 # TRAP,  4 # RP ADDQ,  DR0 S [ MOV,  NEXT  ;C

: FWORD   \ word for filenames
  BLK F@ IF BLK F@ BLOCK  ELSE  TIB F@ THEN IN F@ + SWAP
  ENCLOSE HERE C/L ERASE IN +! OVER - >R  R HERE C!
  + HERE 1+ R> CMOVE ;

: FNAM   BL FWORD HERE COUNT 2DUP UPPER ; \ condition file name

: TTYPE  \ addr ---  | type until 0 character
  CT->0 TYPE ;

: +DTA  FILING DTA + ;
\      file: files .filename              ( 27  3 92 CRC 16:47 )
;s
: FILE:   CREATE  0 ,  BL FWORD  HERE C@ 2+ ALLOT ?ALIGN
  DOES> ;               FIXED

        \ syntax ' <filewordname> .filename
: .FILENAME  DUP (RES)  [ ' FILE: 36 +    ] LITERAL =
  IF  C>P 4+ COUNT TYPE  ELSE DROP ." Not a file name " THEN ;

FORTH DEFINITIONS   FILING
\ FILE: TXT SHAREWAR.TXT          FILE: SCREENS TEST.SCR
\ and other file names as needed!

FILING DEFINITIONS


\ (pth) (del) (ren)                       ( 13  9 86 CRC 13:44 )
CODE (PTH)      \ addr drive  --- addr | get current path name
 S [+ DR0 MOV,  DR0 RP -[ .W MOV,  \ drive
 S [ RP -[ MOV,  ( addr)  47 # RP -[ .W MOV,  \ fun#
 1 # TRAP,  8 # RP ADDQ,  NEXT  ;C
: GETPATH       \ addr drive  ---  | get current path name
  (PTH)  CT->0 LOWER ;

CODE (DEL)      \ addr --- ec | unlink file at addr
  S [ RP -[ MOV,   41 # RP -[ .W MOV,  1 # TRAP,
  6 # RP ADDQ,   DR0 S [ MOV,   NEXT  ;C

CODE (REN)      \ addrO addrN --- ec | rename Old to New
  RP DR7 MOV,   S [+ RP -[ MOV,   S [ RP -[ MOV,
  RP -[ .W CLR,  ( ??)  56 # RP -[ .W MOV,   1 # TRAP,
  DR7 RP MOV,   DR0 S [ MOV,  NEXT  ;C
\ (parblk) df:                            ( 27  3 92 CRC 16:45 )
CODE (PARBLK)  \  addr drv ---  (buf) | data ret in addr
  S [+ DR0 MOV,  DR0 RP -[ .W MOV,  S [+ RP -[ MOV,
  36 # RP -[ .W MOV,  1 # TRAP,  8 # RP ADDQ,  NEXT  ;C

: .DF   \ addr --- results of (parblk) call shown
  ?CR       DUP F@       ." Free Bytes on Drive:"
        8 DTA + F@ *   0C DTA + F@ *   DUP >R            0D ,.R
  COL   4+  DUP F@       ." Total Bytes on Drive:"
        8 DTA + F@ *   0C DTA + F@ *   DUP               0C ,.R
  COL R> -               ." Occupied:"                   18 ,.R
  COL       DUP F@       ." Number of Clusters:"         0E ,.R
  COL    4+ DUP F@       ." Sector Size, bytes:"         0E ,.R
  COL    4+     F@       ." Cluster Size, sectors:"      0B ,.R
        ?CR ;

\ (parblk) df:                            ( 24  8 95 CRC 18:05 )
CODE CURDRV  \  -- n | return current drive, 0-0f
  19 # RP -[ .W MOV,  1 # TRAP,  2 # RP ADDQ,  DR0 S -[ MOV,
  NEXT ;C

FORTH DEFINITIONS
: DF:       FILING DTA  [COMPILE] CTL (PARBLK)  DTA .DF ;

: DF        FILING DTA  CURDRV 1+     (PARBLK)  DTA .DF ;
FILING DEFINITIONS

: .FILENAME  FILE CT->0 TYPE ;

: .ENTRYNAME  DTANAME CT->0 TYPE ;


\ (crf) (opf) (clf)                       ( 29  5 87 CRC 18:42 )
CODE (CRF) \ addr --- ec | create r-w file at addr
  RP -[ .W CLR,  S [ RP -[ MOV,
  3C # RP -[ .W MOV,  1 # TRAP,  8 # RP ADDQ,  DR0  S [ MOV,
  NEXT ;C
;s      in nucleus for file based versions
CODE (OPF) \ addr --- handle/ec | open file at addr
  (ATT) *+ RP -[ .W MOV,  S [ RP -[ MOV,
  3D # RP -[ .W MOV,  1 # TRAP,  8 # RP ADDQ,  DR0  S [ MOV,
  NEXT  ;C

CODE (CLF) \ handle --- ec | close file at handle
  S [ DR0 MOV,  DR0 RP -[ .W MOV,
  3E # RP -[ .W MOV,  1 # TRAP,  4 # RP ADDQ,  DR0 S [ MOV,
  NEXT  ;C

\ rdf wtf                                 ( 15 11 86 CRC  9:14 )
;S      in nucleus for file based versions
CODE RDF   \ addr count handle --- ct/er | read from addr for
    \ count bytes to file/handle. Return count read or error.
  ' PAUSE <SUB>  RP DR7 MOV,  S [+ DR0 MOV,
  S [+ DR1 MOV,  S [ RP -[ MOV, ( addr )  DR1 RP -[ MOV, ( ct)
  DR0 RP -[ .W MOV, ( handle)  3F # RP -[ .W MOV,
  1 # TRAP,  DR7 RP MOV,  DR0  S [ MOV,  NEXT  ;C

CODE WTF   \ addr count handle --- ct/er | read to addr for
    \ count bytes from file/handle. Return count read or error.
  ' PAUSE <SUB>  RP DR7 MOV,  S [+ DR0 MOV,
  S [+ DR1 MOV,  S [ RP -[ MOV, ( addr )  DR1 RP -[ MOV, ( ct)
  DR0 RP -[ .W MOV, ( handle)  40 # RP -[ .W MOV,
  1 # TRAP,  DR7 RP MOV,  DR0  S [ MOV,  NEXT  ;C

\ setdta (sfirst) (snext) snext attribute (  3 12 86 CRC  9:43 )
CODE SETDTA \  -  | tell os where to put dir stuff
  DTA #L RP -[ MOV,  1A # RP -[ .W MOV,
  1 # TRAP,  6 # RP ADDQ,  NEXT   ;C

CODE (SFIRST) \ addr --- fl | get file entry to dta
  (ATT) @#L RP -[ .W MOV,  \ attribute
  S [ RP -[ MOV,  4E # RP -[ .W MOV,  1 # TRAP,
  8 # RP ADDQ,  DR0 S [ MOV,  NEXT  ;C

CODE (SNEXT)  \  -- fl | get next entry after sfirst
 4F # RP -[ .W MOV,  1 # TRAP,  2 # RP ADDQ,
 DR0 S -[ MOV,  NEXT  ;C

: SNEXT   DTANAME 0D BLANKS  (SNEXT)  DTANAME 0D LOWER ;
: ATTRIBUTE   CREATE   W,  DOES> W@ (ATT) W! ;
\ .fileerr                                ( 25  2 87 CRC 11:42 )
BASE F@ DECIMAL
: .FILEERR   \ filerr# ---  | file error in text
  OK  ." Disk Error: " DECIMAL MINUS DUP  .  CASE
  32 OF ." Invalid Function Number" ENDOF
  33 OF ." File Not Found"          ENDOF
  34 OF ." Pathname Not Found"      ENDOF
  35 OF ." Too Many Files Open"     ENDOF
  36 OF ." Access Not Possible"     ENDOF
  37 OF ." Invalid Handle Number"   ENDOF
  39 OF ." Not Enough Memory"       ENDOF
  40 OF ." Invalid Memory Block"    ENDOF
  46 OF ." Invalid Drive Spec"      ENDOF
  49 OF ." No More Files"           ENDOF    ENDCASE
  SPACE  0 ERROR  STOP
BASE F!
\ sfirst drivename setdrive: b: c:        (  3  6 93 CRC 10:55 )
: SFIRST   DTANAME 0D BLANKS  (SFIRST)  DTANAME 0D LOWER ;

: SETDEF  1F AND  CURDRV SWAP  DUP 0 0F WITHIN  IF [ >R >R ]
  DUP (SETDEF)  1 ROT 2*S AND 0= IF (SETDEF)  [ R> R> ] THEN
     ABORT" You don't have that drive!" THEN  DROP ;

: DRIVENAME  CREATE  LATEST 1+ C@  ASCII A -  W,
  DOES>  W@ SETDEF ;
FORTH DEFINITIONS
: SETDRIVE:   FILING [COMPILE] CTL  1-  SETDEF ;
FILING DRIVENAME B:     DRIVENAME C:    DRIVENAME A:
       drivename d:  \  DRIVENAME E:    \ DRIVENAME P:
( DRIVENAME F:     )            FILING DEFINITIONS


\ (cd)                                    ( 16 11 92 CRC  9:32 )
CODE <CD> \ addr --- fl | set dir to given path
  ' PAUSE <SUB>  S [ RP -[ MOV,  3B # RP -[ .W MOV,
  1 # TRAP,  6 # RP ADDQ,  DR0 S [ MOV,  NEXT  ;C

: (CD)  \ addr ---    | set dir to given drive & path
  DUP 1+ C@  ASCII : =  IF   DUP C@ 1- SETDEF  2+ THEN
  <CD>  -DUP IF .FILEERR THEN ;

: ?FILE         \ ---   | abort if no valid file at handle
  HANDLE F@ 0= IF  OK BELL ABORT" No file open!"  THEN ;





\ cd: lseek                               ( 15  7 92 CRC  7:41 )
FORTH DEFINITIONS
: CD:    \ txt ---  | set current subdirectory
  FILING PATH 3C ERASE   FNAM  PATH SWAP CMOVE  PATH (CD) ;

FILING DEFINITIONS
;S      in nucleus for file-based versions
        \ type: 0= from start 1= rel to current  2=from end
CODE LSEEK   \ faddr handle type --- fl |
  RP DR7 MOV,  S [+ DR0 MOV,  DR0 RP -[ .W MOV, \  type
  S [+ DR0 MOV,  DR0 RP -[ .W MOV,              \  handle
  S [ RP -[ MOV,  ( addr)  42 # RP -[ .W MOV,   1 # TRAP,
  DR7 RP MOV,  DR0 S [ MOV,  NEXT  ;C



\ character filtre for .file:             (  6  8 88 CRC 12:51 )
1 VARIABLE CFILTRE

7F VARIABLE ?TXT   \ binary/text flag for outfile handler

CODE CHARFIL   \ c -- c'  | no unprintable language!
  S [ DR0 MOV,  ?TXT *+ DR0 AND,
  CFILTRE *+ AR0 LEA,  AR0 [ TST,  NE IF,
    BL # DR0 .B CMP,  LE IF,
    CTL [ # DR0 .B CMP,  NE IF,
    CTL J # DR0 .B CMP,  NE IF,
    CTL M # DR0 .B CMP,  NE IF,
    CTL L # DR0 .B CMP,  NE IF,   BL # DR0 .B MOV,
  THEN, THEN, THEN, THEN, THEN, THEN,  DR0 S [ MOV,  NEXT  ;C
  FIXED

\ (fr/w) (chr)                            ( 13  6 87 CRC 19:28 )
: (CHR)  \  chr --   | massage pointers for form control
  DUP CTL J = IF 8 PRINTER LNCTR +!  ELSE
  DUP CTL L = IF           LNCTR OFF THEN THEN
  CHARFIL ;
;S
: (FR/W)   \ addr blk# r/w ---  | r/w for a file once opened
  OVER MAXBLK > 6 ?ERROR  OVER  0< 6 ?ERROR
  RHANDLE F@ IF >R  0A 2*S ( B/BUF *)     PAUSE
  R IF  RHANDLE  ELSE  WHANDLE  THEN  F@ F@ 0 LSEEK
      0< IF ABORT"  File Seek Error" THEN
      B/BUF R> IF RHANDLE F@ F@ RDF ELSE WHANDLE F@ F@ WTF THEN
      B/BUF - IF ABORT"  File Size Overflow" THEN
    ELSE ABORT"  File not open!!" THEN ;


\ parsefile: ?txt textfile binfile -0s    ( 24  8 95 CRC 18:06 )
: PARSEFILE: \ txt ---  | set file name up for tos in  file
  FILE C/L ERASE  FNAM FILE SWAP  CMOVE ;

: TEXTFILE     7F ?TXT F! ;             TEXTFILE

: BINFILE      FF ?TXT F! ;

CODE -0S \ addr ct --- addr ct' | drop trailing 0s
  S [+ DR0 MOV,  S [ AR0 MOV,  DR0 AR0 ADD,
  1 # DR0 ADDQ, BEGIN, 1 # DR0 SUBQ, NE IF,  AR0 -[ .B TST,
  DROP ROT ROT NE UNTIL,  2 THEN,  DR0 S -[ MOV,  NEXT  ;C

: .NAME\        \ print name in dta w/ \ if directory
  .ENTRYNAME  15 DTA + C@  10 AND IF ASCII \ EMIT  THEN ;

\ sfirst: (femit) .bit fmod               ( 15  5 93 CRC 14:04 )
: SFIRST: \  -- fl | get first instance of file in dir
  PARSEFILE:  FILE SFIRST   -DUP IF .FILEERR THEN ;

: (FEMIT)  \ char ---  | send to an open file
  ?FILE  ?TXT F@ AND  (CHR)  SP@ 3+ 1 HANDLE F@  FDATE  WTF
    1- IF  .FILEERR  THEN DROP ;

: .BIT  \  d c -- d'  | add c to $ under const iff d is odd
  >R 2 M/MOD ROT R> SWAP 0= IF DROP ASCII - THEN HOLD ;

: .FMOD  \  m ---  | print a file's mode
  0  <#  ASCII w .BIT  ASCII h .BIT  ASCII s .BIT
  ASCII v .BIT  ASCII d .BIT ASCII m .BIT  BL HOLD #>  TYPE ;


\ close rawdisk attributes                (  7  7 87 CRC 21:08 )
: CLOSE   \ hanvariable ---  | close named file pointed to
  DUP F@  -DUP IF  DUP F@ (CLF)  -DUP IF  .FILEERR THEN
  OFF OFF  THEN ;

\ FORTH DEFINITIONS
\ : RAWDISK   FILING  RHANDLE F@  WHANDLE F@  OR IF
\   OR/W F@ 'R/W F!  OMAX F@  'MAXBLK F!
\   WHANDLE CLOSE  RHANDLE F@ IF  RHANDLE CLOSE   THEN THEN ;

FILING DEFINITIONS FILING        2 ATTRIBUTE OCCULT
 1 ATTRIBUTE R-O                 2 ATTRIBUTE HIDDEN
 4 ATTRIBUTE SYSTEM              8 ATTRIBUTE W/VOL
 0 ATTRIBUTE R-W                -1 ATTRIBUTE ALL
10 ATTRIBUTE SUBDIR             R-W

\ using: writing:                         (  4  8 91 CRC 15:12 )
;s 0 VARIABLE OMAX                 0 VARIABLE OR/W

: USING:  FILING  MAXBLK OMAX F!  R-W
  [COMPILE] ' C>P  DUP 5 + (OPF)  DUP 0<  IF .FILEERR THEN
  OVER F!  DUP  RHANDLE  F!  WHANDLE F!
  0 RHANDLE F@ F@ 2 LSEEK  B/BUF /  1- 'MAXBLK F! ;

FILING DEFINITIONS
: WRITING:
  [COMPILE] ' C>P  DUP 5 + (OPF)  DUP 0<
  IF .FILEERR THEN
  OVER F!  WHANDLE F!
  0 WHANDLE F@ F@ 2 LSEEK  B/BUF /  1-  MAXBLK MAX
  'MAXBLK F! ;

\ lsentry lentry entryaction anentry      ( 24  8 95 CRC 18:06 )
: LSENTRY       \  --- | print directory entry
  .ENTRYNAME CR ;

: LENTRY        \  --- | print directory entry
  BASE F@  DECIMAL   .ENTRYNAME  10 TAB
  1A DTA + F@ DUP 0B ,.R  DUP HEX 9 .R  FLSZ +!
  2 SPACES  18 DTA + W@  EXPANDDATE <DATE> TYPE
  2 SPACES  16 DTA + W@  <GETTIME> TYPE
  SPACE  15 DTA + C@ .FMOD  BASE F!  CR ;

' LSENTRY VARIABLE ENTRYACTION

: ANENTRY       \  --- | print directory entry
  ENTRYACTION @EXECUTE STOP

\ .path dmy ?filespec c+!                 ( 25  2 87 CRC 15:52 )
: PWD: \   ---    | print pathname on given drive
  HERE [COMPILE] CTL  GETPATH  HERE TTYPE  ASCII \ EMIT ;

0 VARIABLE DMY  -4 ALLOT ASCII * C, ASCII . C,  ASCII * C, 0 C,

: ?FILESPEC   \ does the $ at here contain a file spec?
  HERE COUNT  2DUP + 1- C@ ASCII . = IF 2DUP + 3 BLANKS 3+ THEN
  DUP >R +  5 R> MIN
  0 DO DUP C@ ASCII . = IF DROP 0 LEAVE ELSE 1- THEN
    LOOP  0= ;

FORTH DEFINITIONS
CODE C+!   S [+ AR0 MOV,  S [+ DR0 MOV,  DR0 AR0 [ .B ADD,  NEXT
  ;C
FILING DEFINITIONS
\ firstfile                               (  9  4 89 CRC 14:31 )
: .D:PATH   1+  DUP ASCII ` OR EMIT  ASCII : EMIT
  HERE SWAP GETPATH  HERE TTYPE  ASCII \ EMIT  ;
FORTH DEFINITIONS
: PWD  FILING CURDRV .D:PATH ;
FILING DEFINITIONS
: FIRSTFILE   \  ---  | setup to print out a directory
  FILING FILE C/L ERASE
  SETDTA  BLK F@ -DUP IF BLOCK ELSE
  TIB F@ THEN IN F@ + C@ IF BL WORD  \ get file spec if any
    ?FILESPEC 0= IF  HERE COUNT + 1- C@  ASCII \ -
      IF ASCII \ HERE COUNT + C!  1 HERE C+! THEN
      DMY HERE COUNT + 3 CMOVE          \ if needed,
      3 HERE C+! THEN                   \ add *.*
    HERE COUNT FILE SWAP CMOVE          \ save it off
  ELSE  DMY F@ FILE F!  THEN ;          \ get default
\ lc ls lcentry                           ( 15  5 93 CRC 14:17 )
: <LC>    \  ---  | print out a directory
  ENTRYACTION F!  FIRSTFILE
  FILE SFIRST  0= IF   ANENTRY  \  Do it!
  BEGIN  SNEXT  ?TERMINAL OR
      0= WHILE ANENTRY ?STACK  REPEAT THEN ;

: (LC)  \ cfa ---  | ls, lc, etc, using cfa for entry action
  (ATT) F@ >R ALL  4 SPACES PTODAY  FLSZ OFF  CR   <LC>
  ." Total Bytes: "  FLSZ F@ ,.  ?CR  R> (ATT) F!  ;

: LCENTRY  .NAME\  1A DTA + F@  FLSZ +!  COL ;

: L     FILING  ' LENTRY   (LC) ;


\ ?outfile fcr ls lc                      ( 15  7 92 CRC  7:50 )
FORTH DEFINITIONS
: LC    FILING  ' LCENTRY  (LC) ;               LC *.*
: LS    FILING  ' LSENTRY  <LC> ;
: ll    filing  ' lentry   (lc) ;

: ?OUTFILE 'EMIT F@  FILING ' (FEMIT) = ;
FILING DEFINITIONS
: FCR  LNCTR F@  LN/PG F@ >  IF  PAGE  ELSE
  CTL M EMIT  CTL J EMIT  THEN ;

CREATE RET      FILING PATH C/L ERASE    PATH 0 GETPATH
CURDRV ASCII a + C, ASCII : C,
PATH CT->0  IFTRUE
  CT->0 DUP ALLOT  RET 2+ SWAP CMOVE
OTHERWISE  DROP  IFEND  ASCII \ C,   0 C,  ?ALIGN
\ mkf: opf: clf outfile                   (  7  6 87 CRC 11:40 )
: MKF:          \   ---  | create a file w/ given name
  HANDLE F@ IF ABORT"  File Open " THEN PARSEFILE:  FILE (CRF)
  DUP 0< IF  .FILEERR  THEN  HANDLE F!  ;

: OPF:          \   --- er# | open a file w/ given name
  HANDLE F@ IF ABORT"  File open " THEN PARSEFILE:  FILE (OPF)
  DUP 0< IF  .FILEERR  THEN  HANDLE F!  ;

: CLF   ?FILE  HANDLE F@ (CLF) -DUP IF  .FILEERR
  ELSE  HANDLE OFF  THEN ;

FORTH DEFINITIONS
: OUTFILE  FILING ?FILE
        OUTPUT> (FEMIT) (TYPE)  2DROP
            PRINTER   PPAGE   NLIST  FILING FCR  STOP
\ lines waitkey ftype .file:              ( 20  3 90 CRC 18:22 )
FILING DEFINITIONS                 0 VARIABLE LINES
: WAITKEY  \  if crt then wait on every 24th line
  ?CRT IF  OUT OFF  LINES 1+!  LINES F@  0= IF   OUT OFF
    KEY   DUP CTL M =  IF  -1  ELSE  -18  THEN  LINES F!
    LI = IF BELL 2DROP  CLF QUIT THEN  THEN THEN ;

: FTYPE  \ addr ct ---   | type w/ hold for key if -> CRT
  -DUP IF BOUNDS  DO  I C@ DUP CTL J =  OUT F@ 50 MOD 0=
  OR IF  WAITKEY THEN CHARFIL EMIT LOOP ELSE DROP THEN ;

FORTH DEFINITIONS
: .FILE:  \   ---  | file printed out
  FILING  -18 LINES F!
  OPF: HANDLE F@ IF CR BEGIN  HERE B/BUF HANDLE F@ RDF
  HERE OVER FTYPE  B/BUF -  UNTIL THEN CLF ;
\ hd: mv::                                (  3  3 95 CRC 13:39 )
FORTH DEFINITIONS
: HD:      \   ---  | (hex) dump a file
  FILING OPF:  HANDLE F@ IF  PAD FUDGE F!  BASE F@  HEX  0
  BEGIN  PAD 100 ERASE  PAD 100 HANDLE F@ RDF 2DUP DUMP
    -100 FUDGE +! >R 100 + R> 100 -
    ?CRT IF  KEY LI =  ELSE  0  THEN  OR  UNTIL
  FUDGE OFF  DROP  BASE F!  THEN CLF ;

: MV::  \ --  | mv:: oldname newname
  FILING PARSEFILE: FILE  FNAM DROP (REN)
  -DUP IF .FILEERR THEN ;

: MKOUTFILE: LNCTR OFF FILING MKF: OUTFILE ;


\ closeoutfile mout (memit) memory mkill  ( 20  3 90 CRC 19:09 )
: CLOSEOUTFILE  \    | close the output file
  OK  FILING CLF ;

\ 0 VARIABLE MOUT \ c --  | to memory buffer

\ : (MEMIT)  FILING (CHR)  MOUT F@ C! MOUT 1+! ;

\ : .MEM     PAD MOUT F@ OVER - TYPE ;

\ : MEMORY OUTPUT> PRINTER
\               (MEMIT) (TYPE)  2DROP  PPAGE   NLIST  PCR  STOP

\ : MKILL  PAD MOUT F! ;


\ (copy::) room srchanle                  ( 21  8 87 CRC 21:18 )
FILING DEFINITIONS               2 VARIABLE SRCHANDLE
CODE ROOM  \ FIRST PAD - ;
  OFUSER 'FIRST DR0 MOV,  OFUSER DP DR1 MOV,
  PAD HERE - #L DR1 ADD,  DR1 DR0 SUB,  DR0 S -[ MOV,  NEXT  ;C

: (CP::)        \ ---  | copy a file. srchandle & handle set up
  0 BEGIN  PAD ROOM SRCHANDLE F@ RDF >R  R +
     PAD R HANDLE F@ WTF  DUP R> -
     IF  CLF  SRCHANDLE F@ (CLF) SRCHANDLE F!
        FILE (DEL)  DROP
        2DROP ." <---  Out of Room!!!"  ;S THEN
     ROOM - UNTIL  ,. ." Bytes copied"
  CLF  SRCHANDLE F@ (CLF)  SRCHANDLE F! ;


\ cp:: cold ?clf                          ( 29 12 95 CRC 12:14 )
FORTH DEFINITIONS     \ n.b. dest file is created r-w

\ copyfile:: sourc.fl dest.fl  non-destructive file copy
: CP::          \  ---  | copies file from source to dest. file
  FILING  OPF:  HANDLE F@  SRCHANDLE F!
  FILE SFILE C/L CMOVE  HANDLE OFF
  MKF:  (CP::) ;

FILING DEFINITIONS
: COLDFILING RET (CD) ;

: ?CLF   FILING HANDLE F@ IF CLF THEN ;



\ >file buildf                            ( 23  1 93 CRC 21:40 )
FILING DEFINITIONS              0 VARIABLE >FILE

: BUILDF \  --   | build file names
  DTANAME (OPF) DUP 0< IF .FILEERR THEN
  SRCHANDLE F!
  DTANAME  >FILE F@  \ path + fname
  OVER 0D -TRAILING -0S ( len to cmove) NIP  CMOVE
  FILE  TTYPE  SPACE
  FILE (CRF)  DUP 0< IF .FILEERR THEN
  HANDLE F! ;
 \ assumes source file name found & in DTA.

: APPEND:       \ open a file for appending.
  OPF:  0 HANDLE F@ 2 LSEEK
  DUP 0< IF  .FILEERR  ELSE  DROP  THEN ;
\ cleanfile copyfiles:: copies::          (  7  7 87 CRC 20:49 )
: CLEANFILE  >FILE F@ FILE OVER -  C/L +  ERASE ;
FORTH DEFINITIONS
: appendoutfile:  filing append: outfile ;

: CPS::   \  ---  | copy a bunch of files into specified
  FILING  (ATT) F@ >R  R-W           \ dir from current dir
  FIRSTFILE  FILE SFILE C/L CMOVE  PARSEFILE:
  FILE C/L -0S  2DUP 1- + C@  ASCII \ -
     IF 2DUP +  ASCII \  SWAP C!  1+  THEN   + >FILE F!
  SFILE SFIRST  0= IF  CR BUILDF (CP::) CLEANFILE
  BEGIN  SNEXT 0=  WHILE  CR BUILDF (CP::) CLEANFILE  REPEAT
  THEN  ?CR  R> (ATT) F! ;
;S
: COPIES::  COPYFILES:: ;         ;S E.g.:
cps:: *.arc b: saves archives off to floppy
\ migrate: (ver) (mkdir) makedir:         (  1 11 87 CRC 21:24 )
FILING DEFINITIONS
\ : MIGRATE::   \ destructive file copy
\   COPYFILE::  SFILE (DEL)  -DUP IF .FILEERR THEN ;

CODE (VER)   \  --- v# | get tos version #
  30 # RP -[ .W MOV,  1 # TRAP,  2 # RP ADDQ,
  DR0 S -[ MOV, NEXT  ;C

CODE (MKDIR) \ addr --- ec | create dir at addr
  S [ RP -[ MOV,  39 # RP -[ .W MOV,  1 # TRAP,
  6 # RP ADDQ,  DR0  S [ MOV,  NEXT  ;C

: MKDIR:   \   --- | create a dir w/ given name
  PARSEFILE: FILE (MKDIR)
  -DUP 0< IF  .FILEERR  THEN ;
\ (rmdir) deletedir:                      ( 11  4 92 CRC 11:27 )
CODE (RMDIR) \ addr --- ec | delete file at addr
  S [ RP -[ MOV,  3A # RP -[ .W MOV,  1 # TRAP,
  6 # RP ADDQ,  DR0  S [ MOV,  NEXT  ;C

: RMDIR:        \   --- | delete a file w/ given name
  PARSEFILE: FILE (RMDIR)
  -DUP 0< IF  .FILEERR  THEN ;

: PATHOLOGIST   \ -- | creates words to switch directories
  CREATE  ,"  0 C,      \ get path name
  DOES> 1+  (CD) ;




\ (rmod) .mod: (chmod) chmod:             ( 29  5 87 CRC 19:01 )
CODE (RMOD) \  addr ---  | return file mode
  RP DR7 MOV,  RP -[ CLR,  S [ RP -[ MOV,  43 # RP -[ .W MOV,
  1 # TRAP,  DR7 RP MOV,  DR0 S [ MOV,  NEXT  ;C

: .MOD:   PARSEFILE:  FILE (RMOD) DUP
  0< IF .FILEERR ELSE .FMOD THEN ;

CODE (CHMOD) \ addr ---  | change mode from existing to (att)
  RP DR7 MOV,  (ATT) @#L RP -[ .W MOV, 1 # RP -[ .W MOV,
  S [ RP -[ MOV,  43 # RP -[ .W MOV,
  1 # TRAP,  DR7 RP MOV,  DR0 S [ MOV,  NEXT  ;C        FIXED

: CHMOD:   PARSEFILE:  FILE (CHMOD) DUP
  0< IF .FILEERR ELSE .FMOD THEN ;

\ (rm) rm:                                ( 16 12 92 CRC  8:21 )
: (RM)  \  --  | delete file whose name is in dta
  DTANAME SFILE 0D CMOVE ." Removing: " SFILE 0D TYPE
  SFILE  (DEL)  -DUP IF .FILEERR THEN COL ;

: RM: \ --  | delete multiple files
  FILING  FIRSTFILE  FILE SFIRST  0= IF CR (RM)
  BEGIN  SNEXT 0= WHILE (RM) REPEAT THEN ;

;S
: DELETEFILE: DEL: ;        \ keep old names for compatability

: DELETE:     DEL: ;



\ textfile stuff                          ( 24  1 88 CRC 13:18 )
FILING DEFINITIONS              0 VARIABLE CRS?
: UCR  CTL M (FEMIT) CRS? ON ;

: UEMIT   DUP CTL J = IF DROP CTL M THEN
          DUP CTL L = IF DROP CTL M THEN
  CRS? F@ OVER CTL M =  AND  IF DROP   ELSE
  DUP CTL M = IF  CRS? ON  ELSE  CRS? OFF  THEN  (FEMIT) THEN ;

FORTH DEFINITIONS
: >UPLOAD  FILING ?FILE
        OUTPUT> UEMIT   (TYPE)  2DROP  (PAGE)  NLIST  UCR  STOP

: >UPFILE:  FILING MKF:  >UPLOAD ;
FORTH DEFINITIONS

















































\ screens to text convert: load           ( 22  3 89 CRC 19:18 )
FILING  FORTH DEFINITIONS  BASE F@ DECIMAL
FORGET TASK
: TASK  ;         197 NEEDED SAFEOUTS

: FCR  CTL J EMIT ;      \ setup for WordPerfect

: ABLOCK  DUP BLOCK W@
  IF ." \  " DUP .SCR FCR 16 0 DO I OVER .LINE  FCR  LOOP
  THEN DROP ;

: BLOCKS  2DUP BOUNDS DO SAVEOUTS OK I 5 .R RESTOREOUTS
  I ABLOCK  ?TERMINAL IF LEAVE THEN LOOP + ;
BASE F!  EDITOR FLUSH


\ Wordstart convert: reset bit 7          ( 29  6 88 CRC 15:05 )
FILING  FORTH DEFINITIONS  BASE F@ HEX
FORGET TASK
: TASK  ;  \  FILING  SETDRIVE: C  SETDIR: \WP DIR *.WPF

CODE ZAP  \ addr ct -- | reset bit 7 in range 0 - 7fff
  S [+ DR0 MOV,  S [+ AR0 MOV,
  FALSE DR0 DO,  7 # AR0 [+ BCLR,  LOOP,  NEXT ;C

: ZAPAFILE::  FILING
  OPENFILE: PAD  DUP 7FFF HANDLE RDF  CLOSEIT  2DUP ZAP
  CREATEFILE: HANDLE WTF CLOSEIT 6 .R ."  Bytes Processed." ;

FILING \ SETDRIVE: B  DIR *.*
BASE F!  EDITOR FLUSH

































\ home word defined                       ( 18  8 02 CRC 10:58 )
forth definitions               forget task     filing
\ : task ;        filing
curdrv  (setdef)  1     ascii p ascii a -       2*s  and
IFTRUE
filing pathologist home p:\work"
OTHERWISE
curdrv  (setdef)  1     ascii i ascii a -       2*s  and
IFTRUE
filing pathologist home i:\work"
OTHERWISE
filing pathologist home c:\work"
IFEND
."  Home directory is: " ' home c>p count type space  : task ;
;s      we set the default working directory to p:\work (the ram
drive) if it's there. Otherwise it's the hard drive.
\ scan line, up or down                   (  7 11 93 CRC 21:12 )
forth definitions               forget task
forth definitions               : task ;
: skipspaces    \ addr dir ---  addr | skip spaces in dir
  swap  begin  dup  c@  bl =  while  over +  repeat  nip ;

: skipnonspaces \ addr dir ---  addr | skip nonspaces in dir
  swap  begin  dup  c@  bl -  while  over +  repeat  nip ;

: nextright     \ addr --- addr | skip to beginning of next word
  1 skipnonspaces  1 skipspaces  ;

: nextleft      \ addr --- addr | skip to beginning of next word
  1- -1 skipspaces  -1 skipnonspaces  1+ ;
editor flush

\ save\restore history                    ( 24  6 94 CRC 15:18 )
FORTH DEFINITIONS       FILING          FORGET TASK
FORTH DEFINITIONS    (  : TASK ;  )     BASE F@ DECIMAL

EXPECTING DEFINITIONS   \ create file name to save/restore from
CREATE SFL      FILING  RET CT->0 DUP ALLOT  SFL SWAP CMOVE
PARSEFILE: HIST.FF
FILE C/L -0S 1+  HERE  OVER ALLOT  SWAP CMOVE


  1 2 +THRU
SAVEHISTORY     \ so we have a valid nxtln value!
BASE F!       EDITOR FLUSH      FORTH DEFINITIONS
: TASK ;


\ save\restore history                    ( 12 11 93 CRC  9:15 )
: CLOSEHANDLE  FILING
  HANDLE F@ (CLF)  DUP 0< IF  .FILEERR  THEN  HANDLE F! ;

: PREPHANDLE
  FILING  HANDLE F@ IF  HANDLE F@ (CLF)
    DUP 0< IF  .FILEERR  THEN  THEN ;

: ADDRESSES     \ addr & ct to be saved/restored
  STRARRAY F@  STRINGS STRSIZE 1+ * ;






\ save\restore history                    ( 12 11 93 CRC  9:15 )
: SAVEHISTORY   \ --- | save current history info.
  PREPHANDLE  FILING
  SFL (CRF)  DUP 0< IF  .FILEERR  THEN  HANDLE F!
  ADDRESSES  DUP >R  FILING  HANDLE F@ WTF  R> -
  IF  ABORT"  File Write Error! "  THEN
  NXTLN  4  FILING  HANDLE F@ WTF  4-
  IF  ABORT"  File Write Error! "  THEN  CLOSEHANDLE ;

: GETHISTORY    \ --- | restore current history info.
  PREPHANDLE  FILING
  SFL (OPF)  DUP 0< IF  DROP  ELSE  HANDLE F!
  ADDRESSES DUP >R  FILING  HANDLE F@ RDF  R> -
  IF  ABORT"  File Read Error! "  THEN
  NXTLN  4  FILING  HANDLE F@ RDF  4-
  IF  ABORT"  File Read Error! "  THEN  CLOSEHANDLE  THEN ;
\ begin line editor                       ( 16  5 91 CRC  8:25 )
FORTH DEFINITIONS   (   DEBUG     )     FORGET TASK
FORTH DEFINITIONS   (   : TASK ;  )     BASE F@ DECIMAL
SEQ BELL  1 C,  CTL G C,

' (EXPECT) 'EXPECT F!

VOCABULARY EXPECTING IMMEDIATE  EXPECTING DEFINITIONS

  BLK F@ DUP 1+ SWAP 13 + THRU   \ HERE FIRST OVER - ERASE

' LNED 'EXPECT F!
  HERE FENCE F!   BASE F!       : TASK ;        EDITOR FLUSH



\ line editor: variables, constants       ( 16  4 93 CRC  8:47 )
20 CONSTANT STRINGS             \ number of back strings saved

CREATE STRARRAY STRINGS 4* ALLOT        \ pointer array

0 VARIABLE CURS                 \ line cursor
0 VARIABLE BUF                  \ holding buffer
0 VARIABLE SIZE                 \ size of line already in buffer
1 VARIABLE PLACEF               \ are we inserting or replacing?
STRARRAY VARIABLE NXTLN         \ pointer to next line to place

' QUERY 5 + C@ CONSTANT STRSIZE \ *very* implementation specific




\ line editor: makstrs, up dn history     ( 16  4 93 CRC  8:48 )
: MAKESTRS      \ construct the string buffer at compile time.
  STRINGS 0  DO  HERE  DUP  STRARRAY I 4* +  F!
      STRSIZE 1+  DUP ALLOT  ERASE  LOOP ;
MAKESTRS

: UP    4 NXTLN +!  NXTLN F@ STRARRAY - 4/
  STRINGS = IF STRARRAY  NXTLN F! THEN ;

: DN    NXTLN F@ STRARRAY        \ down one in the string buffer
  = IF [ STRARRAY STRINGS 4* + ] LITERAL NXTLN F! THEN
  -4 NXTLN +! ;




\ line editor: redraw, history access     ( 25 11 91 CRC 13:47 )
FORTH DEFINITIONS
: HISTORY  EXPECTING STRINGS 0 DO  DN  NXTLN F@ F@
  COUNT DUP IF CR  I 4 .R SPACE THEN  TYPE  LOOP  SPACE ;
: HIST HISTORY ;

EXPECTING DEFINITIONS
: REDRAW        \   ---   | re-display the line from cursor
  ERL  BUF F@  CURS F@ +  SIZE F@  CURS F@ -
  -DUP IF  DUP >R  TYPE   SPACE
       R> 1+  0  DO  LEFT  LOOP
       ELSE  SPACE LEFT  DROP  THEN ;

: STORESTR      \ --- | store string in array
  BUF F@  NXTLN F@ F@ 1+  SIZE F@  2DUP SWAP 1- C!  CMOVE ;

\ line editor: keystrokes                 ( 16  5 91 CRC  8:21 )
: GETSTR        \ --- | get string from array
  NXTLN F@ F@  COUNT SIZE F!  BUF F@  SIZE F@  CMOVE
  CURS OFF  CTL M EMIT  REDRAW ;

: LEFT          \   ---   | action on left arrow
  CURS F@  IF  LEFT  -1 CURS +!  ELSE  BELL  THEN ;

: RIGHT         \   ---   | action on right arrow
  CURS F@  SIZE F@ -  0< IF  CURS 1+!  RIGHT
         ELSE  BELL  THEN ;





\ line editor: keystrokes                 ( 18  1 91 CRC 21:14 )
: DEL           \   ---   | delete under cursor
  BUF F@  CURS F@ +  DUP 1+  SWAP  SIZE F@  CURS F@ -  CMOVE
  CURS F@  SIZE F@ -  0< IF  -1 SIZE +!
      ELSE  BELL  THEN  REDRAW ;

: REND          \   ---   | move cursor to right end
  SIZE F@  CURS F@ - -DUP IF  0 DO  RIGHT  LOOP  THEN ;

: BKSP    LEFT  DEL ;

: PUT           \ c ---   | put the char in the buffer
  DUP EMIT  BUF F@ CURS F@  + C!   SIZE F@  CURS F@  =
  IF  SIZE 1+!  THEN  CURS 1+! ;


\ line editor: help                       (  4 11 93 CRC 10:45 )
: INSRT         \ c ---   | insert the char in the buffer
  BUF F@  CURS F@ +  DUP 1+  SIZE F@  CURS F@ -  <CMOVE
  SIZE 1+!  PUT  REDRAW ;

: PLACE   PLACEF F@ IF  INSRT  ELSE  PUT  THEN ;

: INSERTKEY   [ PLACEF 3 + ] LITERAL 1 TOGGLE   BELL ;

: HELP          \   ---   | show help screen
  16 1 DO  I  [ 8 +BLK ] LITERAL  (LINE) -TRAILING
    -DUP IF  CR  TYPE  ELSE  DROP  THEN  LOOP  CR
  CURS F@  CURS OFF  REDRAW
  BEGIN -DUP  WHILE  RIGHT 1-  REPEAT ;


\ line editor: lend                       (  4 11 93 CRC 10:01 )
: LEND          \   ---   | move to left of line
  BEGIN  CURS F@  WHILE  LEFT  REPEAT  ;

: DATE          \   ---  | install date in current cursor loc.
  (DATE)  0 DO  CURSOR  DUP C@  PLACE  1+  LOOP  DROP ;

: KILL          \   ---  | kill current line
  LEND  SIZE OFF  ERL  ;

: CMPSTR        \ addr' addr ct --- fl | compare strs
                \ w/ main buffer. Case rude. 0: equal
  ROT F@ COUNT  ROT MIN  SWAP EDITOR -CITEXT ;



\ line editor: string compares            ( 11 11 93 CRC 18:24 )
: SCAN          \ --- fl | scan array for str at buf
  1  NXTLN F@   STRINGS 0 DO
    DUP  BUF F@  SIZE F@  CMPSTR
    ROT AND  DUP 0= IF  OVER NXTLN F!  LEAVE  ELSE
       SWAP  4+  DUP   STRARRAY - 4/
       STRINGS = IF  DROP STRARRAY  THEN  THEN  LOOP  NIP ;

: RETRIEVE      \ ---  | recover line starting w/ str at buf
  SCAN  IF  BELL  ELSE   GETSTR  THEN ;






\ line editor: lefts rights               (  1  3 19 crc 17:03 )
: lefts         \   ---   | move left until next blank
  begin left   buf f@ curs f@ + c@ bl =
        curs f@ 0=  or until ;

: rights        \   ---   | move right until next blank
  begin right  buf f@ curs f@ + c@ bl =
        size f@  curs f@ =  or until ;
























\ line editor: line editor                (  3 12 91 CRC 22:06 )
FORTH DEFINITIONS
: LNED          \ addr ct  --   | expect w/ line editing
  EXPECTING  >R  BUF F!  CURS OFF  SIZE OFF   NXTLN F@
  (GETTIME) 20 + [ KEYCODE 2+ ] LITERAL W!  \ for the blanking
  BEGIN   KEY   DUP 0= IF   KEY  CASE           \ code, later
        ASCII ; OF      DATE            ENDOF   \ f1, date
        ASCII < OF      KILL            ENDOF   \ f2, kill line
        ascii > of      lefts           endof   \ f4, lefts
        ascii ? of      rights          endof   \ f5, rights
        ASCII A OF      HISTORY  CR     ENDOF   \ f7, history
        ASCII B OF      RETRIEVE        ENDOF   \ f8, retrieve
        ASCII G OF      REND            ENDOF   \ home key
        ASCII H OF      GETSTR UP       ENDOF   \ up arrow
[

\ line editor: line editor                ( 18 11 93 CRC 21:46 )
]       ASCII K OF      LEFT            ENDOF   \ l. arrow
        ASCII M OF      RIGHT           ENDOF   \ r. arrow
        ASCII P OF      DN GETSTR       ENDOF   \ dn arrow
        ASCII R OF      INSERTKEY       ENDOF   \ insert key
        ASCII a OF      KILL            ENDOF   \ undo key
        ASCII b OF      HELP            ENDOF   \ help key
\       ASCII s OF      LEND            ENDOF   \ ctl <--
\       ASCII t OF      REND            ENDOF   \ ctl -->
        bell  ENDCASE   ELSE  DUP CTL M -
    IF  DUP 127 = IF  DEL  ELSE  DUP CTL H = IF  BKSP  ELSE
             DUP PLACE  THEN  THEN  THEN  THEN  ?STACK
    0  BUF F@ SIZE F@ + C!  CTL M =   SIZE F@  R =  OR UNTIL
  RDROP   REND  SIZE F@  OUT F!  SPACE
  NXTLN F!  SIZE F@  IF  DN STORESTR  THEN ;

\ line editor: test setup                 ( 23 12 90 CRC 12:28 )
\ : tst pad 30 lned history ;

: TEST  EXPECTING  HEX
  PAD 40 ASCII Z FILL  PAD 20 LNED  PAD 40 DUMP SIZE F@ . ;

PAD  BUF F!  10 SIZE F!
PAD  80 ASCII Z FILL
0 +BLK BLOCK  PAD C/L CMOVE

;S
: GETSTR        \ --- | get string from array
  NXTLN F@ F@  COUNT  DUP >R  BUF F@  SIZE F@ +  SWAP  CMOVE
  R> SIZE +!  REDRAW ;


\ help screen for line editor             (  4 11 93 CRC 10:20 )
            *help screen for fastforth line editor*
<---, --->      move cursor in current line
home            move to right hand end of line
up, down arrows scroll through buffer
insert          toggle insert/replace mode
help            cause this help screen to appear
undo            kill current line
f1      insert date             f2      kill current line
f4      left to next space      f5      right to next space
f7      history                 f8      scan for line





\ blank, to save the screen               (  7  4 93 CRC 20:13 )
FORTH DEFINITIONS       FORGET TASK
FORTH DEFINITIONS   \   : TASK ;
BASE F@ >R DECIMAL

1 5 +THRU

R> BASE F! EDITOR FLUSH
FORTH DEFINITIONS       : TASK ;

  6 +LOAD





\ blank, variables                        (  5  8 91 CRC 17:45 )
VOCABULARY BLANKING IMMEDIATE   BLANKING DEFINITIONS

0 VARIABLE OLDSCR
32768 CONSTANT SCRSIZE

HERE 256 + -256 AND DP F!               \ here = multiple of 256
HERE SCRSIZE ALLOT CONSTANT TEMPSCR     \ make buffer
TEMPSCR SCRSIZE ERASE

(GETTIME) VARIABLE COLOR





\ blank, code defs                        (  5  8 91 CRC 16:13 )
HEX
CODE RANDOM     \   ---  rn | rnd number generator
  11 # RP -[ .W MOV,  BEGIN, >R >R  0E # TRAP,  2 # RP ADDQ,
  DR0 S -[ MOV,  NEXT  ;C

CODE GETPHYS    \  --- addr | return current screen's base addr
  2 # RP -[ .W MOV,   R> R> AGAIN,    ;C    FIXED

DECIMAL






\ blank, scr switching, rnd,              (  5  8 91 CRC 16:30 )
: NEWSCR        \  ---  | move logical screen to temp
  -1  TEMPSCR  DUP  SCRSIZE ERASE  DUP SETSCREEN ;

: RESTORE       \  ---  | restore logical screen to original
  -1  OLDSCR F@ DUP  SETSCREEN ;

: RND           \ n --- n | return a random number modulus n
  RANDOM SWAP MOD ;

: SETCOLOR      \  ---  | set a random colour into the scrren
  COLOR F@  4 2*S  5 RND  2+ +  DUP COLOR F!
  3 SETCOLOUR DROP ;



\ blank, cursor stuff                     (  6 11 91 CRC 12:32 )
MSSG (WARN)   I love you! "
' (WARN)  C>P C@ 8 + CONSTANT WARNSIZE

: WARN  (WARN) .TIME ;

: KILL  WARNSIZE 0 DO  LEFT  LOOP ;

: PUTWARN   23 RND
  [ 80 WARNSIZE - ] LITERAL  RND  GOTOXY  WARN ;

CODE TICKER   DR0 CLR,  ' (WARN) C>P *+ AR0 LEA,
  AR0 [+ DR0 .B MOV,   2 # DR0 SUBQ,  AR0 [+ DR1 .B MOV,
  DR0 FALSE DO,  AR0 [+  AR0 -2 &[ .B MOV,  LOOP,
  DR1 AR0 -2 &[ .B MOV,  NEXT ;C        FIXED        ;s
MSSG (WARN) Hit the 'Any' key to continue...  "
\ blank, main loop                        (  7  4 93 CRC 19:33 )
: AWAIT         \ n ---  | wait n cycles or until keystroke
  >R  R IF  PUTWARN  THEN
  BEGIN  PAUSE  R IF  DUP 400 MOD 0=
         IF  TICKER KILL WARN  THEN THEN
    1-  DUP 0=  ?KEY  OR  UNTIL  R> 2DROP
  KILL WARNSIZE SPACES ;

: (BLANK)   EDITOR FLUSH BLANKING       \ --- key | blank scr
  OUT F@  NO.CURSOR  GETPHYS OLDSCR F!  SV.CUR  NEWSCR
  VERT   -1 3 SETCOLOUR  BEGIN   SETCOLOR  ?STACK
    15000 RND  2000 + 1 AWAIT
     7500 RND  2000 + 0 AWAIT ?KEY UNTIL  3 SETCOLOUR
  RESTORE  RST.CUR  DROP  CURSOR  OUT F!  DISPLAY ;
FORTH DEFINITIONS
: BLANK   BLANKING (BLANK)  KEY DROP ;
\ hook into keystroke for delay           (  7  4 93 CRC 19:19 )
FORTH DEFINITIONS               FORGET TASK
FORTH DEFINITIONS           (   : TASK ;   )    EDITOR FLUSH

BLANKING DEFINITIONS            BASE @ DECIMAL
300 VARIABLE TIMEOUT    \ time before blanking, in seconds

: (TBKEY)  KEYCODE 2+ W@ BEGIN PAUSE
  DUP  KEYCODE 2+ W@  -  TIMEOUT F@ 2/ > IF  (BLANK)  THEN
  .CLOCK ?KEY UNTIL  KEYCODE 2+ W! <KEY> ;

FORTH DEFINITIONS
: TBKEY  BLANKING [ ' (TBKEY)  ] LITERAL 'KEY F! ;   TBKEY

(GETTIME) 20 + KEYCODE 2+ W!    BASE !
: TASK ;
















































































\ File extender: more                     (  5  4 88 CRC 19:22 )
forth definitions forget task
forth definitions : task ;
filing definitions
: pattern   0 pad dup b/buf blanks w! ;

: (more)    pad b/buf whandle f@ f@ wtf
  b/buf - if whandle f@ close
           abort"  File out of Room" then
  'maxblk 1+! ;

    \ N.B: close to make changes permanent!!!
: more      whandle f@ f@ 0= if abort" No file Open" then
  0  whandle f@ f@  2  lseek drop  cr  pattern
  0 do  i 5 .r  (more)  loop  ;
editor flush
































\ disk copier: copies all files & subdirs ( 15  1 89 CRC 14:03 )
FILING  FORGET TASK             FORTH DEFINITIONS : TASK ;
HEX    editor flush
0 VARIABLE DIRS                 0 VARIABLE NEWDIRS
C/L 100 * CONSTANT STACKSIZE
0 VARIABLE DIRSTACK   STACKSIZE 4- ALLOT

\ : .self  latest [compile] literal compile id. ; immediate

: ZAPDIRS  \  --  | clean out the dir stack
  DIRSTACK STACKSIZE ERASE NEWDIRS Off  DIRS OFF  ;   ZAPDIRS

: ADIR    \ n --- addr  | returns addr of nth dir
  6 2*s DIRSTACK + ;       -->


\ disk copier: copies all files & subdirs ( 15  1 89 CRC 14:35 )
: ADDENDUM  NEWDIRS F@ ADIR C/L FILING -0S + ;

: GETCUR  \  ---  | gets curent dir, saves to dir stack
  FILING NEWDIRS F@ ADIR  DUP C/L ERASE
  0 GETPATH  NEWDIRS 1+! ;

: NXTPTH \ fl -- fl' | find a path in the current dir
  FILING  SUBDIR  BEGIN 15 +DTA  C@ 10 =  OVER OR 0=
    1E +DTA C@ ASCII . =  OR
    WHILE 1E +DTA 0D ERASE DROP (SNEXT)  REPEAT ;
\ DUP 0= IF COL 1E +DTA TTYPE  THEN  ; \ temp for debug

: SEE  DIRSTACK STACKSIZE DUMP ;
                                               -->

\ disk copier: copies all files & subdirs ( 15  1 89 CRC 14:04 )
: TILL0   \ addr --- addr'  | skip until 0 found
  BEGIN DUP C@ WHILE 1+ REPEAT ;

: FIRSTPATH \ addr$ -- fl | find a path in the current dir
  FILING DMY OVER  TILL0  DUP >R  3 CMOVE
  SUBDIR (SFIRST)  NXTPTH
  R> 4 ERASE ;
                                        \ dir# ---  | printit
: .APATH   FILING COL ADIR C/L -0S TYPE ;

\ : L SCR F@ LIST ;
                       \ n.b: works from given directory
: FIRSTDIR   FILING BL FWORD  HERE COUNT  2DUP UPPER  0 ADIR
  SWAP CMOVE  NEWDIRS ON ;   \ include trailing \
-->
\ disk copier: copies all files & subdirs ( 15  1 89 CRC 14:04 )
: SAVEPATH   \ --  | makes a full path name & saves it off
  NEWDIRS F@ ADIR C/L ERASE
  FILING DIRS F@ ADIR  C/L -0S  addendum SWAP CMOVE
\ ( scr f@ list)  newdirs f@ adir c/l dump key drop
  1E +DTA DUP TILL0 OVER - ADDENDUM SWAP CMOVE
\ ( scr f@ list)  newdirs f@ adir c/l dump key drop
  ASCII \ ADDENDUM C!
  NEWDIRS 1+! ; -->







\ disk copier: copies all files & subdirs ( 15  1 89 CRC 14:04 )
: NEXTPATH    \  --  fl | next path found
  FILING (SNEXT) NXTPTH ;

: SAVEPATHS   \ addr ---  |save all pathnames on this dir
  FIRSTPATH 0= IF  BEGIN SAVEPATH NEXTPATH UNTIL THEN ;

: LASTDIR?   \   ---  fl | is the current dir occupied?
  DIRS F@ ADIR F@  0= ;

: .PATHS   DIRS off
  BEGIN  DIRS F@ .APATH DIRS 1+! LASTDIR? UNTIL ;

: SAVESUBS  \ save subsidiary directories from current
  FILING (ATT) W@  ZAPDIRS  FIRSTDIR  BEGIN  DIRS F@ ADIR
  SAVEPATHS  DIRS 1+!  LASTDIR? UNTIL  (ATT) W! ;    -->
\ disk copier: copies all files & subdirs (  1 11 87 CRC 18:46 )
: SRCF  \   --  | set up source path
  FILING  DIRS F@ ADIR  FILE C/L CMOVE ;

: DEST  \   --  | set up dest file spec
  FILING  SFILE  DUP >FILE F!   C/L ERASE
  DIRS F@ ADIR  ADDENDUM OVER -
       >FILE F@ SWAP  DUP >FILE +!  CMOVE
  PATH  C/L -0S
       >FILE F@ SWAP  DUP >FILE +!  CMOVE ;

: seefiles   filing  cr ." path: " path 40 -0s dump
  ." file: " file 40 -0s dump   ." sfile: " sfile 40 -0s dump ;

-->

\ disk copier: copies all files & subdirs (  4 11 87 CRC 20:13 )
: ADDNAME   \ addr -- | add file name to addr, create it
  FILING  C/L -0S +   1E +DTA  SWAP  OVER
     0D -TRAILING -0S ( len to cmove)  NIP  CMOVE ;

: ADDDST   \  -- |  add file name to dest, open it
  FILING  FILE C/L ERASE HERE  COUNT FILE  SWAP CMOVE
  FILE C/L -0S + >FILE F!
  NEWDIRS F@ ADIR  ADDENDUM OVER -  >FILE F@  SWAP CMOVE
  FILE ADDNAME    (ATT) W@  R-W
  FILE (CRF)   SWAP (ATT) W!
  DUP 0< IF .FILEERR THEN  HANDLE F!
  FILE TTYPE SPACE ;      -->



\ disk copier: copies all files & subdirs (  4 11 87 CRC 22:09 )
: ADDSRC   \  -- |  add file name to source, create it
  FILING NEWDIRS F@ ADIR SFILE C/L CMOVE
  SFILE ADDNAME
  SFILE (OPF)  DUP 0< IF .FILEERR THEN  SRCHANDLE F! ;

: COPYADIR  \  ---  | copy one dir
  FILING  SRCF  DEST  SFILE (SFIRST)
      0= IF  CR  ADDSRC  ADDDST  (COPY::)
  BEGIN  SRCF DEST (SNEXT)
     0=  WHILE  CR ADDSRC ADDDST (COPY::) REPEAT  THEN ;

-->



\ disk copier: copies all files & subdirs ( 15  1 89 CRC 14:38 )
: XCOPY::    ZAPDIRS  SAVESUBS  FILING            \ source
  (ATT) W@ >R   PARSEFILE:  FILE PATH C/L CMOVE   \ filespec
  FILE C/L ERASE  SFILE C/L ERASE
  BL FWORD ( dest)    HERE COUNT UPPER            \ destination
  DIRS OFF  7 (ATT) W!
  BEGIN  COPYADIR  DIRS 1+! LASTDIR? 0= UNTIL
  R> (ATT) W! ;
EDITOR FLUSH

filing definitions  editor   ;s
syntax   xcopy:: d:srcpath\  sourcefile.spec  d:destpath




































































































































































































































































































































































































































































































\ Whereis in FORTH                        ( 15  1 89 CRC 14:18 )
FILING  FORGET TASK             FORTH DEFINITIONS : TASK ;
HEX    editor flush
0 VARIABLE DIRS                 0 VARIABLE NEWDIRS
C/L 100 * CONSTANT STACKSIZE
0 VARIABLE DIRSTACK   STACKSIZE 4- ALLOT

: .SELF  LATEST [COMPILE] LITERAL COMPILE ID. ; IMMEDIATE

: ZAPDIRS  \  --  | clean out the dir stack
  DIRSTACK STACKSIZE ERASE NEWDIRS OFF  DIRS OFF  ;   ZAPDIRS

: ADIR    \ n --- addr  | returns addr of nth dir
  C/L * DIRSTACK + ;       -->


\ Whereis in FORTH                        ( 15  1 89 CRC 14:35 )
: ADDENDUM  NEWDIRS F@ ADIR C/L FILING -0S + ;

: GETCUR  \  ---  | gets curent dir, saves to dir stack
  FILING NEWDIRS F@ ADIR  DUP C/L ERASE
  0 GETPATH  NEWDIRS 1+! ;

: NXTPTH \ fl -- fl' | find a path in the current dir
  FILING  SUBDIR  BEGIN 15 +DTA  C@ 10 =  OVER OR 0=
    1E +DTA C@ ASCII . =  OR
    WHILE 1E +DTA 0D ERASE DROP (SNEXT)  REPEAT ;
\ DUP 0= IF COL 1E +DTA TTYPE  THEN  ; \ temp for debug

: SEE  DIRSTACK STACKSIZE DUMP ;
                                               -->

\ Whereis in FORTH                        ( 15  1 89 CRC 14:19 )
: TILL0   \ addr --- addr'  | skip until 0 found
  BEGIN DUP C@ WHILE 1+ REPEAT ;

: FIRSTPATH \ addr$ -- fl | find a path in the current dir
  FILING DMY OVER  TILL0  DUP >R  3 CMOVE
  SUBDIR (SFIRST)  NXTPTH
  R> 4 ERASE ;
                                        \ dir# ---  | printit
: .APATH   FILING COL ADIR C/L -0S TYPE ;

\ : L SCR F@ LIST ;
                 \ n.b. Works from ROOT directory!
: FIRSTDIR   ASCII \ DIRSTACK C!
  NEWDIRS ON ;
-->
\ Whereis in FORTH                        (  2  1 89 CRC 10:57 )
: SAVEPATH   \ --  | makes a full path name & saves it off
  NEWDIRS F@ ADIR C/L ERASE
  FILING DIRS F@ ADIR  C/L -0S  addendum SWAP CMOVE
\ ( scr f@ list)  newdirs f@ adir c/l dump key drop
  1E +DTA DUP TILL0 OVER - ADDENDUM SWAP CMOVE
\ ( scr f@ list)  newdirs f@ adir c/l dump key drop
  ASCII \ ADDENDUM C!
  NEWDIRS 1+! ; -->







\ Whereis in FORTH                        ( 15  1 89 CRC 14:18 )
: NEXTPATH    \  --  fl | next path found
  FILING (SNEXT) NXTPTH ;

: SAVEPATHS   \ addr ---  |save all pathnames on this dir
  FIRSTPATH 0= IF  BEGIN SAVEPATH NEXTPATH UNTIL THEN ;

: LASTDIR?   \   ---  fl | is the current dir occupied?
  DIRS F@ ADIR F@  0= ;

: .PATHS   DIRS OFF
  BEGIN  DIRS F@ .APATH DIRS 1+! LASTDIR? UNTIL ;

: SAVESUBS  \ save subsidiary directories from root
  FILING (ATT) W@  ZAPDIRS  FIRSTDIR  BEGIN  DIRS F@ ADIR
  SAVEPATHS  DIRS 1+!  LASTDIR? UNTIL  (ATT) W! ;    -->
\ Whereis in FORTH                        (  2  1 89 CRC 11:13 )
: +FILE   \ dir# -- | file name appended
  FILING  ADIR  TILL0  FILE C/L -0S  ROT SWAP  CMOVE ;

: -FILE   \ dir# -- addr ct | path ready for printing, less file
  FILING  ADIR  DUP TILL0
  BEGIN DUP C@ ASCII \ - WHILE 1- REPEAT  OVER - 1+ ;

: .FIND   \ dir# -- | print strike w/ pathname
  CR -FILE TYPE   FILING 1E +DTA TTYPE ;

: ZAPFILE  \ dir#  ---  | strip old file spec
  FILING  DUP ADIR C/L -0S +  SWAP -FILE +
  SWAP OVER - ERASE ;
                                         -->

\ Whereis in FORTH                        (  2  1 89 CRC 12:14 )
: HITDIR
  DIRS F@ +FILE  DIRS F@ ADIR FILING (SFIRST)
  0= IF  BEGIN  DIRS F@ .FIND  (SNEXT) UNTIL  THEN  ;

: WHEREIS:  \  ---  | print out all hits of filespec(s) given
  4 SPACES pTODAY  SAVESUBS
  BEGIN  DIRS OFF FILING PARSEFILE:  FILE F@  WHILE
  CR  FILE C/L -0S TYPE
  BEGIN  HITDIR  DIRS F@ ZAPFILE
    DIRS 1+!  LASTDIR?  UNTIL  CR  REPEAT
  OUT F@ IF CR THEN ;

EDITOR FLUSH


\ lines for screen definition             ( 22  4 92 CRC  8:03 )
DEBUG   FORTH DEFINITIONS       FORGET TASK
: TASK ;                        BASE F@ >R      HEX
0 VARIABLE BASIS
CODE GETPHYS    \  --- addr | return current screen's base addr
  2 # RP -[ .W MOV,   0E # TRAP,  2 # RP ADDQ,
  BASIS *+ DR0 ADD,  DR0 S -[ MOV,  NEXT  ;C

CODE SFILL      \ addr ct fill  | fill every other word on scr
  S [+ DR0 MOV,  S [+ DR1 MOV,  S [+ AR0 MOV,  2 # DR1 LSR,
  DR1 FALSE DO,  DR0 AR0 [+ .W EOR,  2 # AR0 ADDQ,  LOOP,
  NEXT ;C

1 +LOAD         BOX
R> BASE F!       EDITOR FLUSH

\ lines for screen definition             ( 22  4 92 CRC  8:13 )
CODE VLINE      \ baseaddr mask ---  | draw vertical line
  S [+ DR1 MOV,  S [+ AR0 MOV,   C8 # DR0 .W MOV,
  DR0 FALSE DO,  DR1 AR0 [+ .W EOR,  9E #L AR0 ADD,  LOOP,
  NEXT  ;C

: HLINE     9E FFFF SFILL  ;
: TOPLINE   HLINE ;
: BOTLINE   [ 7D00 A0 - ] LITERAL  + HLINE ;

: BOX   GETPHYS  DUP BOTLINE  DUP TOPLINE
  DUP 8000 VLINE  9C + 1 VLINE ;

: SHOW  NO.CURSOR PAGE BOX (KEY) DROP  CURSOR ;


\ chess clock                             ( 13  1 92 CRC  8:47 )
DEBUG
FORTH DEFINITIONS       FORGET TASK
BASE F@ DECIMAL  674 NEEDED TT  BASE F!
FORTH DEFINITIONS       : TASK ;
BASE F@ >R HEX

1 5 +THRU

R> BASE F! EDITOR FLUSH






\ chess clock                             ( 13  1 92 CRC  8:47 )
0 VARIABLE PLAYER       \ the player currently being timed
0 VARIABLE WTIME        \ clock registers
0 VARIABLE BTIME        \ clock registers
1 VARIABLE STARTED      \ the shift key that started off

4BA CONSTANT SYSCLOCK   \ 200 hz system clock

MSSG .WH White"
MSSG .BL Black"
MSSG .ISLFT  is the right shift key"
MSSG .ISRT  is the left shift key"




\ chess clock                             (  6  3 92 CRC  8:59 )
LENGTH F@ 0C LENGTH F!
: CHANGEPLAYER  \ --- | test to see if the player has changed
  -1  KEYMODE  3 AND  -DUP IF
    DUP STARTED F@  =  IF  WTIME  PLAYER F!  THEN
    STARTED F@  3 XOR  =  IF  BTIME PLAYER F!  THEN  THEN ;

DECIMAL
: GETCLOCK
  BEGIN  SYSCLOCK F@ 20 MOD  WHILE  CHANGEPLAYER  REPEAT ;

: .CLK  \ n -- | print n as time
  10 / <#  60 /MOD  SWAP 0 SEXTAL  60 /MOD SWAP 0 SEXTAL 0 #S
  BL HOLD  ASCII : HOLD  #> TYPE ;


\ chess clock                             ( 28  2 93 CRC 17:08 )
: SETPLAYERS    \ determine from first keystroke who is
                \ white, who is black
  ?CR ." Black: press your shift key to begin. "
  BEGIN  -1  KEYMODE  3 AND  -DUP UNTIL  CTL M EMIT  erl
  DUP STARTED F!        6 spaces
  1-  IF  ( left is white )
    .WH .ISLFT  CR 6 SPACES  .BL .ISRT
      ELSE ( right is white )
    .WH .ISRT  CR 6 SPACES  .BL .ISLFT
      THEN   WTIME PLAYER F! ;

: .BOTH  ." Total time"  WTIME F@  BTIME F@  +  .CLK  SPACE ;



\ chess clock                             ( 28  2 93 CRC 17:08 )
: WAITCLOCK     \ ---  | wait for next second on clock
  GETCLOCK  PLAYER F@  1+! ;

: .PLAYER  ." Turn: " REV.ON SPACE
  PLAYER F@  BTIME =  IF  .BL  ELSE  .WH  THEN  SPACE  REV.OFF
  3 SPACES ;

: WHTIME .WH  WTIME F@ .CLK ;

: BLTIME .BL  BTIME F@ .CLK ;





\ chess clock                             ( 28  2 93 CRC 17:09 )
: CLOCK WTIME OFF  BTIME OFF  CR  EDITOR FLUSH
  BASE F@  NO.CURSOR  FORTH
  0 -1 DUP SETSCREEN   SETPLAYERS
  BEGIN   11 12 GOTOXY       WAITCLOCK  .PLAYER
     12 12 GOTOXY  WHTIME
     13 12 GOTOXY  BLTIME
     ?KEY UNTIL  1 -1 DUP SETSCREEN
  KEY  DROP  WHTIME  CR BLTIME  cr .both  CURSOR
  BASE F! DISPLAY ;
LENGTH F!





( optimizers for : defs                   ( 14  9 94 CRC 17:00 )
BASE F@ HEX
0 VARIABLE OPT          ( not particularly re-entrant! )

: OPGET         ( addr ct --- | get operand ct bytes from addr )
  + W@ ;

-->








( binary defining word                    ( 21  4 92 CRC  8:15 )
: BINARY  CREATE  SMUDGE  -FIND  IF DROP ,  ELSE  0 ERROR  THEN
  SMUDGE  W, W,  IMMEDIATE
  DOES>  STATE F@                       ( only if compiling... )
    IF  HERE OPT F@ -                   ( not following a begin)
      IF  HERE 4- C@  70 =              ( byte literal?        )
        IF  HERE 4- E TOGGLE            ( xx # dr7 moveq,      )
          -2 ALLOT  4 OPGET W,          ( dr7 s [ xxx,         )
        ELSE  HERE 6- W@ 273C =         ( large literal?       )
          IF  6 OPGET  HERE 6- W!       ( yy #l s [ xxx,       )
          ELSE  HERE 4- W@  272E =      ( user f@ ??           )
 [
-->



( daughter words                          ( 24  7 93 CRC 20:44 )
]
            IF  HERE 4- 9 TOGGLE  4 OPGET W,  ( ofuser s [ add )
            ELSE  HERE 6- W@  2739 =    ( literal f@ ??        )
              IF  HERE 6- 9 TOGGLE  4 OPGET W,  ( lit dr7 mov, )
              [ >R >R ]  THEN  THEN  THEN
      ELSE  [ R> R> ]  THEN
            F@ <COMP>  THEN     ( following br resolution      )
    ELSE  @EXECUTE  THEN ;      ( not compiling                )
(             l.w. lit  byte lit                               )
                 693   DF93    BINARY +   +
                 493   9F93    BINARY -   -
                  93   8F93    BINARY OR  OR
                 293   CF93    BINARY AND AND
                 A93   BF93    BINARY XOR XOR
-->
( optimizers: unary                       (  1  7 93 CRC 10:26 )
: UNARY  CREATE  SMUDGE  -FIND  IF DROP ,  ELSE  0 ERROR  THEN
  SMUDGE  W, W, W, W,  IMMEDIATE
  DOES>  STATE F@                       ( only if compiling... )
    IF  HERE OPT F@ -                   ( not following a begin)
      IF  HERE 6- W@  273C =            ( following a literal? )
        IF  4 OPGET  HERE 6- W!         ( yyy ** @#l xxx,      )
        ELSE HERE 2- W@  2708 =         ( ar0 s -[ mov, eg user)
          IF  -2 ALLOT  HERE 4- W@  41EE = ( user variable?    )
            IF  6 OPGET  HERE 4- W!     ( yyy u ** &[ xxx,     )
            ELSE  HERE 4- W@  41FA =    ( pc *+ variable?      )
              OVER 0A OPGET 273A =  AND ( f@ only!)
                IF 0A OPGET HERE 4- W! REL OFF ( a *+ s -[ mov )
                ELSE  8 OPGET  W, THEN  ( yyy ar0 [ xxx,       )
            THEN        [       -->

( optimizers: unary                       ( 24  7 93 CRC 20:44 )
]         ELSE  HERE 4- W@ 272E =       ( user f@ optimize     )
            IF  206E  HERE 4- W!  8 OPGET  W,
            ELSE  HERE 6- W@  2739 =    ( literal f@ optimize  )
              IF  2079 HERE 6- W!     8 OPGET W,
              [ >R >R ]  THEN  THEN  THEN
      ELSE  [ R> R> ]  THEN
            F@ <COMP>  THEN     ( following br resolution      )
    ELSE  @EXECUTE  THEN ;      ( not compiling                )

( opget    0a   8    6     4    )
             0 5290 52AE  52B9  UNARY 1+! 1+!
             0 4290 42AE  42B9  UNARY OFF OFF
             0 209B 2D5B  23DB  UNARY F!  F!
          273A 2710 272E  2739  UNARY F@  F@
-->
( optimizers for : defs                   ( 14  9 94 CRC 16:57 )
: THEN   HERE OPT F!  [COMPILE] THEN  ;         IMMEDIATE

: BEGIN  HERE OPT F!  [COMPILE] BEGIN ;         IMMEDIATE

: (FORGET)  (FORGET) OPT OFF ;

: FORGET   [COMPILE] ' STATE F@ IF COMPILE (FORGET)
                                ELSE (FORGET) THEN ;  IMMEDIATE

BASE F!





\ test area for macro mods                ( 21  4 92 CRC  7:08 )
DEBUG   FORTH DEFINITIONS       FORGET TASK
: TASK ;                        BASE F@ >R      HEX
: ?LEN:   [COMPILE] ' 2- W? ;
0 VARIABLE SNARK
CODE FOO   ofuser fld dr7 mov,  dr7 s [ and,
           snark @#l dr7 mov,   dr7 s [ and,
           7f # dr7 movq,       dr7 s [ and,
           ffff #l                  s [ and,
             NEXT ;C

 1 2 +THRU
: BAR    fld f@ and  snark f@ and  7f and  ffff and  ;

R> BASE F!       EDITOR FLUSH  ?CR ?LEN: FOO ?LEN: BAR
' FOO  DUP 2- W@  ' BAR EDITOR -CITEXT .  UN: BAR UN: FOO
( binary defining word                    ( 21  4 92 CRC  8:15 )
: BINARY  CREATE  SMUDGE  -FIND  IF DROP ,  ELSE  0 ERROR  THEN
  SMUDGE  W, W,  IMMEDIATE
  DOES>  STATE F@                       ( only if compiling... )
    IF  HERE OPT F@ -                   ( not following a begin)
      IF  HERE 4- C@  70 =              ( byte literal?        )
        IF  HERE 4- E TOGGLE            ( xx # dr7 moveq,      )
          -2 ALLOT  4 OPGET W,          ( dr7 s [ xxx,         )
        ELSE  HERE 6 - W@ 273C =        ( large literal?       )
          IF  6 OPGET  HERE 6 - W!      ( yy #l s [ xxx,       )
          ELSE  HERE 4- W@  272E =      ( user f@ ??           )
            IF  HERE 4- 9 TOGGLE  4 OPGET W,  ( ofuser s [ add )

 [


( optimizers: binary                      ( 26  6 93 CRC 22:31 )
]
            ELSE  HERE 6 - W@  2739 =   ( literal f@ ??        )
              IF  HERE 6 - 9 TOGGLE  4 OPGET W, ( lit dr7 mov, )
              ELSE  F@ <COMP>  THEN  THEN  THEN  THEN
      ELSE  F@ <COMP>  THEN     ( following br resolution      )
    ELSE  @EXECUTE  THEN ;      ( not compiling                )

                 693   DF93    BINARY +   +
                 493   9F93    BINARY -   -
                  93   8F93    BINARY OR  OR
                 293   CF93    BINARY AND AND
                 A93   BF93    BINARY XOR XOR



\ test area for macro mods                ( 28  6 93 CRC 22:50 )
DEBUG   FORTH DEFINITIONS       FORGET TASK
: TASK ;                        BASE F@ >R      HEX
: ?LEN:   [COMPILE] '  2- W? ;  mssg hi hi, there!"
0 VARIABLE SNARK
 1 4 +THRU
code foo   snark *+ ar0 lea, ar0 s -[ mov,
           snark *+ s -[ mov,  next  ;c

: bar  [ snark ] tlit  [ snark ] tlit f@  [ snark ] tlit 1+!
  [ snark ] tlit off  [ snark ] tlit f! ;

R> BASE F!       EDITOR FLUSH  ?CR ?LEN: FOO ?LEN: BAR
' FOO  DUP 2- W@  ' BAR EDITOR -CITEXT .  UN: BAR UN: FOO


( optimizers: unary                       ( 30  6 93 CRC 22:05 )
: UNARY  CREATE  SMUDGE  -FIND  IF DROP ,  ELSE  0 ERROR  THEN
  SMUDGE  w, W, W, W,  IMMEDIATE
  DOES>  STATE F@   cr .s               ( only if compiling... )
    IF  HERE OPT F@ -                   ( not following a begin)
      IF  HERE 6 - W@  273C =           ( following a literal? )
        IF  4 OPGET  HERE 6 - W!        ( yyy ** @#l xxx,      )
        ELSE HERE 2- W@  2708 =         ( ar0 s -[ mov, eg user)
          IF  -2 ALLOT  HERE 4- W@  41EE = ( user variable?    )
            IF  6 OPGET  HERE 4- W!     ( yyy u ** &[ xxx,     )
            ELSE  here 4- w@  41fa =    ( pc *+ variable?      )
              over 0a opget 273a =  and ( f@ only!)
                if 0a opget  here 4- w! ( a *+ s -[ mov )
                ELSE  8 OPGET  W, THEN  ( yyy ar0 [ xxx,       )
            then        [

( optimizers: unary                       ( 21  4 92 CRC  8:15 )
]         ELSE  HERE 4- W@ 272E =       ( user f@ optimize     )
            IF  206E  HERE 4- W!  8 OPGET  W,
            ELSE  HERE 6 - W@  2739 =   ( literal f@ optimize  )
              IF  2079 HERE 6 - W!     8 OPGET W,
              ELSE  F@ <COMP>  THEN  THEN  THEN  THEN
      ELSE  F@ <COMP>  THEN     ( following br resolution      )
    ELSE  @EXECUTE  THEN ;      ( not compiling                )

( opget    0a   8    6     4    )
             0 5290 52AE  52B9  UNARY 1+! 1+!
             0 4290 42AE  42B9  UNARY OFF OFF
             0 209B 2D5B  23DB  UNARY F!  F!
          273a 2710 272E  2739  UNARY F@  F@


( optimizers: unary                       ( 15  4 92 CRC  8:37 )
;s
: UNARY  CREATE  SMUDGE  -FIND  IF DROP ,  ELSE  0 ERROR  THEN
  SMUDGE  W, W, W,  IMMEDIATE
  DOES>  STATE F@                       ( only if compiling... )
    IF  HERE OPT F@ -                   ( not following a begin)
      IF  HERE 6 - W@  273C =           ( following a literal? )
        IF  4 OPGET  HERE 6 - W!        ( yyy ** @#l xxx,      )
        ELSE  HERE 2- W@  2708 =        ( ar0 s -[ mov, eg user)
          IF  -2 ALLOT  HERE 4- W@  41EE = ( user variable?    )
            IF  6 OPGET  HERE 4- W!     ( yyy u ** &[ xxx,     )
            ELSE  8 OPGET  W, THEN   [  ( yyy ar0 [ xxx,       )
-->



\ comma'd decimal output                  ( 22  3 92 CRC 11:09 )
FORTH DEFINITIONS               BASE F@ >R      HEX
0 VARIABLE PLC                  ASCII , VARIABLE DELIM
: #,S   PLC OFF  BEGIN #  2DUP OR
   WHILE  PLC 1+!  PLC F@ 3 =
   IF  DELIM F@ HOLD  PLC OFF THEN  REPEAT ;

: D,.R  >R SWAP  OVER  DABS  <#  #,S  SIGN #>
        R> OVER  -  SPACES  TYPE ;
: D,.   0 D,.R SPACE ;
: ,.R   >R S->D R> D,.R ;

: ,.    S->D D,. ;     \        : ,?       @ ,. ;
\ : W,?    W@ ,. ;                : C,?      C@ ,. ;
R> BASE !

\ test area comma'd decimal output        (  4  3 92 CRC  9:15 )
DEBUG   FORTH DEFINITIONS       FORGET TASK
BASE F@ >R      HEX
0 VARIABLE PLACE                ASCII , VARIABLE DELIM
CREATE SAVE#S 6 ALLOT           ' #S SAVE#S 6 CMOVE
: ,COLD   SAVE#S ' #S 6 CMOVE ;         oncold: ,cold

HERE !CSP ] PLACE OFF  BEGIN #  2DUP OR
   WHILE  PLACE 1+!  PLACE F@ 3 =
   IF  DELIM F@ HOLD  PLACE OFF THEN  REPEAT ;
4EF9 ' #S W!  ' #S 2+ F!
HERE FENCE !                    : TASK ;
R> BASE F!       EDITOR FLUSH   ;s
        Warning: patches nucleus & affects ALL numeric output!!!


\ Begin SCSI access: load screen          (  7  9 87 CRC 13:08 )
debug  forget task              : task ;
base F@ hex                     here first over - erase
FF8604 CONSTANT WDC             WDC 2+ CONSTANT WDL
FF8609 CONSTANT DMA             FFFA01 CONSTANT PORT
   43E CONSTANT FLOCK           0 FLOCK W! \ just in case!
     0 VARIABLE COUNT

decimal

1 10 +thru

base F! editor flush



\ SCSI: basics setdma count waits         (  2  9 87 CRC 21:38 )
: LABEL  0 VARIABLE -4 ALLOT  [COMPILE] ASSEMBLER
  ASSEMBLER ~ ;

LABEL COM 11 C, 0 W, 132 C, 0 W,

LABEL SETDMA   \ set the dma controller's address
  DMA @#L ar4 LEA,  7 RP &[ 4 ar4 &[ .B MOV,
  6 RP &[ 2 ar4 &[ .B MOV,  5 RP &[ ar4 [ .B MOV,  RTS,

LABEL WAITS    \ wait for possible timeout
  BEGIN,  1 # COUNT @#L SUBQ,
    MI IF,  255 # DR0 MOVQ,  RTS,  THEN,  \ timeout
    PORT @#L DR0 .B MOV,  32 # DR0 .B AND, EQ UNTIL,
  DR0 CLR,  RTS,

\ SCSI: wait waitl sendbyte               (  2  9 87 CRC 21:47 )
LABEL WAIT     \ wait for possible timeout, 1 sec
   15000 #L COUNT @#L MOV,  WAITS *+ BRA,

LABEL WAITL    \ wait for possible timeout, 6 sec
  900000 #L COUNT @#L MOV,  WAITS *+ BRA,

HEX
LABEL SENDBYTE \ send a byte out to the hdc
  DR0 .W SWAP,  8A # DR0 .W MOV,  DR0 AR0 [ MOV,  WAIT *+ BRA,






\ SCSI: setcmd tout exec                  (  3  9 87 CRC 18:11 )
LABEL SETCMD   \ set data for the command
  8A # 2 &[ AR0 .W MOV,
  WAIT *+ BSR,      EQ IF,  5 4+ RP &[  DR0 .B MOV,  \ Sec # hi
  SENDBYTE *+ BSR,  EQ IF,  6 4+ RP &[  DR0 .B MOV,  \ Sec # mid
  SENDBYTE *+ BSR,  EQ IF,  7 4+ RP &[  DR0 .B MOV,  \ Sec # mid
  SENDBYTE *+ BSR,  EQ IF,  8 4+ RP &[  DR0 .B MOV,  \ count
  SENDBYTE *+ BSR,  THEN,  THEN,  THEN,  THEN,  RTS,

LABEL TOUT   80 # AR0 [ .W MOV,  NOP,
  AR0 [ DR7 MOV,  FF00FF #L DR7 AND,   \ hi: hcd lo: dma stat
  FLOCK @# .W CLR,  RTS,

LABEL EXEC
  AR0 [ DR7 MOV,  FF00FF #L DR7 AND,   \ hi: hcd lo: dma stat
  TOUT *+ BRA,
\ SCSI: write                             (  4  9 87 CRC  8:13 )
LABEL WRITE  WDC @#L AR0 LEA,  FLOCK @# TAS,
  0A RP &[ RP -[ MOV,  SETDMA *+ BSR,  4 # RP ADDQ,
  88 # 2 AR0 &[ .W MOV,  NOP,  0A008A #L AR0 [ MOV,  \ write cmd
  SETCMD *+ BSR,  TOUT *+ MI BCC,   \ send command
  90 # 2 AR0 &[ .W MOV,  NOP,
  190 # 2 AR0 &[ .W MOV,  NOP, \ write
  8 RP &[ AR0 [ .W MOV,  NOP,
  18A # 2 AR0 &[ .W MOV,  NOP, \ count
  100 # AR0 [ .W MOV,  WAITL *+ BSR,  TOUT *+ MI BCC,
  18A # 2 AR0 &[ .W MOV,  EXEC *+ BRA,





\ SCSI: read                              (  4  9 87 CRC  8:13 )
LABEL READ   WDC @#L AR0 LEA,  FLOCK @# TAS,
  88 # 2 AR0 &[ .W MOV,  NOP,  08008A #L AR0 [ MOV,  \ read cmd
  0A RP &[ RP -[ MOV,  SETDMA *+ BSR,  4 # RP ADDQ,
  SETCMD *+ BSR,  TOUT *+ MI BCC,   \ send command
  190 # 2 AR0 &[ .W MOV,  NOP,
  90 # 2 AR0 &[ .W MOV,  NOP, \ write
  8 RP &[ AR0 [ .W MOV,  NOP,
  8A # 2 AR0 &[ .W MOV,  NOP, \ count
  AR0 [ .W CLR,  WAITL *+ BSR,  TOUT *+ MI BCC,
  8A # 2 AR0 &[ .W MOV,  EXEC *+ BRA,





\ SCSI: read                              (  4  9 87 CRC  8:13 )
LABEL SEND   WDC @#L AR0 LEA,   FLOCK @# TAS,
  88 # AR0 2 &[ .W MOV,  5 # DR1 MOVQ,
  DR1 FALSE DO,  DR0 CLR,  AR1 [+ DR0 .B MOV,
      SENDBYTE *+ BSR,  TOUT *+ MI BCC,  LOOP,
  WAITL *+ BSR,  TOUT *+ MI BCC,
  AR0 [ DR7 MOV,  FF00FF #L DR7 AND,  80 # 2 AR0 &[ .W MOV,
  FLOCK @# .W CLR,  RTS,








\ seek the disk!                          ( 10  9 87 CRC 18:38 )
LABEL SK   0B C, 0 C, 0 C,  5 C, 0 W,

CODE SEEK \ s#  --- fl | fl = sucess or timeout
  SK *+ AR1 LEA,
  S [ DR0 MOV,  DR0 2 AR1 &[ .W MOV,  DR0 .W SWAP,
  1F # DR0 .B AND,  1 AR1 &[ DR0 .B OR,  DR0 1 AR1 &[ .B MOV,
  SEND *+ BSR,
  FFFF0000 #L DR7 AND,  DR7 .W SWAP,  DR7 S [ MOV,  NEXT ;C
  FIXED






\ home the disk!                          ( 10  9 87 CRC 18:09 )
;S ATARI drive specific!

LABEL PK   1B C, 0 C, 0 C,  0 C, 0 W,

CODE PARK \ s#  --- fl | fl = sucess or timeout
  PK *+ AR1 LEA,
  SEND *+ BSR,  DR0 S -[ MOV,  DR7 S -[ MOV,  NEXT ;C FIXED








\ scsiread                                ( 10  9 87 CRC 18:57 )
CODE SCSIREAD  \ blk# ctblks addr  --- fl  | read from disk
  S [+ RP -[ MOV,                   \ addr
  S [+ DR0 MOV,  DR0 RP -[ .W MOV,  \ block count
  S [+ RP -[ MOV,                   \ sector
  READ *+ BSR,
  DR0 S -[ MOV,  DR7 S -[ MOV,  NEXT ;C         FIXED


: TESTREAD    4000 8 PAD  SCSIREAD ;






































































\ block read/re-write routines            ( 24  9 94 CRC 13:08 )
: bk  dup 8 ,.r  block  update drop ;

: bks  cr do  i bk  ctl m emit
  ?terminal if  leave then  loop ;

hex
: next    1000 +  swap  1000 +  swap  2dup ;








\ Begin SCSI access: load screen          ( 14  9 87 CRC 21:22 )
editor flush
debug  forget task
\ 10.ds +harddisk    \ <---  !!!!!!!!!!!!!!!!!!!!!!!!!
129 needed pick

: task ;
base @ decimal

1 10 hex +thru

decimal         maxscsi  . ." Blocks available. "
12 +blk loader bootblk
base f! editor flush


\ useful stuff: exit get-latest rdrop     ( 23 11 91 CRC  9:44 )
code exit   rts,  ;c     2 setlen

: get-latest    \  --  | compile in nfa of word being compiled
  ?comp latest [compile] literal ;  immediate

\ code rdrop      \  --  | =  r> drop
\   4 # rp addq,  next    ;c








\ fast ! & @                              ( 16  9 87 CRC 20:22 )
code fw!   \ w addr --  | fast .w store to addr
  s [+ ar0 mov,  s [+ ar1 mov,  ar1 ar0 [ .w mov,  next ;c

        \ superceeded by nucleus version
\ code f!    \ w addr --  | fast .l store to addr
\   s [+ ar0 mov,  s [+ ar0 [ mov,  next  ;c

code fw@   \ addr  --  w | fast .w read from addr
  s [ ar0 mov,  dr0 clr,  ar0 [ dr0 .w mov,  dr0 s [ mov,  next
  ;c





\ SCSI constants                          ( 14  9 87 CRC 19:48 )
   80000 constant lengthwait
\  40000 constant lengthwait
     43e constant flock

  ff8604 constant wdc
  wdc 2+ constant wdl
  wdc    constant wdcwdl

  ff8609 constant dmahi
dmahi 2+ constant dmamid
dmahi 4+ constant dmalow

  fffa01 constant gpip
base f@ decimal 799 variable 'maxscsi  base f!
code maxscsi 'maxscsi @#l s -[ mov,  next  ;c
\ SCSI errorrt gdone                      ( 21 11 93 CRC 18:28 )
0 variable targ

: sasi-req-error-routine ( --  nfa )
  80 wdl fw!  wdc fw@ drop 0 flock fw!  id. ;

: qdone ( calling word's nfa -- 0 if no error )
  lengthwait                  ( nfa if error  )
  begin  1- dup 0= if
     drop  sasi-req-error-routine \ exit then
     abort"  Scsi Command Error! "       then
     gpip c@ 20 and  0= until  2drop  0  ;      fixed




\ SCSI endcmd setdma                      ( 14  9 87 CRC 21:12 )
: endcmd ( value to be written to wdl -- 0 if no error )
  wdl fw!  get-latest  wdc fw@ ff and ( nfa if error  )
  0= if  drop 0  then  80 wdl fw!  0 flock fw! ;

: setdma ( dma address -- )
  dup dmalow c!  8 2/s dup dmamid c!  8 2/s dmahi  c! ;

: sconvert \ addr blk#  ---  ct scblk dev addr | reformat data
  2 rot >r ( ct)  swap 2* ( blk# ) 0 ( dev)  r> ( addr) ;






\ SCSI setss                              ( 14  9 87 CRC 19:55 )
: setss ( count\sector #\devno\or -- 0 if no error )
                                    ( nfa if error )
  >r                          ( write MSB sector# or devno )
  5 2*s over 10 2/s or        ( count\sector\devorsec )
  10 2*s r or wdcwdl f!       ( count\sector )
  get-latest qdone
  -dup if rdrop nip exit then

  dup 8 2/s ff and            ( write MID sector# )
  10 2*s r  or wdcwdl f!
  get-latest qdone
  -dup if rdrop nip exit then
[


\ SCSI setss cont                         ( 14  9 87 CRC 21:06 )
]
  ff and                      ( write LSB sector# )
  10 2*s r  or wdcwdl f!      ( count )
  get-latest qdone
  -dup if rdrop nip exit then

  10 2*s r  or wdcwdl f!      ( write sector count )
  get-latest qdone
  -dup if rdrop exit then

  r> 100 and wdcwdl f!        ( control )
  get-latest qdone
;


\ SCSI hread                              (  7  4 93 CRC 10:42 )
: hread ( count\sect\devno\dma address -- 0 if no error )
  ffff flock fw!                         ( nfa if error )
  setdma
  90 wdl fw!  190 wdl fw!  90 wdl fw!  ( toggle r/w )

  3 pick wdc fw!                      ( write sector count reg )
  88 wdl fw!                             ( select dma bus )

  targ f@  8008a or wdcwdl f!            ( read command )
  get-latest qdone
  -dup if  nip nip nip exit  then
  8a setss -dup if exit then
  8a endcmd  ;


\ SCSI hwrite                             (  7  4 93 CRC 10:42 )
: hwrite ( count\sect\devno\dma address -- 0 if no error )
  ffff flock fw!                          ( nfa if error )
  setdma
  198 wdl fw!  98 wdl fw!  198 wdl fw!    ( toggle r/w )
  98 wdl fw!  198 wdl fw!
  3 pick wdc fw!    ( write sector count reg )
  188 wdl fw!

  targ f@  a018a or  wdcwdl f!            ( write command )
  get-latest qdone
  -dup if  nip nip nip  exit then
  18a setss -dup if exit then
  18a endcmd  ;

2 +blk loader partitions
\ SCSI read for r/w                       ( 23 11 91 CRC 10:01 )
: (sr/w)  \ addr blk fl  ---   | fl: 1 is read, 0 is write
  over  0 maxscsi within  0= 6 ?error  \ out of range check
  >r sconvert r>  if  hread  else  hwrite  then
  -dup if  cr id.  abort"  SCSI Error"  then ;

: scsi    \ --  | install scsi r/w
  ' (sr/w)  'r/w f! ;

: getsize   ( count\sect\devno\dma address -- 0 if no error )
                1    0     0    pad     hread   -dup  if
    ." Scsi disk read failure!!!!" id.  abort  then
  pad 1c2 + f@  2/  'maxscsi f! ;

: target  15 2*s  targ f!  getsize ;
0 target
\ Scsi data collection                    ( 24  1 91 CRC 19:37 )
base f@ decimal  -11 +blk needed scsi  base f!

editor flush    forth
\ 10.ds +harddisk    \ <---  !!!!!!!!!!!!!!!!!!!!!!!!!
base f@ decimal


1 3  hex +thru

pad  200 + forget +scsi   here  swap  over - erase

base f!         \ editor flush



\ Scsi data collection                    ( 24  1 91 CRC 20:14 )
: +scsi   here b/buf + + ;

: show    +scsi  f@   decimal  9 ,.r  hex  space ;

: wshow   +scsi  fw@  decimal  9 ,.r  hex  space ;

: cshow   +scsi  c@   decimal  9 ,.r  hex  space ;

: showpart      \ drltr offset ---  offset' | decipher partition
  ?cr  ascii @ or  emit  ." :  Type: "
  dup 1+ +scsi 3 type
  ."   partition starts: "  4+ dup show
  ."   partition size: " 4+ dup show  4+ ;


\ Scsi data collection                    (  2  4 92 CRC 13:01 )
( count\sect\devno\dma address -- 0 if no error )
    1    0     0    0 +scsi     hread   -dup IFTRUE
pad  forget +scsi   here  swap  over - erase
." Scsi disk read failure!!!!"  id.     abort
IFEND  cr   ." Scsi Disk Information. (sectors)" cr
targ f@ 15 2/s ." Target is: "  18 .r

cr ." Park position             "  1be cshow  ."  Decimal"
cr ." Heads                     "  1b8 cshow
cr ." Sectors/Track             "  1c1 cshow
cr ." Total Sectors             "  1c2  show
cr ." Dead Sectors              "  1fa  show
1c6 ascii C  showpart           ascii D  showpart
    ascii E  showpart           ascii F  showpart   drop

\ Scsi data collection                    (  2  4 92 CRC 13:01 )
156 ascii G  showpart           ascii H  showpart
    ascii I  showpart           ascii J  showpart
    ascii K  showpart           ascii L  showpart
    ascii M  showpart           ascii N  showpart       drop
cr ." To access from Forth, divide the starting sector by 2."










\ reworked editor: load screen            (  9  9 87 CRC 22:52 )
FORTH DEFINITIONS   DECIMAL
\ FORGET TASK                     : TASK ;

\ FORTH DEFINITIONS   DECIMAL      EDITOR FLUSH   FORTH

1 BLK F@ + 23 BLK F@ + THRU

\ EDITOR FLUSH







\ orgn .pad text line -c/l 3+             (  7  9 87 CRC 22:56 )
FORTH  DEFINITIONS  BASE F@ HEX
: ORGN 0 0 GOTOXY  ;

: .PAD   ORGN ." pad" SPACE PAD 1+ C/L TYPE ;
                              \ Accept following text to pad
: TEXT  HERE C/L 1+ BLANKS WORD HERE PAD C/L 1+ CMOVE .PAD ;
                        \ Relative to scr, leave addr of line
: LINE  DUP -10 AND 17 ?ERROR SCR F@ (LINE) DROP ;

R# F@ B/BUF MIN R# F! \ It may have a value worth preserving

C/L MINUS CONSTANT -C/L

CODE 3+   3 # S [ ADDQ,  NEXT  ;C

\ editor sp$ clear$s range$ top$          ( 16  4 88 CRC 16:10 )
VOCABULARY  EDITOR  IMMEDIATE     EDITOR    DEFINITIONS

178 USER SP$                    DC USER 'Q

: CLEAR$S      SP$ ON  FIRST C/L - C/L ASCII T FILL ;  CLEAR$S

CODE (TOP$)   OFUSER 'FIRST DR0 MOV,  OFUSER SP$ DR1 MOV,
  6 # DR1 LSL,   DR1 DR0 SUB,  DR0 S -[ MOV,  NEXT  ;C

: RANGE$  (TOP$)  PAD 100 + < IF CLEAR$S THEN ;

: TOP$   RANGE$  (TOP$) ;



\ add$ drop$ .top clr$s                   ( 15  9 87 CRC 20:20 )
: ADD$  \ addr ---  | add $ at addr to the $stack
  SP$ 1+!  TOP$ C/L CMOVE ;

: DROP$ \ addr ---  | remove $ at top to addr
  TOP$ SWAP C/L CMOVE  -1 SP$ +!  RANGE$ ;

: .TOP  1 0 GOTOXY  ." top " TOP$ C/L TYPE ERL ;

: CLR$S    CLEAR$S .TOP ;






\ where #locate, etc. -move               (  7  9 87 CRC 15:31 )
FORTH DEFINITIONS
: WHERE  WARNING ON   \ Print screen # and image of error
  DUP DUP SCR F! ." Base = " BASE F@ DECIMAL . .SCR
  SWAP DUP R# F! C/L /MOD  6 2*s  ROT BLOCK + CR C/L -TRAILING
  TYPE CR  SPACES  ASCII ^ EMIT [COMPILE] EDITOR QUIT
STOP           EDITOR    DEFINITIONS
: #LOCATE                \ Leave cursor offset-2, line -1
        R#  F@  C/L  /MOD  ;
: #LEAD               \ Line address -2, offset-1
        #LOCATE  LINE  SWAP  ;
: #LAG           \ Cursor addr-2, count-1 after cursor
        #LEAD  DUP  >R  +  C/L  R>  -  ;
: -MOVE         \ Move in block buffer addr from-2, line-1
        LINE  C/L  CMOVE  UPDATE  ;
:  #LOC  R#  F@  C/L  /   ;     \ return line # only
\ insc cursor h e s l                     ( 23  1 92 CRC  9:15 )
: INSC  R# F@ 0 3FF WITHIN ;  \ are we on scr?

: CURSOR     #LOCATE   3+ 4 ROT + GOTOXY  ;

: H  INSC  \ l --- | Hold numbered line at pad
  IF LINE PAD 1+ C/L DUP PAD C! CMOVE .PAD THEN ;

: E   LINE  C/L  BLANKS UPDATE ;   \ erase line-1 with blanks

: S  DUP  1-  ( limit ) 0E \ first to move      \ spread making
   DO  I  LINE I  1+  -MOVE -1 +LOOP E ;        \ line-1 blank

: L    13 2   NO.CURSOR                 \ relist screen
  DO  FORTH I 0 GOTOXY  ERL  LOOP
  1 0 GOTOXY  CURSOR  L ;
\ (d) d rstr m t l o                      ( 21 12 90 CRC 20:11 )
: (D)  DUP 0F < IF  0F DUP ROT
   DO I 1+ LINE I -MOVE LOOP THEN E ;
: D  DUP H (D) ;

: RSTR #LOC DUP 3+ 4 GOTOXY SCR F@ .LINE ERL ;

: NEXT    SCR 1+! L ;
: LAST -1 SCR  +! L ;
              \ move cursor by signed amount.
: M   R# F@  +  DUP 0<  IF  B/BUF +  LAST  THEN
  DUP [ B/BUF 1- ] LITERAL  > IF  B/BUF -  NEXT  THEN  R# F! ;

: T   0F AND  DUP  6 2*s R# F!  H ; \ Type line, save in pad

: O  SCR F@ SWAP SCR F! L ;
\ r p i top pl                            (  7  9 87 CRC 17:18 )
: R                     \ replace on line #-1, from pad *
  INSC IF PAD 1+ SWAP -MOVE ELSE DROP THEN ;

: P  1 TEXT R ;         \ put following text on line-1 *

: I  DUP  S  R   ;      \ insert text from pad onto line # *
CR
: TOP  R# OFF ;         \ home cursor to top left of screen *

: PL    \ line#-1    PL    Partial list of rest of screen
  INSC  IF  NO.CURSOR  #LOCATE NIP  3+ 0 GOTOXY
   BASE F@ DECIMAL  10 ROT DO  FORTH I  DUP 3 .R SPACE
   SCR F@ .LINE  ERL CR  LOOP  BASE F!  CURSOR
  ELSE DROP THEN ;

\ wipe copy undo lupp rupp place          ( 23 12 90 CRC 11:44 )
D8 USER PLACEF  PLACEF OFF
: WIPE          \ Clear current screen *
  0 SCR F@ BLOCK DUP B/BUF BLANKS W! UPDATE  ;

: COPY          \ duplicate screen-2 onto screen-1 *
  OFFSET F@ + SWAP BLOCK  4- F! UPDATE ;

: UNDO   ( this session )  7FFFFFFF SCR F@ BLOCK 4- F! L ;
: LUPP   #LEAD UPPER UPDATE RSTR ;
: RUPP   #LAG  UPPER UPDATE RSTR ;

: PLACE  INSC  IF  DUP EMIT  PLACEF F@ IF
  #LAG SWAP DUP 1- SWAP ROT <CMOVE THEN #LAG UPDATE DROP C!
  1 M  CURSOR  PLACEF F@ IF  #LAG -TRAILING TYPE ERL  THEN
  ELSE DROP THEN ;
\ delete (del) b shelp date               ( 21  5 87 CRC 14:41 )
: DELETE  -DUP IF         \ backwards at cursor by count-1 *
  >R  #LAG  +  FORTH  R  - \ save blank fill location
  #LAG  R  MINUS  R#  +!   \ back up cursor
  #LEAD  +  SWAP  CMOVE
  R> BLANKS UPDATE THEN ;  \ fill from end of text

: BKSP   INSC IF 1 DELETE CURSOR #LAG -TRAILING TYPE ERL THEN ;

: B  PAD  C@  MINUS  M ; \  Back up cursor by text in pad

        \ adjust scr # to suit!                \ help key
: SHELP  0A offset @ -  O KEY 0= IF KEY DROP THEN O DROP ;

: DATE   \   --  | install date in current cursor loc.
  (DATE)  0 DO  CURSOR  DUP C@  PLACE  1+  LOOP  DROP ;
\ -text, case sensitive                   ( 27  5 91 CRC 11:38 )
HEX  \  addr1  count  addr2  --- f
CODE -CSTEXT    1 # DR1 MOVQ,  \ set up flag
  S [+ AR0 MOV,  S [+ DR0 MOV, S [ AR1 MOV,  1 # DR0 SUBQ,
  DR0 NE DO,  AR0 [+ AR1 [+ .B CMP,  LOOP,
     EQ IF,    DR1 CLR,  ELSE,
     CC IF, DR1 NEG, THEN, THEN, DR1 S [ MOV, NEXT  ;C
  \ n.b. 15 bit count max!! Use the version below if necessary.
                                                   ;S
  flag:  1 means the $ at addr1 is less than the $ at addr2
         0 means the $ at addr1 is  equal to the $ at addr2
        -1 means the $ at addr2 is less than the $ at addr1
  S [+ AR0 MOV,  S [+ DR0 MOV, S [ AR1 MOV,   \ 32 bit version
  BEGIN,  AR0 [+ AR1 [+ .B CMP,   \ Unstructured! Unstructured!
     EQ IF, DROP ROT ROT 1 # DR0 SUBQ, EQ UNTIL, 2
     DR1 CLR,  ELSE,
\ -text, case insensitive                 ( 27  5 91 CRC 11:51 )
ASSEMBLER HERE    HEX           \ case insensitive subroutine
  ASCII a # DR1 .B CMP,  GE IF,  ASCII z # DR1 .B CMP, LE IF,
      20 # DR1 .B EOR,  THEN, THEN,  RTS,

HEX  >R         \  addr1  count  addr2  --- f
CODE -CITEXT    1 # DR3 MOVQ,  \ set up flag
  S [+ AR0 MOV,  S [+ DR0 MOV, S [ AR1 MOV,  1 # DR0 SUBQ,
  DR0 NE DO,
     AR0 [+ DR1 .B MOV,   R  *+ BSR,  DR1 DR2 .B MOV,
     AR1 [+ DR1 .B MOV,   R> *+ BSR,
     DR2 DR1 .B CMP,  LOOP,
     EQ IF,    DR3 CLR,  ELSE,
     CC IF, DR3 NEG, THEN, THEN, DR3 S [ MOV, NEXT  ;C FIXED

' -CITEXT  VARIABLE 'TEXT    \ warning: not multi-user
\ -text                                   ( 13 12 91 CRC 13:22 )
FORTH DEFINITIONS
: CIS   EDITOR ' -CITEXT  'TEXT F! ;

: CS    EDITOR ' -CSTEXT  'TEXT F! ;

: -TEXT EDITOR 'TEXT @EXECUTE  STOP

EDITOR DEFINITIONS
LENGTH F@       0A LENGTH F!    \ go for speed !!!
: MATCH               \ addr1 count1 addr2 count2  --- f n3
   >R >R   2DUP R> R> 2SWAP BOUNDS         DO
      2DUP FORTH I -TEXT 0= IF >R 2DROP R> - FORTH I SWAP -
         0 SWAP 0 0 LEAVE  THEN LOOP 2DROP SWAP 0= SWAP ;
LENGTH F!

\ match                                   ( 15  7 90 CRC 17:52 )
           ;S
CODE MATCH            \ addr1 count1 addr2 count2  --- f n3
  S [+ DR2 MOV,  S [+ DR0 MOV,  S [+ DR4 MOV,  S [ DR1 MOV,
  1 # DR2 SUBQ,  FF # DR5 MOVQ,  1 # DR4 SUBQ,  1 # DR1 SUBQ,
  DR6 CLR,  DR4 EQ DO,  1 # DR1 ADDQ,  1 # DR5 ADDQ,
    DR0 AR0 MOV,  DR1 AR1 MOV,   DR2 DR3 MOV,
    DR3 NE DO,  AR0 [+ AR1 [+ .B CMP,  LOOP,   LOOP,
  EQ IF,  1 # DR6 MOVQ,  DR2 DR5 ADD,  THEN,
  1 # DR5 ADDQ,  DR6 S [ MOV,  DR5 S -[ MOV,  NEXT  ;C

dr0, ar0 - addr2       dr2, dr3 - count2     dr5 - offset
dr1, ar1 - addr1       dr4      - count1     dr6 - flag



\ bll blr stamp .stamp                    ( 26  2 92 CRC  9:55 )
: BLL    INSC
  IF #LEAD -DUP IF BLANKS RSTR UPDATE ELSE DROP THEN THEN ;

: BLR    INSC
  IF #LAG  -DUP IF BLANKS ERL  UPDATE ELSE DROP THEN THEN ;

DECIMAL
: BUILDSTAMP   BLK F@ BLOCK 42 + (STAMP) 22 CMOVE ;
BUILDSTAMP

: STAMP   SETSTAMP (STAMP) SCR F@ BLOCK 42 + 22 CMOVE UPDATE ;

: .STAMP  SETSTAMP (STAMP) 22 TYPE ;   HEX


\ next last 1line find up dn merge        (  4  8 91 CRC 15:22 )
: 1LINE  \ scan line w/ cursor for match to PAD text, update
  #LAG  PAD  COUNT  MATCH  R#  +! ;     \ cursor, return boolean

: FIND  \ string at pad over full scr, else err
  BEGIN  3FF R# F@ < IF  TOP PAD  HERE C/L 1+ CMOVE
  0 BOTTOM ERROR THEN  1LINE  UNTIL ;

: UP  -C/L * M  R# F@    0< IF  400 R# +! LAST THEN ;

: DN   6 2*s M  R# F@ 3FF > IF -400 R# +! NEXT THEN ;

: MERGE #LAG -TRAILING 1 UP #LAG DROP SWAP CMOVE UPDATE RSTR ;

: EOL  R# F@  -C/L AND  R# F!  #LAG -TRAILING M DROP ;

\ documentor day month merge placing      ( 10  2 19 crc 11:45 )
DECIMAL
: DOCUMENTOR   CREATE C, C, DOES>  >R  BL WORD  FORTH
   HERE 1+ ( from) R C@ DUP HERE C@ MIN - HERE 10 + + ( to)
   HERE C@ R C@ MIN ( count) CMOVE
   HERE 10 + ( from)  (STAMP)    R 1+ C@ + ( to)
   R> C@ ( count) 1+ ( keep separation) CMOVE ;

\   2 2 DOCUMENTOR DAY             5 2 DOCUMENTOR MONTH
(   8 2 DOCUMENTOR YEAR  )        11 3 DOCUMENTOR PROGRAMMER
: PLc      2 0 ( 0 71 ) GOTOXY ( ERL) PLACEF F@
  IF ." Inserting" ELSE  ." Replacing" THEN ;     HEX

: placing  placef 1 toggle  plc ;
: FLUSH   FIRST #BUFS 0 DO DUP F@ 0< IF DUP DUP F@ 7FFFFFFF AND
  SWAP 2DUP F! 4+ SWAP 0 R/W THEN +BUF DROP LOOP DROP ;
\ delline erline tab insline other incboth(  7  9 87 CRC 15:47 )
: DELLINE    #LOC DUP D PL ;            \ delete current line

: ERLINE     #LOC E RSTR ;              \ erase current line

: TAB     R# F@  8 +  -8 AND  R# F@ -   \ next multiple of 8
  PLACEF F@ IF  0 DO  CURSOR  BL PLACE  LOOP  ELSE  M  THEN ;
: NL         #LAG M DROP ;              \ beginning of next line
: INSLINE    #LOC DUP I PL ;            \ insert pad's contents

: OTHER      SWAP O SWAP ;              \ other screen

: RLINE      #LOC R RSTR ;      : SLINE    #LOC DUP S PL ;

: INCBOTH    SWAP 1+ SWAP NEXT ;    \ use to step through
: DECBOTH    SWAP 1- SWAP LAST ;    \ shadow screens
\ hline z$ 1up pull$ push$ put$ grab$     (  7  9 87 CRC 23:26 )
: HLINE  #LOC H ;               : Z$  PAD C@ DELETE RSTR ;

: FWD  1 M ;                    : BKWD  -1 M ;

: 1UP  1 UP ;                   : 1DN  1 DN ;

: PULL$     #LOC S  #LEAD DROP DROP$  #LOC PL  .TOP  UPDATE ;

: PUSH$     #LEAD DROP ADD$  #LOC DUP (D) PL  .TOP ;

: GRAB$     #LOC LINE ADD$  .TOP 1DN ;

: PUT$      1UP  #LOC LINE DROP$  .TOP RSTR  UPDATE ;

: >STAMP    STAMP  R# F@  R# OFF  CURSOR RSTR  R# F! ;
\ flip doctls                             (  4  8 91 CRC 15:23 )
\ : FLIP   SCR F@ BLOCK  R# F@ +  80 TOGGLE  RSTR 1 M ;

: DOCTLS  0 MAX CTL ^ MIN EXEC
\     @       a       b       c       d       e       f
      |       B       LAST    Z$      DELLINE ERLINE  BKWD
\     g       h       i       j       k       l       m
      FWD     BKSP    TAB     INSLINE >STAMP  GRAB$   BOTTOM
\     n       o       p       q       r       s       t
      NEXT    OTHER   PUT$    PUSH$   RLINE   SLINE   1UP
\     u       v       w       x       y       z       [
      NL      1DN     PULL$   FLUSH   CLR$S   HLINE   DECBOTH
\     \       ]       ^
      EOL     INCBOTH |       |       STOP


\ dofuns                                  (  7  9 87 CRC 17:03 )
HEX
: DOFUNS   3A MAX  56 MIN  3A -  EXEC  |
\     f1 3B   f2 3C   f3 3D   f4 3E   f5 3F   f6 40   f7 41
      BLL     MERGE   BLR     LUPP    RUPP    undo    DATE
\     f8 42   f9 43   f10 44  45      46      clh 47  up 48
      .PAD    TOP     FLUSH   |       |       top     1UP
\     49 pup  4A -    <- 4B   4C      -> 4D   + 4E    4F
      last    |       BKWD    |       FWD     |       |
\     dn 50   51 pdn  nsrt 52 53      F1 54   F2 55   F3 56
      1DN     next    PLACING |       SHELP   undo    |
\     F4 57   F5 58   F6 59   F7 5A   F8 5B   F9 5C   F10 5D
      stop \  |       |       |       |       |       |



\ del (q)                                 ( 13  9 87 CRC 12:28 )
: DEL  \  --  | delete to right of cursor w/o moving
  #LAG  >R 1+ DUP 1-  R> 1- CMOVE
  BL #LAG + 1- C!  UPDATE  RSTR ;

: (Q) 4 8 CURSCONF  \ continuous stream editor
  BEGIN plc  CURSOR KEY
  DUP        BL 7E WITHIN  IF            DUP PLACE  ELSE
  DUP                7F =  IF                  DEL  ELSE
  DUP  CTL A CTL _ WITHIN  IF           DUP DOCTLS  ELSE
  DUP            0=  IF KEY
    DUP 62 = IF  SHELP DROP  ELSE
    DUP 61 = IF  UNDO DROP   ELSE  DOFUNS  THEN THEN
    THEN THEN THEN THEN  CTL M = UNTIL
  plc  BOTTOM 4 14 CURSCONF ;

\ q z n f till x                          ( 10  2 19 crc 11:45 )
' (Q) 'Q F!
: Q 'Q @EXECUTE  STOP       \ plan ahead for multiuser some day
: Z  ORGN ERL  .TOP .PAD L  placing placing  Q ;
: N    \ find occurance of text previously specified; in pad
   FIND  Q ;
: F    \ find occurance of following text
   1  TEXT  N ;

: X    \ Delete following text only
   1 TEXT  FIND  PAD  C@  DELETE RSTR Q ;

: TILL \ delete on cursor line from cursor to end of given text
   #LEAD + 1 TEXT 1LINE 0= IF BOTTOM 0 ERROR THEN
   #LEAD + SWAP - DELETE RSTR Q ;

\ search research cont edit ender         ( 21  4 19 crc 16:26 )
HEX E0 USER ENDER    ENDER OFF       DECIMAL
: RESEARCH    \ from-2  to-1   ---  wanted string
  CR BOTTOM 1+ SWAP DO FORTH I SCR F! EDITOR TOP
    forth i editor  block w@ if \ Don't search binary scrs
      BEGIN 1LINE DUP ?TERMINAL OR IF LEAVE THEN
      1023 R# F@ < OR UNTIL  then  ." ." LOOP Z ;

: SEARCH  DUP ENDER F! 1 TEXT RESEARCH ;  \ from-2  to-1   ---

: CONT  SCR F@ 1+ ENDER F@ RESEARCH ;
FORTH DEFINITIONS

: EDIT SCR F! EDITOR  Z FORTH  [COMPILE]  EDITOR ;
   CR  ." Editor loaded. "  CR     BASE F!      ;S
   Typical use to locate 'KEY-WORD' :  21 44 SEARCH KEY-WORD
\ hard disk raw access: +blk, +load, +thru( 17  7 88 CRC 11:37 )
FORGET TASK                     EDITOR DEFINITIONS
: FINDBLNK  \  -- blk# | find next empty block from here
  SCR F@ 1+  BEGIN DUP BLOCK W@ WHILE  1+ REPEAT ;

: INSERTSCR \  --  | insert an empty screen by moving scrs up 1
  FORTH FLUSH  EDITOR FINDBLNK  BEGIN  1-  DUP 2DUP 1+  COPY
      SCR F@ = UNTIL  DROP ;
FORTH DEFINITIONS

CODE +BLK   OFUSER BLK DR0 MOV,
 EQ IF,  OFUSER SCR DR0 MOV,  THEN,  DR0 S [ ADD,  NEXT ;C




\ hard disk raw access: copies            ( 17  7 88 CRC 11:37 )
: +LOAD  +BLK LOAD ;

: +THRU  +BLK SWAP  +BLK SWAP  THRU ;

BASE F@ DECIMAL
: COPIES   \ src dest ct ---  src' dest' | screen copier
  BASE @ 10 - IF ABORT" Try this in decimal!" THEN
  BEGIN  >R 2DUP  EDITOR COPY  1 1 D+
    R> 1-  DUP 0=  ?TERMINAL OR  UNTIL DROP FLUSH ;
BASE F!
\ : TASK ;




\ Atari cookie jar search                 (  3  3 19 crc 14:04 )
\ see http://toshyp.atari.org/en/003007.html
forth definitions               editor flush
forget task                     : task ;        base @ decimal
107 needed iftrue  hex  05a0 f@ 0= iftrue  base ! ;s IFEND
05a0 constant cookiejar
: cookid.       \  addr  ---  addr'  | print cookie name
  begin  dup c@  dup while  emit  1+  repeat drop ;

: .cookie       \  addr  ---    | print cooke name & value
  cookid.  space  ? ;

: .cookies      \  ---  | print all the cookies
  base @ hex cr  cookiejar f@  begin  dup  f@
  while  dup .cookie col  8 + repeat  4+ ?  base ! ;
-->
\ Atari cookie jar search                 (  3  3 19 crc 14:04 )
0 variable sought       \ name of the cookie we want goes here.

: getname       \   ---   | get the name of the cookie to seek.
  bl word  here count  dup 4 >  if  abort"  4 chars!" then
  sought dup off  swap cmove ;

: scan          \   ---   | scan for and show a given cookie.
  getname  base @ hex  cookiejar f@  begin  dup  f@
  while  dup  4 sought  editor -cstext  forth
     0= if  dup .cookie col then  8 + repeat drop  base ! ;
base !




































\ test for new branch definition          ( 12  1 92 CRC 10:05 )
\  DEBUG FORTH DEFINITIONS FORGET TASK
\  : TASK ;
HEX
: OLD  [COMPILE] FORTH ; IMMEDIATE

VOCABULARY NEW IMMEDIATE        NEW DEFINITIONS

0 VARIABLE CONDL        \ to become user variables
1 VARIABLE NDRP                 0 VARIABLE LNG?

-->




\ old style conditionals we need          ( 12  1 92 CRC 10:17 )
FORTH DEFINITIONS

CODE R0<>  DR0 CLR,  S [ TST,  NE IF,  1 # DR0 ADDQ,  THEN,
   DR0 S [ MOV,  NEXT ;C

: NOT  0= ;     \ now they are different words!

NEW DEFINITIONS

\ useful words for conditional tests.
CODE 0<>  S [  TST,  NEXT  ;C
CODE CMP  S [+ DR0 MOV,  S [  DR0 CMP, NEXT ;C
-->


\ new defs for (do), (loop)               ( 28  1 92 CRC  8:55 )

ASSEMBLER BEGIN, 2DUP  >R >R   2 # AR0 ADDQ,
  RP [+ DR6 MOV,  RP [+ DR5 MOV,  AR0 [ JMP,

CODE (LOOP)     RP [+ AR0 MOV,  1 # DR5 ADDQ,
( LABEL LP2 )   here   DR5 DR6 CMP,
                R> R> GT UNTIL,    >r
( LABEL LP5 )   here >r  AR0 [ AR0 .W ADD,
                AR0 [ JMP,  ;C        FIXED

CODE (DO)  RP [ AR0 MOV,  DR5 RP [ MOV,  DR6 RP -[ MOV,
  S [+ DR5 MOV,  S [+ DR6 MOV,  AR0 [ JMP, ;C FIXED

CODE I  DR5 S -[ MOV,  NEXT  ;C         r> r>  -->
dr5: index                      dr6: limit
\ (+loop) redefined                       ( 21  1 92 CRC 10:18 )

2SWAP  >R >R  >R >R
CODE (+LOOP)  RP [+ AR0 MOV,   R> R>
  S [+ DR0 MOV,  DR0 DR5 ADD,  DR0 TST,  ( LP2) *+ PL BCC,
  DR5 DR6 CMP,  ( LP5) *+ LT BCC,   R> R> AGAIN,   ;C  FIXED
\       dr5: index                      dr6: limit
-->
( LABEL LP5 )   here >r  AR0 [ AR1 .W MOV,  AR1 AR0 ADD,







\ processor conditional states            ( 12  1 92 CRC 10:20 )
: BRCH CREATE IMMEDIATE W,  DOES> W@  CONDL F! ;

6100 BRCH TRUE  6000 BRCH FALSE 6300 BRCH HI    6200 BRCH LS
6500 BRCH CC    6400 BRCH CS    6700 BRCH NE    6600 BRCH EQ
6500 BRCH HS    6400 BRCH LO   \ synonyms
6900 BRCH VC    6800 BRCH VS    6B00 BRCH PL    6A00 BRCH MI
6D00 BRCH GE    6C00 BRCH LT    6F00 BRCH GT    6E00 BRCH LE
NE

CODE NOP  NOP,  NEXT ;C         \ for testing branches later
-->




\ test for new branch definition          ( 10  1 92 CRC 11:29 )
\ if we can do so: change addressing mode of prev. instruction
\ to drop results ( e.g. +, or, etc.) & signal results.
: ?CPU  \ --- fl | do we need the tst instruction?
  HERE 1- DUP C@ 93 = IF  NDRP @ IF  8 TOGGLE 0
  ELSE  DROP 0  THEN  NDRP ON   ELSE  DROP 1  THEN ;

: TSTWD  CREATE  SMUDGE
  [COMPILE] ' ,  [COMPILE] '  ,  ,  IMMEDIATE  SMUDGE
  DOES> STATE F@ IF  ?CPU  IF  DUP F@ <COMP> THEN
  4+ @EXECUTE  THEN  4+ 4+ @EXECUTE  STOP

: KEEP   NDRP OFF ;  IMMEDIATE  \ override auto-drop on test.
-->


\ test for new branch definition          ( 12  1 92 CRC 10:25 )
\ runtime    name compare conditional
 ' 0=   TSTWD 0=    0<>      NE
 ' 0<   TSTWD 0<    0<>      MI
 ' R0<> TSTWD 0<>   0<>      NE
 ' >    TSTWD >     CMP      LT
 ' <    TSTWD <     CMP      GT

 \ for use with if, else & then.
: LONG    LNG? ON  ;  IMMEDIATE
: SHORT   LNG? OFF ;  IMMEDIATE         SHORT

-->     previous versions, for historical analysis
: >    COMPILE CMP [COMPILE] LT ;       IMMEDIATE
: <    COMPILE CMP [COMPILE] GE ;       IMMEDIATE

\ internal branching words                ( 12  1 92 CRC  9:34 )
\ forward branch resolution.
| : LRESOLVE       HERE OVER - 2- SWAP 2+ W! ;

| : SRESOLVE       HERE OVER -  DUP -100 AND IF  .S
  ABORT" BR out of range!!" THEN  2- OVER W@  OR SWAP W! ;

        \ there fl ---  resolve branch from there to here
: RESOLVE        IF  LRESOLVE  ELSE  SRESOLVE  THEN ;

\ backward branch resolution.
| : SBKWD           HERE ROT SWAP - 2-   FF AND OR  W, ;
| : LBKWD  10 2*S   HERE ROT SWAP - 2- FFFF AND OR   , ;

| : BKWD  OVER HERE -  2-  -7F 7F WITHIN
    IF  SBKWD  ELSE  LBKWD  THEN ;              -->
\ build forward branch instructions       ( 12  1 92 CRC 10:37 )
: LBRN   HERE  CONDL F@ ( 2 *+ xx BCC, ) 10 2*S  , ;

: SBRN   HERE  CONDL F@ ( 2 *+ xx BCC, )        W, ;

: BRN     LNG? F@  IF  LBRN  ELSE  SBRN  THEN  LNG? F@
  [COMPILE] SHORT ;

: DO    ?COMP  COMPILE (DO) HERE 3 ;           IMMEDIATE

: LOOP         3 ?PAIRS COMPILE (LOOP)  BACK ; IMMEDIATE

: +LOOP        3 ?PAIRS COMPILE (+LOOP) BACK ; IMMEDIATE
-->


\ test for new branch definition          (  9  1 92 CRC 17:41 )
\ --- here l/s skchk | mark forward branch location
: IF    ?COMP  ?CPU DROP  BRN  [COMPILE] NE  2 ;   IMMEDIATE

: THEN    HERE LASTTHEN F!
  ?COMP   2 ?PAIRS  RESOLVE ;                   IMMEDIATE

: ELSE    2 ?PAIRS  [COMPILE] FALSE BRN
  2SWAP   2 [COMPILE] THEN  [COMPILE] NE  2 ;   IMMEDIATE

: ENDIF [COMPILE]  THEN  ;                      IMMEDIATE

: BEGIN ?COMP HERE 1 ;                          IMMEDIATE
-->


\ test for new branch definition          (  9  1 92 CRC 17:41 )
: UNTIL 1 ?PAIRS  ?CPU DROP
                CONDL F@  BKWD  [COMPILE] NE ;  IMMEDIATE

: AGAIN 1 ?PAIRS  6000 BKWD ;                   IMMEDIATE

: REPEAT   >R >R >R [COMPILE] AGAIN R> R> R> 2-
                [COMPILE] THEN  ;               IMMEDIATE

: WHILE [COMPILE] IF 2+ ;                       IMMEDIATE

: END   [COMPILE] UNTIL ;                       IMMEDIATE
-->



\ begin test words for new conditionals   ( 10  1 92 CRC 11:46 )
: FOO  0<>        IF ." true "  ELSE ." false " THEN ;
: BAR  0<>     EQ IF ." false " ELSE ." true "  THEN ;
: BAZ  + KEEP  CS IF ." set "   ELSE ." reset " THEN  . ;
: M    0<         IF ." neg "   ELSE ." pos "   THEN ;
: Y    >          IF ." false " ELSE ." true "  THEN ;

: -TDUP 0<> KEEP IF DUP THEN ;

: TS->D   0<> KEEP  MI IF -1 ELSE 0 THEN ;

: CTS BEGIN  1- KEEP CS UNTIL  DROP ;

: SNARK  BEGIN  0<> KEEP PL WHILE  1-  REPEAT ;
-->

\ more test words                         (  5  1 92 CRC 11:25 )
: TD+   >R ROT  + KEEP CS IF  1 UNDER+  THEN  SWAP  R> + ;
: TD-   >R ROT  SWAP  - KEEP
   CS IF  1 UNDER+  THEN  R> ROT - ;

: (VLST)    80 OUT F!   \ addr --- | vlist of given voc
  BEGIN  COL  DUP ID. ?STACK
      N>L F@  DUP NOT  ?TERMINAL OR  UNTIL
  DROP  CR ;

: VLIST    CONTEXT F@ F@  (VLST) ;
: CURLIST  LATEST         (VLST) ;

: TL NEW  0 3 DO I .    -1 +LOOP ;
EDITOR FLUSH                    -->

\ more test words                         ( 27  1 92 CRC  9:55 )
: nops,  0 do  assembler  nop,  loop ;

: kazoo   \ test long if/then
       0<>  long  IF ." true "
       [   80 nops,   cr .s   ]
              long              ELSE  nop ." false "
       [   80 nops,   cr .s   ]
                                                THEN ;







\ Time a given word                       ( 18 12 91 CRC 18:57 )
DEBUG FORTH DEFINITIONS BASE F@ HEX             FORGET TASK
0 VARIABLE CT
CODE SETTIMER  4BA @#  DR0 MOV,
  BEGIN, 4BA @# DR0 CMP,  NE UNTIL,
  4BA @#  CT @#L MOV,  NEXT  ;C

: .T    0 <# # # #> TYPE ;

: TIME  \  ---  | count cycles from word start
  4BA F@  CT F@ - DUP 8 .R  2 /MOD  64 /MOD  5 .R ASCII . EMIT
  .T  5 *  . ;
: TT  [COMPILE] '  SETTIMER  EXECUTE TIME ;

BASE F! EDITOR FLUSH            : TASK ;
\ CODE TESTNEXT   NEXT          : TEST ;
\ 8 queens problem rf 2.0                 ( 18 12 91 CRC 18:46 )
-1 +blk needed time
debug forget task forth definitions     decimal
-15 +blk needed new     forth definitions       decimal
: task ;                        editor flush
true  constant usenew           usenew not constant useold
length f@ 16 length f!

code -rot  s [ dr0 mov,  s 4 &[ s [ mov,  s 8 &[ s 4 &[ mov,
  dr0 s 8 &[ mov,  next  ;c
 0 constant falseflag           -1 constant trueflag
 8 constant boardsize           boardsize 1- constant boardmask

: recurse  latest n>c <sub> ;   immediate
: a@  compile  c@  ;    immediate
: a!  compile  c!  ;    immediate       -->
\ 8 queens problem rf 2.0                 ( 18 12 91 CRC 18:46 )
: iarray ( n -- )  create  ( 2* 2*) allot
  ;code ( n -- adr )  rp [+ dr0 mov,  dr0 s [ add,  next  ;c

boardsize    iarray ax          boardsize 2* iarray bx
boardsize 2* iarray cx          boardsize    iarray xx

: safe? ( n1 n2 -- f )
  dup ax a@ -rot              \ -- ax[n2] n1 n2
  2dup + bx a@ -rot           \ -- ax[n2] bx[n1+n2] n1 n2
  swap - boardmask + cx a@    \ -- ax[n2] bx[n1+n2] cx[n2-n1+7]
  and and ;                   \ -- fl
                                -->
  does> ( n -- adr )  + ;
  does> ( n -- adr )  >r 2* 2* r> + ;
  ;code ( n -- adr )  rp [+ dr0 mov,  dr0 s [ add,  next  ;c
\ 8 queens problem rf 2.0                 ( 18 12 91 CRC 18:46 )
: mark ( n1 n2 -- )
  dup ax  falseflag swap a! ( -- n1 n2 )
  2dup + bx  falseflag swap a! ( -- n1 n2 )
  swap - boardmask + cx  falseflag swap a! ( -- ) ;

: unmark ( n1 n2 -- )
  dup ax  trueflag swap a! ( -- n1 n2 )
  2dup + bx  trueflag swap a! ( -- n1 n2 )
  swap - boardmask + cx  trueflag swap a! ( -- ) ;

0 variable printsol?            falseflag printsol? f!
0 variable tries                0 variable hits

: laconic   printsol? off ;     : verbose   printsol? on ;
                                -->
\ 8 queens problem rf 2.0                 ( 18 12 91 CRC 18:46 )
USEOLD IFTRUE
: printsol ( -- )
  printsol? f@  if  ." Found on try " tries f@ 6 .r cr
      boardsize 0 do  i xx a@ 1+ 5 .r  loop cr  then
  hits 1+! ;

: run ( 0 -- )   ( -- recursion count ) boardsize 0 do
  1 tries +! \  ?key if key abort then
  dup i safe? if  dup i mark dup i swap xx a!
  dup boardmask < if dup 1+ recurse
              else printsol then
                  dup i unmark then  loop drop ;
IFEND
  -->

\ 8 queens problem rf 2.0                 ( 12  1 92 CRC 11:33 )
USENEW IFTRUE
: printsol ( -- )
  printsol? f@  new 0<> if  ." Found on try " tries f@ 6 .r cr
      boardsize 0 do  i xx a@ 1+ 5 .r  loop cr  then
  hits 1+! ;

: run ( 0 -- )   ( -- recursion count ) boardsize 0 do
  1 tries +! new \ ?key eq if key abort then
  dup i safe? 0<> if  dup i mark dup i swap xx a!
  dup boardmask < if dup 1+ recurse
              else printsol then
                  dup i unmark then  loop drop ;
IFEND
  --> results: shaves .015 sec off laconic run, .035 sec off
verbose run.
\ 8 queens problem rf 2.0                 ( 18 12 91 CRC 18:46 )
: unmark-all ( -- )
  boardsize    0 do  trueflag i ax a!  trueflag i xx a! loop
  boardsize 2* 0 do  trueflag i bx a!  trueflag i cx a! loop ;

: do-it ( -- )  tries off  hits off
  unmark-all  0 ( counter ) run  tries ?  hits ? ;

length f!







\ import\export files to\from pc          ( 29 12 95 CRC 12:26 )
BASE F@ DECIMAL                 702 NEEDED ship:        base f!
create work ," work" 0 c,
base f@
1  7 HEX +THRU

EDITOR FLUSH    BASE F!









\ import\export files to\from pc          ( 29 12 95 CRC 12:26 )
: SETPATH       \ get current path into path
  FILING PATH C/L ERASE
  HERE CURDRV GETPATH  HERE  CT->0 PATH SWAP CMOVE ;

: ADD\  FILING ASCII \ PATH CT->0 + C! ;

: -\    \ delete last directory name from path
  FILING PATH CT->0 BOUNDS SWAP  DO
  I C@  0 I C!  ASCII \ = IF LEAVE THEN
  -1 +LOOP ;

: DODIR         \ if it's a directory, act on it.
  ADD\  FILING DTANAME CT->0  PATH SWAP CMOVE
  PATH (CD) ;

\ import\export files to\from pc          ( 29 12 95 CRC 12:26 )
2C CONSTANT DTASIZE
CREATE DTAS    DTASIZE 20 * ALLOT       \ allocate
DTAS HERE OVER - ERASE                  \ clean 'em

DTAS VARIABLE THEDTA

CODE ISDTA      \ addr -  | tell os where to put dir stuff
  S [+ RP -[ MOV,  1A # RP -[ .W MOV,
  1 # TRAP,  6 # RP ADDQ,  NEXT   ;C

: PUSHDTA       \ push a dta on the dta stack
  DTASIZE THEDTA +!  THEDTA F@ ISDTA ;

: POPDTA        \ pop a dta from the dta stack
  DTASIZE MINUS THEDTA +!  THEDTA F@ ISDTA ;
\ import\export files to\from pc          ( 29 12 95 CRC 12:26 )















\ import\export files to\from pc          ( 29 12 95 CRC 12:26 )















\ import\export files to\from pc          ( 29 12 95 CRC 12:26 )















\ import\export files to\from pc          ( 29 12 95 CRC 12:26 )
: dofiles       \ do the files in a directory
  filing dmy SFIRST 0= IF  BEGIN  SENDENTRY  SNEXT UNTIL THEN ;

: dodirectories ;











\ import\export files to\from pc          ( 29 12 95 CRC 12:26 )
: SHIPs \  ---  | send all files incl. subdirs
  FILING HANDLE F@ IF  ABORT" File Already Open! " THEN   ?CR
  PWD CR
  'TYPE F@ >R  ' SLTYPE  'TYPE F!  KEYMASK W@ >R  FF KEYMASK W!
  VERT  'EMIT F@ >R  PURGE   ASCII K XEMIT
  dtas dup thedta f!  isdta
  no.cursor  dodirectories  dofiles  cursor
  ASCII D XEMIT  R> 'EMIT F!  DISPLAY   setdta
  R> KEYMASK W!  R> 'TYPE F!  ?CR ;






















\   cross reference utility.              (  6  2 92 CRC  9:38 )
FORTH DEFINITIONS  FORGET TASK   : TASK ;  BASE F@ >R DECIMAL
VOCABULARY CREF IMMEDIATE   \   CREF DEFINITIONS
5 +BLK NEEDED P>C

: GETWD         \ cfa --- | if relocatable, add cfa to table
  DUP 2- W@ IF  , ELSE  DROP THEN ;

: GETVOC        \ vhead ---  | get relocatable wds in this voc
  BEGIN  DUP N>C GETWD  N>L F@
    DUP LIMIT U< 0=  OVER 0=  OR UNTIL  DROP ;

: GETLOCS       \  ---  | build list of relocatable words
  VOC-LINK BEGIN  F@ -DUP  WHILE  DUP 8 - F@ GETVOC  REPEAT ;

1 4 +THRU  (   : TASK ; )  R> BASE F!            EDITOR FLUSH
\   cross reference utilities             ( 17  6 92 CRC  9:43 )
CREATE RELOCS  GETLOCS  HERE CONSTANT LASTLOC

: .RELOCS   LASTLOC RELOCS  DO COL I F@  C>N ID.
  ?TERMINAL IF LEAVE THEN  4 +LOOP ;

: SCAN      0  LASTLOC RELOCS  DO  OVER  I F@ =
  IF 2DROP I I LEAVE THEN  4 +LOOP  DROP ;

: FOUND         \ relocaddr ---  | handle found in line code
  IP F@  7 U.R
  F@ DUP C>N AID. ."  <in line code>"  2- W@  IP +!  CR ;

: TEST          \ relocaddr --- fl | check a reloc against targ
  IP F@  OVER F@ -  IF  F@ DUP 2- W@  IP F@  EDITOR -CSTEXT  0=
  ELSE  DROP 0  THEN ;
\   cross reference utilities             ( 27  5 92 CRC 13:23 )
: SRCH    1 LASTLOC RELOCS  DO  I TEST
    IF  1-  I FOUND  LEAVE THEN  4 +LOOP  ;

: DISM   CR IP F!  ?QUIT OFF
  BEGIN SRCH  IF  DECOMPILER <UN:>  THEN
  KEY LI =  ?QUIT F@  OR  UNTIL ;

0 VARIABLE COUNTEM

: .CT COUNTEM F@ -DUP IF DECIMAL 6 .R COUNTEM OFF THEN  ?CR ;





\   cross reference utilities             ( 23  2 92 CRC 14:17 )
: LOC   \ nfa  ---      | print out screen & line # if can
  BASE F@ DECIMAL SWAP
  DUP ' WHERETHEN > IF SPACE N>L L>S F@ WHERETHEN  C/L /
  ."  Line " 3 .R SPACE .SCR SPACE  ELSE DROP THEN BASE F! ;

DECIMAL
: .VOC  \ vla ---   | print out name of vocabulary
  ."  vocabulary is: "  DUP LIMIT  U< IF  P>C
     ELSE  DROP  ' FORTH  THEN  C>N ID. ;

FORTH DEFINITIONS
: .CON  ."  Context" CONTEXT F@ CREF .VOC ;

: .CUR  ."  Current" CURRENT F@ CREF .VOC ;

\   cross reference utilities             ( 23  2 92 CRC 14:17 )
: ?LIKE   [COMPILE] '  (RES) >R  CR  CONTEXT F@ F@
  CREF  COUNTEM OFF  BEGIN  N>C DUP  (RES) R  =
    IF CR DUP C>N ID.  COUNTEM 1+!
    R  [ ' BASE (RES) ] LITERAL  =
        IF COL  DUP  C>P W@ 10 U.R  THEN
    R  [ ' BL   (RES) ] LITERAL  =
        IF COL  DUP C>P  F@ 10 U.R  THEN
    THEN  C>N N>L F@  DUP 0= ?TERMINAL OR  UNTIL
  R> 2DROP  .CT ;

: .VOCS   CR    \ print out all vocabularies
  CREF  COUNTEM OFF   VOC-LINK F@
  BEGIN  -DUP WHILE  DUP 8 - .VOC  COL  F@  COUNTEM 1+!  REPEAT
  .CT ;
\ : foo 4+ 4- ;                   ' foo ip F!
















































\ import screens from pc                  (  7  1 96 CRC 13:35 )
: XKEY          \ --- c | get a character from the host
  [ 10 SECONDS ] LITERAL SETWATCH  AWAITKEY ;

: XEXPECT       \ addr ct ---  | get ct characters from host
  0 DO  XKEY  OVER C!  1+  LOOP DROP ;


: GETSCR  I/O F@ INPUT >HOST
  SCR @ BLOCK B/BUF XEXPECT   I/O F!  UPDATE forth l ;

: SHIPSCR  I/O F@  OUTPUT >HOST
  SCR @ BLOCK B/BUF SLTYPE    I/O F! ;
EDITOR FLUSH


\ import files from pc: routine stuff     ( 11 11 95 CRC 13:13 )
editor flush    purge
cd: e:\packets\nwcs     ?cr ." Getting nwcs"            get
cd: f:\packets\lvractn2 ?cr ." Getting lvractn"         get
cd: f:\packets\guntalk  ?cr ." Getting guntalk"         get
cd: g:\logs             ?cr ." Getting logs"            get
cd: d:\grid\modem\telix\cs
                        ?cr ." Getting telix scripts"   get
cd: d:\grid\modem\telix\lvractn
                        ?cr ." Getting telix"   get     get
cd: d:\grid\modem\bwave\lvractn
                        ?cr ." Getting blue wave"       get
-->



\ import files from pc: routine stuff     ( 11 11 95 CRC 13:13 )
cd: f:\txt              ?cr ." Getting txts"            get
cd: i:\                 ?cr ." Getting inis & C" ( get) get
cd: d:\sample   get     get     get     get     get
cd: d:\txtfltrs get     get     get     get     get
cd: h:\gemul8r                                  get
cd: c:\checking\wamututa
                        ?cr ." Getting checking"        get
\ cd: i:\winword\pmassist ?cr ." Getting PMAssist"        get
cd: i:\winword\template ?cr ." Getting templates"       get
cd: i:\winword\crc      ?cr ." Getting crcstuff"        get
cd: i:\winword\quotefil ?cr ." Getting quotefile"       get
cd: d:\grid\fd          ?cr ." Getting front door"      get
\ cd: d:\               ?cr ." Getting root"     get    get
-->

\ import files from pc: routine stuff     ( 11 11 95 CRC 13:13 )
cd: g:\zips             ?cr ." Getting zips"            get
cd: i:\faxworks         ?cr ." Getting faxes"           get
cd: i:\faxworks\receive ?cr ." Getting faxes"           get
4000 setwatch
cd: i:\faxworks\keeps   ?cr ." Getting faxes"           get
cd: c:\rf               ?cr ." Getting rf"              get
  home pwd ?cr
                        ." d:\ " df: d:
." e:\ " df: e:         ." f:\ " df: f:
." g:\ " df: g:         ." h:\ " df: h:
." i:\ " df: i:         ." j:\ " df: j:




\ import files from pc                    (  8  9 95 CRC 17:51 )
DECIMAL 201 NEEDED >LOCAL       674 NEEDED TT   FORGET TASK
( HOME )          PWD ?CR
FORTH DEFINITIONS : TASK ;      BASE F@ DECIMAL PC
0 VARIABLE LEN                  0 VARIABLE CHECKSUM
0 VARIABLE DATE                 0 variable isdir
0 VARIABLE TIME

1 13 HEX +THRU

EDITOR FLUSH    BASE F!





\ import files from pc                    (  8  9 95 CRC 17:48 )
BASE F@ HEX
4BA CONSTANT 200HZ
0 VARIABLE CT

: SETWATCH      \ n ---  | set watchdog to n ticks in future
  200HZ F@ +  CT F! ;

: WATCHDOG      \  ---  | have we exceeded our time?
  CT F@  200HZ F@  < IF  DISPLAY
     BELL ABORT" Watchdog Timeout! " THEN ;
DECIMAL
: SECONDS   200 * ;

: AWAITKEY  4000 SETWATCH  BEGIN  ?KEY WATCHDOG  UNTIL (KEY) ;
BASE F!
\ import files from pc                    (  6 10 94 CRC 15:27 )
: ?TERMINAL
  I/O F@ >R  INPUT >LOCAL  ?TERMINAL  R> I/O F! ;

: LEMIT
  I/O F@ >R  OUTPUT >LOCAL  (EMIT)  R> I/O F! ;

: XEMIT  I/O F@ >R  OUTPUT >HOST  (EMIT)  R> I/O F! ;

: XKEY  I/O F@ >R  INPUT >HOST  AWAITKEY  R> I/O F! ;

: GETTXT        \ addr ---  | get text until cr or terminal ix
  BEGIN   AWAITKEY  DUP  CTL M =  IF DROP  0  THEN
      DUP  WHILE  ( DUP LEMIT)  OVER C!  1+  REPEAT
  2DROP ;

\ import files from pc                    (  6 10 94 CRC 15:27 )
: GETFILENAME   \ get file name from host into file
  FILING  FILE  40 ERASE  FILE  GETTXT  FILE CT->0 LOWER ;

: RECEIVE
  FILING HANDLE F@ IF ABORT"  File Open " THEN
  INPUT >HOST
  GETFILENAME FILE (CRF)
  DUP 0< IF  .FILEERR  THEN  HANDLE F!
  ASCII A XEMIT
  BEGIN  ?KEY  UNTIL
  BEGIN  ?KEY  WHILE
     (KEY) PAD C!  PAD 1 HANDLE F@ WTF
     1-  IF  ABORT"  file write problem on output! " THEN
  REPEAT  CLF ;

\ import files from pc                    ( 19 10 94 CRC 22:39 )
: NOSHIPFILE  ASCII Q XEMIT  ." not shipping: "
  FILING  FILE CT->0  TYPE  5 SPACES ;

: GETDATA       \ -- fl | get data on file from host
  HEX                                           ASCII L XEMIT
  GETFILENAME                                   ASCII M XEMIT
  PAD GETTXT  PAD 1- NUMBER  DROP  LEN    F!    ASCII N XEMIT
  PAD GETTXT  PAD 1- NUMBER  DROP  TIME F!      ASCII O XEMIT
  PAD GETTXT  PAD 1- NUMBER  DROP  DATE F!      ASCII P XEMIT
  PAD GETTXT  PAD 1- NUMBER  DROP  isdir F!     ASCII Q XEMIT
  FILING FILE  SFIRST  0=
    IF 18 DTA + W@   DATE F@      = 0=
       16 DTA + W@   TIME F@      = 0= OR
       1A DTA + F@   LEN    F@    = 0= OR
    ELSE 1 THEN ;
\ import files from pc                    ( 22 10 94 CRC 13:52 )
0 VARIABLE SPINCH

CREATE SPINNERS  ASCII | C,  ASCII / C,  ASCII - C,  ASCII \ C,

: SPIN  \ --- | make things lively on screen
  SPINCH F@  1+ 3 AND  DUP SPINCH F!
  SPINNERS + C@  LEFT  (EMIT) ;

: DESPIN  CURSOR LEFT BL (EMIT) ;

CODE WMOD  \ n d --- m | 32bit / 16bit --> 16bit modulus
  S [+ DR1 MOV,  S [ DR0 MOV,  DR1 DR0 DIVU,  DR0 .W CLR,
  DR0 .W SWAP,  DR0 S [ MOV,  NEXT  ;C


\ import files from pc                    ( 29 12 95 CRC 12:14 )
: SHIPFILE  ASCII S XEMIT ;

 80 CONSTANT BUFSIZE            BUFSIZE MINUS CONSTANT -BUFSIZE
CREATE INBUF BUFSIZE ALLOT

: GETBUF        \ n --- | get n chars into buf,
  ?STACK   0 DO AWAITKEY  DUP CHECKSUM +!
         I INBUF +  C!   LOOP ;

: WTBUF         \ n --- | send n bytes from buffer to file
  FILING  INBUF OVER HANDLE F@ WTF
  - IF  ABORT"  file write problem on output! " THEN
  SPIN ;


\ import files from pc                    (  7  4 95 CRC 13:24 )
LENGTH F@  10 LENGTH F!
: GETFL         \  ---  | get file from host
  SHIPFILE  CHECKSUM OFF
  FILING  AWAITKEY  ASCII A = IF  FILE CT->0 TYPE  DISPLAY
      ABORT"  File failure on host! " THEN
  FILING  INPUT >HOST  NO.CURSOR
  FILE (CRF)   FILE CT->0  TYPE
  DUP 0< IF  ASCII O XEMIT  .FILEERR  THEN  HANDLE F!
  BASE F@ DECIMAL  COL  LEN F@ 0B ,.R  2 SPACES  BASE F!
  LEN F@  -DUP IF  -1 SWAP DO
         I BUFSIZE MIN  -DUP IF  DUP GETBUF  WTBUF  THEN
         ascii A xemit  -BUFSIZE +LOOP  THEN       ASCII Q
  PAD GETTXT  PAD 1- NUMBER  DROP  CHECKSUM F@ -
     IF 1- THEN  XEMIT  DESPIN ;
LENGTH F!
\ import files from pc                    (  8  9 95 CRC 18:06 )
CODE  TOUCH   \ hndl  ---  | set time & date of file
  RP DR7 MOV,  S [+ DR3 MOV,            \ save stack, handle
  DATE 2+ *+ S -[ .W MOV,               \ date stored
  TIME 2+ *+ S -[ .W MOV,               \ time stored
  1 # RP -[ .W MOV,                     \ flag
  DR3 RP -[ .W MOV,                     \ handle
  S RP -[ MOV,                          \ buffer addr
  57 # RP -[ .W MOV,  1 # TRAP,         \ do it
  4 # S ADDQ,                           \ drop storage space
  DR7 RP MOV,  NEXT  ;C                 \ restore stack

\ word mask for outgoing characters. Set to ff
' (EMIT) C>N N>L L>S  2- CONSTANT KEYMASK


\ import files from pc                    ( 29 12 95 CRC 12:15 )
: GET    EDITOR FLUSH  ?CR  PWD  ?CR  FILING ?CLF
  FILING HANDLE F@ IF ASCII O XEMIT  ABORT"  File Open " THEN
  INPUT >HOST  VERT     SETDTA  BASE F@ >R  HEX
  BEGIN  AWAITKEY  ASCII K =  UNTIL
  BEGIN  AWAITKEY  ASCII A =
      WHILE  GETDATA  IF  OUT OFF  GETFL
      FILING  HANDLE F@ TOUCH   CLF  \ CHECKSUM ?
      ELSE  NOSHIPFILE  THEN  COL       REPEAT
  INPUT >LOCAL   DISPLAY  R> BASE F!  ;

-C  +BLK LOADER GETTER          40 VARIABLE ABIDE
: SLTYPE -DUP \ addr ct --  | send out slowly
  IF BOUNDS DO I C@ EMIT  ABIDE F@  0 DO PAUSE LOOP
                         LOOP  ELSE DROP  THEN ;

\ file shipping                           (  8  9 95 CRC 18:19 )
CREATE FILEBUF  filebuf  bufsize dup ALLOT  ASCII Z FILL

: AWAIT \ c ---  | await processing on other end
  [ 40 SECONDS ] LITERAL SETWATCH  XKEY  2DUP  -
  IF  OK DISPLAY  HEX . . FILING HANDLE F@ IF  CLF  THEN
    ABORT" serial failure! "   ELSE  2DROP  THEN ;

: SEND FILEBUF SWAP 2DUP TYPE   \ ct --- | ship 'em out
  -DUP IF BOUNDS  DO I C@ CHECKSUM +!  LOOP ELSE DROP THEN
  ?TERMINAL IF  DISPLAY OK  FILING CLF  ABORT  THEN
  ascii A await  ;
\ >local  checksum 2@ 5 d.r space  >host ;

: PASS          \ --- ct | read & ship a buffer's worth.
  FILEBUF BUFsize FILING HANDLE F@ RDF  DUP  SEND ;
\ file shipping                           (  9  9 95 CRC 11:50 )
13 constant showsize
: SHOWOFF  out f@ >r  I/O F@  OUTPUT >LOCAL  SWAP
  showsize ,.R  showsize 0 DO LEFT LOOP  I/O F!  r> out f! ;

: (SHIP)        \ ---  | ship an entire file
  CHECKSUM OFF  PURGE  OUTPUT >HOST   len f@ if
  BEGIN  LEN F@  SHOWOFF  [ BUFSIZE MINUS ] LITERAL LEN +!
         PASS  BUFSIZE - UNTIL  then  FILING Clf ;

\ : XTYPE>0 BEGIN  DUP C@  -DUP WHILE  XEMIT 1+  REPEAT  DROP ;
HEX
: SENDONE:
  FILING OPF:  .FILENAME  OUTPUT >HOST .FILENAME  CTL M XEMIT
  ASCII A AWAIT  (SHIP)  ;

\ file shipping                           (  7  1 96 CRC 13:26 )
: SENDENTRY     FILING  OUTPUT >HOST  OUT F@
  BASE F@ HEX >R  ASCII A XEMIT          ASCII L AWAIT \ another
  .ENTRYNAME      CTL M XEMIT            ASCII M AWAIT \ name
  1A +DTA F@  DUP U. CTL M XEMIT LEN F!  ASCII N AWAIT \ len
  16 +DTA W@  U.  CTL M XEMIT            ASCII O AWAIT \ time
  18 +DTA W@  U.  CTL M XEMIT            ASCII P AWAIT \ date
  15 +DTA c@  U.  CTL M XEMIT            ASCII Q AWAIT \ attribs
  40 SECONDS SETWATCH  XKEY  ASCII S = IF  OUTPUT >LOCAL  OUT F!
    .ENTRYNAME 10 TAB   OUTPUT >HOST  OUT F@
    1E +DTA (OPF) DUP 0< 0= IF  HANDLE F!  ASCII O XEMIT
        DECIMAL  (SHIP)  HEX  CHECKSUM F@ U.  CTL M EMIT
        ASCII Q AWAIT   OUTPUT >LOCAL  OUT F!
        SHOWSIZE SPACES  COL  OUTPUT >HOST  OUT F@
    ELSE  ASCII A EMIT  HEX . ABORT" File Opening Error! " THEN
  THEN  R> BASE F!  OUTPUT >LOCAL  OUT F! ;
\ file shipping                           ( 24  8 95 CRC 17:44 )
: SHIP: \  ---  | send all files
  FILING HANDLE F@ IF  ABORT" File Already Open! " THEN   ?CR
  pwd cr
  'TYPE F@ >R  ' SLTYPE  'TYPE F!  KEYMASK W@ >R  FF KEYMASK W!
  VERT  'EMIT F@ >R  PURGE   ASCII K XEMIT
  BLK F@ -DUP IF BLOCK ELSE  TIB F@  THEN
  IN F@ + C@ IF BL WORD HERE COUNT OVER + 0 SWAP !
        ELSE DMY THEN
  SFIRST 0= IF  no.cursor  BEGIN  SENDENTRY  SNEXT UNTIL
        cursor  THEN
  ASCII D XEMIT  R> 'EMIT F!  DISPLAY
  R> KEYMASK W!  R> 'TYPE F!  ?cr ;

1 +BLK LOADER SHIPPER
: XTEST  SCR @ BLOCK  OUTPUT >HOST B/BUF SLTYPE  OUTPUT >LOCAL ;
\ file shipping: routine                  (  4  2 95 crc 10:53 )
editor flush  setup             filing setdrive: c
filing setdir: \crc\bwave\down
ship: nwcspdx*.*                ship: lvractn.*
ship: guntalk*.*                ship: odsbbs*.*
filing setdir: \crc\telix
ship: *.log                     ship: *.slt
ship: telix*.*                  ship: slearn*.*
filing setdir: \crc\bwave
ship: *.bw                      ship: *.job
ship: *.txt
filing setdir: \crc             ship: inis.zip \ ship: csrc.zip
filing setdir: \c700\source\samples
ship: *.c       ship: *.mak     ship: *.h       ship: *.sts
ship: *.bat
-->
\ file shipping: routine                  ( 26  3 95 crc 10:38 )
filing setdir: \c700\source\txtfltrs
ship: *.c       ship: *.mak     ship: *.h       ship: *.sts
ship: *.bat    setdir: \gemul8r3                ship: *.zip
filing setdir: \crc\checking\wamutual           ship: *.*
filing setdir: \msoffice\winword\pmassist       ship: *.doc
filing setdir: \msoffice\winword\template       ship: *.dot
filing setdir: \msoffice\winword\crc            ship: *.*
filing setdir: \msoffice\winword\quotefil       ship: *.*
filing setdir: \crc\fd                          ship: *.*
\      setdir: \        ship: autoexec.bat     ship: config.sys
filing setdir: \crc\bwave\down                  ship: *.zip
setdir: \fxwkspro                       ship: fx_phbk*.*
setdir: \fxwkspro\receive               ship: *.*
setdir: \fxwkspro\keeps                 ship: *.*
filing setdir: \crc\rf                          ship: *.*
this is screen 718 of ff.scr.















this is screen 719 of ff.scr.















