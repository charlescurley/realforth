**********************  fig-FORTH  MODEL  **********************
*                                                              *
*                    Through the courtesy of                   *
*                                                              *
*                     FORTH INTEREST GROUP                     *
*                        P. O. BOX 1105                        *
*                    SAN CARLOS, CA. 94070                     *
*                                                              *
*                          RELEASE 1                           *
*                    WITH COMPILER SECURITY                    *
*                                                              *
*                    VARIABLE LENGTH NAMES                     *
*                                                              *
*               Distributed by Charles Curley for              *
*                  IBM PC computers and clones                 *
*****  Further distribution must include the above notice. *****
     ERROR MESSAGES                         06 12 84 CRC
 Empty Stack
 Dictionary Full
 Has Wrong Addressing Mode
 Isn't Unique
 Branch out of Range
 Disk Range ?
 Full Stack
 Disk Error !!!
Bytes (hex) Dictionary space available.
 Not a user variable
  This can't happen!! msg 11
  This can't happen!! msg 12
  This can't happen!! msg 13
     ?? Not in dictionary ??
real-FORTH on MS-DOS               (c) 1981-98 by Charles Curley
     ERROR MESSAGES                       (  2 10 90 crc 13:13 )
 Compilation Only, Use in definitions
 Execution only
 Conditionals not paired
 Definitions not finished
 In protected dictionary
 Use only when loading
 Off Current Screen
 Declare Vocabulary
  This can't happen!! msg 25
 Centronics Interface Printer Failure!!
  This can't happen!! msg 27
  This can't happen!! msg 28
  This can't happen!! msg 29
  This can't happen!! msg 30
'exit' to return to real-Forth.
( LOAD SCREEN -- serial -- Pre-compiled   ( 26  5 92 crc 11:17 )
( ."  Please do a  9 LOAD  first!!" ABORT for new users        )
' RHANDLE DROP   ( ensure we're on the host!)
DECIMAL      338 CONSTANT UTILITIES     UTILITIES BRING
  CR R# @ ABS B/BUF MIN R# !    CACHE           FORTH
  ' (ERL) CFA 'ERL !    ' (BOT) CFA 'BOT !      VMODE.SET
  ' P?T  CFA '?TERMINAL !       2827 ATTRIBUTE !        DOK OK
  ' TASK NFA FENCE !    HEX 0F MESSAGE  CLR.EOP
  ' NEWCREATE CFA 'CREATE !     PAD C/L 1+ BLANKS       ?CR
  ' (PQUIT) CFA  'QUIT !        DECIMAL   502 LOAD  ?DICT
  EDITOR        ' (Q) CFA 'Q !  ' LNED CFA 'EXPECT !
  ENDER OFF     PLACEF OFF      LNCTR OFF       CLEAR$S
  BLK @ BLOCK 42 +  EDITOR (STAMP)  22 CMOVE
  SCR @ ABS MAXBLK MIN SCR !    HOMESEG
  expecting makestrs forth      here first over - erase
  TODAY ( CTL G EMIT)   ?CR EDITOR   \  TKEY
\ verify ram disk                         (  8  1 87 crc       )
5 NEEDED RAMDISK   RAMDISK
: WRITE  DUP BLOCK ! UPDATE ;

: WRITES  BOUNDS DO I 5 .R  I WRITE LOOP  ?CR ;

: CHECK  DUP BLOCK @  2DUP - IF  6 .R  4 .R  ELSE 2DROP THEN ;

: CHECKS  BOUNDS DO I CHECK LOOP ;

: VERIFY  2DUP  WRITES CHECKS ;
EDITOR FLUSH




\ Pseudo-disk for MS-DOS                  ( 11  4 90 crc 15:19 )
FORGET TASK   BASE @ >R           ' (R/W) CFA 'R/W !
( : TASK ; ) DECIMAL 292 NEEDED CMOVEL  102 NEEDED ABORT"  HEX
B/BUF 10 / CONSTANT SEG/BUF     MAXBLK CONSTANT RMAX
            \         fl : 0 = sucessful
CODE (?RAM) \  --- s# fl | return highest seg# available
  CS PUSH,  ES POP,           \ es isn't guaranteed!
  ' NEXTSEG #) BX MOV,        \ here's what we're using
  4A # AH MOV,  21 INT,       \ release what we aren't using
  -1 # BX MOV,  4A # AH MOV,  \ ask for max ram
  21 INT,  BX PUSH,           \ put result on stack
  4A # AH MOV,  21 INT,       \ get it back again
  NEXT

BLK @ DUP 1+ SWAP 3+ THRU   R> BASE !
: TASK ;  EDITOR FLUSH
\     glue code for mess-dos              ( 11  4 90 crc 15:19 )
(?RAM)  FORGET (?RAM)  NEXTSEG @ -  SEGMENT 0BLKSEG
0 CONSTANT MAXPSB       HERE FIRST OVER - ERASE

: BLKSEG  \ blk# -- seg# | turn a block number into a seg
  SEG/BUF *  0BLKSEG +  ;

: READRAM  \ addr blk#  --  | read from ram disk
  BLKSEG  0  ROT  CS@ SWAP  B/BUF CMOVEL ;

: WRITERAM \ addr blk#  --  | write to ramdisk
  BLKSEG  CS@ -ROT  0  B/BUF CMOVEL ;




\     glue code for mess-dos              ( 11  4 90 crc 15:21 )
: MAXRAMBLK   \ --  | calculate maximum ram blk
  NEXTSEG @ 0BLKSEG - 0 SEG/BUF U/ NIP 1-
  DUP  4 .R  ."  Blocks in the ramdisk. "
  DUP [ ' MAXPSB ] LITERAL !
  1+ MAXBLK + [ ' RMAX ] LITERAL ! ;

: CLEANRAM   ." Clear out ramdisk? y/n? "
  KEY DUP EMIT  BL OR ASCII y =
  IF  PAD B/BUF BLANKS  PAD OFF  MAXPSB
     ?CR 0 DO  PAD I WRITERAM  LOOP  THEN ;

DECIMAL  MAXRAMBLK       CLEANRAM  FORGET MAXRAMBLK

: OLDDISK [ ' (R/W) CFA ] LITERAL 'R/W ! ;

\ Pseudo-disk for MS-DOS                  (  7  2 90 crc 10:04 )
\  blk#  ---  blk# | disk moving words:
: BACKUP   CR \ read disk(s) into pseudo disk
  DUP EMPTY-BUFFERS FLUSH RMAX 1+ MAXBLK 1+ DO  I OVER
  BLOCK 2- ! UPDATE DUP 5 .R 1+ LOOP DROP EDITOR FLUSH ;

: BACKDOWN CR \  blk#  ---   | write a pseudo disk to disk(s)
  MAXPSB 0 DO DUP I +  DUP 5 .R  I MAXBLK 1+ + BLOCK 2- !
  UPDATE  LOOP DROP EDITOR FLUSH ;

: NR/W  >R  DUP MAXBLK 1+ < IF R> (R/W) ELSE
  DUP RMAX > 6 ?ERROR  MAXBLK 1+ -
  R> IF READRAM ELSE WRITERAM THEN  THEN ;

: RAMDISK [ ' NR/W  CFA ] LITERAL 'R/W ! ;

( LOAD SCREEN -- serial -- Recompiling    ( 24  7 88 crc  8:02 )
DECIMAL  338 CONSTANT UTILITIES     27 CONSTANT LI
HEX : \ ?LOADING  IN @ C/L + -40 AND  IN ! ; IMMEDIATE  : | ;
   1 CONSTANT DEBUGGING         1 CONSTANT AT
   : THRU  1+ SWAP DO I LOAD LOOP ; DECIMAL 56 LOAD
    24 LOAD 270 LOAD ( assem)  62 LOAD  18 LOAD 20 LOAD
   292 LOAD  25 LOAD CR  22 LOAD   132 LOAD \ time stuff
   27 LOAD  128 LOAD ( newcreate ) 366 load \ 525 LOAD
   SCR @ BLK @ LIST SCR ! C/L LOAD  17 LOAD \ i/o vectors
   58 LOAD    61 LOAD ( utilities ) 63 LOAD   291 LOAD \ @L
: ?DICT  BASE @ FIRST HERE - HEX U.  9 MESSAGE BASE ! SPACE ;
   300 LOAD 121 LOAD  50 LOAD   HERE FENCE ! ?CR 15 MESSAGE ?CR
   495 LOAD  191 LOAD   96 LOAD   260 LOAD  DOK  570 LOAD
   104 LOAD   21 LOAD   HERE 1024 BLANKS  ?CR ?DICT CR
 SCR @ ABS MAXBLK MIN SCR ! UTILITIES SAVEOVER LI PAD C/L BLANKS

\ editor help screen                      ( 20 12 90 crc  9:18 )
f1 - blanks left        f2 - merge        f3 - blanks right
f4 - upper case left    f5 - upper right  f6 - undo screen
f7 - place date                           f9 - home cusor
ctl a - back up by len in pad   ctl d - delete current line
ctl e - erase current line      ctl j - insert contents of pad
ctl r - replace current line    ctl s - add a line at cursor
ctl z - hold current line       ctl c - del by length at pad
ctl k - stamp screen            ctl u - next line
ctl b - back up a screen        ctl n - forward a screen
ctl q - push a $ from scr       ctl l - copy to $ stack
ctl w - insert from $ stack     ctl p - overwrite to scr from $s
ctl y - clear $ stack           ctl o - "other" screen
Backsp - del to left of cursor  Delete - del to right of cursor
F1 - help screen                Insert - toggle placing mode
               <<Any key returns to editor!>>
\ q & d checksum routine                  (  7  4 86 CRC 16:00 )
CODE (CHECK) \ addr ct --- w | calculate checksum
 CX POP,  BX POP,   DX DX SUB,  AH AH SUB,
 DO,  0 [BX] AL MOV,  AX DX ADD,  BX INC,  LOOP,  DX PUSH,  NEXT

: CHECKDICT   0 +ORIGIN HERE OVER - (CHECK) . ;

: CHECKSCR    SCR @ BLOCK B/BUF     (CHECK) . ;

?CR ." Use a user variable to store the checksum!" CR
editor flush





( boot screen for debugging 9 load        (  5  4 90 crc  8:20 )
: (create)  (create) latest id. ;
' (create) cfa 'create !

( : :  [compile] :  compile cr
  latest [compile] literal compile id. ;
immediate                                   )

: load  base @ decimal  cr over  6 .r space  base !  load ;

9 load





\ Multiuser hooks: very dangerous!        ( 18 10 86 CRC 12:33 )
0 USER MOI   MOI ON               4 USER MYLINK
BASE @ HEX                       60 USER TEMPUS
CODE WAIT \  ct ---  | wait ct 200 hz cycles - atari specific
  S [+ DR0 MOV,  4BA @# DR0 ADD,  DR0 OFUSER TEMPUS MOV,
  BEGIN,  ' PAUSE 1A - @#L JSR,
    OFUSER TEMPUS DR0 MOV,  4BA @# DR0 CMP,  MI UNTIL,  NEXT

CODE SAFELINK{ \ save current link on return stack & delink
  OFUSER MYLINK RP -[ MOV,  U OFUSER MYLINK MOV,  NEXT
CODE }RELINK    \ restore link from return stack
  RP [+ OFUSER MYLINK MOV,  NEXT              BASE !
;S   These words are used to send text to the terminal where
output may not be interrupted by other tasks' output. The word
SAFELINK{  saves the current link of the current task on the
return stack, and  }RELINK  restores it from there.
\ screen object editor -- byte patcher    ( 12  2 86 CRC 20:51 )
: SEE \  start count --- | dump relative to current screen
  SCR @ BLOCK FUDGE ! DUMP ;
: VIEW \ start end  --- | like index - 1st line dumped
  ?CR 1+ SWAP DO I DUP 4 .R SCR ! 0 C/L SEE
  ?TERMINAL IF LEAVE THEN LOOP ;
: T!  FUDGE @ +  ! UPDATE ;
: TC! FUDGE @ + C! UPDATE ;
: TFILL ROT FUDGE @ + -ROT FILL UPDATE ;
: TDIS   FUDGE @ + DISASSEM ;
: NON0  BLOCK 0 B/BUF BOUNDS DO DUP I + C@ IF I 5 .R THEN
   LOOP DROP ;
: NON0S  1+ SWAP DO ?CR I 10 .R I NON0
  ?TERMINAL IF LEAVE THEN LOOP ;
editor flush

\ 132 col printer test                    ( 23 11 92 crc 13:49 )
debug forth definitions forget task     printer 0 lefts
debug forth definitions : task ;                base @ hex
: .132  cr 84 0 do dup emit 1+
  dup  7f = if drop bl  then    loop  drop ;

: rows   bl  swap 0 do  dup .132  1+
  dup  7f = if drop bl  then
  ?terminal if leave then  loop  drop ;

base ! editor flush





















\ Vectoring words: vtok print output>     ( 10  2 19 crc 19:21 )
  BASE @ HEX   FORTH  DEFINITIONS
: OUTPUT> R>   'EMIT 0C CMOVE ;
                \ emit   type   gotoxy page    list   cr
: (OK)  [ ' (emit) cfa ] literal isemit !
        OUTPUT> (EMIT)  (TYPE)  (GOTO) IPAGE   NLIST  (CR) STOP

: PRINT PRINTER
        OUTPUT> (PNT)   (TYPE)  2DROP  PPAGE   NLIST  PCR  STOP

6A USER 'OK             ' (OK) CFA  'OK !

: OK 'OK  @EXECUTE STOP         BASE !



\   SPINWRITER controls                   ( 10  2 19 crc 19:21 )
  BASE @ HEX   FORTH  DEFINITIONS        \ See the RF manual
' (EMIT)    CFA variable isemit
: ?CRT    'EMIT @  isemit @  = ;

: VTAB  ( line count-1 VTAB)
    -DUP IF  CTL J                         \ version for printer
  \ -DUP IF  ?CRT IF CLT J ELSE CTL M THEN \ version for lsi 11
     SWAP  0 DO DUP EMIT LOOP DROP THEN ; \ w/o line feeds

\ : MON   ." Are you sure? "
\   KEY DUP EMIT ASCII _ AND ASCII Y =  IF MON THEN
\   QUIT STOP

: BYE  MON STOP
BASE !
















\   SPINWRITER    list                    ( 12  2 86 CRC 14:43 )
  BASE @ HEX   FORTH  DEFINITIONS
: ?CR  OUT @ IF CR THEN ;

: NLIST   BASE @  SWAP  DECIMAL     \ See the RF manual
  CR  DUP  SCR ! 1E  ?CRT 0= LI * + SPACES
  .SCR 10 SCR @ BLOCK @  IF
  0 DO  CR I 3 .R  SPACE I SCR @ .LINE
  ( ?TERMINAL IF LEAVE ENDIF ) LOOP ELSE
  VTAB  THEN  CR BASE ! ;          ' NLIST CFA 'LIST !

: L SCR @ LIST ;        \ micro source listing facility
: N SCR 1+! L ;         \ next screen
: B SCR @ 1- LIST ;     \ back a screen
\ : O SCR @ SWAP LIST ;   \ other screen, on top of stack
  BASE !
\ dx nx cx                                (  3  8 90 crc 12:50 )
FORGET TASK                BASE @ DECIMAL
: DX  \  scr# ---  | show 60 line 0s from scr#
  DUP 60 + OVER  PAGE   DO  I OVER -  20 /MOD  26 * GOTOXY
     I 5 .R  I BLOCK @ IF  SPACE  I BLOCK 20 -TRAILING TYPE
       ELSE  I BLOCK 2+ @ 8224 -  IF  ."  Binary"  THEN THEN
     ?TERMINAL IF LEAVE THEN  LOOP  DROP  20 1 GOTOXY ;

: CX  \   ---   | dx for current volume
  SCR @  60 /  60 *  DX ;
: NX  \   ---   | dx the next volume
  SCR @  60 /  1+         60 *  SCR !  CX ;
: BX  \   ---   | dx the last volume
  SCR @  60 /  1-  0 MAX  60 *  SCR !  CX ;
                BASE !
: TASK ;
\ <cmove, segment support code            ( 28  6 92 crc  8:26 )
CODE CS@  CS PUSH,  NEXT

CODE <CMOVE   \ fr-3  to-2  cnt-1  ---   | See the RF manual
  STD,  IP BX MOV,  CS PUSH,  ES POP,  CX POP,
  CX DEC,  DI POP,  IP POP,  CX DI ADD,  CX IP ADD,  CX INC,
  REP,  .B MOVS,  BX IP MOV,  CLD,  NEXT
BASE @ HEX
0 VARIABLE NEXTSEG      \ total sizes of segs we're using
0 VARIABLE SEG-LINK     \ make them into a linked list
\ define a segment of size on the stack. Coded this way to be
\ relocatable under mess-dos.  pfa: | link | seg  | size |
: SEGMENT  <BUILDS  HERE  SEG-LINK @ ,  SEG-LINK !
  NEXTSEG @ ,  DUP ,  NEXTSEG +!  ;CODE
  CS AX MOV,  4 [BX] AX ADD,  1PUSH     1000 SEGMENT CODESEG
BASE !
\ Documenting                             ( 14  8 87 CRC 20:26 )
FORTH DEFINITIONS DECIMAL           TODAY FORGET TASK : TASK ;
VOCABULARY DOCUMENTING IMMEDIATE  DOCUMENTING DEFINITIONS
0 VARIABLE W C/L 2- ALLOT   HEX \ See the RF manual
: ?PAGE ?CRT 0= IF  \ page iff not crt and not top of form
  LNCTR @ IF  PAGE  THEN  THEN ;
: TRIAD  3 / 3 * 3 BOUNDS 2DUP DO I BLOCK @ LOOP OR OR \ rf
  IF ?PAGE DO I LIST ?TERMINAL IF LEAVE THEN  LOOP
  CR 4 SPACES W C/L TYPE CR 4 SPACES TODAY ELSE 2DROP THEN ;
: SHOW   3 / 1+ 3 * SWAP DO I TRIAD ?TERMINAL    \ See RF man
  IF LEAVE THEN 3 +LOOP ;
: INDEX   1+ SWAP DO I 3C MOD 0= IF ?PAGE THEN   \ See RF man
  CR I DUP 4 .R SPACE BLOCK @ IF 0 I .LINE ELSE I BLOCK 2+ @
  2020 - IF ." binary" THEN THEN ?TERMINAL IF LEAVE THEN
  LOOP CR ;  DECIMAL 181 182 THRU  DECIMAL
  67 68 THRU  170 LOAD DOCUMENTING DECIMAL PRESENT TODAY
\  case statement  -- Eaker case from f.d.( 29  5 86 CRC 14:42 )
: CASE   ?COMP CSP @ !CSP 4 ;  IMMEDIATE

: OF  4 ?PAIRS  COMPILE (OF) HERE 0 ,  5 ;   IMMEDIATE

: ENDOF  5 ?PAIRS  COMPILE BRANCH  HERE 0 ,
  SWAP  2 [COMPILE] THEN  4  ;   IMMEDIATE

: ENDCASE   4 ?PAIRS  COMPILE DROP
  BEGIN SP@ CSP @ - WHILE 2 [COMPILE] THEN REPEAT CSP ! ;
            IMMEDIATE          ;S

Case statement from Forth Dimensions. See the real-FORTH User's
Guide.


\ Terminal specific io stuff here - IBM   (  9 12 91 crc 10:16 )
HEX B000 VARIABLE VIDEO-SEG     0 VARIABLE VCTLR
3C USER ATTRIBUTE   B0B ATTRIBUTE !     DECIMAL 92 LOAD HEX
CODE (ERL)
  40 # AX MOV,  AX ES MOV,  50 # CX MOV,  \ where the cursor is
  ES: 51 #) AL MOV,  A0 # BX MOV,  BL MUL,  \ get row offset
  ES: 50 #) BL MOV,  BL CX SUB,             \ get count to cx
  BX SHL,  AX BX ADD,  BX DI MOV,           \ add col to offset
  VIDEO-SEG #) ES MOV,                      \ destination seg
  UP #) BX MOV,  OFUSER ATTRIBUTE AX MOV,   \ screen attribute
  20 # AL MOV,  REP,  AX STOS,  NEXT

CODE XY@   40 # AX MOV,  AX ES MOV,  ES: 51 #) AL MOV,
  AX PUSH,  ES: 50 #) AL MOV,  1PUSH

CODE IPAGE      ( -- ) 2 # AX MOV,  10 INT,  NEXT        -->
\ Terminal specific io stuff here - IBM   (  5  1 88 crc       )
CODE (GOTO)  DX POP,  AX POP,  AL DH MOV,
  BH BH XOR,  2 # AH MOV,  10 INT,   NEXT

: GOTOXY  'GOTOXY @EXECUTE STOP  ' (GOTO) CFA 'GOTOXY !

: CLR.EOP   XY@  (ERL)  >R  19 OVER 1+
  DO  I 0 GOTOXY (ERL) LOOP  R> GOTOXY ;

: (BOT)  13 0 GOTOXY  CLR.EOP  OUT OFF ;

6E USER 'BOT           : BOTTOM  'BOT  @EXECUTE STOP
6C USER 'ERL           : ERL     'ERL  @EXECUTE STOP

' (ERL) CFA 'ERL !  ' (BOT) CFA 'BOT !   DECIMAL \ See RF manual

\ reworked editor: load screen            (  9  7 88 crc 12:32 )
FORTH  DEFINITIONS  BASE @ >R  DECIMAL
\ FORGET TASK                     : TASK ;
\ FORTH DEFINITIONS   DECIMAL      EDITOR FLUSH   FORTH

1 BLK @ + 21 BLK @ + THRU

CR  R> BASE !
EDITOR FLUSH







\ orgn .pad text line                     (  7  9 87 CRC 22:56 )
FORTH  DEFINITIONS   HEX
: ORGN 0 0 GOTOXY  ;

: .PAD   ORGN ." pad" SPACE PAD 1+ C/L TYPE  erl ;
                \ Accept following text to pad
: TEXT  HERE C/L 1+ BLANKS WORD HERE PAD C/L 1+ CMOVE .PAD ;
                \ Relative to scr, leave addr of line
: LINE  DUP -10 AND 17 ?ERROR SCR @ (LINE) DROP ;

R#  @ B/BUF MIN R# ! \ It may have an old value worth preserving





\ 3+ editor sp$ image range$ top$         ( 13  4 90 crc  8:13 )
: 3+  3 + ;

VOCABULARY EDITOR  IMMEDIATE     EDITOR    DEFINITIONS
66 USER 'Q                      86 USER SP$

800 SEGMENT SEG$

: IMAGE  [ PAD C/L + 1+  HERE - ] LITERAL HERE + ;

: (TOP$)    SEG$  SP$ @ ;

: RANGE$  SP$ @ 0< IF  7FC0 SP$ ! THEN ;

: TOP$   RANGE$  (TOP$)  ;

\ add$ drop$ .top clr$s clear$ clr$s att  (  7  8 90 crc 16:11 )
: ADD$  \ addr ---  | add $ at addr to the $stack
  -40 SP$ +!  CS@ OVER TOP$ C/L CMOVEL  IMAGE C/L CMOVE ;

: DROP$ \ addr ---  | remove $ at top to addr
  IMAGE SWAP C/L CMOVE  C/L SP$ +!  TOP$ CS@ IMAGE C/L CMOVEL ;

: .TOP  1 0 GOTOXY  ." top " IMAGE C/L TYPE ERL ;

: CLEAR$S    SP$ OFF  IMAGE C/L ascii t fill  IMAGE ADD$ ;
  CLEAR$S

: CLR$S    CLEAR$S .TOP ;

: ATT      ATTRIBUTE 10 TOGGLE ;

\ where #locate, etc. -move               ( 24  7 88 crc  9:04 )
FORTH DEFINITIONS
: WHERE  WARNING ON     \ Print screen # and image of error
  DUP DUP SCR ! ." Base = " BASE @ DECIMAL . .SCR
  SWAP DUP R# ! C/L /MOD C/L * ROT BLOCK + CR C/L -TRAILING
  TYPE CR  SPACES ASCII ^ EMIT [COMPILE] EDITOR QUIT
STOP           EDITOR    DEFINITIONS
: #LOCATE       \ Leave cursor offset-2, line -1
  R#  @  C/L  /MOD  ;
: #LEAD         \ Line address -2, offset-1
  #LOCATE  LINE  SWAP  ;
: #LAG          \ Cursor addr-2, count-1 after cursor
  #LEAD  DUP  >R  +  C/L  R>  -  ;
: -MOVE         \ Move in block buffer addr from-2, line-1
   LINE  C/L  CMOVE  UPDATE  ;
:  #LOC  #LOCATE NIP ;     \ return line # only
\ cursor h e s (d) d                      (  8  8 90 crc  9:59 )
: CURSOR     #LOCATE   3+ 4 ROT + GOTOXY  ;

: H     \ l --- | Hold numbered line at pad
  LINE PAD 1+ C/L DUP PAD C! CMOVE .PAD ;

: E   LINE  C/L  BLANKS UPDATE ;   \ erase line-1 with blanks

: S  DUP  1-  ( limit ) 0E \ first to move      \ spread making
   DO  I  LINE I  1+  -MOVE -1 +LOOP E ;        \ line-1 blank

: (D)  DUP 0F < IF  0F DUP ROT
   DO I 1+ LINE I -MOVE LOOP THEN E ;

: D  DUP H (D) ;

\ rstr t l o r p                          (  7  8 90 crc 16:12 )
: RSTR #LOC DUP 3+ 4 GOTOXY SCR @ .LINE ERL ;

\ : T   0F AND  DUP C/L * R# !  H ; \ Type line, save in pad

: L \ GET-CURSOR  NO.CURSOR       \ relist screen
  ATT   13 2  DO  FORTH I 0 GOTOXY  ERL  LOOP
  1 0 GOTOXY  SCR @ LIST ( SET-CURSOR )  ATT  ;

: O  SCR @ SWAP SCR ! L ;

: R                     \ replace on line #-1, from pad *
  PAD 1+ SWAP -MOVE ;

\ : P  1 TEXT R ;         \ put following text on line-1 *

\ i top pl lupp rupp placef               (  8  8 90 crc  9:40 )
: I  DUP  S  R   ;      \ insert text from pad onto line # *

: TOP  R# OFF ;         \ home cursor to top left of screen *

: PL    \ line#-1    PL    Partial list of rest of screen
\ GET-CURSOR  NO.CURSOR SWAP
  #LOCATE SWAP DROP 3+ 0 GOTOXY
  BASE @ DECIMAL  10 ROT DO FORTH I DUP 3 .R
  SPACE SCR @ .LINE ERL CR LOOP  BASE ! CURSOR ( SET-CURSOR) ;

: LUPP   #LEAD UPPER UPDATE RSTR ;

: RUPP   #LAG  UPPER UPDATE RSTR ;

64 USER PLACEF  PLACEF OFF
\ next last m scrend wipe copy undo       (  8  8 90 crc  9:41 )
: NEXT    SCR 1+! L ;
: LAST -1 SCR  +! L ;
              \ move cursor by signed amount.
: M   R# @  +  DUP 0<  IF  B/BUF +  LAST  THEN
  DUP [ B/BUF 1- ] LITERAL  > IF  B/BUF -  NEXT  THEN  R# ! ;

: SCREND   [ B/BUF C/L - ] LITERAL  R# ! ;

: WIPE  \ Clear current screen *
  0 SCR @ BLOCK DUP B/BUF BLANKS ! UPDATE  ;

: COPY  \ duplicate screen-2 onto screen-1 *
   OFFSET @ + SWAP BLOCK  2- ! UPDATE ;

: UNDO   ( this session )  7FFF SCR @ BLOCK 2- ! L ;
\ place delete bksp b                     ( 18  5 92 crc 20:43 )
: PLACE  DUP EMIT  PLACEF @ IF
  #LAG SWAP DUP 1- SWAP ROT <CMOVE THEN #LAG UPDATE DROP C! 1 M
  PLACEF @ IF CURSOR #LAG -TRAILING TYPE ERL THEN ;

: DELETE  -DUP IF         \ backwards at cursor by count-1 *
  >R  #LAG  +  FORTH  R  - \ save blank fill location
  #LAG  R  MINUS  M        \ back up cursor
  #LEAD  +  SWAP  CMOVE
  R> BLANKS UPDATE THEN ;  \ fill from end of text

: BKSP  1 DELETE CURSOR #LAG -TRAILING TYPE ERL ;

: B  PAD  C@  MINUS  M ; \  Back up cursor by text in pad

: EOL   #LEAD SWAP  C/L -TRAILING NIP  SWAP - M ;
\ -citext                                 ( 30  6 95 crc  6:32 )
HEX  \  addr1  count  addr2  --- f
ASSEMBLER HERE >R ( !*!)   DX IP MOV,  CX PUSH,  NEXT
HERE  BL AL CMP,  U> IF,   BH AL CMP,  U< IF,
  20 # AL XOR,  THEN,  THEN,  RET,
CODE -CITEXT \ addr1 len addr2 -- -1|0|1  | string compare
  IP DX MOV,  DI POP,  CX POP,  SI POP,  R ( !*!) JCXZ,
  7B60 # BX MOV,  CS PUSH,  ES POP,
  DO,  AL LODS,  ROT DUP #) CALL,  AL AH XCHG,
    0 [DI] AL MOV, DI INC,  #) CALL,  AL AH CMP,
    0<  IF,   1 # CX MOV,  R ( !*!) #) JMP,  THEN,
    0<> IF,  -1 # CX MOV,  R ( !*!) #) JMP,  THEN,  LOOP,
  R   ( !*!)  #) JMP,           R>      ;S
  flag:  1 means the $ at addr1 is less than the $ at addr2
         0 means the $ at addr1 is  equal to the $ at addr2
        -1 means the $ at addr2 is less than the $ at addr1
\ -cstext                                 ( 30  6 95 crc  6:32 )
>R \ ASSEMBLER HERE >R ( !*!)   DX IP MOV,  CX PUSH,  NEXT
CODE -CSTEXT \ addr1 len addr2 -- -1|0|1  | string compare
  IP DX MOV,  DI POP,  CX POP,  SI POP,  R ( !*!) JCXZ,
  CS PUSH,  ES POP,  REPZ,  .B CMPS,  R ( !*!) JE,
  0< IF,  1 # CX MOV,  R ( !*!) #) JMP,  THEN,  -1 # CX MOV,
  R> ( !*!) #) JMP,
' -CITEXT CFA VARIABLE '-TEXT   \ not multi-tasking!
FORTH DEFINITIONS
        \  addr1  count  addr2  --- f
: -TEXT   EDITOR '-TEXT @EXECUTE  STOP
        \ case sensitive text searches
: CS   EDITOR [ ' -CSTEXT CFA ] LITERAL '-TEXT ! ;
        \ case rude (?) text searches
: CI   EDITOR [ ' -CITEXT CFA ] LITERAL '-TEXT ! ;
EDITOR DEFINITIONS
\ shelp date match bll blr                (  8  8 90 crc 11:10 )
: SHELP  0A O KEY 0= IF KEY DROP THEN O DROP ; \ help key

: DATE   \   --  | install date in current cursor loc.
  (DATE)  0 DO  DUP C@  DUP CURSOR EMIT PLACE  1+  LOOP  DROP ;

: MATCH               \ addr1 count1 addr2 count2  --- f n3
   >R >R   2DUP R> R> 2SWAP BOUNDS         DO
      2DUP FORTH I -TEXT 0= IF >R 2DROP R> - FORTH I SWAP -
         0 SWAP 0 0 LEAVE  THEN LOOP 2DROP SWAP 0= SWAP ;

: BLL
  #LEAD -DUP IF  BLANKS RSTR UPDATE  ELSE  DROP  THEN ;

: BLR
  #LAG  -DUP IF  BLANKS ERL  UPDATE  ELSE  DROP  THEN ;
\ stamp .stamp flush 1line find up dn     (  8  8 90 crc 11:34 )
DECIMAL  BLK @ BLOCK 42 + (STAMP) 22 CMOVE
: STAMP   SETSTAMP (STAMP) SCR @ BLOCK 42 + 22 CMOVE UPDATE ;
: .STAMP  SETSTAMP (STAMP) 22 TYPE ;   HEX

: FLUSH   FIRST #BUFS 0 DO DUP @ 0< IF DUP DUP @ 7FFF AND
  SWAP 2DUP ! 2+ SWAP 0 R/W THEN +BUF DROP LOOP DROP ;

: 1LINE  \ scan line w/ cursor for match to PAD text, update
   #LAG  PAD  COUNT  MATCH  R# +! ;  \ cursor, return boolean

: FIND  \ string at pad over full scr, else err
  BEGIN  3FF R# @ < IF  TOP PAD  HERE C/L 1+ CMOVE
  0 BOTTOM ERROR THEN  1LINE  UNTIL ;

: UP  -40 * M ;                 : DN  C/L * M ;
\ merge documentor day month plc placing  (  2  7 90 crc 12:36 )
: MERGE #LAG -TRAILING 1 UP #LAG DROP SWAP CMOVE UPDATE RSTR ;
DECIMAL
: DOCUMENTOR   <BUILDS C, C, DOES>  >R  BL WORD  FORTH
  HERE 1+ ( from) R C@ DUP HERE C@ MIN - HERE 10 + + ( to)
  HERE C@ R C@ MIN ( count) CMOVE
  HERE 10 + ( from)  (STAMP)    R 1+ C@ + ( to)
  R> C@ ( count) 1+ ( keep separation) CMOVE ;

\   2 2 DOCUMENTOR DAY             5 2 DOCUMENTOR MONTH
(   8 2 DOCUMENTOR YEAR       )   11 3 DOCUMENTOR PROGRAMMER

: PLC  2 0 GOTOXY PLACEF @
  IF ." Inserting" ELSE ." Replacing" THEN ; ?CR  HEX
: PLACING  PLACEF  1 TOGGLE  PLC ;

\ delline erline tab insline other incboth(  7  9 87 CRC 15:47 )
: DELLINE    #LOC DUP D PL ;            \ delete current line

: ERLINE     #LOC E RSTR ;              \ erase current line

: TAB     R# @  8 +  -8 AND  R# @ -     \ next multiple of 8
  PLACEF @ IF  0 DO  CURSOR  BL PLACE  LOOP  ELSE  M  THEN ;
: NL         #LAG M DROP ;              \ beginning of next line
: INSLINE    #LOC DUP I PL ;            \ insert pad's contents

: OTHER      SWAP O SWAP ;              \ other screen

: RLINE      #LOC R RSTR ;      : SLINE    #LOC DUP S PL ;

: INCBOTH    SWAP 1+ SWAP NEXT ;        \ use to step through
: DECBOTH    SWAP 1- SWAP LAST ;        \ shadow screens
\ hline z$ 1up pull$ push$ put$ grab$     (  7  9 87 CRC 23:26 )
: HLINE  #LOC H ;               : Z$  PAD C@ DELETE RSTR ;

: FWD  1 M ;                    : BKWD  -1 M ;

: 1UP  1 UP ;                   : 1DN  1 DN ;

: PULL$     #LOC S  #LEAD DROP DROP$  #LOC PL  .TOP  UPDATE ;

: PUSH$     #LEAD DROP ADD$  #LOC DUP (D) PL  .TOP ;

: GRAB$     #LOC LINE ADD$  .TOP 1DN ;

: PUT$      1UP  #LOC LINE DROP$  .TOP RSTR  UPDATE ;

: >STAMP    STAMP  R# @  R# OFF  CURSOR RSTR  R# ! ;
\ flip doctls                             ( 18  5 92 crc 20:44 )
\ : FLIP   SCR @ BLOCK  R# @ +  80 TOGGLE  RSTR 1 M ;

: DOCTLS  0 MAX CTL ^ MIN EXEC
\       @       a       b       c       d       e       f
        |       B       LAST    Z$      DELLINE ERLINE  BKWD
\       g       h       i       j       k       l       m
        FWD     BKSP    TAB     INSLINE >STAMP  GRAB$   |
\       n       o       p       q       r       s       t
        NEXT    OTHER   PUT$    PUSH$   RLINE   SLINE   1UP
\       u       v       w       x       y       z       [
        nl      1DN     PULL$   FLUSH   CLR$S   HLINE   DECBOTH
\       \       ]       ^
        EOL     INCBOTH |       |       STOP
HEX

\ dofuns                                  ( 15  2 90 crc  9:03 )
: DEL  \  --  | delete to right of cursor w/o moving
  #LAG  >R 1+ DUP 1-  R> 1- CMOVE
  BL #LAG + 1- C!  UPDATE  RSTR ;

: DOFUNS   3A MAX  56 MIN  3A -  EXEC  |
\       f1 3B   f2 3C   f3 3D   f4 3E   f5 3F   f6 40   f7 41
        BLL     MERGE   BLR     LUPP    RUPP    UNDO    DATE
\       f8 42   f9 43   f10 44  45      46      clh 47  up 48
        .PAD    TOP     FLUSH   |       |       TOP     1UP
\       49 pup  4A -    <- 4B   4C      -> 4D   + 4E    end 4F
        LAST    |       BKWD    |       FWD     |       SCREND
\       dn 50   51 pdn  nsrt 52 53      F1 54   F2 55   F3 56
        1DN     NEXT    PLACING DEL     SHELP   undo    |
\       F4 57   F5 58   F6 59   F7 5A   F8 5B   F9 5C   F10 5D
        stop \  |       |       |       |       |       |
\ (q)                                     (  7  8 90 crc 16:12 )
: (Q)                 \ continuous stream editor
  GET-CURSOR >R  BIG-CURSOR  ATT
  BEGIN  PLC CURSOR KEY
    DUP        BL 7E WITHIN  IF         DUP PLACE   ELSE
    DUP                7F =  IF               DEL   ELSE
    DUP  CTL A CTL _ WITHIN  IF         DUP DOCTLS  ELSE
    DUP                  0=  IF         KEY DOFUNS
                        THEN THEN THEN THEN  CTL M = UNTIL
  ATT   PLC BOTTOM  R> SET-CURSOR  ;






\ q z n f till x                          (  2  7 90 crc  9:54 )
' (Q) CFA 'Q !
: Q   'Q @EXECUTE  STOP    \ plan ahead for multiuser some day
: Z   ORGN ERL  .TOP .PAD  ATT  L ATT   Q ;
: N    \ find occurance of text previously specified; in pad
  FIND  Q ;
: F    \ find occurance of following text
  1  TEXT  N ;

: X    \ Delete following text only
  1 TEXT  FIND  PAD C@  DELETE  ATT  RSTR ATT   Q ;

: TILL \ delete on cursor line from cursor to end of given text
  #LEAD + 1 TEXT 1LINE 0= IF BOTTOM 0 ERROR THEN
  #LEAD + SWAP - DELETE  ATT  RSTR ATT   Q ;

\ search research cont edit ender         ( 21  4 19 crc 22:26 )
HEX 68 USER ENDER    ENDER OFF       DECIMAL
: RESEARCH    \ from-2  to-1   ---  wanted string
  DUP ENDER !  BOTTOM 1+ SWAP DO FORTH I SCR ! EDITOR TOP
    forth i editor  block @ if  \ Don't search binary scrs
      BEGIN 1LINE DUP ?TERMINAL OR IF LEAVE THEN
      1023 R# @ < OR UNTIL  then  ." ." LOOP Z ;
: SEARCH  DUP ENDER ! 1 TEXT RESEARCH ;  \ from-2  to-1   ---

: CONT  SCR @ 1+ ENDER @ RESEARCH ;

: ALL  0 MAXBLK  ;    \ convenient for disk searches
FORTH DEFINITIONS
: EDIT SCR ! EDITOR  Z FORTH  [COMPILE]  EDITOR ;
   ?CR  ." Editor loaded. "     ;S
   Typical use to locate 'KEY-WORD' :  21 44 SEARCH KEY-WORD
\ some utilities: 8* 8/ xtend w* uw*      (  7  4 86 CRC 12:23 )
CODE XTEND S [ DR0 MOV,  DR0 EXT,  DR0 S [ MOV,  NEXT

CODE 8/  S [ DR0 MOV,  3 # DR0 LSR,  DR0 S [ MOV,  NEXT
CODE 8*  S [ DR0 MOV,  3 # DR0 LSL,  DR0 S [ MOV,  NEXT
;S
CODE UW*   \ w w --- n | 16bit x 16bit --> 32bit prod
  S [+ DR0 MOV,  S [ DR1 MOV,  DR1 DR0 MULU,  DR0 S [ MOV,  NEXT

CODE W*    \ w w --- n | 16bit x 16bit --> 32bit prod
  S [+ DR0 MOV,  S [ DR1 MOV,  DR1 DR0 MULS,  DR0 S [ MOV,  NEXT

CODE -ROT  S 4 &[ DR0 MOV,  S 8 &[ S 4 &[ MOV,
  S [ S 8 &[ MOV,  DR0 S [ MOV,  NEXT


\ Loader screen                           ( 13  4 90 crc 15:28 )
: LOADER  \  scr#-1   ---  <name>  defines screen to load
  <BUILDS ,     \ Section 7.4
  DOES> WARNING @ >R WARNING OFF   @ LOAD  R> WARNING ! ;
    23 LOADER DOCUMENTING          53 LOADER DISKING
   174 LOADER RECITE              222 LOADER CREF
   150 LOADER TOWERS              240 LOADER DEBUG
(  201 LOADER TERM         )      136 LOADER FILING
   524 LOADER XFER         \      360 LOADER APPLICATION
   375 LOADER XPURGE              373 LOADER .envir
(  423 LOADER TIMECARD     )      367 LOADER SHELL
    87 LOADER CHECKBOOK \         183 LOADER STRINGS
   409 LOADER BLANK               503 LOADER CPRESENT

: NEEDED  \ scr# ---  | compiles scr if not already loaded.
  -FIND IF 2DROP DROP ELSE LOAD THEN ;
\ fibonacci numbers                       ( 26  2 86 CRC 15:54 )
: FIB    \ n1 n2 --- n2 n3 | generate the next number in series
  2DUP + ROT DROP ;

: FIBS   \  ---  | print 'em
  ?CR 1 1 2DUP 14 .R COL 14 .R
  BEGIN FIB DUP 0< 0= WHILE COL DUP 14 .R REPEAT 2DROP ;

FIBS ;S
CODE FIB \ n1 n2 --- n2 n3 | generate the next number in series
  S [+ DR0 MOV,  S [ DR1 MOV,  DR0 DR1 ADD,  DR0 S [ MOV,
  DR1 S -[ MOV,  NEXT




\   BULK INITIALISER -- int, init         ( 11  9 89 crc 15:06 )
BASE @  HEX                0 VARIABLE SINGLE
CODE (FMT) \ bufaddr dev# trk side  --- fl | format a track
  CS AX MOV,  1000 # AX ADD,  AX ES MOV,    \ buffer segment
  AX POP,  AL DH MOV,  ( side )  AX POP,  AL CH MOV, \ trk
  AX POP,  AL DL MOV,  ( dev )  BX POP,  BX BX XOR, \ buf
  509 # AX MOV,  13 INT, \ U< IF,  AH AL MOV,  AH AH XOR,
(  ELSE,  AX AX XOR,  THEN,) pushf,  1PUSH

: FMT  \ bufaddr dev# trk side  ---    | format a track
  PAUSE (FMT) -DUP IF 8 .R ABORT"  Formatting error!"  THEN
  PAUSE ;      CS@ 1000 + SETSEG        DECIMAL

: CYL  \ bufaddr dev# trk       ---    | format a cylinder
  81 MIN >R 2DUP R 0 FMT  R> 1 FMT ;   \ double sided only!
BASE !
\   BULK INITIALISER -- int, init         ( 13  9 87 CRC 16:08 )
FORTH DEFINITIONS FORGET TASK   : TASK ; \ See the RF manual
BASE @ DECIMAL VOCABULARY DISKING IMMEDIATE
102 NEEDED ABORT"    DISKING DEFINITIONS   52 LOAD

  : (INIT)  \ trkfr trkto  ---  | format a cylinder
    ?CR  PAD 0 ( 1) 2SWAP 1+ SWAP DO 2DUP I
    SINGLE @ IF 0 FMT ELSE CYL THEN  I 5 .R LOOP 2DROP ;

  : INIT   0 81  (INIT) ;
  : 10INIT  9 0 DO INIT I 4 .R KEY DROP LOOP INIT ;
DECIMAL 108 LOAD 110 LOAD            116 LOAD  157 LOAD
127 LOAD FORTH DEFINITIONS EDITOR FLUSH  BASE ! DISKING ;S
N.B. Use  INIT  to init a new disk. However, it must be cleaned
out and set to blanks. For this purpose, use  CLEARDISK  or
BACKUP  ( for an entire disk ).
\ for next code                           ( 26  1 88 crc  9:34 )
CODE (NEXT)  0 # 0 [RP] CMP,
  0<> IF,  0 [IP] IP ADD,  0 [RP] DEC,  NEXT  THEN,
    2 # IP ADD,  2 # RP ADD,  NEXT

: FOR  COMPILE >R HERE 6 ;  IMMEDIATE

: NEXT   6 ?PAIRS COMPILE (NEXT) BACK ;   IMMEDIATE    ;S

: T  DUP CR FOR OUT @ C/L > IF CR THEN DUP I - 8 .R  NEXT DROP ;
   20 DUP T   \ up count, then down count
: T1 CR FOR OUT @ C/L > IF CR THEN I 8 .R  NEXT ;   T1 ;S
Concept from Chuck Moore's FORTH chip, the Novix 4000. FOR ...
NEXT  is equivalent to  n 1+ 0  DO  LOOP  but faster. Also, n
may be greater than -1 2/ .

\ 1 second timer from the system clock    ( 28  5 92 CRC 20:24 )
BASE @  HEX
: TK   PAUSE  (GETTIME) NIP  FF AND ;

: GT   TK  5 > ;

: EOS  BEGIN GT  ?KEY IF  DROP 0 THEN  0= UNTIL ;

: NS   BEGIN GT  UNTIL ;

: SEC  EOS 0 DO  NS EOS  LOOP ;

: TICK  TK  BEGIN  TK OVER -  UNTIL  DROP ;
BASE !  ;S
: TT   CR .TIME SPACE SEC .TIME  CTL G EMIT ;

\ extensions to FORTH                     (  1  1 88 CRC 18:21 )
BASE @ HEX
: CTL   BL WORD HERE 1+ C@ 1F AND [COMPILE] LITERAL ; IMMEDIATE
     \ See the real-Forth manual
: ASCII BL WORD HERE 1+ C@        [COMPILE] LITERAL ; IMMEDIATE

: .SCR    ." Scr #"   6 .R ;

: TAB  OUT @ -  SPACES  ;

: STOP ( compilation) ?CSP SMUDGE [COMPILE] [       ; IMMEDIATE

\ : EXEC (  Execute a case statement) DUP + R> + @EXECUTE  STOP

: 2@  DUP 2+ SWAP  @ SWAP @ ;  : 2!  DUP 2+ ROT SWAP  !  ! ;
BASE ! ;S
\  :: , the immediate compilation mode  WFR 26 05 81 CRC )
      FORTH  DEFINITIONS        \ See the RF manual
:  ::   \ compile and execute nameless FORTH
    HERE  >R
    [  '   QUIT  CFA   @  ]  LITERAL  ,
    !CSP  ]     ( enter compile state )
    BEGIN  INTERPRET   STATE   @
         WHILE   CR  QUERY
       REPEAT
    SMUDGE   R   EXECUTE   R>  DP  !  ;
 CR  ."   ::  is loaded."  ;S
The above definition  ::  will accept and compile FORTH
words until the next  ; . the code will then be executed
once and forgotten. This is a method to execute conditionals
from the terminal for testing or repetitive functions.
I.e.  HEX :: 5F 40  DO  I EMIT  LOOP ;
\ stack printing words: .s depth u.r      ( 20 11 94 crc 16:35 )
\ : UD.  <# #S #> TYPE  SPACE ;
: U.R  0 SWAP D.R ;              : U.   0      D.  ;
6 USER SP0           \           8 USER RP0
: DEPTH  SP0 @ SP@ - 2/ 1- ; \ gets the depth of the stack
\ CODE DEPTH  UP #) BX MOV,  ' SP0 @ [BX] AX MOV,
\   SP AX SUB,  AX SAR,  1PUSH  \ same size, faster.
:  .S     \ prints out contents of stack non-destructively
  DEPTH  -DUP  IF 6 .R ASCII : EMIT  SP@ 2-  SP0 @ 2-
    DO I @ 6 U.R -2 +LOOP   ELSE ." Empty" THEN SPACE ;
  ;S    not used much
CODE RP@  RP PUSH, NEXT
: RDEPTH RP0 @ RP@ - 2/ 1- ; \ gets the depth of return stack
:  .RS    \ prints out contents of stack non-destructively
  RDEPTH -DUP  IF 6 .R ASCII : EMIT  RP@ 2-  RP0 @ 2-
    DO I @ 6 U.R -2 +LOOP   ELSE ." Empty" THEN SPACE ;
\   New, a full screen  editor   by WFR     26 05 81 CRC )
      FORTH  BASE  @   DECIMAL
: NEW    ( line  #  -----   builds from this line downward )
    BASE @ SWAP DECIMAL 16  0  PAGE  CR  ." SCR " SCR  @  3 .R
 DO CR I 3 .R SPACE C/L SPACES 124 EMIT C/L 1+ 0 DO 8 EMIT LOOP
       I  OVER   =
       IF [  DROP ] ( error )  QUERY  1  TEXT  PAD  1+  C@
           IF  ( not at null )  I  EDITOR  R  FORTH  1+
              ELSE  ( before  or after )  8  EMIT  [  ROT  2 ]
        THEN   I   SCR  @   .LINE   THEN
  LOOP   DROP  CR  BASE ! ;
   CR  ." NEW is loaded. "  BASE  !  ;S
  This editor builds a NEW screen. Either list the screen or
set SCR manually. Then give: 'n  NEW ' where  n  is the first
new line.  Previous lines are listed; an empty line will
terminate building the new screen.
\ frills: dump & ascii print              ( 30 12 87 CRC 20:31 )
BASE @ HEX                      0 VARIABLE FUDGE
: TC@ FUDGE @ + C@ ;            : T@ FUDGE @ + @ ;
: (DUMP) \  addr ct ---  | dump as pointed to by reloc
  SPACE  BOUNDS DO  I TC@ 3 .R  LOOP ;
\ : U.R 0 SWAP D.R ;     \        : TAB OUT @ - SPACES ;
: LASCI   \  addr ct ---  | asci type as pointed to by reloc
  BOUNDS DO  I TC@  7F AND  DUP
    BL ASCII ~ WITHIN 0= IF DROP ASCII . THEN  EMIT  LOOP ;
: HEAD  \ addr --- | headder for dump display
  10 0 DO I OVER + 0f AND 3 .R LOOP DROP ;
  \ N. B: Not responsible for negative counts! -- the MGT.
: DUMP   \  addr ct ---  | dump as pointed to by reloc
  OVER ?CR 6 SPACES HEAD  BEGIN  DUP  WHILE  CR OVER 5 U.R
     2DUP 10 MIN >R  R 2DUP (DUMP)  37 TAB LASCI
  R R> MINUS D+  ?TERMINAL IF DROP 0 THEN REPEAT 2DROP ; BASE !
(  Vlist col tab id.                      (  7  8 86 CRC 12:30 )
 BASE @ HEX
: AID.  BASE @ HEX >R  PAD BL ASCII _ FILL
   DUP PFA DUP CFA 5 U.R SPACE  LFA OVER -
   PAD SWAP CMOVE   PAD COUNT 01F AND 1- 2DUP TYPE
   + C@ 7F AND EMIT SPACE R> BASE ! ;

: COL  OUT @  [ 3 ( columns 1- ) 14 ( width) * 1- ] LITERAL >
       IF  CR  ELSE  OUT @ 14 / 1+ 14 * TAB  THEN ;

: (VLST)    80  OUT !  \ addr --- | vlist of given voc
  BEGIN  COL  DUP AID.  PFA LFA @  DUP 0=  ?TERMINAL OR UNTIL
     ?CR DROP  ;

: VLIST    CONTEXT @ @  (VLST) ;  \ See the RF manual
: CURLIST  LATEST       (VLST) ;    BASE  !
\ Assembler extensions to FORTH           (  2  8 90 crc 15:59 )
BASE @ HEX        ." Double Precison handlers..."
CODE 2*     (  n -- 2*n )
   AX POP,  AX SHL,  1PUSH
CODE 2/     (  n -- n/2 )
   AX POP,  AX SAR,  1PUSH

CODE -ROT   W POP,  AX POP,  DX POP,  3PUSH
   ."  loaded " BASE !    ;S
CODE 2SWAP  (  d1 d2 -- d2 d1 )  \ moved to kernel
   BX POP,  CX POP,  AX POP,  DX POP,  CX PUSH,  3PUSH

CODE 2@  S [ AR0 MOV,  AR0 4 &[ S [ MOV,  AR0 [ S -[ MOV,
    NEXT ;C
CODE 2!  S [+ AR0 MOV,  S [+ AR0 [+ MOV,  S [+ AR0 [ MOV,
    NEXT ;C
\ nec-safe  quit                            12 12 84 CRC
( 1 VARIABLE STACKPRINT )   BASE @ HEX

: (PQUIT)    \  See the RF manual
  BLK OFF  [COMPILE] [  OK  BEGIN BEGIN
    RP! CR  QUERY INTERPRET  OK  \ Reset output vectors
    DEPTH ( STACKPRINT @ OR ) IF  .S  THEN \ THEN
    STATE @ 0= UNTIL ."  iok"  AGAIN  STOP

' (PQUIT) CFA  'QUIT !
    ."  Necquit loaded."  BASE  !





\      driver for parallel printer        (  7  3 88 crc 12:33 )
FORTH DEFINITIONS               VOCABULARY PRINTER IMMEDIATE
BASE @ HEX >R
62 USER LNCTR  LNCTR OFF \ shared w/ mptr in overlay code
PRINTER DEFINITIONS
BLK @ 1+ LOAD

\ 11 CTRL SELECT     13 CTRL DESELECT    \ supports Epson
\ ASCII P CTL [ 2  CTRL 80CHAR           \ FX-80 and JX-80
\ ASCII m CTL [ 2  CTRL 132CHAR          \ printers.

DECIMAL 69 LOAD       10 LEFTS
R> BASE !   FORTH DEFINITIONS  EDITOR FLUSH



\      driver for parallel printer        ( 21  2 90 crc 13:34 )
0 VARIABLE PR#
HERE ASSEMBLER  HEX   UP #) BX MOV,
  0C # AL CMP,  0= IF,  0 # OFUSER LNCTR MOV,  ELSE,
  0A # AL CMP,  0= IF,  8 # OFUSER LNCTR ADD,  THEN,  THEN,
  AX PUSH,  BEGIN,  \ ' PAUSE 1A - @#L JSR,   re-code for 808x
   PR# #) DX MOV,  2 # AH MOV,  17 INT,  90 # AH CMP,  0= UNTIL,
  AX POP,  0 # AH MOV,  PR# #) DX MOV,  17 INT,  RET,

CODE (PNT)   AX POP,  7F # AL AND,  #) CALL,  NEXT

: CTRL <BUILDS  DUP C, 0 DO C, LOOP
  DOES> 'EMIT @ [ ' (PNT) CFA ] LITERAL =
      IF COUNT TYPE ELSE DROP THEN ;


\ text shipping words: send to other compu(  4 10 86 CRC 18:28 )
DECIMAL  FORGET TASK   here first over - erase
: SEND   PRINTER
        OUTPUT> (PNT)  SLTYPE   2DROP  PPAGE   NLIST  (CR) STOP

: ABLOCK BLOCK DUP W@ IF B/BUF TYPE ELSE
     LI EMIT DROP 400 MS THEN ;
: ABLOCKS   2DUP SEND BOUNDS      DO I ABLOCK
    ?TERMINAL IF LEAVE THEN LOOP + ;

: APPLE" 0 WORD SEND HERE COUNT TYPE CTL M EMIT ;
EDITOR DEFINITIONS
: XFER  SCR @ ABLOCK ;    FORTH DEFINITIONS
\ : TERM
\       BEGIN KEY DUP CTL Q - WHILE PRINTER (PNT) REPEAT DROP ;
: TASK ;   DECIMAL
\ Documentor code: since                    14  2 84 CRC
0 VARIABLE (SINCE)  0 ,      \ holds todays address
: STARTDATE \ starting address of date in block
  SCR @ BLOCK 43 + ;
: ?BL  1+ DUP C@ BL = IF DUP 16 TOGGLE THEN 1- ;

: GETDATE  \ addr --- d | accumulate 3 numbers into one
  PAD 9 CMOVE 0 0 PAD 6 + DUP 1+ C@ BL = + ?BL (NUMBER) DROP
  >R  DUP 60 < IF 100 + THEN R>  \ turn of century proviso
  PAD 3+ ?BL (NUMBER) DROP  PAD ?BL (NUMBER) DROP  ;

: GETSINCE   \  ---   | stores since's date in since
  BL WORD 0 0 HERE (NUMBER)  DROP               \ day
  BL WORD 0 0 HERE (NUMBER) 2DROP   100 M*  D+  \ month
  BL WORD 0 0 HERE (NUMBER) 2DROP  DUP 60 < IF 100 + THEN
  10000 M* D+  ( year)  (SINCE) 2! ;
\ Documentor code: since                  ( 19  2 88 crc  7:14 )
: ASCR   \  --- fl  | screen more recent than since?
  SCR @ BLOCK @ IF STARTDATE GETDATE DMINUS (SINCE) 2@ D+ 0<
  NIP  ELSE 0 THEN ;
0 VARIABLE TRIADS
: SINCE  \ fr to ---  | print out screens over range given
\ fr to SINCE (d)d (m)m (y)y<ret>  n.b. max of 2 chars. per!!
  TRIADS OFF  PAD C/L 1+ BLANKS  SWAP SCR ! GETSINCE n
  BEGIN  ASCR IF  SCR @ DOCUMENTING TRIAD  TRIADS 1+! THEN
  SCR 1+!  ?TERMINAL IF  DUP SCR ! THEN
  SCR @ OVER -  0< 0= UNTIL DROP ;

FORTH DEFINITIONS   ;S
N.B.  SINCE  ignores screens updated the day of the date given.
To print out every screen updated during September, use:
0 B/DRV SINCE 0 9 84
\      driver for parallel printer        ( 15  1 88 crc  8:13 )
PRINTER DEFINITIONS  DECIMAL
0 VARIABLE LEFT

: LMRGN LEFT @ SPACES OUT OFF ;    : LEFTS  LEFT ! ;

: PPAGE    (PAGE) LNCTR OFF LMRGN ;

: PCR  (CR) LNCTR @ 488 > IF  PPAGE  ELSE  LMRGN  THEN ;

FORTH DEFINITIONS
: ?PRINT 'EMIT @ [ PRINTER ' (PNT) CFA ] LITERAL = ;




\ aim object file format utilities        ( 12  1 89 crc  9:03 )
DECIMAL 201 NEEDED SLTYPE  FORGET TASK  here first over - erase
HEX        0 VARIABLE CHKSUM  0 VARIABLE LINECT
  \         checksum of line   line count
  \ This format is defined in the AIM 65 User's Guide, pg F-5
  \ to F-7
: ABYTE  0 # # 2DROP ;       : ACELL  0 # # # # 2DROP ;

: WCHK   DUP FF AND CHKSUM +!  8 2/S  CHKSUM +! ;
: BUILDCHK  \  addr cnt  --- | checksum in chksum
  2DUP  CHKSUM OFF WCHK  WCHK BOUNDS  DO I TC@ CHKSUM +! LOOP ;

: BUILDBYTES  \ addr cnt --- | string construction
  SWAP 1- SWAP OVER + DO I TC@ ABYTE -1 +LOOP ;
: DOT  ASCII . (EMIT) ;
BLK @ 1+ DUP 2+ THRU     DECIMAL   : TASK ;   EDITOR FLUSH
\ aim object file format utilities        ( 12  1 89 crc  8:17 )
: ALINE  \ builds a line in the string construction area
         \ addr cnt ---  addr$ cnt$ ready for typing
  2DUP BUILDCHK  <# CHKSUM @ ACELL 2DUP BUILDBYTES  SWAP
  ACELL ( addr) ABYTE ( cnt) ASCII ; HOLD  0 0 #>  LINECT 1+! ;

: LASTLINE  \  -- addr$ cnt$ | builds last line of file for ty
  CHKSUM OFF  LINECT @ WCHK
  <# CHKSUM @ ACELL ( chksum)  LINECT @ ACELL ( lines)
  0 ABYTE ASCII ; HOLD 0 0 #> LINECT OFF  TYPE CTL M EMIT ;

: UMIN  2DUP U< IF SWAP THEN NIP ;
: LINES    \ addr cnt --    | dump contiguous memory
  BEGIN 18 OVER U< WHILE 2DUP 18 UMIN DUP >R ALINE  TYPE  DOT
  CTL M EMIT  R - SWAP R> + SWAP  REPEAT
  -DUP IF ALINE  TYPE  DOT  CTL M EMIT  ELSE DROP THEN ;
\ aim object file format utilities          23 10 84 CRC
: CHAR    \  addr n1 --  addr+1 n2 | decode one char into n
  10 * OVER C@ 10 DIGIT 0= 0 ?ERROR + SWAP 1+ SWAP ;

: DECODEBYTE  \ addr --  addr  n | decode two chr at addr
  0 CHAR CHAR ;

: DECODECELL  \ addr --  addr  n | decode four chr at addr
  0 CHAR CHAR CHAR CHAR ;

FIRST B/BUF - CONSTANT TAREA

: DOCHKSUM  \ addr --- addr+4 | decode & compare against chksum
    DECODECELL CHKSUM @ - IF ." checksum error !! " CR  QUIT
        THEN  ;

\ aim object file format utilities          23 10 84 CRC
HEX
: DECODELINE  \ addr ---  | line of text decoded & placed
  DUP C@ ASCII ; - 0 ?ERROR  \ first char
  1+ DECODEBYTE   DUP CHKSUM !  \ count
  DUP IF  \ if not the last line
    SWAP DECODECELL DUP CHKSUM +! \ addr
    ROT BOUNDS      DO DECODEBYTE DUP CHKSUM +! I C! LOOP
  ELSE  \ do last line
    DROP DECODECELL DUP CHKSUM !
    LINECT @ - IF ." Bad record count!" CR QUIT THEN
    DOCHKSUM  LINECT OFF  THEN DROP ;

: DECODELINES    LINECT  OFF
    BEGIN LINECT 1+! PAD DUP  60 EXPECT
    DECODELINE LINECT @ 0= UNTIL ;
\ Unlink utility                          (  2  2 87 CRC 12:10 )
\ FORGET TASK
FORTH DEFINITIONS
: FLINK  \ nfa addr ---  addr'/fl | find word pointing to given
  SWAP >R
  BEGIN @  DUP PFA LFA @ DUP 0=  SWAP  R =  OR
    0= WHILE  PFA LFA  REPEAT
  PFA LFA  DUP @ R>  - ;

: UNLINK:  \  --  | remove given word from dict. linx.
  -FIND 0= 0 ?ERROR  DROP  DUP NFA
  CONTEXT @  FLINK  IF DROP DUP NFA  CURRENT @ FLINK DROP  THEN
  >R  LFA @  R> ! ;

\ : TASK ;

\ text shipping words: send to lsi-11     ( 29  9 86 CRC 13:25 )
DECIMAL 201 NEEDED BUGOFF ( get terminal prgm)
FORGET TASK   197 NEEDED SAFEOUTS     here first over - erase
  : SEND      printer    serial on
        OUTPUT> (PNT)   SLTYPE  2DROP  PPAGE   NLIST  (CR) STOP
\ : SEND   PRINT ;
: ABLOCK 16 0 DO I OVER (LINE) TYPE  CTL M EMIT
  6000 0 DO 2 DROP LOOP                         LOOP DROP ;

: BLOCKS  SEND  2DUP BOUNDS DO SAVEOUTS OK I 5 .R RESTOREOUTS
  I ABLOCK  ?TERMINAL IF LEAVE THEN LOOP + ;

: HOST" 0 WORD SEND HERE COUNT TYPE 13 EMIT ;

: TX   ." Sending" SEND  SCR @ ABLOCK OK TERM ;
: TASK ;
\ [[  and ]]                                          14Sep87crc
ASSEMBLER DEFINITIONS
  HERE   RP DEC,  RP DEC,  IP 0 [RP] MOV,       \ save ip
  IP POP,  ( remove "return" addr )  NEXT       \ do next word

: ]]  LITERAL [ 2 CSP +! ]  #) CALL,
  CURRENT @ CONTEXT ! [COMPILE] ]  ;

HERE DUP 2+ ,                             \ make it headerless
  IP W MOV,  0 [RP] IP MOV,  RP INC,  RP INC,  W JMP,

FORTH DEFINITIONS
: [[  LITERAL [ 2 CSP +! ]  ,   [COMPILE] ASSEMBLER
  [COMPILE] [ ;   IMMEDIATE


\ [[  and ]] : testing                                15Sep87crc
CODE TEST1   W PUSH,  IP PUSH,  ]]  U. U. ;       SMUDGE

CODE TEST4   7 # AX MOV,  AX PUSH,  8 # AX MOV,  AX PUSH,
   ]] U. U. [[  NEXT

: TEST2  3 4 [[  NOP, NOP,  NOP, NOP,  AX POP,  AX POP,  NEXT
    ] STOP

: TEST3  5 6 [[  AX POP,  AX POP, ]] .S ;

;S  This code is from a handout by Martin Tracy at a Los Angeles
fig meeting, with many improvements by CRC. It is public domain.
It may be used to intermix high level and assembly code, as
these examples show.

\ Transient code support                  ( 19  5 86 CRC  8:27 )
BASE @ HEX FIRST 2000 - CONSTANT TAREA  TAREA VARIABLE TP
     \ set size as needed! Beware of moving disk buffers!
: TRANSIENT  HERE TP @ DP ! ;   \  --  here | change dict.
: PERMANENT  HERE TP ! DP ! ;   \ here  --  | restore dict.
\ get at pfui2 code the hard way - it's an orphan
' (CREATE) LFA @ PFA 0A + @ DUP  ROT BASE !
: DISPOSE  \  --  | get rid of transients
  TAREA TP !  VOC-LINK    BEGIN DUP   [ ROT ]
     BEGIN @ DUP TAREA [ ROT , ] UNTIL DUP ROT ! DUP 0=  UNTIL
  DROP VOC-LINK @ BEGIN DUP 4 -           [ ROT 4 CSP +! ]
     BEGIN [ ROT ] DUP BEGIN PFA LFA @ DUP TAREA [ ROT , ]
     UNTIL DUP ROT PFA LFA ! DUP 0= UNTIL
  DROP @ DUP 0= UNTIL  DROP [COMPILE] FORTH DEFINITIONS ;  ;S
Pfui2 code (see kernel listing of  FORGET ) is necessary due to
romable version of word  FORTH .
\ Transient demo stuff                    (  9  1 88 crc 13:51 )
DECIMAL   86 NEEDED ~:          EDITOR FLUSH
TRANSIENT          ?CR .S
: EQUATE  <BUILDS , IMMEDIATE DOES> [ .S ] @ [COMPILE] LITERAL ;
 TRANSIENT
9 3 + 2/ 1- EQUATE FIVE         6 EQUATE SIX

: NEWCON   <BUILDS , ;CODE  2 [W] PUSH,  NEXT

: DEMO3 FIVE . ;                : DEMO4 FIVE SIX + . ;

0 NEWCON ZERO                   1 NEWCON ONE

~: TEST1     ONE 2 3 4 . . . . ;

: FRED   5 . TEST1  ZERO . ;
\ More transient code support             ( 19  6 86 CRC 11:40 )
BASE @  DECIMAL 78 NEEDED TRANSIENT   HEX
: (T;CODE)  R> @ LATEST PFA CFA ! ;   \ TRANSIENT \ if you wish
: ;CODE  ?CSP TAREA HERE U< IF COMPILE (T;CODE) DUP , PERMANENT
  2 CSP +!  [COMPILE] ASSEMBLER  [COMPILE] STOP ASSEMBLER
  ELSE  [COMPILE] ;CODE  THEN ; IMMEDIATE

: DOES>  ?CSP TAREA HERE U< IF COMPILE (T;CODE) DUP , PERMANENT
  FORTH 2 CSP +!  [ ' DOES> 6 + @ ] LITERAL
  E8 C,  HERE 2+ - ,
  ELSE  [COMPILE] DOES>  THEN ;  IMMEDIATE  ( PERMANENT) BASE !
;S   These defining word modifiers are used to make the  <builds
portion of a defining word transient, with the  does>  portion
permanent. N.B. The definitions so produced will finish in the
permanent memory!!!! If the next defintion is to be transient,
this must be explicitly stated!!!!!!  See scr 79.
\ s   object file format utilities          24 01 85 CRC
BASE @ HEX 0 VARIABLE CHKSUM  C/L VARIABLE (NLL)
  \         checksum of line   nulls count
  \ This format is defined SYS 68K monitor firmware manual, page
  \ D-1 and D-2. Only builds 16 bit address for now. 24 later.

: ABYTE  0 # # 2DROP ;       : ACELL  0 # # # # 2DROP ;

: BUILDCHK  \  addr cnt  --- | checksum in chksum
  2DUP CHKSUM ! ( cnt) 100 /MOD CHKSUM +! CHKSUM +! \ addr
  BOUNDS DO I C@ CHKSUM +! LOOP CHKSUM @ MINUS 1- CHKSUM ! ;

: BUILDBYTES  \ addr cnt --- | string construction
  SWAP 1- SWAP OVER + DO I C@ ABYTE -1 +LOOP ;
BLK @ 1+ DUP 1+ THRU BASE !

\ s   object file format utilities          24 01 85 CRC
: STARTREC  \  -- 0 0 | start record construction
  ASCII S HOLD  0 HOLD  CTL J HOLD  CTL M HOLD ;

: HEADER C/L SPACES ;

: NLL (NLL) @ 0 DO 0 EMIT LOOP ;

: NULLS (NLL) ! ;

: LASTLINE  \   --   | builds last line of file for type
  <# FC ABYTE 0 ACELL 3 ABYTE  0 ABYTE \ rec type
  STARTREC 0 0 #> NLL TYPE ;

HEX 10 CONSTANT MAXBYTES

\ s   object file format utilities          24 01 85 CRC
: ALINE  \ builds a line in the string construction area
         \ addr cnt ---  addr$ cnt$ ready for typing
  2DUP BUILDCHK  <# CHKSUM @ ABYTE  2DUP BUILDBYTES
  SWAP ACELL ( addr) 3 + ABYTE ( cnt)
  ASCII 1 HOLD STARTREC 0 0  #> ;

: LINES    \ addr cnt --    | dump contiguous memory
  BEGIN DUP MAXBYTES > WHILE
  2DUP MAXBYTES MIN DUP >R ALINE NLL TYPE  ASCII . (EMIT)
  R> DUP MINUS D+  REPEAT  ?TERMINAL IF DROP MAXBYTES 2/ THEN
  -DUP IF ALINE TYPE ASCII . (EMIT) ELSE DROP THEN ;
;S  download actually in target compiler, scr 250.

: DOWNLOAD  HEX BASE-ADDR DPNEW @ DELTA - OVER -
  HEADER LINES LASTLINE ;
\  Wordstar Compatible Editor: BJR          20  3 85 CRC
base @ hex : (Q) BEGIN CURSOR KEY DUP CASE  \ continuous stream
 CTL s OF    -1  M                  ENDOF   \ <-----
 CTL h OF    -1  M                  ENDOF   \ <-----
 CTL d OF     1  M                  ENDOF   \ ----->
 CTL e OF                  1 UP     ENDOF \  up
 CTL x OF                  1 DN     ENDOF \ down
 CTL m OF  #LAG      M        DROP  ENDOF   \ beginning next lin
 CTL n OF  #LOC  DUP  S PL          ENDOF   \ spread screen
 CTL u OF  #LOC  E RSTR             ENDOF   \ erase current line
 CTL y OF  #LOC  DUP  D        PL   ENDOF   \ delete a line
 CTL t OF  #LOC  H                  ENDOF   \ hold current line
 CTL p OF  #LOC     R RSTR          ENDOF   \ replace current li
 CTL b OF  #LOC  DUP  I PL          ENDOF   \ insert contents pa
 CTL r OF     LAST                  ENDOF   \ back a screen
 CTL c OF     NEXT           ENDOF -->  \ next screen forward
\  Wordstar Compatible Editor: BJR          20  3 85 CRC
 CTL o OF      SWAP    O   SWAP     ENDOF   \ other screen
 CTL v OF                   PLACING ENDOF \ keying
 CTL l OF                   MERGE   ENDOF \ bump ln
 CTL q OF KEY CASE  CTL e OF      TOP      ENDOF \ home
                    CTL y of      BLR      ENDOF \ blanks right
                    CTL u OF      UNDO     ENDOF
                       7F OF      BLL      ENDOF \ blanks left
                  ENDCASE       ENDOF
    7F OF      (DEL)                ENDOF \ del
\             ASCII ,  OF KEY DROP .PAD    ENDOF \ f, - show pad
        DUP  DUP  DUP  7F <  SWAP  1F   >  AND
  IF DUP EMIT PLACE ELSE DROP THEN  ENDCASE CTL Z = UNTIL
  BOTTOM ;                                      BASE !


\ Transient: ~:                           ( 21  6 87 CRC 12:57 )
( DEBUG ) FORGET TASK       78 NEEDED TRANSIENT
: ~: ?EXEC !CSP  CURRENT @ CONTEXT !
   TRANSIENT  CREATE  PERMANENT
   HERE  [ ' QUIT CFA @ ] LITERAL ,
   TRANSIENT  SWAP ,  PERMANENT  ]   IMMEDIATE
   DOES>  @ STATE @ IF , ELSE EXECUTE THEN ;

80 NEEDED (T;CODE)              : TASK ; ;S
Extensions to the transient word set. ~: allows compiling the
head of a word into the transient area, with the body in the
permanent area. They may NOT be immediate words; declare those
transient explicitly anyway.
~: TEST1     1 2 3 4 . . . . ;

: FRED   5 . TEST1  0 . ;
\ checkbook language: start               ( 11  5 90 crc 11:10 )
FORGET TASK      here first over - erase
: TASK ;   DECIMAL              VOCABULARY CHECKS IMMEDIATE
128 NEEDED SEE:  ( so we have the see: field ) EDITOR FLUSH
CHECKS DEFINITIONS              0 VARIABLE LAST 0 ,

: 10*S  -DUP IF 3 AND 0  \ adjust for decimal point, in cents
  DO 0 SWAP BASE @ U* DROP ROT BASE @ U* D+ LOOP THEN ;

: PFLOAT \ pseudo floating point version of number
  NUMBER DPL @ 1+ IF  2 DPL @ -  ELSE 2 THEN
  10*S 2DUP LAST 2! ;

: ID.  COUNT 31 AND BOUNDS  DO  I C@ 127 AND EMIT  LOOP ;
88 91 THRU

\ checkbook language                      ( 13  5 90 crc 14:37 )
: H"  HERE  ,"   LATEST 2- ! ;

: .H  \ nfa  ---  | help field printed
  2- @ COUNT TYPE ;

: PFINTERPRET  BEGIN -FIND  IF  ( found)  STATE @ <
        IF CFA , ELSE  CFA EXECUTE THEN
        ELSE HERE PFLOAT [COMPILE] DLITERAL
        THEN ?STACK AGAIN     STOP

: $.R  \ d ct ---  | money formatted print
        >R SWAP OVER DABS
        <# # # ASCII . HOLD #S SIGN BL HOLD ASCII $ HOLD #>
        R> OVER  -  SPACES  TYPE ;
: NORMALISE    100 U/ NIP ;
\ checkbook language                      ( 11  5 90 crc 11:00 )
:  .S     \ prints out contents of stack non-destructively
  DEPTH  2/ -DUP IF 4 .R ASCII : EMIT  SP@ 4 -  SP0 @ 4 -
  DO I 2@ SWAP 15 $.R -4 +LOOP  ELSE ."    Empty" THEN SPACE ;
: QUIT   [ 'ABORT @ ] LITERAL  'ABORT !  WARNING ON
  [COMPILE] FORTH DEFINITIONS SP! [COMPILE] EDITOR QUIT STOP
H" Return to Forth."
: Q QUIT  STOP
H" Return to Forth."
: X       BLK @ IF ?EXEC THEN R> DROP ;         IMMEDIATE
BASE @ HEX 80  LATEST 1+ C!  BASE !  \  make it "null"
: HELP     CONTEXT @ @
  BEGIN  DUP [ LATEST PFA LFA @ ] LITERAL -
     IF ?CR DUP ID.   DUP 20 TAB .H  THEN
     PFA LFA @  DUP 0=  ?TERMINAL OR UNTIL DROP  ;
H" Print out this help information."
\ checkbook language                      ( 13  5 90 crc 14:57 )
: 2*   2DUP D+ ;
H" Multiply the top number on the stack by two."
CODE +     ' D+    CFA @  LATEST PFA CFA !
H" Add the two top numbers on the stack."
: - DMINUS + ;
H" Subtract the two top numbers on the stack."
CODE SWAP  ' 2SWAP CFA @  LATEST PFA CFA !
H" Swap the two top numbers on the stack."
CODE DROP  ' 2DROP CFA @  LATEST PFA CFA !
H" Drop the top number on the stack."
CODE DUP   ' 2DUP  CFA @  LATEST PFA CFA !
H" Duplicate the top number on the stack."
: MONTH  MONTH ;
H" Print a calendar for this month and the next two."
: DATE   TODAY ;
\ checkbook language                      (  1  6 90 crc 14:56 )
H" Print out the current time, data, and day of the week"
: CALENDAR  NORMALISE >R NORMALISE  R>  OVER 1 12 WITHIN
  0= IF  ABORT  THEN  CALENDAR ;
H" Print a given month and year:  (m)m yy calendar"
: PAGE PAGE ;
H" Clear the display."
: R LAST 2@ ;
H" Return the last number entered."
FORTH DEFINITIONS
: CHECKBOOK -1 WARNING ! SP! DECIMAL ?CR  [ LATEST PFA CFA ]
  LITERAL 'ABORT !  ."  real-forth Checkbook Language"
  BLK OFF   [COMPILE] [  [COMPILE] CHECKS DEFINITIONS  CHECKS
  BEGIN RP! CR ." > " QUERY PFINTERPRET  CR .S AGAIN  STOP
FORTH CHECKS ' QUIT FORTH LFA OFF  \ seal vocabulary
CHECKBOOK
\ VIDEO-SEG ?VMODE VMODE.SET              (  9 12 91 crc 10:16 )
BASE @ >R DECIMAL
CODE ?VMODE     ( --- N1 )
  15 # AH MOV,  16 INT,  AH AH SUB,  1PUSH
CODE SET-CURSOR  CX POP,  1 # AH MOV,  16 INT,  NEXT
CODE GET-CURSOR  AX AX SUB,  AX ES MOV,  ES: 1120 #) AX MOV,
  1PUSH    HEX
: VMODE.SET     ( --- )
  ?VMODE 7 = IF  3B4 0B000  ELSE  3D4 0B800  THEN
  VIDEO-SEG !  VCTLR ! ;        VMODE.SET

: NO.CURSOR   GET-CURSOR  2000  OR  SET-CURSOR ;
: CURSOR      GET-CURSOR  0F0F AND  SET-CURSOR ;
: ACURSOR  <BUILDS , , DOES> ?VMODE 7 = 2* + @ SET-CURSOR ;
0C0D 0607 ACURSOR NORM-CURSOR   020B 0106 ACURSOR BIG-CURSOR
0A0D 0507 ACURSOR MED-CURSOR    R> BASE !
\ dos interface: writing: collapse        ( 20  2 89 crc  7:06 )
FILING FORTH DEFINITIONS  FORGET TASK  here first over - erase
FORTH DEFINITIONS ( : TASK ;)     FILING DEFINITIONS
: WRITING:   R-W  PARSEFILE:  FILE (OPF)  DUP 0<
  IF ABORT"  Open Error" ELSE  ' WHANDLE !  THEN      ;

: COLLAPSE   WHANDLE RHANDLE - IF
  WHANDLE  (CLF) -DUP IF ." Oops! "
  ELSE RHANDLE  ' WHANDLE  !  FILE C/L ERASE  THEN THEN ;

FORTH DEFINITIONS    BASE @ DECIMAL
: DI  DUP 23 + INDEX ;          : CI  SCR @ DI ;
: NI  23 SCR +! CI ;            : TASK ;
EDITOR FLUSH         BASE !


\ virtual access to files, for proms      ( 16  1 89 crc  8:19 )
FILING   ' RHANDLE DROP      DECIMAL   70 NEEDED LINES
0 VARIABLE STARTBLK          9600BAUD
: VC@  \ vaddr -- c | c@ into virtual space
  FUDGE @ +  0 B/BUF U/  STARTBLK @ +  BLOCK  +  C@ ;

CODE ><  AX POP,  AH AL XCHG,  1PUSH

: V@   \ vaddr -- n |  @ into virtual space
  DUP VC@  SWAP 1+  VC@  >< OR  ;

: VIRTUAL    ' V@   CFA 'T@ !   ' VC@ CFA 'TC@  !  ;
: MEMORY     ' (T@) CFA 'T@ !   ' (TC@) CFA 'TC@  !  ;

: SEND  ' SLTYPE CFA  'TYPE !   ' XEMIT CFA 'EMIT ! ;
: SHIP  SEND  LINES LASTLINE ;   VIRTUAL  EDITOR FLUSH
















\ Will Baden Calendar Code                ( 28  8 86 CRC 10:46 )
DECIMAL FORTH DEFINITIONS  FORGET TASK   102 NEEDED ABORT"
( CODE) : UNDER+  ( a b c --- a+c b ) ROT + SWAP ;
\ BX POP,  AX POP,   DX POP,  W DX ADD,  2PUSH

: >DAY  -3 UNDER+   OVER 0< IF 12 UNDER+ 1- THEN   \ dd mm yy
  ( 1900 MOD ) 1461 4 */   SWAP 153 * 2+ 5 / + + ; \ -- d.o.c.

: NEW/FULL      \ day --- semi-lunation age
  1700 25101 OVER >R  */MOD  SWAP R> / ;
                --> ceased to work in late 20th century.
: DATE/MOONPHASE \ centday monthday ---   | Print day/phase
  OVER NEW/FULL IF DROP 3 .R
  ELSE SPACE 1 AND IF ASCII F ELSE ASCII N THEN EMIT
       ASCII M EMIT DROP THEN ;       -->

\ Will Baden Calendar Code                (  5  6 86 CRC  8:59 )
: >DATE  4 U*   1. DMINUS D+ 1461 M/MOD DROP
  SWAP 4 / 1+ 5 * 3 - 153 /MOD   SWAP 5 / 1+  SWAP 3 +
  ROT OVER 12 >  IF -12 UNDER+ 1+ THEN ;

: DOW ( day of cent. --- day of week ) 3 + 0 7 M/MOD 2DROP ;

: MNTH \ y m | build a month name, print it centered in calendar
  <BUILDS ,"
  DOES> COUNT 17 OVER - 2/ TAB TYPE ASCII , EMIT 1900 + 5 .R ;

MNTH JAN January"    MNTH FEB February"    MNTH MAR March"
MNTH APR April"      MNTH MAY May"         MNTH JUN June"
MNTH JUL July"       MNTH AUG August"      MNTH SEP September"
MNTH OCT October"    MNTH NOV November"    MNTH DEC December"
                 -->
\ Will Baden Calendar Code                (  5  6 86 CRC  8:59 )
\ : +days >r >day r> + >date ;

\ : apart >day >r  >day r> - ;

MSSG .SU Sun"  MSSG .MO Mon" MSSG .TU Tues"  MSSG .WE Wednes"
MSSG .TH Thurs" MSSG .FR Fri"  MSSG .SA Satur"

: .DOW    EXEC .SU .MO .TU .WE .TH .FR .SA  STOP

: .MONTH  SWAP 1- EXEC  JAN FEB MAR APR MAY JUN
        JUL AUG SEP OCT NOV DEC STOP  -->
This code treats March as the first day of the year. Thus, 1900
"starts" on 1 March, 1900, and the 0th day of the century is 28
February, 1900. From a handout at Orange County fig, 3, 85.

\ Will Baden Calendar Code                ( 20  2 90 crc 13:13 )
: CALENDAR  \ m y ---  | print out calendar
  LNCTR @ [ 487 7 8 * - ] LITERAL > IF PAGE  LNCTR OFF  THEN
  ?CR OVER 1 12 WITHIN 0= IF ABORT" Month Out of Range" THEN
  2DUP .MONTH CR  2DUP 1 -ROT >DAY  DUP DOW 3 * SPACES
  1 2SWAP 1 UNDER+ >DAY   OVER - 1+ 1
  DO I 3 .R           1+ DUP DOW 0= IF CR THEN LOOP DROP ;
\ DO I DATE/MOONPHASE 1+ DUP DOW 0= IF CR THEN LOOP DROP ;

: MONTHS  0 DO  2DUP CALENDAR  SWAP 1+  DUP 13 =  IF  DROP 1+
  1  THEN  SWAP  ?TERMINAL IF LEAVE THEN  LOOP  2DROP ;

: YEAR  1 SWAP  12 MONTHS ;      -->



\ Will Baden Calendar Code                (  9  2 19 crc 20:50 )
code 3dup  \ a b c --- a b c a b c
\  >r 2dup r -rot r> ;
  ax pop, dx pop, w pop,  w push,  dx push,  ax push,  3push

: TODAY  (GETDATE) 256 /MOD  ROT 1900 -
  >DAY DOW .DOW ." day " .DATE SPACE .TIME SPACE ;

\ : SETDATE SETDATE TODAY ;

: MONTH  (GETDATE) 8 2/S SWAP 1900 -  3 MONTHS CR TODAY ;

-->



\ Will Baden Calendar Code                ( 20  2 90 crc 13:13 )
: pdate         \ d m y  ---  | date pretty printed
  base @ decimal >r  rot  <# 0 $size #> type  \ day
  1900 - .month  r> base ! ;

: .day  3dup 1900 -  >day dow .dow ." day "
  pdate space .time space ;

: ptoday  (getdate)  dup 255 and  swap  8 2/s  rot .day ;
DECIMAL                             ?CR TODAY CR : TASK ;






\ mssg, seq, abort"  words                ( 24  5 88 crc  9:17 )
: SEQ     \ build a control sequence the hard way
  <BUILDS   DOES> COUNT TYPE ;

: ,"  ASCII " WORD HERE C@ 1+ ALLOT ;

: (ABORT")  OK  R> COUNT TYPE  SP! ( HEX ) DECIMAL
  BLK @ IF IN @ BLK @ THEN
  [COMPILE] FORTH  DEFINITIONS  OFFSET OFF QUIT  STOP
' (ABORT") CFA  ' 'ABORT" !   \ allow disassem to catch it
: MSSG  <BUILDS ,"  DOES> COUNT TYPE ;

: ABORT"  COMPILE (ABORT") ,"  ;    IMMEDIATE        ;s  E. G:
: T   IF ABORT" Non-zero number!"  THEN ;
MSSG HI Hi, my name is Fred. "   : HELLO HI ;
SEQ PG   4 C, LI C, ASCII H C, LI C, ASCII J C,  \ VT 52 page
\ Conditional interpretation test screen    17  4 85 CRC
decimal 107 needed iftrue
?CR ." This is always executed."

IFTRUE    CR ." This is the true part of the screen."
OTHERWISE CR ." This is the false part of the screen."
IFEND

CR ." This is always executed."







\ disk blocks present in memory           ( 27  6 90 crc 16:28 )
FORGET TASK   BASE @ HEX   FORTH DEFINITIONS
: PRESENT    \  ---  | lists current blocks in memory
  BASE @ DECIMAL ?CR PREV @ BEGIN
  DUP @  DUP 7FFF AND 6 .R  0< IF ."  updated" THEN  COL
  +BUF 0= UNTIL  DROP  ?CR  BASE ! ;
\ : ?PRESENT  \ blk -- addr or 0 | is given blk here?
\   OFFSET @ + >R  0 PREV @  BEGIN  SWAP OVER @ 7FFF AND  R =
\   IF  R OFFSET @ - BLOCK  ELSE  0  THEN  OR
\   SWAP  +BUF 0= UNTIL R> 2DROP ;
CODE UNUPDATE \  --   | flag current buffer as not updated
  UP #) BX MOV,  OFUSER PREV BX MOV,  7FFF # 0 [BX] AND,  NEXT
\ : EMPTY-BUFFERS   EMPTY-BUFFERS  PREV @
\   BEGIN  7FFF OVER !  +BUF 0= UNTIL  DROP ;
DECIMAL  PRESENT  BASE !                : TASK ;

\ will baden's square root                ( 16  2 89 crc  8:26 )
: SQRT \ n1 --- n2 | calculate square root of n1. good to 180
  -1 SWAP OVER DO 2+ DUP +LOOP 2/ ;
BASE @ HEX
: USQRT \ n1 --- n2 | calculate square root of n1. good to 256
  -1 SWAP 8000 - 7FFF DO 2+ DUP +LOOP 2/ ;
BASE !
: DSQRT \ d1 --- n2 | calculate square root of d1. good to 65536
  DROP USQRT ;

: TST  \ n --  | test square root to n squared
  ?CR  0 DO I DUP 6 .R  DUP *  DUP 7 U.R  USQRT  I -  COL
     IF I 5 .R   ABORT"  Square Root Failed"  THEN
     ?TERMINAL IF LEAVE THEN  LOOP ;
EDITOR FLUSH

\ module creation code -- internal externa( 20 10 85 CRC       )
\ 1 CONSTANT TRUE                  0 CONSTANT FALSE

: INTERNAL \   --- dest | begin code to hide later on
  ?EXEC     LATEST    ;   IMMEDIATE

: EXTERNAL \   --- src  | end code to hide
  ?EXEC     HERE   2+ ;   IMMEDIATE \ skip see: field

: MODULE   \ dest src ---  | hide the stuff
  ?EXEC     PFA LFA ! ;   IMMEDIATE
;S
: ON       \ addr ---  | turn a flag on
  TRUE  SWAP ! ;

: OFF  FALSE SWAP ! ;
\ Conditional interpretation              ( 30  7 90 crc 13:08 )
DECIMAL FORTH DEFINITIONS 106 NEEDED MODULE
INTERNAL 0 VARIABLE FLAG     LATEST
: IFEND     FLAG ON ;        ' IFEND LFA
: OTHERWISE IFEND   ;
: X        23  ERROR ;     \ all nulls are off screen!!
  128 LATEST 1+ C! \ makes it into the null word!!
LATEST ROT CURRENT @ ! SWAP OFF \ instant hidden vocabulary!
EXTERNAL SWAP   \ pointer to nfa of of null on top of stack
: OTHERWISE  \  ---  | scan until terminator found
  FLAG OFF BEGIN [ ROT ] BEGIN [ ROT ]  BL WORD   HERE LITERAL
  (FIND) UNTIL DROP CFA EXECUTE FLAG @ UNTIL  [ 2 CSP +! ] ;
: IFTRUE \ fl --- | scan if false, else interpret
  0= IF OTHERWISE THEN ;
: IFEND  ; (  placeholder )      MODULE   \ hide it!
: IFDEF  -FIND DUP  IF  NIP NIP  THEN ;
\ disk re-arrangement code                ( 10  6 86 CRC 10:51 )
BASE @ DECIMAL  DISKING DEFINITIONS
B/DRV    VARIABLE TOBLK       \ disk re-arrangement
: SKIP   EDITOR NEXT BOTTOM ;
: SEND SCR @ TOBLK @ EDITOR COPY TOBLK 1+! SKIP ;
: REP   DUP B/DRV  + EDITOR COPY ;
: ALLOT  TOBLK +! ;             : START B/DRV + TOBLK ! ;
: STDBUFS  FLUSH  60 +ORIGIN @ 'FIRST ! SETU/P ;
: MAXBUFS  LIMIT DUP PAD - 0  B/BUF 4 + U/ NIP
  B/BUF 4 + U* DROP  - 'FIRST ! EMPTY-BUFFERS FLUSH ;
: BACKING  FLUSH  MAXBUFS 1+ SWAP ?CR DO FORTH I DUP DUP
   ?TERMINAL IF LEAVE THEN       \  from to --- | disk copy
   #BUFS  MOD 0= IF FLUSH THEN  4 .R REP
   OUT @ C/L > IF CR THEN LOOP  STDBUFS FLUSH ;
: BACKUP   0 B/DRV 1- BACKING ;
FORTH DEFINITIONS   DISKING BASE !
\ Memo  Application                       ( 13  6 86 CRC 15:00 )
FORTH DEFINITIONS  BASE @ DECIMAL
: DOSCREEN  \ screen  DOSCREEN
  16 1 DO DUP I SWAP 7 SPACES .LINE CR LOOP DROP ;

: MEMO     \ Prints three screens a memo     ( screen-1 -- )
  5 VTAB CR 3 / 3 * DUP 3 + SWAP
  DO I DOSCREEN LOOP CR ?CRT 0= IF PAGE THEN ;

: REVIEW   \ Prints three screens for review ( screen-1 -- )
  ?CRT IF PAGE 5 VTAB CR
  3 / 3 * DUP 2+ SWAP BEGIN DUP
  DOSCREEN 2DUP - WHILE DUP  4 .R ."   continue " KEY DROP
  1+ 15 0 DO 8 EMIT LOOP EDITOR ERL REPEAT CR 2DROP THEN ;
BASE     !

\ Disking Extensions: Bulkclear           ( 24 10 85 CRC       )
BASE @ DECIMAL DISKING DEFINITIONS      \ See the RF manual
: BULKCLEAR  ?CR  \  from-2  to-1  wipe-screens
  FIRST HERE - 1094 U< 2 ?ERROR 0 PAD DUP B/BUF BLANKS !
  1+  SWAP DO PAD FORTH I DUP 6 .R OFFSET @ + 0 R/W
  ?CR  LOOP  ;

: CLEARDISK  B/DRV MAXBLK BULKCLEAR ;

        FORTH DEFINITIONS        DISKING       BASE !  ;S
     Use  BULKCLEAR to put sector information on a new disk or
to clean out a series of screens on an otherwise useful disk.
To put new sector information on a new disk, first initialise it
using  INIT , then (while it is still in 1 drive), type:
   CLEARDISK

\ More Will Baden Calendar: New Moon      (  5  7 86 CRC 12:25 )
: NEW/FULL  \ day --- semi-lunation age
  1700 25101 OVER >R  */MOD  SWAP R> / ;

: DATE/MOONPHASE  \ centday monthday ---   | Print day/phase
  OVER NEW/FULL IF DROP 3 .R
  ELSE SPACE 1 AND IF ASCII F ELSE ASCII N THEN EMIT
       ASCII M EMIT DROP THEN ;                 ;S

: CALENDAR  \ m y ---  | print out calendar
  DO I NEW/FULL 1+ DUP DOW 0= IF CR THEN LOOP DROP ;
  DO I 3 .R 1+ DUP DOW 0= IF CR THEN LOOP DROP ;

: TUCK  SWAP OVER ;


\ Hard disk support                       ( 26 10 86 CRC 14:11 )
FILING  SETDRIVE: C  R-W LS *.SCR  FILING DEFINITIONS
  \  open file & set lseek first. Close when done!
: >FILE  \ blk# ct  ---  | write to file from disk
  EMPTY-BUFFERS FLUSH
  BOUNDS ?CR DO  I 5 .R  I BLOCK B/BUF HANDLE WTF
  DUP B/BUF - IF 6 .R ABORT"  Disk Error! "  ELSE DROP THEN
  ?TERMINAL IF LEAVE THEN ?STACK  LOOP ;

: FILE>  \ blk# ct  ---  | write to disk from file
  EMPTY-BUFFERS FLUSH
  BOUNDS ?CR DO  I 5 .R  I OFFSET @ + BUFFER B/BUF HANDLE RDF
  DUP B/BUF - IF 6 .R ABORT"  Disk Error! "  ELSE DROP THEN
  ?TERMINAL IF LEAVE THEN ?STACK  UPDATE LOOP  FLUSH ;
FORTH DEFINITIONS  EDITOR FLUSH FILING

\ times code: repeat a given word         ( 21  3 90 crc 11:23 )
DECIMAL FORTH DEFINITIONS   54 NEEDED FOR
CODE I'  2 [RP] PUSH,  NEXT

\  CODE R>DROP    RP INC, RP INC,  NEXT
CODE R>DROP    ' ;S 3+  LATEST PFA CFA !

: TIMES \ ct ---  | execute next cfa ct times
  R @ >R  2- FOR I' EXECUTE  NEXT  R>DROP ;

: T  1 5 TIMES 2* ;
EDITOR FLUSH




\ BSP product labels runoff code            31 03 82 CRC
BASE @  DECIMAL
: .LAB  115 .LINE SPACE ;

: .BOOT   6 0  DO  I  1+ CR  .LAB  LOOP ;

: .CODE   6 0  DO  I  7 + CR .LAB  LOOP ;
                                  \ vmargin reset
: .LABELS   VMARGIN @  VMARGIN OFF  SWAP
      0  DO  I 4 .R  NEC .BOOT  .CODE OK  LOOP VMARGIN !  ;

BASE !




\ BSP product labels runoff code            31 03 82 CRC

        Blue Sky Products
            fig-FORTH
            BOOT DISK

Copyright 1982, Blue Sky Products

        Blue Sky Products
            fig-FORTH
           FORTH DISK

Copyright 1982, Blue Sky Products



\ Disking: check  range  verify           ( 14  4 19 crc 23:03 )
BASE @ HEX DISKING DEFINITIONS
: CHECK \  scr-2 scr-1 --   | check a screen against another
   2dup block @   swap block  @  or if
   2DUP BLOCK B/BUF  ROT BLOCK EDITOR -CSTEXT
   -DUP IF 0< IF SWAP THEN  9 .R 7 .R ELSE 2DROP THEN
   else 2drop then ;
: VERIFY ?CR  \ St-3 Compareto-2 cnt-1 | over a range of scrs
   BOUNDS DO I OVER CHECK 1+ ?TERMINAL IF LEAVE THEN
   ?STACK  LOOP  DROP ;

: VERIFYDISK   EDITOR FLUSH DISKING B/DRV 0 OVER  VERIFY ;

\ : 3DUP   >R 2DUP R -ROT R> ;  \ code def. in calendar code
\ : COPIES  3DUP COPIES 2DROP VERIFY ;  \ requires hdisk util!!
BASE !
\ Brodie Doer/Make code                   ( 23  3 86 CRC 18:59 )
\ From Brodie, Thinking FORTH, pg 276 et seq. Public domain.
DECIMAL DEBUG       \ real-FORTHed by CRC.
0 VARIABLE MARKER   \ N.B. This stuff is not ROMable.

: DOER  <BUILDS ' | , DOES> @ >R  ;

: (MAKE)  R> DUP 2+ DUP 2+ SWAP @ 2+ !
  @ -DUP IF >R THEN  ;

: MAKE  STATE @  IF COMPILE (MAKE)  HERE MARKER ! 0 ,
   ELSE HERE [COMPILE] ' ! SMUDGE [COMPILE] ] THEN ; IMMEDIATE

: ;AND  COMPILE ;S  HERE MARKER @ ! ; IMMEDIATE

: UNDO  [ ' | CFA ] LITERAL [COMPILE] ' ! ;   -->
\ Brodie Doer/Make code                   ( 23  3 86 CRC 18:59 )
DOER WHY?
: RECITAL
  CR ." Your daddy is standing on the table. Ask him 'Why?' "
  MAKE WHY? ." To change the lightbulb."
       BEGIN
  MAKE WHY? ." Because it's burnt out."
  MAKE WHY? ." Because it was old."
  MAKE WHY? ." Because we put it in there a long time ago."
  MAKE WHY? ." Because it was dark!"
  MAKE WHY? ." Because it was night time!!"
  MAKE WHY? ." Stop saying WHY?"
  MAKE WHY? ." Because it's driving me crazy."
  MAKE WHY? ." Just let me change this light bulb!"
     AGAIN  STOP
: WHY?  WHY? QUIT STOP
\ Other Brodie useful code                ( 23  3 86 CRC 19:04 )
CODE EXIT ' ;S CFA @ LATEST PFA CFA !

: \S  B/BUF IN ! ;

: FH   BLK @ -DUP 0= IF SCR @ THEN + ;

CODE LEAP   4 # RP ADD,  ' ;S CFA @ #) JMP,








  fig-FORTH decompiler: messages          (  6 12 90 crc 13:34 )
     User variable, current value = D
     Variable, current value      = D
     Constant = D
     ?? Not in dictionary ??
  <primitive>
      Branch on 0 to:
      Unconditional branch to:
      Loop back to:
      +Loop back to:
      Print compiled inline string:
      Inline literal, value        = D
 in-line cfa                     = $
  Disassembled:
 >>  Immediate  <<
      OF branch (if equal) to:
\ fig-FORTH decompiler: load              (  9  7 88 crc 15:22 )
0 VARIABLE ?QUIT                0 VARIABLE IP

0 CONSTANT 'ABORT"

: !QUIT!  1 ?QUIT ! ;

BASE @ >R  DECIMAL
: IP@+   IP @ 2 IP +! ;

: .LABEL  [ BLK @ 1- ] LITERAL .LINE SPACE ;

: N.            \ print a number in both hex and decimal
                BASE @ SWAP  DUP  DECIMAL 7 .R
                HEX  ."  $ " 5 U.R   BASE ! ;
BLK @ 1+ DUP 3 + THRU  R> BASE !
\ fig-FORTH decompiler:    pdotq          (  7  3 90 crc 12:29 )
: DISP  DUP T@ N. 4 SPACES 2 LASCI ;

: .LIT  11 .LABEL  IP@+  DISP  ;

: .CLIT 11 .LABEL IP @  IP 1+!
   DUP TC@ SEXT N.  4 SPACES 1 LASCI ;

: PDOTQ         \ display inline text string
  IP@+ COUNT DUP 1- IP +! TYPE  ASCII " EMIT ;

: PABORTQ  ."  Abort " [ ASCII " HERE 1- C! ] PDOTQ  ;

: VECTORS  \ addr ---  | print out name of word in vector
  @ 2+ NFA AID. ;

\ fig-FORTH decompiler: branch uservar      07 08 84 CRC
: WORD.         \ given a cfa, display name field, if any
        DUP 2+ DUP LFA 1- TC@ 128 AND IF   NFA  AID.
            ELSE CFA 5 U.R ."  <orphan>"  THEN
        [ ' ;S CFA    ] LITERAL =  IF !QUIT! THEN ;

: BRANCHSHOW        \ calculate the target address & show it
                  IP@+    \ branches occupy 2 cells
                  DUP T@ +  5 U.R ;

: USERV  1 .LABEL TC@ 16 +ORIGIN @ + DISP  ;

: ENDER  IP@+ 2- T@ WORD. !QUIT! ;



\ fig-FORTH decompiler: variable constant ( 23  7 88 crc 17:55 )
: VAR              2 .LABEL  DISP   ;

: CONST            3 .LABEL  DISP   ;

: COMP  IP @ 2- T@ 2+ NFA AID.   12 .LABEL
        SPACE IP@+ T@ 2+ NFA ID. ;

: .PSCODE
  IP @  [ ' DOES> 6 + @ ] LITERAL  OVER 1+ T@  - 3 - =
  IF 3 IP +! 7 SPACES ." DOES>"  ELSE
      IP @ 2- T@ WORD. !QUIT!  IP@+ DISASSEM THEN ;




\ fig-FORTH decompiler: begin un:         (  9  7 88 crc 15:22 )
: (UN:)   HOMESEG ?QUIT OFF  IP ! \ addr --  | decompiled code
    BEGIN  IP@+  DUP HEX 0 5 D.R  SPACE   T@   CASE
[ ' LIT      CFA ] LITERAL OF               .LIT        ENDOF
[ ' CLIT     CFA ] LITERAL OF               .CLIT       ENDOF
[ ' 0BRANCH  CFA ] LITERAL OF  6 .LABEL     BRANCHSHOW  ENDOF
[ ' BRANCH   CFA ] LITERAL OF  7 .LABEL     BRANCHSHOW  ENDOF
[ ' (LOOP)   CFA ] LITERAL OF  8 .LABEL     BRANCHSHOW  ENDOF
[ ' (+LOOP)  CFA ] LITERAL OF  9 .LABEL     BRANCHSHOW  ENDOF
   LIT (OF)                OF 15 .LABEL     BRANCHSHOW  ENDOF
[ ' (.")     CFA ] LITERAL OF 10 .LABEL     PDOTQ       ENDOF
[ ' COMPILE  CFA ] LITERAL OF               COMP        ENDOF
[ ' (;CODE)  CFA ] LITERAL OF               .PSCODE     ENDOF
[ ' QUIT     CFA ] LITERAL OF               ENDER       ENDOF
[ ' @EXECUTE CFA ] LITERAL OF               ENDER       ENDOF
[ ' ABORT    CFA ] LITERAL OF               ENDER    ENDOF -->
\ fig-FORTH decompiler:  end un:          (  9  7 88 crc 15:21 )
  'ABORT"                  OF               PABORTQ       ENDOF
   DUP WORD.  ENDCASE ?CR   ?QUIT @ ?TERMINAL OR  UNTIL   ;
: DEFINED  \ pfa -- | decompile does> portion of word
  ." Defined Word Does>"  CR CFA @ 3 + (UN:) ;
: TESTCFA  CFA @ CASE  \ pfa -- | check for type of word
[ ' IP     CFA @ ] LITERAL OF  CR         VAR           ENDOF
[ ' C/L    CFA @ ] LITERAL OF  CR         CONST         ENDOF
[ ' BASE   CFA @ ] LITERAL OF  CR         USERV         ENDOF
[ ' QUIT   CFA @ ] LITERAL OF  CR         (UN:)         ENDOF
                    C@ 232 OF             DEFINED       ENDOF
  SWAP  2- T@ DISASSEM  ENDCASE  ;
: UN:    HOMESEG BASE @ HEX  -FIND 0= IF 4 .LABEL  CR
    ELSE  C/L AND IF 14 .LABEL  THEN
      DUP DUP  NFA  CR  SPACE ID. 13 .LABEL
      TESTCFA  THEN CR BASE ! ;
\    .!  -- Diskdir                       ( 25  9 85 CRC       )
  BASE @  DECIMAL   DISKING DEFINITIONS
: REDISK ( MAXBUFS B/DRV 0) ?CR DO I DUP BLOCK DROP UPDATE 4 .R
     ?TERMINAL IF LEAVE THEN LOOP FLUSH STDBUFS ;

: EXERCISE  1 DO  0 I BLOCK DROP UPDATE
    ?TERMINAL IF LEAVE THEN LOOP FLUSH ;


FORTH DEFINITIONS   BASE   !






( Substitute CREATE for auto sourcecode li(  9  4 90 crc 13:22 )
   BASE @ HEX       ' (CREATE) CFA  'CREATE !
: WHERENOW      ( line start & blk compressed for storage )
   BLK @  10 *  IN @ C/L /  OR ;
: WHERETHEN     ( unpack line# & blk :   ---  r#-2  scr-1 )
   DUP -10 AND  10 /   SWAP 0F AND C/L * ;

: NEWCREATE  2 ALLOT  (CREATE) WHERENOW  LATEST 2- !
    OUT @ C/L >  IF CR  THEN ;     ' NEWCREATE CFA 'CREATE !

: SEE:  -FIND IF DROP DUP [ LATEST  3 - ] LITERAL
   U<  IF  ." kernel " DROP  ELSE
   NFA 2- @ WHERETHEN R# ! EDIT  THEN
   ELSE 0E MESSAGE  4 SPACES THEN ;

: FORGET  FORGET -2 ALLOT  ;            HERE FENCE ! BASE !
\ pick & roll in code                     (  1  3 86 CRC 11:32 )
CODE ROLL    CX POP,  CX W MOV,  W SHL,  SP W ADD,
  -2 [W] W LEA,  0 [W] PUSH,
  DO,  -2 [BX] AX MOV,  AX 0 [BX] MOV,  BX DEC,  BX DEC,  LOOP,
  AX POP,  NEXT

CODE 4DUP   AX POP,  DX POP,  BX POP,  CX POP,
  CX PUSH,  BX PUSH,  DX PUSH,  AX PUSH,  CX PUSH,  3PUSH

EDITOR FLUSH             ;S
               \ removed to kernel
CODE PICK    W POP,  W SHL,  SP W ADD,  -2 [W] PUSH,  NEXT




\ ?key <key> keycode ktime                ( 15 12 89 crc 10:09 )
BASE @  HEX        0 VARIABLE KEYCODE    0 VARIABLE KTIME

CODE ?KEY  \   --- fl | is there a key ready?
  28 INT,  \ idle interrupt. let tsrs have a go!
  KEYCODE #) AL MOV,  0 # AL CMP,   0= IF, DROP  1 # AH MOV,
  16 INT,  0= IF,  0 # AX MOV,  ELSE, ROT 2 THEN, \ Unstructured
  1 # AX MOV,  THEN,  1PUSH

CODE <KEY>   \  -- chr | get character from wherever
  KEYCODE #) AL MOV,  0 # AL CMP,
  0= IF,  7 # AH MOV,  21 INT,  0 # AL CMP,
     0= IF,  21 INT,  ASCII S # AL CMP,      \ fake real del key
        0= IF,  7F # AX MOV,  1PUSH  THEN,
     AL KEYCODE #) MOV,  AX AX SUB,  THEN,  AH AH SUB,
  ELSE,  AH AH SUB,  AH KEYCODE #) MOV,  THEN,  1PUSH  -->
\ keymode .clock tkey okey (tkey)         ( 26  2 90 crc 10:52 )
CODE KEYMODE  \  ---  stat | get keyboard mode
  40 # AX MOV,  AX ES MOV,  ES: 17 #) AL MOV,  1PUSH
DECIMAL
: .CLOCK     \ oldtime --- new | showtime
  DUP (GETTIME)  NIP - IF OUT @  XY@  GET-CURSOR NO.CURSOR
  0 72 GOTOXY .TIME  1 72 GOTOXY .DATE
  2 72 GOTOXY   ." Caps o"
     KEYMODE C/L AND IF ." n " ELSE ." ff" THEN
  SET-CURSOR  GOTOXY  OUT ! DROP (GETTIME) NIP THEN  ;

: (TKEY)  KTIME @ BEGIN  PAUSE  ?KEY 0= WHILE  .CLOCK  REPEAT
  KTIME ! <KEY> ;

: OKEY  [ ' (KEY)   CFA ] LITERAL 'KEY ! ;
: TKEY  [ ' (TKEY)  CFA ] LITERAL 'KEY ! ;    TKEY   BASE !
\ clock stuff: primitives                 ( 10  7 88 crc 17:03 )
BASE @ >R  HEX
CODE (GETTIME) \   ---  n | n is bit packed time from rtc
  DX DX XOR,   DX CX MOV,  2C # AH MOV,  21 INT,
  CX PUSH,  DX PUSH,    NEXT

BLK @ 1+ DUP 2+ THRU   BLK @ 2- LOAD    R> BASE !       ;S

CODE (SETTIME) \ d  --- | d is byte packed time to rtc
  CX POP,  DX POP,  2D # AH MOV,  21 INT,  CBW,  1PUSH

CODE (SETDATE) \ dd mm yy --- | send to sytem to set date
  CX POP, 76C # CX ADD,  AX POP,  DX POP,  AL DH MOV,
  2B # AH MOV,  21 INT,  NEXT


\ clock stuff: settime                    ( 10  7 88 crc 17:03 )
: $SIZE  BL HOLD OVER 0A < >R #S R> IF BL HOLD THEN ;

CODE (GETDATE) \   ---  n | n is bit packed date from rtc
  DX DX XOR,   DX CX MOV,  2A # AH MOV,  21 INT,
  CX PUSH,  DX PUSH,    NEXT

70 USER (STAMP)         ;s

: H/M  0 0 ROT (NUMBER) NIP DUP C@ ASCII : - 0 ?ERROR ;

: SETTIME  \  ---  | n is packed time for rtc
  BASE @ >R  DECIMAL  BL WORD  HERE  H/M  H/M
  0 0 ROT (NUMBER) 2DROP  100 *  ROT 100 *
  ROT OR  R> BASE ! (SETTIME)  0 ?ERROR ;

\ clock stuff: (date) stampdate setdate   ( 14  1 88 crc 13:23 )
: (DATE)     \   ---  addr ct | date ready for printing
  BASE @ DECIMAL >R (GETDATE) <# SWAP 0 # #  2DROP  100 /MOD
  0 $SIZE 2DROP  0 $SIZE  #> R> BASE ! ;

: STAMPDATE (DATE) (STAMP) 2+ SWAP CMOVE ;
      \          | <--------  optional  ---------> |
: .DATE  (DATE)  OVER ASCII / SWAP 2+ 2DUP 3 + C! C! TYPE ;
;s
: SETDATE  \  ---  | convert trailing $ to date & set sys date
  BASE @ DECIMAL
  BL WORD 0 0 HERE (NUMBER) 2DROP               \ day
  BL WORD 0 0 HERE (NUMBER) 2DROP               \ month
  BL WORD 0 0 HERE (NUMBER) 2DROP  DUP 50 < IF  64 + THEN
  ( year)   (SETDATE) BASE ! ;

\ clock stuff: gettime .time stamptime    (  8  1 88 crc       )
: GETTIME      \   ---  addr ct | time ready for printing
  BASE @ DECIMAL (GETTIME) <#  100 / 0 # #  ASCII : HOLD 2DROP
  100 /MOD SWAP 0 # # 2DROP  ASCII : HOLD
  0 OVER 0A < >R #S R> IF BL HOLD THEN #>  ROT BASE ! ;

: .TIME  GETTIME TYPE ;

: STAMPTIME GETTIME 3 - (STAMP) 0F + DUP 5 BLANKS SWAP CMOVE ;

: SETSTAMP   STAMPDATE STAMPTIME ;
 ;S  debug tools
\ : T SETTIME .TIME SPACE .DATE ;

: TEMPUS  BEGIN CR .TIME SPACE .DATE ?TERMINAL UNTIL ;

\ dos interface: setdefault file handle   ( 20  3 90 crc  8:26 )
FORGET TASK     base @ decimal  107 needed iftrue
VOCABULARY FILING IMMEDIATE     FILING DEFINITIONS      hex
CODE (SETDEF) \  n (0-15) ---  | set the default drive
  DX POP,   0E # AH MOV,  21 INT,  NEXT
FORTH DEFINITIONS
: SETDRIVE:  [COMPILE] CTL  1- FILING (SETDEF) ;

FILING DEFINITIONS                0 VARIABLE FLCT 0 ,
0 VARIABLE DTA 29 ALLOT           0 VARIABLE FILE C/L 2- ALLOT
0 VARIABLE PATH 3E ALLOT          0 CONSTANT HANDLE
0 VARIABLE (ATT)
0 VARIABLE DMY  -2 ALLOT ASCII * C, ASCII . C,  ASCII * C, 0 C,
BLK @ 1+ DUP 0C + THRU ( DECIMAL 112 LOAD )  BASE !
FORTH DEFINITIONS  : TODAY  TODAY  FILING .FILENAME  SPACE ;
: TASK ;   EDITOR FLUSH   FILING
\ dos interface: getpath (del)            (  2  7 90 crc  9:41 )
CODE GETPATH  \ addr drive  ---  | get current path name
  DX POP,  IP AX MOV,  IP POP,  AX PUSH,
  47 # AH MOV,  21 INT,  IP POP,  NEXT

CODE (DEL) \ addr --- ec | unlink file at addr
  DX POP,  41 # AH MOV,  21 INT,
  U< IF,  AX NEG,  ELSE,  AX AX SUB,  THEN,  1PUSH

CODE +DTA  \ offset -- addr  | return dta address
  AX POP,  DTA # AX ADD,  1PUSH

CODE (REN) \ addrO addrN --- ec | rename Old to New
  DI POP,  DX POP,   56 # AH MOV,  21 INT,
  U< IF,  AX NEG,  ELSE,  AX AX SUB,  THEN,  1PUSH

\ free: omax -0s : mess-dos interface     ( 26  7 90 crc 10:10 )
0 VARIABLE OMAX                 0 VARIABLE OR/W

CODE <FREE>  \ dr --  <data>  | dr: 0=current, 1=A, etc.
  DX POP,  36 # AH MOV,  21 INT,
  BX PUSH,  CX PUSH,  1PUSH

: (FREE)   <FREE>  * M*  D. ." Bytes free" ;

: FREE: [COMPILE] CTL (FREE) ;

CODE -0S  \ addr ct -- addr ct' | strip trailing 0s
  W POP,  DI POP,  AL AL SUB,
  BEGIN,  AL -1 [BX+DI] CMP,  0= IF,  >R >R  BX DEC,  0= UNTIL,
  R> R> THEN,  DI PUSH,  W PUSH,  NEXT

\ dos interface: (crf) (opf) (clf)        ( 14  2 89 crc  8:09 )
CODE (CRF) \ addr --- ec | create file at addr
  (ATT) #) CX MOV,  DX POP,   3C # AH MOV,  21 INT,
  U< IF,  AX NEG,  THEN,  1PUSH

\  CODE (OPF) \ addr --- handle/ec | open file at addr
\    DX POP,   3D02 # AX MOV,  21 INT,
\    U< IF,  AX NEG,  THEN,  1PUSH

CODE (CLF) \ handle --- ec | close file at handle
  BX POP,  4 # BX CMP,  U> IF, >R >R   3E # AH MOV,  21 INT,
  U< IF,  AX NEG,  ELSE, R> R> THEN,  AX AX SUB,  THEN,  1PUSH

: CT->0   DUP BEGIN  DUP C@  WHILE 1+  REPEAT  OVER - ;


\ dos interface: rdf wtf                  ( 16  6 93 crc 20:32 )
: FNAM:  BL WORD HERE COUNT 2DUP UPPER ; \ condition a file name

CODE TRDF  \ addr count handle --- ct/er | read from addr for
    \ count bytes to file/handle. Return count read or error.
  3F # AH MOV,  BEGIN,
  FORTH SEG ASSEMBLER #) DX MOV,  DX DS MOV,
  BX POP,  CX POP,  DX POP,   21 INT,
  U< IF,  AX NEG,  THEN,  CS DX MOV,  DX DS MOV,  1PUSH

CODE TWTF  \ addr count handle --- ct/er | write from addr for
    \ count bytes from file/handle. Return count written or erro
  40 # AH MOV,  AGAIN,



\ dos interface: (sfirst) setdta snext    ( 15  3 90 crc 12:19 )
CODE SETDTA \  -  | tell os where to put dir stuff
  DTA # DX MOV,  1A # AH  MOV,  21 INT,   NEXT    SETDTA

CODE (SFIRST) \ addr --- fl | get file entry to dta
  (ATT) #) CX MOV, ( file attribute)  DX POP,  4E # AH MOV,
  21 INT,  U< IF,  AX NEG,  THEN,  1PUSH

CODE (SNEXT)    \  -- fl | get next entry after sfirst
 4F # AH MOV,  21 INT,  U< IF,  AX NEG,  THEN,  1PUSH

: SNEXT  1E +DTA 0D BLANKS  (SNEXT) ;
: SFIRST  SETDTA  1E +DTA 0D BLANKS  (SFIRST) ;

CODE SYNCH      \ --  | force files flush to disk
  0D # AH MOV,  21 INT,   NEXT
\ dos interface: setdir lseek             ( 28  2 91 crc 17:36 )
CODE (SETDIR) \ addr --- fl | set dir to given path
  DX POP,  3B # AH MOV,  21 INT,  U< IF,  AX NEG,
  ELSE,  AX AX XOR,  THEN,  1PUSH
\ Don't forget the  \ as part of the pathname!!
: SETDIR:    \ txt ---  | set current subdirectory
  PATH C/L ERASE   FNAM:  PATH SWAP CMOVE  PATH (SETDIR)
  -DUP 0< IF 6 .R  SPACE  PATH C/L -0S TYPE
    ABORT"  Bad Directory name" THEN ;

: ATTRIBUTE  <BUILDS  C,  DOES> C@ (ATT) ! ;
;s      \ type: 0= from start 1= rel to current  2=from end
CODE LSEEK   \ dfaddr handle type --- fl/dfaddr |
  AX POP,  ( type )  BX POP, \ handle
  CX POP,  DX POP,  ( dfaddr)   42 # AH MOV,  21 INT,
  U< IF,  AX NEG,  1PUSH  THEN,  DX AX XCHG,  2PUSH
\ dos interface: (fr/w) curdrv            (  9  2 89 crc 10:59 )
CODE CURDRV  \  -- n | return current drive, 0-0f
  19 # AH MOV,  21 INT,  AH AH SUB,  1PUSH

: (CHR)  \  chr --   | massage pointers for form control
            DUP CTL J = IF  8 LNCTR +!   ELSE
            DUP CTL L = IF    LNCTR OFF  THEN THEN ;

: TYPE>0   BEGIN  DUP C@  -DUP WHILE  EMIT 1+  REPEAT  DROP ;
;S
: (FR/W)   \ addr blk# r/w ---  | r/w for a file once opened
  HANDLE IF >R B/BUF U* HANDLE 0 LSEEK
      0< IF ABORT"  File Seek Error" THEN  DROP
      B/BUF HANDLE R> IF RDF ELSE WTF THEN
      B/BUF - IF ABORT"  File Size Overflow" THEN
    ELSE ABORT"  File not open!!" THEN ;
\ dos interface: parsefile sfirst         (  2  7 90 crc  9:41 )
: PARSEFILE: \ txt ---  | set file name up for dos in  file
  FILE C/L ERASE FNAM:  FILE SWAP CMOVE ;   PARSEFILE: RF.SCR

: SFIRST: \  -- fl | get first instance of file in dir
  PARSEFILE:  FILE SFIRST ;

: (FEMIT)  \ char ---  | send to an open file
  HANDLE IF (CHR)  SP@ 1 HANDLE WTF
    1- IF OK ?CR 6 .R ABORT" File write error"  THEN  DROP
  ELSE OK ?CR ABORT" No output file open" THEN ;

: RENAME:   \  --- ?ec | rename file1 to file2
  FILING PAD C/L ERASE FNAM:  PAD SWAP CMOVE  FNAM:  DROP
  PAD SWAP  (REN)  -DUP  IF HEX . ABORT"   Oops!"  THEN ;

\ .fmod delete: anentry                   ( 22  6 92 CRC 12:47 )
: .BIT  \  d c -- d'  | add c to $ under const iff d is odd
  >R 2 M/MOD ROT R> SWAP 0= IF DROP ASCII - THEN HOLD ;
: .FMOD  \  m ---  | print a file's mode
  0  <#  ASCII w .BIT  ASCII h .BIT  ASCII s .BIT
  ASCII v .BIT  ASCII d .BIT ASCII m .BIT  BL HOLD #>  TYPE ;

: ANENTRY       \  --- | print directory entry
  BASE @  DECIMAL   1E +DTA 0D TYPE
  1A +DTA 2@ 2DUP 0A D.R  HEX 2DUP  8 D.R  FLCT 2@  D+  FLCT 2!
  15 +DTA C@ .FMOD  BASE !  COL ;

: RM:   \  ---    | Delete an existing file. "Unlink"
  0 FNAM: + !  HERE 1+ (DEL)
  -DUP IF 6 .R ABORT"  File Delete Error" THEN ;
: .FILENAME   FILE TYPE>0 ;
\ dos interface: ls .path                 ( 15  3 90 crc 12:54 )
: .PATH: \   ---    | print pathname on given drive
  HERE  DUP [COMPILE] CTL  GETPATH   TYPE>0 ;

FORTH DEFINITIONS
: LS    \  ---  | print out a directory
  FILING  FLCT 4 ERASE  BLK @ -DUP IF BLOCK ELSE  TIB @  THEN
  IN @ + C@ IF BL WORD HERE COUNT OVER + 0 SWAP !  ELSE DMY THEN
  ?CR  DUP SFIRST 0= IF  BEGIN  ANENTRY  SNEXT UNTIL THEN
  ?CR  FLCT 2@ D.   ." Bytes Total "
  COL  DUP 1+ C@  ASCII : = IF  C@  1F AND  ELSE  DROP 0  THEN
  DUP (FREE) COL  HERE SWAP GETPATH  HERE TYPE>0  ;     FILING

1 ATTRIBUTE R-O        2 ATTRIBUTE HIDDEN    4 ATTRIBUTE SYSTEM
8 ATTRIBUTE W/VOL      0 ATTRIBUTE R-W       -1 ATTRIBUTE ALL
R-W                           FILING DEFINITIONS
\ dos interface: mkf: opf: clf            ( 11  4 19 crc 21:00 )
: MKF:          \   --- er# | create a file w/ given name
  HANDLE IF ABORT" File Open " ELSE PARSEFILE: FILE (CRF)
  DUP 10 .R DUP 0< 0= IF ' HANDLE ! THEN THEN ;

: OPF:          \   --- er# | open a file w/ given name
  HANDLE IF ABORT"  File already open" THEN PARSEFILE:
  FILE (OPF) DUP 0< 0= IF ' HANDLE ! THEN ;

: CLF   HANDLE -DUP IF (CLF) -DUP IF ." Oops! "
  ELSE ' HANDLE OFF  FILE C/L ERASE  THEN THEN ;

FORTH DEFINITIONS
: OUTFILE  FILING HANDLE 0= IF ABORT" No file open! " THEN
        OUTPUT> (FEMIT) (TYPE)  2DROP
            PRINTER                    PPAGE   NLIST  PCR  STOP
\ dos interface: .file hd: using: cold    ( 21  4 89 crc 10:59 )
FORTH DEFINITIONS
: .FILE: FILING  \   ---  | file printed out
  MKF: HANDLE IF ?CR BEGIN  PAD B/BUF HANDLE RDF
  PAD OVER TYPE  B/BUF - ?TERMINAL OR UNTIL THEN CLF ;

: HD:           \   ---  | (hex) dump a file
  FILING OPF:  HANDLE IF HOMESEG  PAD FUDGE !  0
  BEGIN PAD 100 HANDLE RDF 2DUP DUMP
    -100 FUDGE +! >R 100 + R> 100 - ?TERMINAL OR UNTIL
  FUDGE OFF  THEN CLF DROP ;

: USING:  FILING   RHANDLE (CLF) -DUP IF . ABORT"  oops"  THEN
  R-W  PARSEFILE:  FILE OPENIT ;

: COLD   FILING CLF  RHANDLE (CLF)  COLD  STOP
\ closeoutfile ret path                   (  4 11 95 crc 13:56 )
: CLOSEOUTFILE   OK  FILING CLF ;

0 VARIABLE RET -2 ALLOT         FILING PATH C/L ERASE
PATH 0 GETPATH
CURDRV ASCII a + C,  ASCII : C,  ASCII \ C,
PATH CT->0 IFTRUE
CT->0 DUP ALLOT RET 3 + SWAP CMOVE
        OTHERWISE DROP  IFEND  0 C,







\ TOWERS OF HANOI C. 1979 PETER MIDNIGHT  (  5  7 86 CRC 12:31 )
( TRANSLATED FOR SPEED COMPARISON ) FORTH DEFINITIONS DECIMAL
DECIMAL PRESENT 260 NEEDED DOK   55 NEEDED SEC  129 NEEDED 4DUP

\ FIRST EXTEND FORTH TO INCLUDE A FEW FEATURES OF PASCAL
: MYSELF \ IN DEFINITION THIS IS A RECURSIVE USE OF A NEW WORD
  LATEST PFA CFA , ; IMMEDIATE
\ : 4DUP 4 PICK 4 PICK 4 PICK 4 PICK ; \ code scr 129

12 CONSTANT NMAX \ max permissable number of rings
NMAX CONSTANT N  ' N CONSTANT (N)  0 CONSTANT HELL-FREEZES-OVER
ASCII = CONSTANT COLOR
0 VARIABLE RING N 2- ALLOT \ ARRAY 1 ... N

CODE 3*  AX POP,  AX BX MOV,  AX SHL,  BX AX ADD,  1PUSH  -->

( TOWERS OF HANOI C. 1979 PETER MIDNIGHT    17 01 81 CRC )
: DELAY ( IDEALLY, CENTISECONDS DELAY )    0 DO TICK LOOP ;

CODE POS   AX POP,  (N) #) DX MOV,  DX SHL,  DX INC,
  DX MUL,  (N) #) AX ADD,  1PUSH ( LOCATION POS -> CO-ORDINATE )

: HALFDISPLAY ( COLOR SIZE HALFDISPLAY )
  0 DO  DUP EMIT  LOOP  DROP ;
: <DISPLAY>  ( LINE COLOR SIZE <DISPLAY> )
  2DUP HALFDISPLAY   ROT 3 <  IF BL  ELSE ASCII |
  THEN EMIT   HALFDISPLAY  ;

: DISPLAY ( SIZE POS LINE COLOR DISPLAY )
  SWAP >R -ROT OVER - R ( COLOR SIZE POS-SIZE LINE )
  SWAP GOTOXY R> ( COLOR SIZE LINE ) -ROT <DISPLAY> ;
   -->
( TOWERS OF HANOI C. 1979 PETER MIDNIGHT  ( 12  2 86 CRC 21:15 )
CODE PRESENCE    ( TOWER RING PRESENCE -> BOOLEAN )
( RING + C@ = ; )  AX POP,  RING #) BX LEA,  AX BX ADD,
  0 [BX] AL MOV,  CBW,  FORTH ' = ASSEMBLER 1+ #) JMP,
: LINE   ( TOWER LINE - > DISPLAY LINE OF TOP )
  4 SWAP N 0 DO DUP I PRESENCE 0= ROT + SWAP LOOP DROP ;
: RAISE           ( SIZE TOWER RAISE )
  DUP  POS SWAP LINE 1 SWAP DO
  2DUP I BL DISPLAY  2DUP I 1-  COLOR DISPLAY
  -1  +LOOP  2DROP ;
: SHOTIME    0 N 3* 7 - 0 MAX GOTOXY  .TIME 2 SPACES .DATE ;

: LOWER  ( SIZE TOWER LOWER )
  DUP POS SWAP LINE 1+ 2 DO
  2DUP  I 1-  BL DISPLAY   2DUP I COLOR DISPLAY
  LOOP  2DROP  ;     -->
( TOWERS OF HANOI C. 1979 PETER MIDNIGHT  ( 26 11 86 CRC 17:47 )
: MOVELEFT  ( size source-tower destiny tower MOVELEFT )
  POS  1- SWAP POS 1- DO DUP R 1+ 1  BL DISPLAY
  DUP R 1 COLOR DISPLAY  -1 +LOOP DROP ;
: MOVERIGHT ( size source-tower destiny-tower MOVERIGHT )
  POS 1+  SWAP POS 1+ DO DUP R 1- 1 BL DISPLAY
  DUP R 1 COLOR DISPLAY   LOOP  DROP ;
: TRAVERSE  ( size source-tower destiny-tower TRAVERSE )
  2DUP >  IF MOVELEFT ELSE MOVERIGHT THEN ?STACK ;
: MOVE    ( size source-tower destiny-tower MOVE 0)
  ?TERMINAL IF N 9 + 0 GOTOXY CURSOR  OK
  [ ATTRIBUTE @ ] LITERAL  ATTRIBUTE !
  ABORT THEN -ROT 2DUP RAISE   >R 2DUP R> ROT TRAVERSE
  2DUP RING + 1- C!  SWAP LOWER  SHOTIME ;
: .CLINE (LINE) -TRAILING 80 OVER - 2/ >R ROT R> GOTOXY
  TYPE ;  --> center a given line on the screen at given row
( TOWERS OF HANOI C. 1979 PETER MIDNIGHT  ( 13 11 86 CRC 17:49 )
: MULTIMOV   ( size source destiny spare MULTIMOV )
  ( ?SLEEP)  4 PICK 1 =  IF DROP MOVE  ELSE
  >R >R SWAP 1- SWAP R> R>  4DUP SWAP MYSELF
  4DUP DROP   ROT 1+ -ROT  MOVE
  -ROT SWAP   MYSELF THEN ;

: MAKETOWER    ( tower MAKETOWER )
  POS 4  N + 3 DO  I OVER GOTOXY ASCII | EMIT LOOP DROP ;
: MAKEBASE   ( no arguements )
  N 4 + 0 GOTOXY N 3* 2* 3 +  0 DO ASCII - EMIT LOOP ;

: MAKERING   ( tower size  MAKRING )
  2DUP RING +  1- C!   SWAP LOWER ;
: SALESPITCH    ( no paramters )
  N 6 +  14  155 .CLINE   N 8 +  13  155 .CLINE  ; -->
( TOWERS OF HANOI C. 1979 PETER MIDNIGHT  ( 26 11 86 CRC 17:48 )
: SETUP  ( no arguements ) PAGE NO.CURSOR SALESPITCH
  RING NMAX 1 FILL  3 0 DO I MAKETOWER LOOP
  MAKEBASE 0 N DO  0 I MAKERING  -1 +LOOP ;

: TOWERS   ( quantity TOWERS )
  (DOK)  ABS 1 MAX NMAX MIN  (N) !  SETUP
  EDITOR FLUSH FORTH  N 2 0 1  BEGIN
  OVER POS  N 4 + SWAP GOTOXY \ N 0 DO  7 EMIT 5 DELAY LOOP
  ROT 4DUP MULTIMOV
  ATTRIBUTE @  16 +  32639 AND  ATTRIBUTE !
  HELL-FREEZES-OVER UNTIL ;  WARNING ON  TOWERS  ;S

true multi-user & multitasking
real-Forth quick & cheap graphics!!
( remember, these are bit mapped characters! )
\ fkey                                    ( 10  2 88 crc  8:00 )
filing forget task
: task ;
: fkey    filing dup sp@ 2+ 1 handle rdf ;
: .file   filing opf:
  begin fkey while emit repeat drop clf ;


editor flush







( Screen cleaning code                    ( 27  6 87 CRC 12:23 )
BASE @ HEX
: CLEAN     ( Check & clear out a screen. )
  BLOCK B/BUF 0 DO DUP C@ ASCII ~ MIN BL MAX OVER C! 1+ LOOP
  DROP UPDATE ;

: CLEANERS    ( Clean out over a range of screens )
  1+  SWAP DO I CLEAN LOOP ;

\ : BACKDOWN: \  ---  | back a hard disk volumne down to 1 drive
\   OFFSET OFF  OPENING:   B/DRV   2 DISKS COPIES ;
BASE !




\ hosted terminal routine                 ( 27  2 86 CRC 16:32 )
: CKEY   2 I/O W! (KEY) ;       \ atari specific -- from console

: SKEY   1 I/O W! (KEY) ;       \ atari specific -- from serial

: CEMIT  2 I/O 2+ W! (EMIT) ;   \ atari specific -- to console

: SEMIT  1 I/O 2+ W! (EMIT) ;   \ atari specific -- to serial

: HEMIT  SKEY  DUP CEMIT . 0 ;

: HKEY   CKEY  SEMIT 0 ;

: H?TERM   2 ?SKEY 0= 0= SEMIT 0 ;
-->

\ hosted terminal routine                 ( 27  2 86 CRC 17:00 )
BASE @ HEX     \ byte swap on stack
CODE ><   S [ DR0 MOV,  DR0 DR1 MOV,
  8 # DR0 LSL,  8 # DR1 LSR,
  DR1 DR0 .B MOV,  FFFF #L DR0 AND,  DR0 S [ MOV,  NEXT
BASE !
: HREAD   SKEY >< (KEY) OR BLOCK  B/BUF  1 I/O 2+ W! TYPE 0 ;

: HWRITE  SKEY >< (KEY) OR BLOCK  B/BUF  1 I/O 2+ W!
  BOUNDS DO (KEY) I C! LOOP  UPDATE 0 ;




-->

\ hosted terminal routine                 ( 28  2 86 CRC  9:05 )
: HTERM  I/O @ >R \ hosted terminal routine
  BL SEMIT     \ tell target we're on line
  BEGIN 1 ?SKEY \ any keys from host?
    IF SKEY  BL - 10 MIN 0 MAX EXEC
    HEMIT  HKEY   H?TERM   HREAD    HWRITE   1       0       0
    0      0      0        0        0        0       0       0
    1  ELSE 0 THEN ?stack  ?TERMINAL OR UNTIL R> I/O ! ;








;S editor softkey definitions             (  9  5 86 BJR 21:43 )
                                                    ;S  ( key 1)
EDITOR TOP L                                        ;S  ( key 2)
-15 SCR +! L                                        ;S  ( key 3)
 15 SCR +! L                                        ;S  ( key 4)
                                                    ;S  ( key 5)
                                                    ;S  ( key 6)
                                                    ;S  ( key 7)
                                                    ;S  ( key 8)
WIPE L                                              ;S  ( key 9)
#LEAD UPPER  ( force to upper case)  L              ;S  ( key J)
#LAG  UPPER                          L              ;S  ( key K)
                                                    ;S  ( key L)
                                                    ;S  ( key M)
                                                    ;S  ( key N)
                                                    ;S  ( key O)
\ strand hosted terminal code             ( 28  5 86 BJR 20:18 )
VOCABULARY TERMINAL IMMEDIATE TERMINAL DEFINITIONS
CODE NYBBL   \ n -- nlo nhi | encode byte into two bytes
   S [ DR0 MOV,  DR0 DR1 .W MOV,  4 # DR1 .W LSR,
   HEX 0F #L DR0 AND,  30 # DR0 .W OR,  DR0 S [ MOV,
   0F #L DR1 AND,  30 # DR1 .W OR,  DR1 S -[ MOV,   NEXT ;C

CODE DENYBBL   \ blo bhi -- b | reverse nybbl
   S [+ DR0 MOV,  0F #L DR0 AND,  4 # DR0 .W LSL,
   S [  DR1 MOV,  0F #L DR1 AND,  DR0 DR1 .W OR,
   DR1 S [ MOV,  NEXT ;C

CODE ?SKEY  \ dev --- fl | is there a key ready?   1=port 2=kbd
 RP DR7 MOV,  S [ DR0 MOV,  DR0 RP -[ .W MOV,
 1 # RP -[ .W MOV,  0D # TRAP,  DR0 S [ MOV,
 DR7 RP MOV,  NEXT       -->
\ strand hosted terminal code             ( 10  5 86 BJR 19:59 )
: RXB   (KEY) (KEY) DENYBBL ;        \ rcvd lo,hi
: RXW   RXB 100 * RXB OR ;           \ rcvd hibyte,lobyte
: XMITB  NYBBL SWAP (EMIT) (EMIT) ;  \ send lo,hi
: XMITW  DUP 100 / XMITB XMITB ;     \ send hibyte,lobyte
: HREAD   BLOCK B/BUF BOUNDS DO  I C@ XMITB  LOOP ;       \ n --
: HWRITE  BLOCK B/BUF BOUNDS DO  RXB I C!  LOOP UPDATE ;  \ n --

: MODEMRX 1 I/O W!    ;  : LOCALRX 2 I/O W!    ;
: MODEMTX 1 I/O 2+ W! ;  : LOCALTX 2 I/O 2+ W! ;
\ entered after receipt of a '1f' request code; must be modemrx!
: DOREQUEST   (KEY) DUP CASE      \ get fcn code from target
   30 OF  DROP          RXW HWRITE ENDOF   \ target -> disk
   31 OF  DROP  MODEMTX RXW  HREAD ENDOF   \ disk -> target
   ( default)   LOCALTX (EMIT) ENDCASE ;
-->
\ strand hosted terminal code             ( 29  9 86 CRC 13:20 )
0 VARIABLE EXITING     decimal 166 load hex \ get new <key>
: DOKEY   LOCALRX <KEY> DUP CTL O = IF EXITING !        \ --
          else dup 100 and if modemtx femit
          ELSE MODEMTX (EMIT) then THEN ;  \ note that rx = loca
: DORX    MODEMRX (KEY) 7F and DUP 1F = IF DROP DOREQUEST  \ --
          ELSE LOCALTX (EMIT) THEN ;  \ note that rx = modem
FORTH DEFINITIONS
: TERM   EDITOR FLUSH   TERMINAL
  I/O @  ." target> "  EXITING OFF  BEGIN
  1 ?SKEY IF  DORX  THEN    \ any keys from host?
  2 ?SKEY IF  DOKEY THEN    \ anyone at keyboard?
  EXITING @ UNTIL   I/O ! ." atari> " ;

: term  no.wrap terminal vt52keys on term vt52keys off wrap ;
-->
\ strand upload from remote system        ( 29  5 86 BJR 17:41 )
\ requires upload support program running in remote system
\ or, this may be the remote system's "target" for hosted term

: UPLOAD   \ hisscr myscr -- | get hisscr (remote), put in myscr
   dup offset @ + buffer drop     \ pre-fetch buffer!
   I/O @ >R   terminal MODEMTX MODEMRX 1F (EMIT) 31 (EMIT)
   SWAP XMITW HWRITE R> I/O ! ;   \ get screen from remot

: UPLOAD-SCREENS   \ 1st last -- | upload screens 1:1
   1+ SWAP DO I DUP . DUP UPLOAD LOOP ;

DECIMAL



\ vt52 keyboard emulator -- <key>         ( 12  5 86 BJR 15:21 )
0 VARIABLE VT52KEYS   \ select applcation keypad

CODE <KEY>  HEX   \  -- key/code | get key or atari code
   RP DR7 MOV,  U ' I/O W@ &[ RP -[ .W MOV,     \ get key in dr0
   2 # RP -[ .W MOV,  0D # TRAP,  DR7 RP MOV,
   VT52KEYS @#L TST,  NE IF,          \ remap numeric keypad?
      DR0 DR1 MOV,  DR1 .W SWAP,  53 # DR1 .W CMP,  NE IF,
      3B # DR1 .W CMP,  GE IF,
      DR0 .W CLR,  THEN, THEN, THEN,  \ yes...force fcn key
   DR0 .W TST,  EQ IF,                \ if function key,
      DR0 .W SWAP,  100 # DR0 .W OR,  \ return scancode+100
   THEN,  FFFF #L DR0 AND,  DR0 S -[ MOV,  NEXT ;C

-->

\ vt52 keyboard emulator -- femit         ( 13  5 86 BJR 16:00 )
: escm   <builds w, does> w@ li (emit) (emit) ;
   ascii A escm pfu    ascii B escm pfd    ascii C escm pfr
   ascii D escm pfl    ascii P escm pf1    ascii Q escm pf2
   ascii R escm pf3    ascii S escm pf4
: esc?m  <builds w, does> w@ li (emit) ascii ? (emit) (emit) ;
   ascii p esc?m ap0   ascii q esc?m ap1   ascii r esc?m ap2
   ascii s esc?m ap3   ascii t esc?m ap4   ascii u esc?m ap5
   ascii v esc?m ap6   ascii w esc?m ap7   ascii x esc?m ap8
   ascii y esc?m ap9   ascii m esc?m ap-   ascii l esc?m ap,
   ascii M esc?m ape   ascii n esc?m ap.
: femit   0ff and 47 max 73 min 47 - exec   |     \ keycode --
   pfu  |  ap- pfl  |  pfr ap,  |  pfd  |   |   |    \ 48-53
    |   |   |   |   |   |   |   |   |   |   |   |    \ 54-5f
    |   |   |  pf1 pf2 pf3 pf4 ap7 ap8 ap9 ap4 ap5   \ 60-6c
   ap6 ap1 ap2 ap3 ap0 ap. ape  |     ;              \ 6d-73
















\ temp copy utilities                     ( 15  5 86 BJR 15:02 )
: scrmove    \ from to cnt --
   editor flush
   bounds do  dup forth i 2dup 6 .r 4 .r editor copy  1+ loop
   drop editor flush ;



: CHINDEX   1+  SWAP
   DO ( I 720 MOD 0= IF DOCUMENTING ?PAGE THEN) ?CR
   I DUP 3 .R   BLOCK W@ IF   SPACE  0  I .LINE  THEN
   ?TERMINAL  IF CR LEAVE  ENDIF  15 +LOOP CR ;




\ Empties: Code to detect empty screens   ( 22  2 87 CRC 13:00 )
DOCUMENTING DEFINITIONS   BASE @ HEX
     \  from-2  to-1  |  list out empty blocks within range
: EMPTIES ?CR  1+ SWAP   ." Empties:" CR
      DO  I 0F MOD 0= IF CR I 5 .R ASCII : EMIT THEN
          I BLOCK @ IF  ."    ."  ELSE  I BLOCK 2+ @  2020 -
        IF ."    *" ELSE I 4 .R    THEN THEN
           ?TERMINAL   IF  LEAVE THEN  ?STACK  LOOP  ?CR ;

HEX  1 BLOCK  B/BUF C/L - + W C/L CMOVE
\ (DATE) W 34 + SWAP CMOVE

BASE !  FORTH DEFINITIONS



\ trial for screen resolution stuff       ( 19  5 86 CRC 10:28 )
DEBUG  HEX  \ 0 variable safe     \ debug version requires this
CODE GETRES    \   ---  n  | get current resolution
  RP DR7 MOV,  4 # RP -[ .W MOV,  0E # TRAP,
  DR7 RP MOV,  DR0 S -[ MOV,  NEXT

\  0: lo res  1: medium res  2: hi (monochrome) res.
CODE SETSCREEN \ res phybase logbase --- | set screen parameters
  RP DR7 MOV,  S [+ DR0 MOV,  S [+ DR1 MOV,  S [+ DR2 MOV,
  DR2 RP -[ .W MOV,  DR1 RP -[ MOV,  DR0 RP -[ MOV,

\ dr7 safe @#l mov,  rp s -[ mov,  dr7 s -[ mov,  ]]   over -
\ over - (dump)  cr .s  [[ safe @#l rp mov, next  \ debug ver

  5 # RP -[ .W MOV,  0E # TRAP,  DR7 RP MOV,  NEXT
EDITOR FLUSH
\ Media Change Detector -- file disks only(  9  7 86 CRC 16:15 )
DEBUG BASE @ HEX FORTH DEFINITIONS FORGET TASK  : TASK ;
CODE MEDIACH  \ dr --- fl | has media been changed??
              \ dr: 0-1   fl: 0-2: no maybe yes
  S [ DR0 MOV,  DR0 RP -[ .W MOV, \ dr
  9 # RP -[ .W MOV,  0D # TRAP,
  4 # RP ADDQ,  DR0 S [ MOV,  NEXT

BASE ! EDITOR FLUSH







\ Auto disk change request.               (  6  7 86 CRC 13:52 )
DECIMAL FORGET TASK 0 CONSTANT BOUND   'R/W @ VARIABLE >R/W
180 NEEDED W/   197 NEEDED SAFEOUTS   0 VARIABLE DISKER
: REQ  \ scr# ---   | request disk; wait on key
  SAVEOUTS OK EDITOR BASE @ DECIMAL SWAP  SV.CUR CTL G EMIT
  ."  Please install " CTL G EMIT FORTH .SCR RST.CUR BASE
  ! KEY ERL LI = IF ABORT"  User Abort!!" THEN  RESTOREOUTS ;
: ?NEWDISK  \ blk#  ---   | disk changed if needed
  DUP BOUND W/ BOUND W* DISKER @ -
  IF DUP REQ DUP BOUND W/ BOUND W* DISKER ! THEN ;
: EXTR/W \ addr dskblk# flag ---  | f:  0 = write 1 = read
  >R  DUP BOUND 3 * 1- > 6 ?ERROR  ?NEWDISK  DISKER @ -
  R> >R/W @EXECUTE STOP
: AUTODISK   'R/W @ ' EXTR/W CFA -   IF 'R/W @ >R/W !
  MAXBLK 1+ ' BOUND !  ' EXTR/W CFA 'R/W !  THEN ;
     HERE FENCE ! : TASK ;      AUTODISK
\   The Theory that Jack Built            ( 16  8 85 CRC       )
\  From The Space Child's Mother Goose by Frederick Winsor
BLK @ 2+ LOADER RECITE ( say this poem ) DECIMAL
: THE               ." the "                        ;
: THAT         CR   ." That "                       ;
: THIS    PAGE      ." This is "              THE   ;
: JACK              ." Jack built"                  ;
: SUMMARY           ." Summary"                     ;
: FLAW              ." Flaw"                        ;
: MUMMERY           ." Mummery"                     ;
: K                 ." Constant K"                  ;
: HAZE              ." Erudite Verbal Haze"         ;
: PHRASE            ." Turn of a Plausible Phrase"  ;
: BLUFF             ." Chaotic Confusion and Bluff" ;
: STUFF             ." Cybernetics and Stuff"       ;
: THEORY            ." Theory "               JACK  ;  -->
\   The Theory that Jack Built              19 01 85 CRC
: BUTTON        ." Button to Start the Machine"     ;
: CHILD         ." Space Child with Brow Serene"    ;
: CYBERNETICS  STUFF ;   : DEMOL ." And Demolished " THE ;
: HIDING    CR  ." Hiding "       THE  FLAW         ;
: LAY      THAT ." lay in "       THE  THEORY       ;
: BASED     CR  ." Based on "     THE  MUMMERY      ;
: SAVED    THAT ." saved "        THE  SUMMARY      ;
: CLOAK     CR  ." Cloaking "          K            ;
: THICK IF THAT ELSE CR ." And " THEN ." Thickened " THE HAZE ;
: HUNG     THAT ." Hung on "      THE  PHRASE       ;
: COVER IF THAT ." Covered " ELSE CR ." To Cover " THEN BLUFF ;
: MAKE      CR  ." To make with " THE  CYBERNETICS  ;
: REST ASCII . EMIT 15 SPACES KEY LI = IF TKEY CURSOR ABORT THEN
 ;  : WITHOUT   CR  ." Without Confusion, exposing the Bluff" ;
: PUSHED    CR  ." Who pushed "   THE  BUTTON       ;  RECITE
\   The Theory that Jack Built              17 01 81 CRC
NO.CURSOR THIS  THEORY   FORTH                             REST
 THIS  FLAW  LAY                                           REST
 THIS  MUMMERY  HIDING  LAY                                REST
 THIS  SUMMARY  BASED  HIDING  LAY                         REST
 THIS  K  SAVED  BASED  HIDING  LAY                        REST
 THIS  HAZE  CLOAK  SAVED  BASED  HIDING  LAY              REST
 THIS  PHRASE 1 THICK CLOAK SAVED BASED HIDING LAY         REST
 THIS  BLUFF HUNG 1 THICK CLOAK SAVED BASED HIDING LAY     REST
 THIS  STUFF 1 COVER HUNG 0 THICK CLOAK SAVED BASED HIDING
     LAY                                                   REST
 THIS BUTTON  MAKE 0 COVER  HUNG 0 THICK  CLOAK SAVED
    BASED  HIDING  LAY  REST            THIS  THE  CHILD
 PUSHED CR ." That made with " THE CYBERNETICS WITHOUT HUNG
 CR ." And, shredding " THE HAZE CLOAK CR ." Wrecked "  THE
 SUMMARY BASED HIDING CR DEMOL THEORY REST CR CR CURSOR
\ screen mover for xfer of changes        ( 20  6 86 CRC  9:50 )
DEBUG DECIMAL DOCUMENTING   DEFINITIONS          DECIMAL
: =DATE \   --  fl | is screen older, = , or newer than ghost?
  STARTDATE GETDATE SCR @ B/DRV +
  BLOCK 43 + GETDATE - ;  \ ghost date

: MOVESCR \  --- | compare scrs, swap as needed
  =DATE -DUP IF SCR @ DUP B/DRV +
  ROT 0< IF SWAP THEN  2DUP SWAP 6 .R 4 .R EDITOR COPY THEN ;

: MOVESCRS \ frm ct ---  | move given screens about
  SCR @ -ROT  EMPTY-BUFFERS FLUSH BOUNDS DO I SCR ! MOVESCR
  OUT @ 50 > IF CR THEN  LOOP CR FLUSH SCR ! ;

: MOVEDISK \ --  | swap latest screens between 2 disks
  TODAY 0 B/DRV MOVESCRS ; FORTH DEFINITIONS DOCUMENTING
\ Slurp source from 11                    ( 26 10 86 CRC 14:12 )
FORGET TASK
BASE @ DECIMAL 55 NEEDED MS HEX  FORTH DEFINITIONS
: RXBLK  \  n ---  | read a block in from the host computer
  ( I/O @ >R 10001 I/O !)  OFFSET @ + BUFFER BL EMIT
  ( 2 OUTPUT W!) B/BUF 2DUP EXPECT
  -TRAILING 0= IF SWAP off ELSE DROP THEN
  UPDATE ( R> I/O !) ;

: RXBLKS  \ st ct  --- nxt | read ct blocks starting at st from
  2DUP BOUNDS DO CR I 5 .R I RXBLK    \  host, leaving next blk
  I #BUFS MOD 0= IF EDITOR FLUSH THEN
  ?TERMINAL IF LEAVE THEN      LOOP + FLUSH ;

: TASK ;  BASE ! EDITOR FLUSH

\ lightboard compile aids                 ( 12  6 86 CRC 14:23 )
AUTODISK  CREF ?CR TODAY
DEBUG BASE @ HEX FORTH DEFINITIONS FORGET TASK
DECIMAL 106 NEEDED MODULE 107 NEEDED IFTRUE
1500 LOADER LIGHTBOARD            here first over - erase
: SETDEBUG ;        IMMEDIATE
  1 CONSTANT CHAS       0 CONSTANT VME        0 CONSTANT BRAD

: TASK ;

: SETBUFS \ n --   | set system to have n buffers
  FLUSH B/BUF 6 + * LIMIT SWAP - 'FIRST !
  EMPTY-BUFFERS FLUSH   #BUFS 4 .R ."  Buffers " ;

CHAS IFTRUE #BUFS 32 = IFTRUE 256 SETBUFS IFEND  #BUFS 5 .R
BASE !
\ word wide math operators                ( 30  5 86 CRC 13:34 )
CODE UW*   \ w w --- n | 16bit x 16bit --> 32bit prod
  S [+ DR1 MOV,  S [ DR0 MOV,  DR1 DR0 MULU,  DR0 S [ MOV,  NEXT

CODE W*    \ w w --- n | 16bit x 16bit --> 32bit prod
  S [+ DR1 MOV,  S [ DR0 MOV,  DR1 DR0 MULS,  DR0 S [ MOV,  NEXT


CODE W/    \ n w --- w | 32bit / 16bit --> 16bit quotient
  S [+ DR1 MOV,  NE IF,  S [ DR0 MOV,  DR1 DR0 DIVS,  DR0 EXT,
  DR0 S [ MOV,  ELSE,  S [ CLR,  THEN,  NEXT

CODE UW/   \ n w --- w | 32bit / 16bit --> 16bit quotient
  S [+ DR1 MOV,  NE IF,  S [ DR0 MOV,  DR1 DR0 DIVU,  DR0 EXT,
  DR0 S [ MOV,  ELSE,  S [ CLR,  THEN,  NEXT
  \ we arbitrarily define division by 0 as producing 0.
\ Documentor code: doc 3doc                 31 12 84 CRC

: SHADOW  B/DRV + ;        HEX

: DOC BASE @ SWAP DECIMAL CR DUP SCR ! 3F  SPACES
   ." SCR #  " 5 .R 10 0  SCR @ BLOCK @  IF
   DO  CR  I 3 .R  SPACE I SCR @ .LINE
   [ C/L 7 + ] LITERAL TAB I SCR @ SHADOW .LINE
   ?TERMINAL IF LEAVE ENDIF LOOP ELSE
   DROP VTAB  THEN  CR BASE ! ;

: 3DOC  3 / 3 * 3 BOUNDS      2DUP DO I BLOCK @ LOOP OR OR
   IF ?PAGE DO CR I DOC  ?TERMINAL IF LEAVE THEN LOOP CR
   [ 6 BL + ] LITERAL SPACES W C/L TYPE CR ELSE 2DROP THEN ;


\ Documentor code: showoff                  10 06 84 CRC

: SHOWOFF   3 / 1+ 3 *  SWAP
   DO I 3 / 3 * 3 BOUNDS      2DUP DO I BLOCK @ LOOP OR OR
   IF ?PAGE DO CR I DOC  ?TERMINAL IF LEAVE THEN LOOP CR
   [ 6 BL + ] LITERAL SPACES W C/L TYPE  CR ELSE 2DROP THEN
   ?TERMINAL IF  LEAVE THEN   3  +LOOP  ;

: NECPAGE ?CRT 0= IF ?PAGE THEN ;  \ force page on printer only







\   STRING HANDLERS --                    ( 16  8 85 CRC       )
debug   FORGET TASK     \ Hi level 79 std upgrades
FORTH DEFINITIONS  : TASK ;    BASE  @
HERE FIRST OVER - ERASE
DECIMAL 129 NEEDED ROLL  HEX

\ CODE R@      ' R     CFA @  LATEST PFA CFA !
\ CODE ?DUP    ' -DUP  CFA @  LATEST PFA CFA !

BASE !  -->






  ( STRING HANDLERS --                      06 12 81 CRC )
 BASE  @ HEX
: (")   R COUNT DUP 1+ R> + ( =CELLS ) >R  ;

: TEXT   PAD 1+ 40  BLANKS  WORD HERE  COUNT
     DUP PAD C!  -DUP
     IF PAD 1+ SWAP CMOVE
     ELSE  DROP    THEN ;
: " ASCII " STATE @ IF COMPILE (")  WORD HERE C@ 1+ ALLOT
     ELSE TEXT PAD COUNT    THEN ;   IMMEDIATE

: STRING     (  n-max   -> )
     <BUILDS   1   MAX   0FE  MIN
          DUP  C,  0 C, ALLOT
     DOES>   1+  COUNT ;                -->

  ( STRING HANDLERS --                      29 01 81 CRC )
: S!    DROP  DUP  2- C@
     ROT  MIN  DUP  3 PICK  1- C!  CMOVE ;

: LEN  SWAP  DROP  ;            : MLEN  DROP  2- C@ ;

: MID$   >R  OVER  MIN  1 MAX  1-
     SWAP  OVER   - R>   MIN   >R  +  R>  ;

: RIGHT$   OVER  1+  SWAP  - 0FF  MID$ ;

: LEFT$  1 SWAP  MID$ ;

: SUB!    ROT MIN  0  MAX CMOVE  ; -->


  ( STRING HANDLERS --                      29 01 81 CRC )
: S=    ROT  OVER  =
    IF  -DUP
     IF 1 SWAP  0
      DO  DROP  OVER  C@  OVER  C@  =
       IF  1+  SWAP  1+  SWAP  1
       ELSE  0 LEAVE
       THEN
      LOOP
     ELSE  1
     THEN
    ELSE DROP  0
    THEN SWAP  DROP  SWAP DROP  ; -->



  ( STRING HANDLERS --                      29 01 81 CRC )
: S<   ROT  OVER MIN  SWAP  OVER  >  >R   -DUP
     IF -1  SWAP 0
      DO  DROP  OVER  C@  OVER  C@  =
       IF  1+  SWAP  1+  SWAP  -1
       ELSE  C@  SWAP  C@  >  LEAVE
       THEN
      LOOP  DUP  0<
      IF DROP  DROP  DROP R>
      ELSE  R>  DROP
      THEN
     ELSE DROP DROP R>
     THEN ;

: S+  >R  OVER  R  + OVER  2- C@  MIN 2DUP
     SWAP  1- C!  R> 1+  0FF MID$  SUB! ;  -->
  ( STRING HANDLERS --                      04 02 81 CRC )
: CHR$ PAD !  PAD 1 ;         : ASC  DROP  C@  ;

: IN$   DUP 4 PICK - DUP 0  >
     IF SWAP OVER -  IF 0 SWAP 2+ 1
       DO  DROP 3 PICK  C@  OVER C@ =
        IF 3 PICK 3 PICK 3 PICK OVER S=
         IF  I LEAVE
         ELSE 1+ 0  THEN
        ELSE 1+ 0  THEN
       LOOP
      ELSE DROP 0
      THEN
        >R  DROP  DROP  DROP R>
     ELSE DROP  S=  THEN ;           -->

  ( STRING HANDLERS --                      07 02 81 CRC )
: VAL  DROP  0. ROT  1- (NUMBER) DROP ;

: SVAL  VAL DROP ;      (  fig-FORTH only? CRC )

: STR$  SWAP  OVER  DABS <#  #S  SIGN #> ;

: SSTR$  S->D  STR$ ;   ( fig-FORTH only ? CRC )

: STRING-ARRAY
     <BUILDS  0 DO  DUP C,  0 C, DUP  ALLOT LOOP
     DOES>  DUP  C@  2+  ROT  *  +  1+  COUNT ;
                       ( Blanks out an array )
: BLANK  DROP DUP DUP 0 ROT 1- C!  2- C@ BLANKS ;
 -->

  ( STRING HANDLERS --                      04 02 81 CRC )
: ACCEPT    SWAP  1+  DUP  ROT  EXPECT 0
     BEGIN  2DUP  + C@
     WHILE  1+
     REPEAT  SWAP  1- C! ;

: GET$  PAD  SWAP  ACCEPT  PAD  COUNT ;

: INPUT$     40 GET$ ;

: GET  GET$  VAL ;            : INPUT  40   GET ;

1 STRING NULL$                : $  STRING ;
BASE !   EDITOR


\ Some programming aids: TRY, etc         ( 19  5 86 CRC 10:52 )
FORTH DEFINITIONS       \ See the RF manual
: RETRY  IN @ >R -FIND IF DROP DUP [ LATEST 2- ] LITERAL U<
   IF  ." kernel " DROP  ELSE
      NFA 2- @ WHERETHEN R IN ! [COMPILE] FORGET
      BLK 2@ >R >R  IN ! BLK ! INTERPRET  R> R> BLK 2! THEN
   ELSE 14 MESSAGE  4 SPACES THEN R> DROP ;

: TRY SCR @ LOAD ;

: TASK ;





\ Interrupt driven serial console         (  5  2 88 crc  8:56 )
base @ decimal  390 load FENCE OFF      forget task
390 loader setserial    hex
0 VARIABLE KEYBUF FFE ALLOT  KEYBUF 1000 ERASE  \ Clean out buf
0 VARIABLE KEYVECTOR 0 , 0 C,      PRESENT
\ keyvector     = chrs in count  keyvector 2 + = chrs out count
\ keyvector 4 + = Break flag

3F8 CONSTANT ACE                ACE     CONSTANT DATA
ACE 1+  CONSTANT IER
ACE 2+  CONSTANT IIR            ACE 3+  CONSTANT LCR
ACE 4 + CONSTANT MCR            ACE 5 + CONSTANT LSR

DECIMAL  193 196 HEX THRU  HERE FENCE !  : TASK ;  BASE !
         EDITOR ;S
re-write this eventually to use an external segment!
\ Interrupt driven serial console         (  3  3 88 crc 11:35 )
CODE XKEY   \   --- key | get a keystroke from the ix buffer
  0 # AH MOV,  KEYVECTOR #) BX LEA,  AH 4 [BX] MOV,
  2 [BX] DI MOV,  BEGIN,  0 [BX] DI CMP,  0<> UNTIL,
  KEYBUF [DI] AL MOV,  DI INC,  FFF # DI AND,
  DI 2 [BX] MOV,  1PUSH
here
IX  STI,  AX PUSH,  SI PUSH,  DX PUSH,  KEYVECTOR #) SI MOV,
  BEGIN,  LSR # DX MOV,  DX AL IN,  1 # AL TEST,
  0<> WHILE,   DATA # DX MOV,  DX AL IN,  AL KEYBUF [SI] MOV,
    20 # AL MOV,  20 # AL OUT,
    SI INC,  FFF # SI AND,   REPEAT,
  SI KEYVECTOR #) MOV,
  DX POP,  SI POP,  AX POP,  IRET,  0C TRAP!
constant service

\ Interrupt driven serial console         (  3  3 88 crc  7:51 )
                \ Emit char only when most recent char is
CODE XEMIT      \ NOT ctl s,  else wait til receipt of ctl q
  KEYVECTOR #) BX LEA,
  0 [BX] DI MOV,  2 [BX] DI CMP,                \ pending chars?
  0<> IF,  DI DEC,  FFF # DI AND,
     CTL S # KEYBUF [DI] .B CMP,                \ is halt?
     0= IF,  BEGIN,  DI 0 [BX] MOV,             \ dump ctl s
             BEGIN,  0 [BX] DI CMP,  0< UNTIL,
          CTL Q # KEYBUF [DI] CMP,  0= UNTIL,
          0 [BX] DEC,  FFF # 0 [BX] AND,          \ unload ctl q
     THEN, THEN,
  LSR # DX MOV,  20 # ( THRE bit ) AH MOV,
  BEGIN,  DX AL IN,  AH AL AND,  0<> UNTIL,
  AX POP,  DATA # DX MOV,  DX AL OUT,  NEXT

\ more ix driven serial port              (  5  2 88 crc 14:30 )
CODE  X?KEY     KEYVECTOR #) AX MOV,   KEYVECTOR 2+ #) AX SUB,
   1PUSH

: SHOWSTAT  CR ."   data  ier  iir  lcr  mcr  lsr  msr"
  CR \ LCR PC@  DUP  80 OR  LCR PC!  ACE P@ 6 .R  LCR PC!
  SPACE  ACE 7 BOUNDS DO I PC@ 5 .R LOOP
  KEYVECTOR 4 (DUMP)  KEYBUF 40 DUMP  ;  SHOWSTAT CR HEX
: SETUP    LCR PC@  80 OR LCR PC!  0C ACE P!
  MCR PC@ 8 OR MCR PC!  21 PC@ E7 AND 21 PC!
  3 ( 8 bits, no parity) LCR PC!  1 IER PC! SHOWSTAT ;  SETUP
decimal
: SETDOWN    0 IER PC! SHOWSTAT ;    \ shut down ixes
: COLD  SETDOWN COLD STOP
: XBREAK  \  --  | send a break
  LCR PC@  DUP 40 OR  LCR PC!  DUP DROP  LCR PC! ;
\ Interrupt driven serial console           09 11 84 CRC
HEX   FORTH DEFINITIONS     ;s
: IOK   OUTPUT> (IEMIT) (TYPE)  (GOTO) IPAGE   NLIST  (CR) STOP
: IXKEY  2AC6 C@ 1 = IF SEI \ do only if terminal is console
         [ ' (IKEY)      CFA ] LITERAL                   'KEY !
         [ ' IOK         CFA ] LITERAL                    'OK !
         [ ' (IEMIT)     CFA ] LITERAL [ ' ?CRT 6 + ] LITERAL !
         [ ' (I?TERM)    CFA ] LITERAL             '?TERMINAL !
         [ 1C1 @ ( irq vec)  ] LITERAL 1C1 !          4C 1C0 C!
         KEYVECTOR 5 ERASE  KEYBUF DUP KEYVECTOR ! 100 ERASE
[ 2 BASE ! ]   10010001  INITACIA  \  Setup for ix
[ HEX ]  \     ^ ^  ^ divide by 16
         \     ^ ^  8 bits + 2 stop bits
         \     ^ lo RTS, no TX enabled
 CLI THEN ; \  Receive interrupt enable
: MON OLDKEY MON IXKEY ;
\ saveoutputs: save & restore output vecto( 30  5 86 CRC 14:29 )
BASE @ DECIMAL

0 VARIABLE SAFEOUTS   10 ALLOT      SAFEOUTS 12 ERASE

: RESTOREOUTS  SAFEOUTS 'EMIT 12 CMOVE  ;

: SAVEOUTS     'EMIT SAFEOUTS 12 CMOVE  ;

BASE !






\ terminal emulator: 8250 control         ( 13  1 96 crc  7:12 )
debug FORGET TASK  BASE @ DECIMAL   106 NEEDED MODULE
292 NEEDED PC@            HEX   here first over - erase
2F8 CONSTANT ACE                ACE     CONSTANT DATA
ACE 2+  CONSTANT IIR            ACE 3+  CONSTANT LCR
ACE 4 + CONSTANT MCR            ACE 5 + CONSTANT LSR
ACE 6 + CONSTANT MSR
CODE SETBAUD   \ n --  | set baud register to n
  LCR # DX MOV,  DX AL IN,  AL BL MOV,  80 # AL OR,  DX AL OUT,
  AX POP,  DX PUSH,  ACE # DX MOV,  DX AX OUT,
  DX POP,  BL AL MOV,  DX AL OUT,  NEXT
               \ 19,200 baud
: SETUP   LIT [ 6 , ] SETBAUD  3 ( 8 bits, no parity) LCR PC!
  mcr pc@ 2 or  mcr pc!  ( CTS negated ) ; \ SETUP
' SETUP 2+ CONSTANT RAWBAUD
BLK @ 1+ dup 1+ thru     : TASK ; decimal 207 load BASE !
\ terminal emulator: 8250 control         (  6 10 94 crc 10:37 )
CODE XEMIT \ c --- | send to host
  MSR # DX MOV,  10 # ( cts bit? ) AH MOV,
  BEGIN,  DX AL IN,  AH AL AND,  0<> UNTIL,
  LSR # DX MOV,  20 # ( THRE bit ) AH MOV,
  BEGIN,  DX AL IN,  AH AL AND,  0<> UNTIL,
  AX POP,  DATA # DX MOV,  DX AL OUT,  NEXT

CODE X?KEY \ --- f | is there a char from the host?
  LSR # DX MOV,  DX AL IN,  1 # AX AND,  1PUSH
CODE XKEY  \ --- c | get char from host
  LSR # DX MOV,  1 # ( DR bit ) AH MOV,
  BEGIN,  DX AL IN,  AH AL AND,  0<> UNTIL,
  DATA # DX MOV,  DX AL IN,  AH AH SUB,  1PUSH

: PURGE  BEGIN  X?KEY  WHILE  XKEY EMIT  REPEAT  ;      PURGE
\ terminal emulator: 8250 useage          ( 28  1 88 crc  7:51 )
: SHOWSTAT  CR ."   baud  data  ier  iir  lcr  mcr  lsr  msr"
  CR LCR PC@  DUP  80 OR  LCR PC!  ACE P@ 6 .R  LCR PC!
  SPACE  ACE 7 BOUNDS DO I PC@ 5 .R LOOP ;   SHOWSTAT    CR

: XBREAK  \  --  | send a break
  LCR PC@  DUP 40 OR  LCR PC!  DUP DROP  LCR PC! ;

: LOOPBACK   MCR PC@  10 OR   MCR PC! ;  \ run in local mode

: LOOPFRONT  MCR PC@  EF AND  MCR PC! ;  \ talk to outside world

: TEST  LOOPBACK  SHOWSTAT CR
  BEGIN KEY  DUP LI - WHILE XEMIT XKEY EMIT REPEAT DROP
  LOOPFRONT ;

\ terminal emulator code: start bugoff    (  2 12 88 crc 13:37 )
BASE @ DECIMAL  ( 260 NEEDED DOK)  267 NEEDED XEMIT  FILING
265 NEEDED DKEY  FORGET TASK  107 NEEDED IFTRUE   55 NEEDED MS
\ 70 NEEDED LASTLINE  \ kim paper tape format
here first over - erase
0 VARIABLE FOLLOW     \         0 VARIABLE ixmask
0 VARIABLE CAPTURE              0 VARIABLE POINTER
0 VARIABLE ?FUN                 0 VARIABLE HOFFSET
217 220 THRU                    HEX

CODE NOIX
  22 FF XOR # AL MOV,  21 # AL OUT,  NEXT

CODE ALLOWIX
   0 # AL MOV,  21 # AL OUT,  NEXT
-->
\ terminal emulator code: filtre capt kill(  2 12 88 crc 13:37 )
: KILL  PAD POINTER ! ;

CODE CAPT  \ c --- c | to capture buffer if flag is asserted
  -1 # CAPTURE #) TEST,  0<> IF,  POINTER #) BX MOV,
  POINTER #) INC, AX POP, AX 0 [W] MOV, AX PUSH,  THEN,  NEXT
                                                  ( HERE
     0 C,   0 C,   0 C,   0 C,    0 C,    0 C,    0 C,    7 C,
     8 C,   9 C,  0A C,   0 C,    0 C,   0D C,    0 C,    0 C,)

( CODE FILTRE  S [ DR0 MOV, 7F # DR0 .W AND,  NOCLOCK *+ DR1 MOV
  \  BL # DR0 .W CMP,  LT IF, ROT 0 &D*+ DR0 .B MOV,  THEN,
  LI # DR0 .W CMP,  EQ IF,  3 # DR1 MOVQ,  ELSE, 1 # DR1 SUBQ,
     MI IF,  DR1 CLR, THEN,  THEN,  DR1 NOCLOCK @#L MOV,
  DR0 S [ MOV,  NEXT ) -->

\ terminal emulator code:                 ( 14  3 88 crc 13:13 )
: (S.")  R COUNT DUP 1+  R> + >R  SLTYPE ;
: S."  ASCII " STATE @ IF  COMPILE (S.")  WORD HERE C@ 1+
  ALLOT ELSE  WORD HERE COUNT SLTYPE THEN ; IMMEDIATE
: FTN <BUILDS BL WORD HERE 1+ C@ LI C, C, DOES> 2 SLTYPE ;
  \ all are shifted function keys
: FN1 S."  3 LOAD  " ;         : FN2 S."  9 LOAD "      ;
: FN3 S." APPLICATION "      ; : FN4 S." G40:100"            ;
: FN5 S." G40:104"  ;
: FN6 S."  COLD" ;
: FN7 s."  Empty-buffers " ;
\ : FN8 s." CHARLES CHARLES  3 LOAD " ;
\ HEX  CTL M DUP  ' FN8 0C + C!    ' FN8 14 + C!
: FN10  xbreak  ;   \ send a break
FTN FN8 B                       FTN FN9 C      -->

\ terminal emulator code: hostkey local   ( 22 10 86 CRC 23:15 )
: FUNCTIONS  \ key --- fl | function key executed
  DUP ASCII G =  ?FUN @  AND  0= IF
  DUP ASCII T ASCII ] WITHIN ?FUN @ AND  IF 0 SWAP  ?FUN OFF
    ASCII T - EXEC  FN1 FN2 FN3 FN4 FN5 FN6 FN7 FN8 FN9 FN10
    ELSE ?FUN @ IF LI XEMIT THEN XEMIT THEN 0 THEN ?FUN OFF ;
: HOSTKEY \  ---  | process key in from host
  XKEY 7F AND  DUP 1F = IF DOREQUEST ELSE
\ DUP CTL R = IF CAPTURE !        ;S THEN  \ Compuserve dc2/dc4
\ DUP CTL T = IF CAPTURE OFF DROP ;S THEN  \ download protocol
  ( FILTRE ) -DUP IF FOLLOW @ IF PRINTER DUP (PNT) THEN  FORTH
  CAPT EMIT  THEN   THEN  ( GETTIME TERMTIME ! ) ;
: LOCALKEY \ --- | process key from user
  <KEY>  DUP  IF FUNCTIONS  ELSE ?FUN ON THEN
  ?QUIT !  ( GETTIME TERMTIME !) ;   -->

\ terminal emulator code: term            ( 27  5 88 crc  9:33 )
: STDBUFS   EDITOR FLUSH 3C +ORIGIN @ 'FIRST ! SETU/P ;
: MAXBUFS  LIMIT DUP PAD - 0  B/BUF 4 + U/ NIP \ see RF manual
  B/BUF 4 + U* DROP  - 'FIRST ! EMPTY-BUFFERS FLUSH ;

: (TERM)   POINTER @ PAD U< IF KILL THEN ?QUIT OFF  ( DOK)
  OFFSET @ >R  HOFFSET @  OFFSET !  FLUSH  MAXBUFS
  ( 7070 ATTRIBUTE !)  BEGIN
  X?KEY  IF  HOSTKEY  THEN          \ any keys from host?
  ?DKEY  IF  LOCALKEY THEN          \ anyone at keyboard??
  ?QUIT @ UNTIL ( 7 ATTRIBUTE ! ) OK
  R> OFFSET !  STDBUFS ;
: TERM   ( DOK)  SLURP (TERM) ;

: TASK ; DECIMAL  178 LOAD   214 LOAD
 BASE !  KILL  EDITOR FLUSH      ?CR WARNING ON ?DICT
( code to slurp in from a host )          ( 26 10 86 CRC 14:12 )
BASE @ HEX
: ABLOCK  \  blk#  ---  | Get a block from host
  OFFSET @ + BUFFER B/BUF INPUT >HOST EXPECT UPDATE
  INPUT >LOCAL ;

: ABLOCKS  ( start ct -- | get in a bunch of blocks )
  BOUNDS  DO I ABLOCK CR I 4 .R CR LOOP ;
BASE !







\ Vectoring words: vtok print output>     (  2  2 88 crc  8:46 )
BASE @ DECIMAL   FORTH  DEFINITIONS     FORGET TASK
198 NEEDED XEMIT   PRESENT    here first over - erase
                \ emit   type   gotoxy page    list   cr
: (XOK) OUTPUT> XEMIT   (TYPE)  (GOTO) IPAGE   NLIST  (CR) STOP

: TOK   [ ' (OK) CFA ] LITERAL 'OK !
  [ 'KEY @ ] LITERAL 'KEY !
  [ ' (?TERMINAL) CFA ] LITERAL '?TERMINAL !  (OK) ;

: XOK   [ ' (XOK) CFA ] LITERAL 'OK !
  [ ' XKEY CFA ] LITERAL 'KEY !
  [ ' X?KEY CFA ] LITERAL '?TERMINAL !  (XOK) ;

: TASK ;     EDITOR FLUSH   BASE !

















\ quick & dirty time totaler              ( 20  6 86 CRC  8:01 )
: .T      0 MAX     DUP 600 < >R   0 <# # 6 BASE ! #
  ASCII : HOLD DECIMAL #S R> IF BL HOLD THEN #> 2 SPACES TYPE ;

: HR  BL WORD HERE H/M 0 0 ROT (NUMBER) 2DROP SWAP DROP
  SWAP 60 * + DUP .T ;

: DAY  DUP .T + ;   \ accumulated a day into a week

: WEEK  DAY DAY ;   \ accumulate a week into a month

: PERIOD    SWAP - 0 MAX ;

: HOURLY   ." At $40 per hour: "
  4000 60 */ 0 <# # # ASCII . HOLD #S
  BL HOLD ASCII $ HOLD #> TYPE ;
\ +load +thru                             ( 16  6 19 crc 22:08 )
forget task                     forth definitions

: +load \ offset ---  | load relative
   +blk load ;

: +thru \ offset1 offset2 ---  | load relative
  +blk swap  +blk swap  thru ;

: task ;






































\ Documentation runnoff screen            (  6  7 88 crc  8:38 )
BASE @ DECIMAL SCR @     DOCUMENTING
   \ 10.DS working disk
\  0 maxblk       3 / 3 *         SINCE 19  5 88
   0 maxblk       3 / 3 *         SINCE  6  7 88

NECPAGE   SCR ! BASE !









\ file handlers for terminal stuff        (  1 11 87 CRC 12:08 )
FORGET TASK   DECIMAL FILING FORTH DEFINITIONS
: .CAPTURED  PAD POINTER @ OVER - -DUP IF TYPE ELSE DROP THEN ;

: SAVEFILE:  \  ---  | file saved out | Needs file name.
  POINTER @ PAD - 1- 0< IF BL WORD KILL DROP ELSE
  FILING MKF:  HANDLE IF PAD POINTER @ OVER - HANDLE WTF
  DUP 0< IF 5 .R ' HANDLE OFF ABORT"  File write Error" ELSE
         DROP THEN CLF THEN THEN ;

\ : HDRIVE   B/DRV *  HOFFSET ! ;

: TASK ; EDITOR FLUSH



















\ Book label printer                        28 07 83 CRC
FORTH DEFINITIONS FORGET TASK : TASK ;  BLK @ CONSTANT THISBLK
DECIMAL   : (LN) (LINE) DROP BL ;
: .CLINE  (LN) 2DUP -TRAILING -DUP IF SWAP DROP OVER
       SWAP - 2/ SPACES -TRAILING TYPE ELSE DROP 2DROP THEN ;
: LABEL  VMARGIN @ VMARGIN OFF 4 0 DO CR  \  vmargin reset
       I 12 + THISBLK .CLINE  LOOP CR CR
       ?NEC IF VMOVER THEN   VMARGIN !   ;
LABEL  EDITOR ;S

ten                             |  <-- right side of label
eleven                          |
                                |
This is a test                  |
of the label printer            |
                                |
\ strand hosted terminal code             ( 28  4 88 crc 18:19 )
BASE @ HEX
CODE NYBBL   \ n -- nlo nhi | encode byte into two bytes
   AX POP,  AH AH SUB,  AX DX MOV,  4 # CL MOV,  AX CL SHR,
   0F # DL AND,  30 # AL OR,  30 # DL OR,  2PUSH

CODE DENYBBL   \ bhi blo -- b | reverse nybbl
  AX POP,  0F # AX AND,  4 # CL MOV,  AX CL SHL,  AX DX MOV,
  AX POP,  0F # AX AND,  DX AX OR,  1PUSH

: RXB   XKEY  XKEY  DENYBBL ;        \ rcvd lo,hi

: RXW   RXB 100 * RXB OR ;           \ rcvd hibyte,lobyte



\ strand hosted terminal code             (  2 12 88 crc 13:38 )
: XMITB  NYBBL SWAP XEMIT XEMIT ;    \ send lo,hi
: XMITW  DUP 100 / XMITB XMITB ;     \ send hibyte,lobyte

: HREAD   BLOCK B/BUF BOUNDS DO  I C@ XMITB  LOOP ;       \ n --

: HWRITE  DUP ?PRESENT  -DUP IF SWAP DROP  ELSE OFFSET @ +
  BUFFER THEN  B/BUF BOUNDS DO  RXB I C!  LOOP UPDATE ;  \ n --

: DOWHERE \ perfrom  where fun for target
  RXW R# !  RXW SCR  hoffset @ + !  [COMPILE] EDITOR !QUIT! ;

: FWRITE  DUP ?PRESENT  -DUP IF SWAP DROP  ELSE OFFSET @ +
  BUFFER THEN  B/BUF BOUNDS DO XKEY I C!  LOOP UPDATE ; \ n --


\ strand hosted terminal code             (  6 12 88 crc  7:07 )
: FREAD   DUP BLOCK @
  IF BL XEMIT BLOCK B/BUF -TRAILING BOUNDS  XKEY DROP
  DO I C@ XEMIT LOOP 1F XEMIT ELSE 21 XEMIT HREAD THEN ;

: SLTYPE    -DUP \ addr ct --  | send out slowly
  IF  BOUNDS  DO  R C@ XEMIT  LIT [ HERE >R   4 , ] MS  LOOP
  ELSE  DROP  THEN ;                     \  word literal!

R>  CONSTANT SPEED

: H"  ASCII " WORD HERE COUNT SLTYPE  CTL M XEMIT ;
BASE @ DECIMAL
: HSTAMP  SETSTAMP  (STAMP) 22  DUP XMITB  SLTYPE ;   BASE !
;s  ' SLTYPE 12 + CONSTANT SPEED

\ strand hosted terminal code             ( 19  9 88 crc 13:27 )
: DOREQUEST   XKEY CASE      \ get fcn code from target
   30 OF  DROP          RXW HWRITE ENDOF   \ target -> disk
   31 OF  DROP          RXW  HREAD ENDOF   \ disk -> target
   32 OF  DROP  EDITOR FLUSH FORTH ENDOF   \ target flush
   33 OF  DROP  DOWHERE            ENDOF   \ target  WHERE
   34 OF  DROP          RXW FWRITE ENDOF   \ target -> disk
   35 OF  DROP          RXW  FREAD ENDOF   \ disk -> target
   36 OF  DROP  19.2BAUD           ENDOF   \ set baud from targ
   37 OF  DROP  PRESENT            ENDOF   \ local present
   38 OF  DROP  ERL                ENDOF   \ target cursor
   39 OF  DROP  RXB RXB GOTOXY     ENDOF   \    controls
   3A OF  DROP  BOTTOM             ENDOF   \ ascii :
   3B OF  DROP  PAGE               ENDOF   \ ascii ;
   3C OF  DROP  hstamp             ENDOF   \ ascii <
              EMIT  ENDCASE ;           BASE !
 (  Disking: single disk copier           ( 28  7 85 CRC       )
( compile on top of cold system!!! ) FORTH DEFINITIONS DECIMAL
: BELL  7 EMIT ;

: STDBUFS  FLUSH 112 +ORIGIN @ 'FIRST ! SETU/P ;
HEX
\ : MAXBUFS  LIMIT 7C7C  -  'FIRST ! EMPTY-BUFFERS  FLUSH ;

   (  from-2 to-1  | backup )
: BACKING FLUSH ( MAXBUFS) 1+ SWAP ?CR DO FORTH I DUP DUP
   #BUFS  MOD 0= IF BELL KEY DROP FLUSH CR KEY DROP THEN
   BLOCK DROP UPDATE  4 .R
   LOOP BELL  KEY DROP FLUSH STDBUFS ;

: BACKUP   0 B/DRV 1- BACKING ;
DECIMAL   ;S  317F = top of host os.
\   cross reference utility. Ken Bell     ( 22  5 92 crc  9:23 )
FORTH DEFINITIONS    FORGET TASK
VOCABULARY CREF IMMEDIATE       CREF DEFINITIONS
CODE QU  AX POP,  AX AX XOR,  1PUSH   BASE @  DECIMAL

0 VARIABLE COUNTEM              0 VARIABLE WORDCT
: ?VOC  @ [ ' ASSEMBLER @ ] LITERAL = ;

: .CT COUNTEM @ -DUP IF DECIMAL 6 .R COUNTEM OFF THEN  ?CR ;

: (.VOC)  \ vla ---   | print out name of vocabulary
  DUP LIMIT U< IF 4 - NFA ID. ELSE ." FORTH" DROP THEN ;

: .VOC   ."  vocabulary is: "  (.VOC) ;
1 +BLK 5 +BLK THRU   BASE !
;S who  &  cross  developed by Ken Bell. Much customised by CRC.
\   cross reference utility. Ken Bell     ( 29  5 86 CRC 16:00 )
: {WHO} \ pfa-2 pfa-1 ---  | search word pfa2 for word pfa1
    >R DUP BEGIN  PAUSE  DUP @ 2+  CASE  R \ ?STACK  CR .S
             OF  COUNTEM 1+!  OVER NFA AID. COL  QU  ENDOF
                                   ' ;S       OF QU  ENDOF
        ' LIT      OF 2+  ENDOF    ' COMPILE  OF 2+  ENDOF
        ' @EXECUTE OF QU  ENDOF    ' CLIT     OF 1+  ENDOF
        ' (.")     OF DUP 2+ C@ 1+ +                 ENDOF
        'ABORT" 2+ OF DUP 2+ C@ 1+ +                 ENDOF
        ' (;CODE)  OF DUP 3 + @  OVER +
            [ ' DOES> 6  + @ 5 - ] LITERAL
            = IF  3 + ELSE QU THEN       ENDOF
    ENDCASE   HERE OVER U< IF QU THEN  \ don't go past  here
              -DUP WHILE 2+ REPEAT R> 2DROP ;


\   cross reference utility. Ken Bell     ( 22  5 92 crc  9:23 )
: (WHO)  \ pfa-1  ---  | search dict. for given word
   >R SPACE COL  VOC-LINK @   BEGIN   DUP 2- @
         BEGIN  PFA DUP CFA @ [ ' QUIT CFA @ ] LITERAL =
           IF DUP  R   {WHO}   THEN
\        CR  ?STACK   .S   ?TERMINAL IF ABORT THEN
           DUP LFA @ DUP 0= ROT NFA ?VOC OR  UNTIL
     DROP @ DUP 0= UNTIL   R> 2DROP .CT  WORDCT 1+! ;

: LOC   \ nfa  ---      | print out screen & line # if can
  BASE @ DECIMAL SWAP
  ' WHERETHEN OVER U< IF SPACE 2- @ WHERETHEN  C/L /
  14 [ BLK @ 1+ ] LITERAL .LINE 3 .R SPACE .SCR SPACE
  ELSE DROP THEN BASE ! ;


\   cross reference utility. Ken Bell     ( 22  5 92 crc  9:24 )
FORTH DEFINITIONS
: .CON  ."  Context" CONTEXT @ CREF .VOC ;

: .CUR  ."  Current" CURRENT @ CREF .VOC ;

: CROSS  ?CR BASE @  .CON CR  CONTEXT @ @ ( nfa ) CREF WORDCT
  OFF  BEGIN  DUP ?VOC  ?TERMINAL OR  OVER 0= OR  0= WHILE
  15 [ BLK @ ] LITERAL .LINE  SPACE  DUP AID. COL
  DUP LOC  PFA  DUP (WHO)  LFA @  REPEAT  DROP BASE ! WORDCT ? ;

: WHO   CREF COUNTEM OFF ?CR BASE @ 15 [ BLK @ ] LITERAL .LINE
  SPACE [COMPILE] ' HERE COUNT TYPE DUP NFA LOC (WHO)  BASE ! ;
;S
Line number
Words using:
\   cross reference utility. Ken Bell     ( 16  4 90 crc 15:25 )
: ?LIKE   [COMPILE] ' CFA @ >R  ?CR  BASE @ HEX  CONTEXT @ @
  CREF  COUNTEM OFF  BEGIN  PFA DUP CFA @ R  =
    IF DUP NFA AID.  COL  COUNTEM 1+!
    R  [ ' BASE CFA @ ] LITERAL  =  IF DUP   @ 6 U.R COL  THEN
    R  [ ' BL   CFA @ ] LITERAL  =  IF DUP   @ 6 U.R COL  THEN
    THEN  LFA @  DUP 0= ?TERMINAL OR  UNTIL
  R> 2DROP BASE !  .CT ;

: .VOCS  \ print list of current vocabularies
  CREF VOC-LINK  countem off  BEGIN  @ -DUP
     WHILE  COL DUP (.VOC) countem 1+! REPEAT  .ct ;




\   cross reference utility.              ( 17  8 90 crc 12:49 )
: .SEGS  \ print list of current external segments
  BASE @  HEX
  SEG-LINK  BEGIN  @ -DUP  WHILE CR  DUP NFA AID.  COL
  DUP 2+ @ CS@ + 6 U.R  DUP 4 + @  16 U*  16 D.R  REPEAT
  SEG-LINK @  2+  2@ +  DUP
  16 U*  CR  16 D.R ."  bytes total; "
  CS@ +  U.  ." next free segment."  BASE ! ;

: TASK ;        \ segments' pfa: | link | seg  | size |






( leo-forth editor: load                  (  2  1 87 crc       )
: LOAD DUP CR 0 5 D.R SPACE  LOAD  ;
: THRU  1+ SWAP DO I LOAD LOOP ;
BASE @ DECIMAL  HERE
VOCABULARY LEO IMMEDIATE          LEO DEFINITIONS
229 232 THRU 239 LOAD 234 238 THRU
HEX  HERE  SWAP  -  CR  6 .R  DECIMAL
: TRY  SCR @ LOAD ;
BASE ! FORTH DEFINITIONS LEO







( leo-forth editor: line text delim cursor  20 12 83 CRC       )
: LINE     ( line#  --- addr | get the addr of a given line #  )
    SCR @ (LINE) DROP ;

: TEXT     ( c ---  | put text until 'c' into pad              )
    HERE 65 BLANKS  WORD  HERE PAD 65 CMOVE ;

0 VARIABLE DELIM     ( Text delimiter                          )

: .CURSOR  (  --   | send out blinking delimiter as cursor     )
( plain vanilla )         DELIM C@ EMIT                 ;

: USE      ( Set delimiter                                     )
    BL WORD HERE 1+ C@ DELIM C! ;  USE ^ ;S
( H1420)  27 EMIT  1 EMIT DELIM C@ EMIT 27 EMIT 25 EMIT ;
( plain vanilla )         DELIM C@ EMIT                 ;
( leo-forth editor: #locate  -- insert-buf  07 12 83 CRC       )
: #LOCATE                ( Leave cursor offset-2, line -1      )
        R#  @  C/L  /MOD  ;
: #LEAD               ( Line address -2, offset-1              )
        #LOCATE  LINE  SWAP  ;
: #LAG           ( Cursor addr-2, count-1 after cursor         )
        #LEAD  DUP  >R  +  C/L  R>  -  ;
: -MOVE         ( Move in block buffer addr from-2, line-1     )
        LINE  C/L  CMOVE  UPDATE  ;
: BUF-MOVE ( addr --- | move pad to addr, if not null          )
   PAD 1+ C@ IF  PAD  SWAP 65  CMOVE ELSE DROP THEN ;
: >LINE#   (   ---- line# | give line# of cursor pos.          )
   #LOCATE SWAP DROP ;
: FIND-BUF         PAD  80 +    ;
: INSERT-BUF       PAD 160 +    ;

( leo-forth editor: {hold}  --  >>        ( 25  7 86 CRC 20:22 )
: (HOLD)   ( line# ---  | move line to insert buffer           )
     LINE INSERT-BUF 1+ C/L DUP INSERT-BUF C! CMOVE ;
: (KILL)   ( line# ---  | erase line to blanks                 )
     LINE C/L BLANKS UPDATE ;
: (SPREAD) (   ---   | spread block at cursor line             )
     >LINE# DUP 1 - 14
     DO I LINE I 1+ -MOVE   -1 +LOOP  (KILL) ;
: ?       (   ---   | display current line                     )
     CR SPACE #LEAD TYPE .CURSOR #LAG TYPE >LINE# . ;
: (DELETE) ( # ---   | zap # characters before cursor          )
     -DUP IF  >R #LAG + R -   #LAG R MINUS R# +!
     #LEAD + SWAP CMOVE    R> BLANKS  UPDATE  THEN ;
: >>       ( # ---   | move cursor # characters                )
     R# +! ? ;

( leo-forth editor: x, t, l, n, b, top, r, p07 12 83 CRC       )
: X       (  ---  | delete current line, save in buffer        )
     >LINE# DUP (HOLD)  15 DUP ROT
     DO I 1+ 15 MIN LINE I -MOVE LOOP  (KILL) ;
: T        ( line# ---  | move cursor to line & type it        )
     C/L * R# !   ? ;
: L        (  ---  |  list current screen                      )
     SCR @ LIST ;
: TOP  0 R# ! ;          ( home cursor                         )
: N    1 SCR +! TOP ;    ( move to next screen                 )
: B   -1 SCR +! TOP ;    ( move to last screen                 )
: (PUT)    (  ---  |  replace cusror line w/ i-buf             )
     >LINE#  INSERT-BUF 1+ SWAP -MOVE  ;
: P        (  ---  |  put text to current line & i-buf         )
     DELIM C@ TEXT  INSERT-BUF  BUF-MOVE  (PUT)  ;

( -text                                   ( 20  3 89 crc 10:10 )
HEX  (  addr1  count  addr2  --- f    )
ASSEMBLER HERE >R ( !*!)   DX SI MOV,  CX PUSH,  NEXT
CODE -TEXT ( addr1 len addr2 -- -1|0|1  | string compare   )
  SI DX MOV,  DI POP,  CX POP,  SI POP,  R ( !*!) JCXZ,
  CS PUSH,  ES POP,  REPZ,  .B CMPS,  R ( !*!) JE,
  0< IF,  1 # CX MOV,  r ( !*!) #) jmp,  then,  -1 # CX MOV,
  R> ( !*!) #) JMP,
 ;S

  flag:  1 means the $ at addr1 is less than the $ at addr2
         0 means the $ at addr1 is  equal to the $ at addr2
        -1 means the $ at addr2 is less than the $ at addr1



( leo-forth editor: match seek-error 1line( 10 11 86 CRC 21:33 )
: MATCH               ( addr1 count1 addr2 count2  --- f n3    )
   >R >R   2DUP R> ROT ROT R> ROT ROT BOUNDS   DO
      2DUP FORTH I -TEXT 0= IF >R 2DROP R> - FORTH I SWAP -
         0 SWAP 0 0 LEAVE  THEN LOOP 2DROP SWAP 0= SWAP ;

: SEEK-ERROR   (  ---  | error exit on searches                )
   TOP  FIND-BUF  COUNT TYPE  ."   ?" QUIT ;

: 1LINE  (  --- fl | scan for find buf, flag sucess            )
   #LAG  FIND-BUF  COUNT  MATCH  R#  +! ;

: (SEEK) (  ---  | search an entire screen                     )
   BEGIN  1023 R# @ <  IF SEEK-ERROR THEN  1LINE UNTIL ;


( leo-forth editor: wipe till f (f          07 12 83 CRC       )
: (F)    (  ---  | find given text                             )
     DELIM C@ TEXT  PAD 1+ C@ IF FIND-BUF  BUF-MOVE THEN
      (SEEK) ;

: F      (  ---  | find given text and display                 )
     (F)  ? ;

: WIPE     (  ---  | kill current block                        )
   0 SCR @ BLOCK DUP B/BUF BLANKS !  UPDATE  ;

: TILL ( delete on cursor line from cursor to end of given text)
   #LEAD + DELIM C@ TEXT   FIND-BUF BUF-MOVE
   1LINE 0= IF SEEK-ERROR THEN  #LEAD + SWAP - (DELETE) ? ;


( more editor: u e d k                       3  6 85 CRC       )
: U        (  ---  | put text under current line               )
    C/L R# +! (SPREAD) P ;

: E        (  ---  | erase backwards from cursor               )
    FIND-BUF C@ (DELETE) ? ;

: D        (  ---  | find it, kill it, show results            )
    (F) E ;

: K        (  ---  | swap find & insert buffers                )
    FIND-BUF PAD 65 CMOVE   INSERT-BUF FIND-BUF 65 CMOVE
    INSERT-BUF  BUF-MOVE ;



( leo-forth editor: i, r, m                 07 12 83 CRC       )
: I       (  ---  | insert text within a line                  )
    DELIM C@ TEXT  INSERT-BUF BUF-MOVE
    INSERT-BUF COUNT  #LAG ROT  OVER  MIN >R
    R R# +!  R - >R
    DUP HERE R CMOVE   HERE #LEAD +  R> CMOVE
    R> CMOVE UPDATE     ? ;

: R       (  ---  | replaced matched w/ insert                 )
    E I ;

: M        ( scr# line ---  | move line under given destination)
    SCR @ >R  R# @ >R    >LINE#  (HOLD)
    SWAP SCR !   1+ C/L * R# ! (SPREAD)   (PUT)
    R> C/L + R# !   R> SCR ! ;

( leo-forth editor: where, o                07 12 83 CRC       )
: O        ( nscr --- oscr | toggle between two screens        )
  SCR @ SWAP LIST ? ;

FORTH DEFINITIONS

: WHERE    ( in blk ---  | point the editor after an error     )
  DUP  B/SCR  /  DUP  SCR  !  DECIMAL  ."  SCR " . SWAP
  DUP R# ! C/L  /MOD  C/L  *  ROT  BLOCK  +  CR  C/L  -TRAILING
  TYPE CR HERE C@ - SPACES LEO .CURSOR   [COMPILE] LEO QUIT [
  SMUDGE





( -text in high level code.               ( 26  7 85 CRC       )
: -TEXT      (  addr1  count  addr2  --- f                     )
   (DO)       0 R> R> BOUNDS   ( uses knowledge of system stuff)
   DO OVER C@ I C@ -  OR
      DUP IF LEAVE ELSE SWAP 1+ SWAP THEN LOOP SWAP DROP ;






                                                             ;S
   SWAP >R >R 0 R> R> BOUNDS  ( straight high level stuff      )
flag:  0 means the $ at addr1 is equal to the $ at addr2
   non 0 means the $ at addr1 is not equal to the $ at addr2
useful in leoforth editor but not for database stuff.
\ begin trap grabbing stuff               ( 10  1 88 CRC 15:26 )
BASE @ >R  FORTH DEFINITIONS  PRESENT  FORGET TASK  DECIMAL
76 NEEDED [[    102 NEEDED MSSG  \  106 NEEDED MODULE
291 NEEDED @L   292 NEEDED CMOVEL
FORTH DEFINITIONS               VOCABULARY DEBUG IMMEDIATE

FORTH     DEFINITIONS
 242 256 HEX THRU

R> BASE !   DEBUG               EDITOR FLUSH
FORTH DEFINITIONS  : TASK ;     here first over - erase





\ recompile the debugger as needed        (  9  1 88 crc 20:31 )
debug restorevecs               fence off
forget debug                    : task ;
blk @ 1- load












\ ix!: call Mess-DOS                      ( 12  2 88 crc  7:58 )
CODE SR@   PUSHF,  NEXT
CODE SR!   POPF,   NEXT
ASSEMBLER DEFINITIONS

          \ Mess-DOS version
CODE IX!  \ addr vec# ---  | store addr & current CS in vec#
  AX POP,  25 # AH MOV,  DX POP,  21 INT,  NEXT

;S        \ Stand-Alone version
: IX!     \ addr vec# ---  | store addr & current CS in vec#
  2* 2* >R
  SR@  DUP FDFF AND SR!  SWAP \ no ixs during vector store!!
  0 R !L ( addr)  CS@ 0 R> 2+ !L ( code seg)  SR! ;


\ trap! ix                                ( 12  2 88 crc  8:08 )
: TRAP!   \ chk addr ix#  ---    | addr stored as #th vector
  FORTH  >R  ?CSP  -3 -   14 ?ERROR  R> IX! HERE FENCE ! ;

FORTH DEFINITIONS   \  -- chk addr | start code routine
: IX   HERE  -3 !CSP  [COMPILE] ASSEMBLER ;

DEBUG DEFINITIONS
0 VARIABLE REGISTERS     1C ALLOT  REGISTERS 1E ERASE
0 VARIABLE RESIDENT      1C ALLOT  RESIDENT  1E ERASE






\ status register printer                 ( 12  2 88 crc  8:38 )
HERE 1+ ," c p a zstidoiinr"

: .BIT  \ d c --  d' | add c to $ under const iff d is odd
  >R 2 M/MOD  ROT R> SWAP 0= IF DROP BL THEN HOLD ;

: (.STAT)  \ n --  addr ct | status $ ready for typing
  0  <#  10 0  DO  I
  [ 2 CSP +! ROT ] LITERAL +  C@ .BIT  LOOP  #>  ;

: .STAT    (.STAT) TYPE ;

: DIAGNOSE  \  n n n n n -- fl | diagnostic for traps
  DISASSEMBLER  HEX  IP U.  W ( dup ) U. ( >name .id )
  ." pc " SWAP 5 U.R ASCII : EMIT U.  DEBUG .STAT  1 CR
  DECIMAL ;
\ diagnostic aids                         ( 31  7 92 crc 16:34 )
10 SEGMENT SAFEIX               0 0  SAFEIX 0  100 CMOVEL

FORTH DEFINITIONS
: RESTOREVECS   DEBUG SAFEIX 0  0 0  100 CMOVEL ;

: COLD   RESTOREVECS  COLD STOP

: MON    RESTOREVECS  MON  STOP
: BYE    RESTOREVECS  BYE  STOP
DEBUG DEFINITIONS             ;S
CODE TESTIX  \ ix# ---  | Test an interrupt handler
  AX POP,  AL HERE 0A + #) MOV,  \ n. b: defeat 286 cache
  NOP, NOP,  NOP, NOP,  NOP, NOP,  0 INT,  NEXT
;s
CODE T0/     CX CX SUB,  12 # AX MOV,  CX DIV,  NEXT
\ default vector for uninited vectors                 15Sep87crc
;S
DTBONLY   \  *NOT* ON THE AT!
IX   W PUSH,  IP PUSH,
      ]] DIAGNOSE ABORT"  Uninited Vector!"  [

DEBUG DEFINITIONS
: FILLTRAPS   \ throwaway to init default vectors
  100 0 DO  2DUP  !CSP I ASSEMBLER TRAP!
  DEBUG LOOP 2DROP ;

FILLTRAPS   FORGET FILLTRAPS




\ Breakpoint stuff                                    24Dec87crc
;s
variable oldop  0 c,  \ save opcode for breakpoint

: breakpoint  \ addr --- | install breakpoint
  dup c@ oldop 2+ c!  dup oldop !  cc swap c! ;

: unbreak    \ addr ---  | uninstall breakpoint
  oldop 2+ c@  oldop @ c! ;







\ register saving stuff                   (  5  7 88 crc  8:42 )
ASSEMBLER DEFINITIONS    HERE \ ds <> cs until we set it.
  CS: AX 0 [BX] MOV,   \ save ax, since we need it.
  DS AX MOV,  CS: AX 12 [W] MOV,
  CS AX MOV,  AX DS MOV,  \ AX 10 [BX] MOV,
  CX 4 [W] MOV,  DX 6 [W] MOV,
  BP 0A [W] MOV,  SI 0C [W] MOV,  DI 0E [W] MOV,
  ES AX MOV,  AX 16 [W] MOV,  RET,

CONSTANT STUFFEM      ASSEMBLER
DEBUG DEFINITIONS





\ register restoring stuff                (  5  7 88 crc  8:42 )
ASSEMBLER DEFINITIONS    HERE \ ds =  cs until line 10
      0A [W] BP MOV,  0C [W] SI MOV,    0E [W] DI MOV,
      16 [W] AX MOV,  AX ES MOV,
       4 [W] CX MOV,  6 [W] DX MOV,
      12 [W] AX MOV,  AX DS MOV,
  CS:  0 [W] AX MOV,  CS:  2 [W] BX MOV, RET,

CONSTANT GRABEM       ASSEMBLER
DEBUG DEFINITIONS     0 VARIABLE COUNTER






\ Registers by name                       (  5  7 88 crc  7:36 )
: REGISTER   \ r: n --      | compile register name
  <BUILDS C, \ c:   -- addr | return addr of that register
  DOES>  C@  REGISTERS + ;

 0 REGISTER AX   2 REGISTER BX   4 REGISTER CX   6 REGISTER DX
 8 REGISTER SP  0A REGISTER BP  0C REGISTER SI  0E REGISTER DI
10 REGISTER CS  12 REGISTER DS  14 REGISTER SS  16 REGISTER ES
18 REGISTER PC  1A REGISTER SR
AA55 SR !                       CS@ CS !        100 PC !

 2 REGISTER W   0A REGISTER RP  0C REGISTER IP  \ forth regs

\    optional:  n. b: reference w/  c@ , c! .
 0 REGISTER AL   2 REGISTER BL   4 REGISTER CL   6 REGISTER DL
 1 REGISTER AH   3 REGISTER BH   5 REGISTER CH   7 REGISTER DH
\ stack space and display for target      (  6  7 88 crc  6:47 )
HERE 40 ALLOT HERE 10 ALLOT  CONSTANT TOS      50 ERASE
HERE 20 ALLOT HERE 10 ALLOT  CONSTANT TRET     30 ERASE

: SHOWRETURN   SEG @  CS @ SETSEG  BP @ 10 - 28 DUMP  SETSEG ;

: SHOWSTACK    SEG @  CS @ SETSEG  SP @ 10 - 28 DUMP  SETSEG ;

: .NAME     \  -- | print name of word being executed
  W @ 2+ NFA ID. ;

: SHOWSTACKS  SHOWSTACK SHOWRETURN ;           ;S
: SHOWRETURN
  RELOC 2@  HOMESEG BP @ RELOC ! -10 28 DUMP  RELOC 2! ;
: SHOWSTACK
  RELOC 2@  HOMESEG SP @ RELOC ! -10 28 DUMP  RELOC 2! ;
\ showall                                 (  5  7 95 crc 22:20 )
: .REGS   EXEC  DISASSEMBLER  \ i --  | print ith register
  AX BX CX DX  SP BP SI DI  CS DS SS ES      STOP

: .RG   OUT @  OVER .REGS 3+
   BEGIN  OUT @ OVER -  WHILE  SPACE  REPEAT  DROP
   2* REGISTERS +  DUP  @ 4 U.R SPACE  DUP 1+ 1 LASCI 1 LASCI ;

: SHOWALL  \  --  | display all registers
  SEG @  BASE @ HEX  CS @ SETSEG  0C 0 DO
  I 6 MOD 0= IF CR THEN  I .RG  SPACE SPACE  LOOP  CR
  SR @ .STAT  PC @ DISASSEMBLER CP !  INST DEBUG
  3C TAB COUNTER @ 6 .R     CS @  CS@ =
  PC @ 3 -  5  ASSEMBLER >NEXT  EDITOR -CSTEXT DEBUG 0=
    AND IF  CR .NAME  THEN  SPACE  BASE !  SETSEG ;
0 VARIABLE STS          SHOWALL
\ step                                    (  5  7 88 crc  9:49 )
CODE STEP    \  --   | perform a single step
  1 # AX MOV,  HERE ( ** )  AX STS #) MOV,  HERE ( ## )
  6 # REGISTERS 8 + #) SUB,
  SS 14 RESIDENT + #) MOV,  SP 8 RESIDENT + #) MOV,
  BX RESIDENT 2+ #) MOV,  RESIDENT #) BX LEA,  STUFFEM #) CALL,
  REGISTERS #) BX LEA,
  REGISTERS 8 + #) BP MOV,  REGISTERS 14 + #) ES MOV,
     18 [W] AX MOV,  ES: AX 0 [BP] MOV,          \  pc
     10 [W] AX MOV,  ES: AX 2 [BP] MOV,          \  cs
     1A [W] AX MOV,  ES: AX 4 [BP] MOV,          \  sr
  GRABEM #) CALL,  CS: 14 REGISTERS + #) SS MOV,
  CS: 8 REGISTERS + #) SP MOV,  IRET,
CODE STEPS  \ n --  | perform n steps
  AX POP,  SWAP ( ** ) #) JMP,
CODE S  ' STEP CFA @ LATEST PFA CFA !  \ sneaky alias technique
\ single step handling routine            ( 23  2 89 crc 10:08 )
>R ( ## )   IX  CS: BX REGISTERS 2+ #) MOV,
  CS: SS 14 REGISTERS + #) MOV,  CS: SP 8 REGISTERS + #) MOV,
  CS: REGISTERS #) BX LEA,   AX PUSH,  BP PUSH,
  SP BP MOV,  4 [BP] AX MOV,  CS: AX 18 [W] MOV,       \  pc
              6 [BP] AX MOV,  CS: AX 10 [W] MOV,       \  cs
              8 [BP] AX MOV,  CS: AX 1A [W] MOV,       \  sr
  BP POP,  AX POP,
  CS: 14 RESIDENT + #) SS MOV,  CS: 8 RESIDENT + #) SP MOV,
  STUFFEM #) CALL,  COUNTER #) INC,  6 # REGISTERS 8 + #) ADD,
  RESIDENT # BX MOV,  GRABEM #) CALL,
  STS #) DEC,  0<> IF,  R> ( ## ) #) JMP,  THEN,
  ]] SHOWALL   ;S [
ASSEMBLER  2DUP  >R >R 3 TRAP!  R> R> 1 TRAP!

CODE T  ' STEP CFA @ LATEST PFA CFA !  \ sneaky alias technique
\ setup for target stuff                  ( 12  2 88 crc  8:51 )
: (TR)   \ addr ---  | execute at addr
  HOMESEG  DEBUG REGISTERS 1C ERASE ;

: (TRACE)  \ addr ---  | execute at addr
  DEBUG PC !  TOS 4 - SP !  TRET BP !   COUNTER OFF
  CS@ DUP CS !  DUP SS !  DS !   ES OFF
  SR@  200 AND 100 OR SR !  HEX  [COMPILE] DEBUG  SHOWALL ;

FORTH DEFINITIONS
: TRACE  \ addr ---  | execute at addr
  DEBUG (TR)  (TRACE) ;

: TRACE:  \   --   | execute word whose name follows
  DEBUG (TR)  [COMPILE] ' CFA DUP W !  @ (TRACE) ;

\ >stack, doint, skip, take (instruction) (  8 10 90 crc 12:51 )
DEBUG DEFINITIONS
CODE >STACK   \  ct  --   | move ct cells from res to target.
  !CSP  CX POP,  CX AX MOV,  AX SHL,  AX NEG,
  DEBUG SP ASSEMBLER #) DI MOV,  DI AX ADD,   AX DI MOV,
  DO,  0 [DI] .B POP,  DI INC,  DI INC,  LOOPNE,
  AX DEBUG SP ASSEMBLER #) MOV,  ]] SHOWALL ;   SMUDGE

: DOINT  SR @ 100 OR SR ! ;

: SKIP     \  --  | skip the next instr
  SEG @ >R  CS @ SETSEG  PC @  DISASSEMBLER CP !  INST
  CP @  DEBUG PC !  SHOWALL    R> SETSEG  ;
: TAKE     \  --  | take most recent bran, jmp, etc.
  SEG @ >R  DISASSEMBLER  TARG 2@  DEBUG CS !
  PC !  SHOWALL  R> SETSEG  ;
\ screen attribute show code              ( 27  2 91 crc 10:36 )
FORTH DEFINITIONS   BASE @ DECIMAL 260 NEEDED DOK  BASE !
FORGET TASK                     HERE FIRST OVER - ERASE
: TASK ; BASE @ HEX             DOK
: .##  S->D  <# # # #>  TYPE ;
CODE J 4 [BP] PUSH,  NEXT
: ATTS   \ --  | show attributes on screen
  XY@  BASE @ HEX  ATTRIBUTE @
  1 0 GOTOXY  3 SPACES  10 0 DO I 2 .R LOOP
  100 0 DO CR  DUP ATTRIBUTE !  I .## SPACE  I ATTRIBUTE !
    10 0 DO  SPACE J I +  RAW   ATTRIBUTE 1+!  LOOP
    10 +LOOP  ATTRIBUTE !  BASE !  >R 12 MAX R>  GOTOXY ;
: CHARS  100 0 DO  I 20 MOD 0= IF CR 27 SPACES THEN  I RAW
  LOOP ;
: SHOW  EDITOR FLUSH   PAGE   CHARS  CR  ATTS ;
BASE ! EDITOR   SHOW
\ multi-tasking support                   ( 30  1 90 crc 10:56 )
BASE @ >R DECIMAL     EDITOR FLUSH     HERE FIRST OVER - ERASE
FORTH DEFINITIONS   FORGET TASK  ATTRIBUTE @  8224 ATTRIBUTE !
ASSEMBLER >NEXT ' PAUSE CFA ! FORTH DEFINITIONS
0 USER MOI      2 USER SPSAVE   4 USER MYLINK   MOI MYLINK !
290 NEEDED }RELINK  HEX HERE  UP #) BX MOV,  IP PUSH,  RP PUSH,
  SP OFUSER SPSAVE MOV,  BEGIN,   OFUSER MYLINK BX MOV,
    28 INT, ( dos)  -1 # OFUSER MOI TEST,  0<> UNTIL,
  OFUSER SPSAVE SP MOV,  RP POP,  IP POP,  BX UP #) MOV,  NEXT
: (MKEY) BEGIN PAUSE ?KEY UNTIL <KEY> ;  ' PAUSE CFA !
: MKEY  [ ' (MKEY) CFA ] LITERAL  'KEY ! ;            MKEY
: SCLOCK (GETTIME) NIP BEGIN SAFELINK{ .CLOCK }RELINK PAUSE
  AGAIN STOP    1 +BLK LOADER TASK: \ cfa addr ---  | builds
100 ALLOT HERE  70 ALLOT  CONSTANT FRED   ' SCLOCK FRED TASK:
: COLD  ASSEMBLER >NEXT [ ' PAUSE CFA ] LITERAL ! COLD STOP
R> BASE !  FORTH DEFINITIONS    : TASK ;  ATTRIBUTE !
\ multi-tasking: how to build a task      ( 15 12 89 crc 10:19 )
SWAP  >R  >R   MOI R 70 CMOVE  ( build user area )
R 100 -  DUP 100 ERASE  R DP MOI - + ! ( here )
R 80 - DUP ( return )  80 - DUP ( stack, limit )
( 3 B/BUF 4 + * ) 10 - ( first )   'FIRST MOI - R + !
DUP  'LIMIT MOI - R + !   10 +  R 3A + ! ( bot of stack )
DUP  2-  R> R> SWAP >R OVER ! ( ip to run )  2-  R 10 -  OVER !
SPSAVE MOI - R + !  ( sp )   SP0 MOI - R + ! ( top of data )
MOI MYLINK OVER -  R + !  ( fred's link )   R ON  \ flag on
R MYLINK !   HERE FENCE !
R> 80 DUMP CR





\ begin direct to screen driver           (  3  7 92 crc 22:27 )
FORGET TASK     VOCABULARY DIRECT IMMEDIATE  DIRECT DEFINITIONS
BASE @  HEX      ( ' (OK) ' | CFA 'OK !  OK      TKEY
0 VARIABLE CURSE                \ 0A ATTRIBUTE C!

\ uses: si, di, cx, ax. enter w/ target segment in es, ds.
ASSEMBLER BEGIN,   18 50 * # CX MOV,  IP PUSH,
  DI DI SUB,  A0 # SI MOV,  REP, MOVS,   CS: UP #) BX MOV,
  CS: OFUSER ATTRIBUTE AX MOV,  20 # AL MOV,  50 # CL MOV,
  REP, AX STOS,  IP POP,  RET,  1 ?PAIRS  CONSTANT (SCROLL)

BLK @ 1+ DUP 3 + THRU      BASE !

  : DOK  DIRECT  ' (DOK) CFA 'OK !  OK ;
\ : OOK          ' (OK)  CFA 'OK !  OK ;
: TASK ;                        EDITOR FLUSH
\ direct to screen driver                 (  9 12 91 crc 10:15 )
ASSEMBLER BEGIN,     \ set cursor from dos memory
  40 # AX MOV,  AX DS MOV,
  50 #) AL MOV,  CBW,  AX BX MOV,  51 #) AL MOV,  CBW,

BEGIN,     \ set cursor from ax & bx
  40 # DX MOV,  DX DS MOV,  AL 51 #) MOV,  BL 50 #) MOV,
  50 # AH MOV,  AH MUL,  BX AX ADD,  CS: AX CURSE #) MOV,
  CS AX MOV,  AX DS MOV,

BEGIN,    \ place 6845 cursor from  curse .
  CURSE #) BX MOV,  VCTLR #) DX MOV,  0F # AL MOV,  DX AL OUT,
  DX INC,  BL AL MOV,  DX AL OUT,  DX DEC,  0E # AL MOV,
  DX AL OUT,  DX INC,  BH AL MOV,  DX AL OUT,
  RET,  1 ?PAIRS  CONSTANT (CURSE)
  1 ?PAIRS  CONSTANT (SETCURSE)  1 ?PAIRS CONSTANT (XY)
\ direct to screen driver                 ( 16  3 90 crc  9:26 )
CODE DPAGE   \  --  | clear scr & home cursor
  UP #) BX MOV,  OFUSER ATTRIBUTE AX MOV,
  19 50 * # CX MOV,  VIDEO-SEG #) ES MOV,
\ 10 # AX ADD,  FF7F # AX AND,  AX OFUSER ATTRIBUTE MOV, \ cute
  20 # AL MOV,  DI DI SUB,  REP, AX STOS,
  AX AX SUB,  AX BX MOV,  (SETCURSE) #) CALL,  NEXT

CODE DCR   \  --  | Carriage return/line feed
\ UP #) BX MOV,  OFUSER ATTRIBUTE AX MOV,               \ also
\ AX INC,  FF7F # AX AND,  AX OFUSER ATTRIBUTE MOV,     \ cute
  40 # AX MOV,  AX DS MOV,  0 # 50 #) .B MOV,   HERE    \ lf
  51 #) .B INC,  18 # 51 #) .B CMP,  > IF,
  CS: VIDEO-SEG #) AX MOV,  AX DS MOV,  AX ES MOV,
  (SCROLL) #) CALL,  40 # AX MOV,  AX DS MOV,  51 #) DEC,  THEN,
  (XY) #) CALL,  CS PUSH,  DS POP,  NEXT
\ direct to screen driver                 ( 28 11 90 crc 13:15 )
>R  CODE DEMIT    \ ch ---  | direct emit: place on screen
  DX POP,  ' (EMIT) NFA 1- #) DL AND,  CTL G # DL CMP,
  0= IF,  DX PUSH, ( bell) ' (EMIT) CFA @ #) JMP,  THEN,
    CTL M # DL CMP,  0<> IF,  CTL J # DL CMP,
          0= IF, 40 # AX MOV, AX DS MOV, R> #) JMP,  THEN,
      DS PUSH,  40 # AX MOV,  AX ES MOV,
      CTL H # DL CMP,  0= IF,  ES: 50 #) .B DEC,  \ raw entry pt
        0< IF,  ES: 0 # 50 #) .B MOV,  THEN,  ELSE,  HERE >R
      UP #) BX MOV,  OFUSER ATTRIBUTE DH MOV,
      CURSE #) BX MOV, BX BX ADD, ( 2*)
      VIDEO-SEG #) DS MOV,  DX 0 [BX] MOV,
      ES: 50 #) .B INC,  ES: 50 #) AL MOV,
      50 # AL CMP, >= IF,  0 # AL MOV,  ES: AL 50 #) MOV,
        ES: 51 #) .B INC, ES: 51 #) AL MOV,     R>

\ direct to screen driver                 ( 10  2 19 crc 19:14 )
  >R    18 # AL CMP,  > IF,  ES: 51 #) .B DEC,  ES PUSH,
          DS AX MOV,  AX ES MOV,  (SCROLL) #) CALL,  ES POP,
    THEN,  THEN,  THEN,  ELSE,
    DS PUSH,  40 # AX MOV,  AX DS MOV,
    0 # 50 #) .B MOV,   THEN,  (XY) #) CALL,  DS POP,  NEXT

CODE DGOTO   \  y x --- | set cursor raw
  BX POP,  AX POP,  (SETCURSE) #) CALL,  NEXT

FORTH DEFINITIONS
CODE RAW  DX POP,       \ c --  | unfiltered screen write
      DS PUSH,  40 # AX MOV,  AX ES MOV,  R> #) JMP,

: (DOK) [ direct ' demit cfa ] literal  isemit !  XY@ dgoto
     OUTPUT>  DEMIT   (TYPE)  DGOTO  DPAGE  NLIST  DCR  STOP
\ non-ix key query                        (  3  3 88 crc  7:24 )
FORGET TASK    BASE @ HEX
CODE ?DKEY  \   --- fl | is there a key ready?
  KEYCODE #) AL MOV,  0 # AL CMP,   0= IF, DROP
  40 # AX MOV,  AX DS MOV,  1A #) AX MOV,  1C #) AX CMP,
  CS AX MOV,  AX DS MOV,
  0= IF,  0 # AX MOV,  ELSE, ROT 2 THEN, \ unstructured
  1 # AX MOV,  THEN,  1PUSH

: (DKEY)   KTIME @  BEGIN  ?DKEY 0= WHILE  PAUSE  REPEAT
  KTIME ! <KEY> ;

: DKEY  [ ' (DKEY)  CFA ] LITERAL 'KEY ! ;
EDITOR FLUSH BASE !    : TASK ;


\ cpz download                            ( 14  3 88 crc 13:05 )
DECIMAL 201 NEEDED DOREQUEST  FORGET TASK   FORTH DEFINITIONS
: TASK ;  HEX  : T! FUDGE @ + ! ;   : TC! FUDGE @ + C! ;
: (BYTE)  ( b -- addr ct ) 0 <# BL HOLD # # #> ;
: BYTE    ( b -- )  (BYTE) SLTYPE  SLURP ;
: BYTES   ( addr ct --  )
  -DUP IF  BOUNDS DO  I C@ BYTE  LOOP  ELSE  DROP  THEN ;
0 VARIABLE BASE-ADDR   2000 2- ALLOT
2000 CONSTANT TARGETSIZE   BASE-ADDR 2000 ERASE
: DOWNLOAD  SLURP CTL M XEMIT SLURP   BASE @ >R HEX
  ASCII E XEMIT SLURP  S." 40:100"
  CTL M XEMIT SLURP BASE-ADDR TARGETSIZE BYTES
  CTL M XEMIT  FN4  TERM  R> BASE ! ;
: IMAGE  100 TARGETSIZE ;  : >IMAGE  BASE-ADDR 100 - FUDGE ! ;
FILING OPF: REAL4TH.pat  BASE-ADDR 2000 HANDLE RDF
CLF  ' TARGETSIZE !  EDITOR FLUSH   >IMAGE
\ support in 14 for serial i/o            ( 12  5 88 crc  9:07 )
FORGET TASK
( : TASK ;  )  BASE @ HEX       0 VARIABLE COM#
CODE X?KEY   \  --  fl  | is there a key for us?
  COM# #) DX MOV,  3 # AH MOV,  14 INT,   1 # AH AND,
  0= IF, 0 # AX MOV,  ELSE,  1 # AX MOV,  THEN,  1PUSH

CODE XKEY    \  --  ch  | get a keystroke
  COM# #) DX MOV,  2 # AH MOV,  14 INT,  7F # AX AND,  1PUSH

: SLURP   BEGIN X?KEY WHILE  XKEY EMIT  REPEAT ;

: PURGE  BEGIN X?KEY WHILE  XKEY DROP  REPEAT ;

BLK @ 1+ DUP 1+ THRU    EDITOR FLUSH   : TASK ;    BASE !

\ support in 14 for serial i/o            ( 19  9 88 crc 12:17 )
HEX                             3F8 CONSTANT ACE
ACE     CONSTANT DATA           ACE 1+  CONSTANT IER
ACE 2+  CONSTANT IIR            ACE 3+  CONSTANT LCR
ACE 4 + CONSTANT MCR            ACE 5 + CONSTANT LSR

: XBREAK  LCR PC@  DUP 40 OR  LCR PC!  DUP DROP  LCR PC! ;

: SETBAUD  LCR PC@  DUP 80 OR LCR PC!  SWAP ACE P!  LCR PC! ;

: SHOWSTAT  CR ."   baud  data  ier  iir  lcr  mcr  lsr  msr"
  CR  LCR PC@  DUP  80 OR  LCR PC!  ACE P@ 6 .R  LCR PC!
  SPACE  ACE 7 BOUNDS DO I PC@ 5 .R LOOP  ;

\ 0 4 14 * @L CONSTANT STARTIX    0 4 14 * 2+ @L CONSTANT RSSEG

\ support in 14 for serial i/o            ( 22  8 89 crc 15:09 )
CODE XEMIT \ c --- | send to host
  LSR # DX MOV,  20 # ( THRE bit ) AH MOV,
  BEGIN,  DX AL IN,  AH AL AND,  0<> UNTIL,
  AX POP,  DATA # DX MOV,  DX AL OUT,  NEXT

: 9600BAUD  0C SETBAUD ;        : 300BAUD   180 SETBAUD ;

: 19.2BAUD   6 SETBAUD ;

: SETUP   \ mode = com1:9600,n,8,1
  9600BAUD  MCR PC@ 8 OR MCR PC!  21 PC@ E7 AND 21 PC!
  3 ( 8 bits, no parity) LCR PC!  1 IER PC! SHOWSTAT ;

SETUP   CR

\ 80X86 assem: load                       (  9  7 88 crc 10:45 )
FORTH DEFINITIONS  BASE @ >R HEX
VOCABULARY ASSEMBLER IMMEDIATE   ASSEMBLER DEFINITIONS

  1 BLK @ +   12 BLK @ +   THRU

\ : END-CODE ;

( : C; ; ) R> BASE ! FORTH DEFINITIONS

: CODE  CREATE !CSP SMUDGE [COMPILE] ASSEMBLER ;  CR

: ;CODE  ?CSP COMPILE (;CODE)  [COMPILE] ASSEMBLER
  [COMPILE] [ SMUDGE   ; IMMEDIATE


\ assembler testing screen                (  5  8 89 crc 10:34 )
\ code tc,  ' c, cfa @  latest pfa cfa !           \ for normal
\ code t,   ' ,  cfa @  latest pfa cfa !           \ usage
\ code md,  ' ,  cfa @  latest pfa cfa !
;s

: #er    0 do # loop ;        \ fixed field printing

: tc,   0 <#  2 #er  #> space  type ;             \ for testing

: t,    0 <#  4 #er  #> space  type ;

\ : md,   base @  swap  8 base !
\   0 <#  3 #er  #> space  type  base ! ;
;s

\ real-FORTH assembler glue               ( 27  1 88 crc  8:29 )
FORTH DEFINITIONS
: NIP      SWAP DROP ;

ASSEMBLER DEFINITIONS
: 0<>  IF -1 ELSE 0 THEN ;

 8 BASE !  \   OCTAL








\ 8086 Assembler                          (  6 12 87 CRC 21:59 )
;S
The 8086 Assembler was written by Mike Perry.
To create and assembler language definition, use the defining
word CODE.  How the assembler operates is a very
interesting example of the power of CREATE DOES>   Basically
the instructions are categorized and a defining word is
created for each category.  When the nmemonic for the
instruction is interpreted, it compiles itself.

Reworked and modified to run on real-FORTH by Charles Curley.





\ 8086 Assembler                          (  1 11 95 crc 12:18 )
\ : LABEL  <BUILDS  [COMPILE] ASSEMBLER   ;
\ 232 CONSTANT DOES-OP
\ 3 CONSTANT DOES-SIZE
\ : DOES?   ( IP -- IP' F )
\    DUP DOES-SIZE + SWAP C@ DOES-OP =  ;
ASSEMBLER DEFINITIONS
\ : C;   ( -- )   END-CODE   ;
HEX
' SP! 2+ @ DUP CONSTANT UP  ." UP is "  0 D.
8 BASE !

: BRSIZE   -200 177 WITHIN 0= 5 ?ERROR  ;
0 VARIABLE INTER


\ 8086 Assembler   Register Definitions   (  9  7 88 crc 10:50 )
: REG    11 * SWAP 1000 * OR CONSTANT   ;
: REGS   ( MODE N -- )   SWAP 0 DO  DUP I REG  LOOP  DROP ;

10 0 REGS   AL  CL  DL  BL  AH  CH  DH  BH
10 1 REGS   AX  CX  DX  BX  SP  BP  SI  DI
10 2 REGS   [BX+SI] [BX+DI] [BP+SI] [BP+DI] [SI] [DI] [BP] [BX]
 4 2 REGS   [SI+BX] [DI+BX] [SI+BP] [DI+BP]
 4 3 REGS   ES  CS  SS  DS
 3 4 REGS   #   #)  S#)

BP CONSTANT RP   [BP] CONSTANT [RP]   ( RETURN STACK POINTER )
SI CONSTANT IP   [SI] CONSTANT [IP]   ( INTERPRETER POINTER )
BX CONSTANT W    [BX] CONSTANT [W]   ;S WORKING REGISTER )
also: sp is data stack, and beware of seg registers

\ Addressing Modes                        (  9  7 88 crc 10:51 )
: MD  <BUILDS 1000 * ,  DOES>  @ SWAP 7000 AND = 0<>  ;
( 0 MD R8? )  1 MD R16?   2 MD MEM?   3 MD SEG?   4 MD #?
: REG?   ( n -- f )   7000 AND 2000 < 0<> ;
: BIG?   ( N -- F )   ABS -200 AND 0<>  ;
: RLOW   ( n1 -- n2 )    7 AND ;
: RMID   ( n1 -- n2 )   70 AND ;
1 VARIABLE SIZE                 0 VARIABLE LOGICAL
: OP,   ( N OP -- )   OR C,  ;
: W,   ( OP MR -- )   R16? 1 AND OP,  ;
: SIZE,   ( OP -- OP' )   SIZE @ OP,  ;
: ,/C,  ( n f -- )   IF  ,  ELSE  C,  THEN  ;
: RR,  ( MR1 MR2 -- )   RMID SWAP RLOW OR 300 OP,  ;
: B/L?   ( n -- f )   BIG? LOGICAL @ OR  ;


\ Addressing                              (  1 11 95 crc 12:17 )
: MEM,   ( DISP MR RMID -- )   OVER #) =
   IF  RMID 6 OP, DROP ,
   ELSE  RMID OVER RLOW OR ROT ROT [BP] = OVER 0= AND
   IF  SWAP 100 OP, C,  ELSE  SWAP OVER BIG?
   IF  200 OP, ,  ELSE  OVER 0=
   IF  C, DROP  ELSE  100 OP, C,
   THEN THEN THEN THEN  ;
: WMEM,   ( DISP MEM REG OP -- )   OVER W, MEM,  ;
: R/M,   ( MR REG -- )
   OVER REG? IF  RR,  ELSE  MEM,  THEN  ;
: WR/SM,   ( R/M R OP -- )   3 PICK DUP REG?
   IF  W, RR,  ELSE  DROP SIZE, MEM,  THEN  SIZE ON ;
: ?FAR   ( n1 -- n2 )   INTER @ IF  10 OR  THEN  INTER OFF ;


\ Defining Words to Generate Op Codes     ( 30  3 88 crc  6:40 )
: 1MI  <BUILDS C,  DOES>  C@ C,  ;
: 2MI  <BUILDS C,  DOES>  C@ C,  12 C,  ;
: 3MI  <BUILDS C,  DOES>  C@ C,  HERE - 1-  DUP BRSIZE C, ;
: 4MI  <BUILDS C,  DOES>  C@ C,  MEM,  ;
: 5MI  <BUILDS C,  DOES>  C@ SIZE,  SIZE ON ;
: 6MI  <BUILDS C,  DOES>  C@ SWAP W,  ;
: 7MI  <BUILDS C,  DOES>  C@ 366 WR/SM, ;
: 8MI  <BUILDS C,  DOES>  C@ SWAP R16? 1 AND OR  SWAP # =
   IF  C, C,  ELSE  10 OR  C,  THEN  ;
: 9MI  <BUILDS C,  DOES>  C@  OVER R16?
   IF  100 OR SWAP RLOW OP,  ELSE  376 WR/SM,  THEN  ;
: 10MI <BUILDS C,  DOES>  C@ OVER CL =  IF  NIP 322 WR/SM,
  ELSE  OVER # = IF  ROT >R 300 ROT DROP WR/SM,  R> C,
  ELSE  320 WR/SM,  THEN THEN   ;

\ Defining Words to Generate Op Codes                 15MAY84HHL
: 11MI  <BUILDS C, C,  DOES>  OVER #) =
   IF  NIP C@ INTER @
     IF  1 AND IF 352  ELSE 232  THEN C,  SWAP , , INTER OFF
     ELSE  SWAP HERE - 2- SWAP  2DUP 1 AND SWAP BIG? 0= AND
       IF  2 OP, C,  ELSE  C,  1- ,  THEN  THEN
   ELSE  OVER S#) = IF  NIP #) SWAP  THEN
     377 C, 1+ C@ ?FAR  R/M,  THEN  ;
: 12MI  <BUILDS C, C, C,  DOES>  OVER REG?
   IF  C@ SWAP RLOW OP,  ELSE  1+ OVER SEG?
     IF  C@ RLOW SWAP RMID OP,
     ELSE  COUNT SWAP C@ C,  MEM,
   THEN THEN  ;
: 14MI  <BUILDS C,  DOES> C@
   DUP ?FAR C,  1 AND 0= IF  ,  THEN ;

\ Defining Words to Generate Op Codes     (  9  7 88 crc 10:56 )
: 13MI  <BUILDS C, C,  DOES>  COUNT >R C@ LOGICAL !  DUP REG?
   IF  OVER REG?
     IF  R> OVER W, SWAP RR,  ELSE  OVER DUP MEM? SWAP #) = OR
     IF  R> 2 OR WMEM,  ELSE  ( # ) NIP  DUP RLOW 0= ( acc? )
     IF  R> 4 OR OVER W, R16? ,/C,
     ELSE  OVER B/L? OVER R16? 2DUP AND
       ROT ROT  1 AND SWAP 0= DUP + OR 200 OP,
       SWAP RLOW 300 OR R> OP,  ,/C,
     THEN  THEN  THEN
   ELSE  ( mem )  ROT DUP REG?
     IF  R> WMEM,
     ELSE  ( # ) DROP  3 PICK B/L? DUP 0= DUP + 200 OR SIZE,
       ROT ROT R> MEM,  SIZE @ AND ,/C,  SIZE ON
   THEN  THEN  ;

\ Instructions                            (  9  7 88 crc 10:53 )
: TEST,  ( source dest -- )   DUP REG?
   IF  OVER REG?
     IF  204 OVER W, SWAP RR,  ELSE  OVER DUP MEM? SWAP #) = OR
     IF  204 WMEM,  ELSE  ( # ) NIP  DUP RLOW 0= ( ACC? )
     IF  250 OVER W,
     ELSE  366 OVER W,  DUP RLOW 300 OP,
     THEN   R16? ,/C,  THEN  THEN
   ELSE  ( MEM )  ROT DUP REG?
     IF  204 WMEM,
     ELSE  ( # ) DROP  366 SIZE,  0 MEM,  SIZE @ ,/C,  SIZE ON
   THEN  THEN  ;

: FAR    ( -- )  INTER ON ;
: .B     ( -- )   SIZE OFF ;

\ Instructions                                        16Oct83map
HEX
: ESC,  ( source ext-opcode -- )   RLOW 0D8 OP, R/M,  ;
: INT,  ( N -- )   0CD C,  C,  ;
: SEG   ( SEG -- )   RMID 26 OP,  ;

: CS:   CS SEG ;                : DS:   DS SEG ;
: ES:   ES SEG ;                : SS:   SS SEG ;

\ : OPSIZE: 66 C, ;               : ADDSIZE: 67 C, ;

: XCHG,  ( MR1 MR2 -- )   DUP REG?
   IF  DUP AX =
     IF  DROP RLOW 90 OP,  ELSE  OVER AX =
     IF  NIP  RLOW 90 OP,  ELSE  86 WR/SM,  THEN  THEN
   ELSE  ROT 86 WR/SM,  THEN  ;
\ Instructions                                        18APR83HHL
: MOV,  ( S D -- )   DUP SEG?
   IF  8E C, R/M,  ELSE  DUP REG?
     IF  OVER #) = OVER RLOW 0= AND
       IF  A0 SWAP W,   DROP  ,  ELSE  OVER SEG?
       IF  SWAP 8C C, RR,  ELSE  OVER # =
       IF  NIP DUP R16? SWAP RLOW OVER 8 AND OR B0 OP, ,/C,
       ELSE  8A OVER W, R/M,  THEN THEN THEN
     ELSE  ( MEM ) ROT DUP SEG?
       IF  8C C, MEM,  ELSE  DUP # =
       IF  DROP C6 SIZE, 0 MEM,  SIZE @ ,/C,
       ELSE  OVER #) = OVER RLOW 0= AND
       IF  A2 SWAP W,  DROP  ,   ELSE  88 OVER W, R/M,
   THEN THEN THEN THEN THEN   SIZE ON ;


\ Instructions                            ( 25  1 88 crc 12:32 )
\ 37 1MI AAA,    D5 2MI AAD,    D4 2MI AAM,     3F 1MI AAS,
0 10 13MI ADC, 0 00 13MI ADD,  2 20 13MI AND,  10 E8 11MI CALL,
  98 1MI CBW,    F8 1MI CLC,    FC 1MI CLD,     FA 1MI CLI,
( F5 1MI CMC,) 0 38 13MI CMP,   A6 5MI CMPS,    99 1MI CWD,
( 27 1MI DAA,    2F 1MI DAS,)   08 9MI DEC,     30 7MI DIV,
       ( ESC ) ( F4 1MI HLT, )  38 7MI IDIV,    28 7MI IMUL,
  E4 8MI IN,      0 9MI INC,  \      ( INT )    CE 1MI INTO,
  CF 1MI IRET, \ 77 3MI JA,     73 3MI JAE,     72 3MI JB,
( 76 3MI JBE,)   E3 3MI JCXZ,   74 3MI JE,  \   7F 3MI JG,
( 7D 3MI JGE,    7C 3MI JL,     7E 3MI JLE,) 20 E9 11MI JMP,
\ 75 3MI JNE,    71 3MI JNO,    79 3MI JNS,     70 3MI JO,
\ 7A 3MI JPE,    7B 3MI JPO,    78 3MI JS,      9F 1MI LAHF,
( C5 4MI LDS, )  8D 4MI LEA,  \ C4 4MI LES, \   F0 1MI LOCK,
  AC 6MI LODS, \ E2 3MI LOOP,   E1 3MI LOOPE,   E0 3MI LOOPNE,

\ Instructions                            ( 22  5 88 crc 10:39 )
        ( MOV )    A4 5MI MOVS,    20 7MI MUL,     18 7MI NEG,
  90 1MI NOP,      10 7MI NOT,   2 08 13MI OR,     E6 8MI OUT,
             8F 07 58 12MI POP,    9D 1MI POPF,
            0FF 36 50 12MI PUSH,   9C 1MI PUSHF,
\ 60 1mi pusha,    61 1mi popa,    \    <-- 188, 286 only!
  10 10MI RCL,     18 10MI RCR,
  F2 1MI REP,      F2 1MI REPNZ,   F3 1MI REPZ,
  C3 14MI RET,      0 10MI ROL,     8 10MI ROR,  \ 9E 1MI SAHF,
  38 10MI SAR,   0 18 13MI SBB, \ 0AE 5MI SCAS,         \ SEG
  20 10MI SHL,     28 10MI SHR,    F9 1MI STC,     FD 1MI STD,
  FB 1MI STI,      AA 6MI STOS,  0 28 13MI SUB,          \ TEST
( 9B 1MI WAIT,)        ( XCHG )  ( D7 1MI XLAT,) 2 30 13MI XOR,
\ C2 14MI +RET,


\ Structured Conditionals                 ( 28 12 88 crc  9:09 )
HEX
75 CONSTANT 0=   74 CONSTANT 0<>   79 CONSTANT 0<
78 CONSTANT 0>=  7D CONSTANT <     7C CONSTANT >=
7F CONSTANT <=   7E CONSTANT >     73 CONSTANT U<
72 CONSTANT U>=  77 CONSTANT U<=   76 CONSTANT U>
71 CONSTANT OV   E3 CONSTANT CX<>0

' ROT 6 + CONSTANT >NEXT
: PUSHER  <BUILDS  C,  ,  DOES>
  >R  R 1+ @  HERE  R> C@ DUP ALLOT  CMOVE ;

>NEXT 3 -    DUP  8 PUSHER 3PUSH
          1+ DUP  7 PUSHER 2PUSH
          1+ DUP  6 PUSHER 1PUSH
          1+      5 PUSHER NEXT
\ Structured Conditionals                 (  6  2 89 crc  8:00 )
: UNTIL,  \ dest.adr 1 br.opcode --
   SWAP 1 ?PAIRS  C,  HERE 1+ - C, ;
: IF,     \ br.opcode -- adr.next.instr 2  | reserve space
  C, 0 C, HERE 2 ;
: THEN,  \ adr.instr.after.br 2 -- | patch the forward ref.
   2 ?PAIRS   HERE OVER -  SWAP 1- C! ;
: ELSE,   \ adr.after.br 2 -- adr.after.this.br 2
   2 ?PAIRS   HERE 2+ #) JMP,  HERE SWAP  2 THEN, 2 ;
: BEGIN,  \ -- dest.adr 1
   HERE 1 ;
: WHILE,  \ dest.adr 1 br.opcode -- adr.after.this 2 dest.adr 1
   IF, 2SWAP ;
\ : ENDIF, THEN, ;   \  : END,  UNTIL, ;
HERE   AX POP,  BX POP,  1PUSH   ' NIP CFA !

\ Structured Conditionals                 (  9  2 89 crc  6:13 )
: AGAIN, \ adr.after.while 2 dest.adr.of.begin 1 --
   EB UNTIL,  ;
: REPEAT, \ adr.after.while 2 dest.adr.of.begin 1 --
   AGAIN,  THEN, ;

: OFUSER   [COMPILE] '  DUP CFA @ [ ' BASE CFA @ ] LITERAL -
  0A ?ERROR  @ [BX] ;

: DO,   HERE  3 ;
: LP   <BUILDS C,  DOES>  C@ C,  3 ?PAIRS  HERE - 1-
  DUP BRSIZE  C, ;
E2  LP LOOP,    E1  LP LOOPE,   E0  LP LOOPNE,   DECIMAL
;S    186  VERSION OF PUSH,
: PUSH,   DUP # =  IF DROP 6A SIZE @ DUP + - C,  SIZE @ ,/C,
  ELSE  PUSH,  THEN  SIZE ON ;
\ proto: dtype                            ( 25  7 90 crc 16:51 )
FORTH DEFINITIONS BASE @ DECIMAL 260 NEEDED DEMIT  BASE !
  DEBUG  FORGET TASK
  FORTH DEFINITIONS : TASK ;
BASE @ HEX >R
CODE DTYPE  \ addr ct ---  | direct to video w/ attributes
  CX POP,  DX POP,  SI DX XCHG,  DX PUSH,  VIDEO-SEG #) AX MOV,
  AX ES MOV,  CURSE #) DI MOV, DI DI ADD, ( 2*)
  CX PUSH,  UP #) BX MOV,  OFUSER ATTRIBUTE AH MOV,
  DO,  AL LODS,  AX STOS,  LOOP,
  40 # AX MOV,  AX ES MOV,  AX POP,  ES: 50 #) AL ADD,
  ES: AL 50 #) MOV,  \ assumes everything stays on the same line
  (XY) #) CALL,  SI POP,  NEXT
R> BASE !    EDITOR FLUSH


\ Multiuser hooks: very dangerous!        ( 18 10 86 CRC 12:33 )
BASE @ HEX  >r
CODE SAFELINK{ \ save current link on return stack & delink
  up #) bx mov,  rp dec, rp dec,  ofuser mylink ax mov,
  ax 0 [rp] mov,  bx ofuser mylink mov,  next
\ OFUSER MYLINK RP -[ MOV,  U OFUSER MYLINK MOV,  NEXT

CODE }RELINK    \ restore link from return stack
  up #) bx mov,  0 [rp] ax mov,  rp inc, rp inc,
  ax ofuser mylink mov,  next
\ RP [+ OFUSER MYLINK MOV,  NEXT
r> BASE !
;S   These words are used to send text to the terminal where
output may not be interrupted by other tasks' output. The word
SAFELINK{  saves the current link of the current task on the
return stack, and  }RELINK  restores it from there.
\      @L C@L !L C!L                      ( 20  3 89 crc  9:02 )
CODE @L   BX POP,  ES POP,  ES: 0 [BX] PUSH,  NEXT

CODE C@L   BX POP,  ES POP,  ES: 0 [BX] AL MOV,
  AH AH XOR,  1PUSH

CODE !L ( n seg adr -- )
  BX POP,  ES POP,  ES: 0 [BX] POP,  NEXT

CODE C!L ( byt seg adr )
  BX POP,  ES POP,  AX POP, ES: AL 0 [BX] MOV,  NEXT





\ CMOVEL p@, etc.                         ( 28  1 88 crc  8:01 )
CODE CMOVEL  ( sseg sptr dseg dptr cnt )
  SI BX MOV,  CX POP,  DI POP,  ES POP,  SI POP,
  DS POP,  REP, .B MOVS,
  CS PUSH,  DS POP,  BX SI MOV,  NEXT

CODE PC@   \ p# -- c | fetch from i/o space
  DX POP,  DX AL IN,  AH AH SUB,  1PUSH
CODE PC!   \ c p# -- | store to i/o space
  DX POP,  AX POP,  DX AL OUT,  NEXT

CODE P@    \ p# -- n | fetch from i/o space
  DX POP,  DX AX IN,  1PUSH
CODE P!    \ n p# -- | store to i/o space
  DX POP,  AX POP,  DX AX OUT,  NEXT

\ last-cmd saver                          ( 24  2 89 crc 10:01 )
DEBUG  FORTH DEFINITIONS  FORGET TASK
: TASK ; BASE @ >R HEX          0 CONSTANT LASTWORD
CODE (GETLAST)   \ save nfa of current word in variable
  AX LODS,  AX ' LASTWORD #) MOV,  NEXT

: GETLAST     \ compile code to save nfa in last word
  COMPILE (GETLAST)  LATEST , ; IMMEDIATE

: FRED   GETLAST  ;
: HARRY  GETLAST  ;

R> BASE !  EDITOR FLUSH ;S

  R> DUP @ LASTWORD !  2+ >R  ;

\ serial terminal interrupt code          ( 25  4 88 crc 16:37 )
DEBUG  FORTH DEFINITIONS   FORGET TASK
FORTH DEFINITIONS   : TASK ;   BASE @ >R HEX
0 52 @L CONSTANT IXSEG          0 50 @L CONSTANT IXSTART
here first over - erase

BLK @ 1+ DUP 2+ THRU




R> BASE !  EDITOR FLUSH




\ serial terminal interrupt code          ( 25  4 88 crc 16:54 )
ix   sti,  2 # ah .b cmp,  0<> if,
   3 # ah .b cmp,  0<> if,
       0 50 @l  0 52 @l  far #) jmp,  then,  \ it's ours
   es push,  ds push,  dx push,  ip push,  di push,
   cx push,   w push,  cs ax mov,  ax ds mov,
   40 # ax mov,  ax es mov,  dx ip mov,  ip ip add,
   0 # w mov,  es: 0 [bx+si] dx mov,
   5 # dx add,  dx al in,  al ah mov,  dx inc,  dx al in,
   fe # ah and,   cs: 118 [ip] di mov,   cs: 120 [ip] di cmp,
   0<> if,  1 # ah or,  then,  ip w mov,
   w shr,  3 # w and,  cs: 1 # 100 [w] .b test,
   0<> if,  2 # ah or,  then,
   else,  nop,


\ serial terminal interrupt code          ( 24  3 89 crc  9:58 )
   es push,  ds push,  dx push,  ip push,  di push,
   cx push,   w push,  cs ax mov,  ax ds mov,
   40 # ax mov,  ax es mov,  dx push,  dx ip mov,
   ip ip add,  0 # w mov,  es: 0 [bx+si] dx mov,
   dx inc,  dx al in,  1 # al or,  dx al out,
   3 # dx add,  dx al in,  8 # al or,  dx al out,  dx pop,
   cs: 118 [ip] di mov,  cs: 120 [ip] di cmp,
   0= if, ip dx xchg,  es: 47c [ip] bl mov,
    ip dx xchg, begin,  cx cx xor,
    do, >r >r  cs: 120 [ip] di cmp,
    0= if,  r> r> loop,  bl .b dec,  2swap 0= until,
    80 # ah mov,  else, >r >r   nop,  then,

r> r>

\ serial terminal interrupt code          ( 24  3 89 crc  9:43 )

  cs: 110 [ip] w mov,  0 [bx+di] al mov,
  cs: 118 [ip] inc,  cs: fff # 118 [ip] and,
  0 # ah mov,  ip w mov,  w shr,  3 # w and,
  cs: 1 # 100 [w] .b test,  0<> if,
    cs: fe # 100 [w] .b and,  2 # ah or,
  then,  then,  then,
  w pop,  cx pop,  di pop,  ip pop,  dx pop,
  ds pop,  es pop,  iret,



-3 ?pairs constant ixnew


\ test opsize override                    ( 31 10 95 crc 13:10 )
debug   forget task             forth definitions : task ;
assembler definitions           hex     editor flush
: opsize: 66 c, ;               : addsize: 67 c, ;
forth definitions

code foo  opsize: 5678 # ax mov, 1234 ,
          opsize: 4321 # ax add, 8765 ,
          opsize: first #) ax mov,
          opsize: first #) ax sub,
          opsize: sp ax mov,
          opsize: ax push, next

code td+  opsize: ax pop,  opsize: bx pop,
          opsize: bx ax add,  opsize: ax push,  next
un: foo
\ beep: direct hardware beep              ( 10  9 90 crc 15:01 )
forth definitions debug forget task
: task ;        editor flush         base @ hex
code beep       \ freq ---  | make a beep via hardware
  bx pop,  pushf,  43 # dx mov,  cli,
  b6 # al mov,  dx al out,  dx dec,     \ timer channel 2  mode
  bl al mov,  dx al out,  bh al mov,  dx al out, \ send freq
  61 # dx mov,  ( port_b)  dx al in,  al bl mov, \ save status
  3 # al or,  dx al out,        \ do it!
  -1 # cx mov,  do,  bx mul,  loop,
  bl al mov,  dx al out,        \ cease fire.
  popf,  next
base !  editor



\ Load screen: 808sux disassembler        (  2  1 88 CRC 15:55 )
FORTH DEFINITIONS  \ FORGET TASK
FORTH DEFINITIONS  \ : TASK  ;

FORTH DEFINITIONS  BASE @ >R DECIMAL

VOCABULARY DISASSEMBLER      IMMEDIATE

301 337 THRU
?STACK

R> BASE !




\ Useful stuff:                           ( 18  4 89 crc 10:05 )
CODE SEXT    \ n --- n' | sign extend lower half of n to upper
  AX POP,  CBW,  1PUSH

: .NAME  \ nfa ---  | print name whose nfa is on the stack
  COUNT 31 AND BOUNDS  DO I C@ 127 AND EMIT LOOP SPACE ;

: (.MOI)   R> DUP  2+ >R  @ .NAME ;

: .MOI   COMPILE (.MOI)  LATEST , ;  IMMEDIATE

: .SELF         \  --  | create a word which prints its name
  <BUILDS DOES> NFA .NAME ;  \ the ultimate in self-doc!

: .SELF&DROP    \ --- | the same, then drops from stack
  <BUILDS DOES> NFA .NAME  DROP ;
\ 2/s, 2*s, other utils                   ( 25  7 89 crc  9:44 )
CODE 2/S     \ n ct --- n' | shift n right ct times
   CX POP,  AX POP,  AX CL SHR,  1PUSH

CODE ANDEXEC   \ n mask --  | and n w/ mask, then run  EXEC
  CX POP,  AX POP,  CX AX AND,  ' EXEC 1+ #) JMP,

CODE 2*S     \ n ct --- n' | shift n left ct times
   CX POP,  AX POP,  AX CL SHL,  1PUSH

\ some flags
0 VARIABLE OPSIZE
0 VARIABLE ADDRSIZE



\ relocation words                        ( 11  2 88 crc 10:41 )
CS@ VARIABLE SEG              \ keeps relocation factor
HERE 0 , CONSTANT FUDGE       \ in 2nd word, seg in first. You
: (T@)   SEG 2@ ROT +  @L ;   \ dump/dis any segment w/ any
                              \ relocation you want by setting
: (TC@)  SEG 2@ ROT + C@L ;   \ FUDGE & SEG  correctly.

: SEG?  SEG @ U. ;              : SETSEG   SEG ! ;

: HOMESEG   CS@ SETSEG FUDGE OFF ;

' (T@) CFA VARIABLE 'T@         ' (TC@) CFA VARIABLE 'TC@

: T@   'T@ @EXECUTE STOP        : TC@  'TC@ @EXECUTE STOP


\ cp, cp related words, relocation words  ( 11 10 90 crc 12:17 )
0 VARIABLE CP         DISASSEMBLER DEFINITIONS

0 VARIABLE TARG       0 , \ segment for interseg jumps, etc

: CP@  CP @ ;

: OOPS   CR CR .S
  CTL G EMIT  ."  Oops! " 0 ERROR  STOP

: NEXTB  CP@ TC@    CP 1+! ;

: NEXTW  CP@ T@   2 CP +! ;

\ : nextl  nextw nextw  swap ;

\ lookahead for disp addressing modes                 27Jul87crc
0 VARIABLE OPS \ operand count
0 VARIABLE IM  \ 2nd operand extension flag/ct

: ?DISP      \ op ext --- op ext | does MOD operand have a disp?
  DUP 6 2/S  DUP 3 =  OVER 0=  OR
  0= IF  IM !  ELSE
     0= IF DUP 7 AND 6 = IF 2 IM ! THEN  THEN  THEN ;








\ addressing modes selfprinters           ( 11  7 89 crc 13:16 )
.SELF AL        .SELF AX        .SELF [BX+SI]   .SELF ES
.SELF CL        .SELF CX        .SELF [BX+DI]   .SELF CS
.SELF DL        .SELF DX        .SELF [BP+SI]   .SELF SS
.SELF BL        .SELF BX        .SELF [BP+DI]   .SELF DS
.SELF AH        .SELF SP        .SELF [SI]      .SELF #
.SELF CH        .SELF BP        .SELF [DI]      .SELF #)
.SELF DH        .SELF SI        .SELF [BP]      .SELF S#)
.SELF BH        .SELF DI        .SELF [BX]
.SELF RP        .SELF [RP]      \ RETURN STACK POINTER
.SELF IP        .SELF [IP]      \ INTERPRETER POINTER
.SELF W         .SELF [W]       \ WORKING REGISTER




\ symbol table for forth re-entry location(  8 10 90 crc 11:28 )
0 VARIABLE SYMBOLS -2 ALLOT  ASSEMBLER
( >NEXT DUP ,  1- DUP ,  1- DUP ,  1- , )  ' BRANCH ,
' 0BRANCH 5 + ,  ' (LOOP) 6 + ,  ' (LOOP) 14 + , DISASSEMBLER
HERE SYMBOLS - 2/ CONSTANT SYMBOLCT
\ .SELF NEXT      .SELF 1PUSH     .SELF 2PUSH     .SELF 3PUSH
.SELF BRANCH    .SELF NOBRAN    .SELF PLOOP     .SELF LVLP

: ?SYMBOL    \ a -- a n | if n = -1 then no symbol, else index
  -1 \ RELOC 2+ @  CS@ = IF \ iff in code segment.
    SYMBOLCT 0 DO OVER I 2* SYMBOLS + @ =
      IF DROP I LEAVE THEN LOOP ( THEN) ;

: .SYMBOL    \ a ---  | print symbol name else value
  DUP TARG !  ?SYMBOL  DUP 0< IF DROP U.  ;S  THEN  SWAP U. EXEC
 ( NEXT 1PUSH  2PUSH  3PUSH)  BRANCH  NOBRAN  PLOOP  LVLP  STOP
\ symbolic debugging, forth style                     17Jul87crc
FORTH DEFINITIONS
1 VARIABLE SYMBOLIC

DISASSEMBLER DEFINITIONS
: SYMBOL  <BUILDS [COMPILE] ' NFA ,  [COMPILE] ' NFA ,
  DOES> SYMBOLIC @ IF 2+ THEN @ .NAME ;

SYMBOL BX BX W   SYMBOL [BX] [BX] [W]
SYMBOL SI SI IP  SYMBOL [SI] [SI] [IP]
SYMBOL BP BP RP  SYMBOL [BP] [BP] [RP]





\ Addressing mode decodes                             16Jul87crc
: .16REG     \ r# ---  | register printed out
  7 ANDEXEC  AX CX DX BX  SP BP SI DI  STOP

: .8REG      \ r# ---  | register printed out
  7 ANDEXEC  AL CL DL BL  AH CH DH BH  STOP

: .SEG       \ s# ---  | register printed out
  3 2/S 3 ANDEXEC  ES CS SS DS   STOP

: 0DISP      \  ---  | do if displacement is 0
  ." 0 "  ;

: BDISP      \  ---  | do if displacement is byte
  CP@  IM @ +  TC@ SEXT U.  OPS 1+! IM OFF ;

\ Addressing mode decodes                 (  7 11 95 crc  7:41 )
: WDISP      \  ---  | do if displacement is word
  CP@  IM @ +  OPSIZE @ IF  DUP  2+ T@  U.  T@  U.  4
  ELSE  T@  U.  2 THEN  OPS +!  IM OFF  ;

: (.R/M)     \ op ext ---  | print a register
  SWAP 1 AND  IF .16REG ELSE .8REG THEN  IM OFF ;

: .R/M       \ op ext --- op ext | print r/m as register
  2DUP        (.R/M) ;

: .REG       \ op ext --- op ext | print reg as register
  2DUP  3 2/S (.R/M) ;

: .DISP      \ op ext --- op ext | print displacement
  DUP 6 2/S  3 ANDEXEC  0DISP BDISP WDISP .R/M STOP
\ Addressing mode decodes                 ( 11  7 89 crc 12:39 )
: BIMM       \  ---  | do if immed. value is byte
  CP@  IM @ +  TC@      .  OPS 1+!  IM OFF ;

HEX
: .MREG     \ op ext --- op ext | register(s) printed out + disp
  DUP C7 AND 6 = IF  OPSIZE OFF  WDISP #)  ELSE
  DUP C0 AND C0 - IF  .DISP
  DUP  7 ANDEXEC  [BX+SI]  [BX+DI]  [BP+SI]  [BP+DI]
                  [SI]     [DI]     [BP]     [BX]
  ELSE .R/M  IM OFF  THEN  THEN ;

.SELF .B        .SELF .W
: .SIZE      \ op ---  | decodes for size
  1 ANDEXEC  .B  .W   STOP

\ opcode decodes: seg: pop, push, segtb   ( 11  7 89 crc 12:45 )
0 VARIABLE SEGTB  -2 ALLOT
ASCII E C, ASCII C C,  ASCII S C,  ASCII D C,

: SEG:       \ op ---  | print segment overrides
  3 2/S 3 AND SEGTB + C@ EMIT  ." S: " ;

: POP,       \ op ---  | handle illegal opcode for cs pop
  DUP  0F = IF ." illegal "  THEN  .SEG  .MOI ;

: PUSH,      \ op ---  | print pushes
  .SEG  .MOI ;

: ?SEG   \ op -- fl | is opcode a segment override?
  DUP 3E =  OVER 36 = OR  OVER 2E = OR  SWAP 26 =  OR ;

\ opcode decodes: p/p adjusts p/seg p/adj             15Jul87crc
: P/P        \ op --- | pushes or pops
  DUP 1 ANDEXEC  PUSH, POP,  STOP

.SELF DAA,      .SELF DAS,      .SELF AAA,      .SELF AAS,

: ADJUSTS    \ op ---  | the adjusts
  3 2/S  3 ANDEXEC  DAA,  DAS,  AAA,  AAS,  STOP

: P/SEG      \ op ---  | push or seg overrides
  DUP 5 2/S  1 ANDEXEC  P/P SEG:      STOP

: P/ADJ      \ op ---  | pop or adjusts
  DUP 5 2/S  1 ANDEXEC  P/P ADJUSTS  STOP


\ opcode decodes: 0gp add, or, 0group                 14Jul87crc
: 0GP        \ op --- op | opcode decoded & printed
  DUP 4 AND IF  DUP 1 AND
            IF WDISP ELSE BIMM THEN  #
            1 AND IF AX ELSE AL THEN  ELSE
  NEXTB  OVER 2 AND
         IF  .MREG .REG  ELSE  ?DISP .REG .MREG
  THEN  2DROP THEN  ;

.SELF ADD,      .SELF ADC,      .SELF AND,      .SELF XOR,
.SELF OR,       .SELF SBB,      .SELF SUB,      .SELF CMP,

: 0GROUP     \ op ---  | select 0 group to print
  DUP 0GP 3 2/S 7 ANDEXEC
  ADD,  OR,   ADC,  SBB,  AND,  SUB,  XOR,  CMP,  STOP

\ opcode decodes: lows .reggp regs        ( 29  3 90 crc  9:39 )
: LOWS       \ op ---  |  0-3f opcodes printed out
  DUP   7 ANDEXEC  0GROUP  0GROUP  0GROUP  0GROUP
                   0GROUP  0GROUP  P/SEG   P/ADJ  STOP

: .REGGP     \ op ---  | register group defining word
  <BUILDS  DOES>  NFA  SWAP .16REG  .NAME ;

.REGGP INC,     .REGGP DEC,     .REGGP PUSH,    .REGGP POP,

: POP,       \ op ---  |
  DUP 38 AND 8 = IF ." illegal," DROP  ELSE  POP,  THEN ;

: REGS       \ op ---  | 40-5f opcodes printed out
  DUP 3 2/S 3 ANDEXEC  INC, DEC, PUSH, POP,   STOP

\ opcode decodes: branches meds #push     (  3  2 89 crc  8:26 )
.SELF O,        .SELF NO,       .SELF B/NAE,    .SELF NB/AE,
.SELF E/Z,      .SELF NE/NZ,    .SELF BE/NA,    .SELF NBE/A,
.SELF S,        .SELF NS,       .SELF P/PE,     .SELF NP/PO,
.SELF L/NGE,    .SELF NL/GE,    .SELF LE/NG,    .SELF NLE/JG,

: .BRANCH    \ op ---  | branch printed out w/ dest.
  NEXTB SEXT  CP @ + .SYMBOL  ASCII J EMIT   0F ANDEXEC
  O,    NO,   B/NAE, NB/AE, E/Z,   NE/NZ, BE/NA, NBE/A,
  S,    NS,   P/PE,  NP/PO, L/NGE, NL/GE, LE/NG, NLE/JG,  STOP






\ opcode decodes: 186 instructions @ 6x   (  7 11 95 crc  9:34 )
.SELF PUSH,     .SELF IMUL,

: INS&OUTS   DUP  2 AND IF  [SI] DX .SIZE ." OUTS,"  ELSE
  DX [DI] .SIZE ." INS,"  THEN ;

: #PUSH  2 AND IF  NEXTB SEXT ELSE NEXTW  THEN U. # PUSH, ;

.SELF&DROP PUSHA,               .SELF&DROP POPA,
: OPSIZE: .MOI OPSIZE ! ;       : ADDRSIZE: .MOI ADDRSIZE ! ;

: 6XS \ op ---  | 188\6 instructions
  DUP 0F ANDEXEC  PUSHA,  POPA,  OOPS ( BOUNDS)  OOPS OOPS OOPS
  OPSIZE:  ADDRSIZE:  #PUSH OOPS ( #MUL)  #PUSH  OOPS \ #MUL
  INS&OUTS INS&OUTS INS&OUTS INS&OUTS  STOP

\ opcode decodes: meds 2ndaries 80/81, 83s(  3  2 89 crc  8:48 )
: MEDS       \ op ---  | 40-7f opcodes printed out
  DUP 4 2/S  3 ANDEXEC  REGS  REGS  6Xs .BRANCH  STOP

: 80/81      \ op ---  | secondary at 80 or 81
  NEXTB  ?DISP OVER 1 AND  IF WDISP ELSE BIMM THEN  # .MREG
  BEGIN  [  >R >R ]   SWAP .SIZE  3 2/S 7 ANDEXEC
  ADD, OR,  ADC, SBB, AND, SUB, XOR, CMP,   STOP

: 83S        \ op ---  | secondary at 83
  NEXTB  ?DISP BIMM #  .MREG   [ R> R> ] AGAIN  STOP





\ opcode decodes: 1gp test xchg movrm/reg ( 29  3 90 crc  9:39 )
: 1GP        \ op ---  | r/m reg opcodes
  <BUILDS  DOES> NFA >R  NEXTB  ?DISP .REG .MREG  2DROP
  R> .NAME ;

1GP TEST,       1GP XCHG,       .SELF LEA,      .SELF MOV,

: MOVRM/REG  NEXTB  ?DISP .REG .MREG  2DROP  MOV, ; \ 88-89

: MOVD       NEXTB        .MREG .REG  2DROP  MOV, ; \ 8A-8B






\ opcode decodes: movs>m 8movs                        17Jul87crc
HEX
: MOVS>M     \ op ---  | display instructions  8C-8E
  NEXTB  OVER 8D = IF  .MREG .REG  LEA,  ELSE
    OVER 8F = IF  .MREG  [ ' POP, NFA ] LITERAL .NAME  ELSE
    SWAP 1 OR SWAP  \ 16 bit moves only, folks!
    OVER 2 AND IF  .MREG DUP .SEG  ELSE
     ( ?DISP) DUP .SEG .MREG  THEN  MOV,  THEN THEN  2DROP ;

: 8MOVS      \ op ---  | display instructions  80-8F
  DUP 2/ 7 ANDEXEC  80/81 83S TEST, XCHG,
                     MOVRM/REG  MOVD  MOVS>M  MOVS>M  STOP

DECIMAL


\ opcode decodes: 98-9F                               15Sep87crc
.SELF XCHG,     .SELF CBW,      .SELF CWD,      .SELF CALL,
.SELF WAIT,     .SELF PUSHF,    .SELF POPF,     .SELF SAHF,
.SELF LAHF,     .SELF NOP,

: INTER      \ ---  | decode interseg jmp or call
  NEXTW .SYMBOL  ." : "  NEXTW  dup targ 2+ !  U. ;

: CALLINTER  \ ---  | decode interseg call
  INTER  CALL, ;

: 9HIS       \ op ---  | 98-9F decodes
  7 ANDEXEC
  CBW,  CWD,  CALLINTER WAIT,  PUSHF,  POPF, SAHF, LAHF,  STOP


\ opcode decodes: 90-9F xchg movs/cmps                15Sep87crc
: XCHGA      \ op ---  | 98-9F decodes
  DUP 7 AND IF  AX .16REG  XCHG,  ELSE  NOP, DROP  THEN ;

: 90S        \ op ---  | 90-9F decodes
  DUP 3 2/S 1 ANDEXEC  XCHGA  9HIS  STOP

.SELF MOVS,     .SELF CMPS,

: MOVS       \ op ---  | A4-A5 decodes
  .SIZE  MOVS, ;





\ opcode decodes: cmps .al/ax movs/acc .te(  8 11 95 crc  8:05 )
: CMPS       \ op ---  | A6-A7 decodes
  .SIZE  CMPS, ;

: .AL/AX     \ op ---  | decodes for size
  1 ANDEXEC  AL AX STOP

: MOVS/ACC   \ op ---  | A0-A3 decodes
  OPSIZE OFF  DUP 2 AND IF  .AL/AX  WDISP #)  ELSE
      WDISP #)  .AL/AX  THEN MOV, ;

.SELF TEST,     .SELF STOS,     .SELF LODS,     .SELF SCAS,

: .TEST      \ op ---  | A8-A9 decodes
  DUP 1 AND IF WDISP ELSE BIMM THEN #  .AL/AX TEST, ;

\ opcode decodes: stos lods scas a0s movs/imm         21Jul87crc
: STOS   ( op --- )  .SIZE  STOS, ;
: LODS   ( op --- )  .SIZE  LODS, ;
: SCAS   ( op --- )  .SIZE  SCAS, ;

: A0S        \ op ---  | A0-AF decodes
  DUP 2/ 7 ANDEXEC
  MOVS/ACC MOVS/ACC  MOVS       CMPS
  .TEST    STOS      LODS       SCAS       STOP

: MOVS/IMM   \ op ---  | B0-BF decodes
  DUP 8 AND IF  WDISP # .16REG  ELSE  BIMM # .8REG  THEN
  MOV, ;



\ opcode decodes: hmeds les/lds ret, rols ( 29  3 88 crc 14:07 )
: HMEDS      \ op ---  | op codes 80 - C0 displayed
  DUP 4 2/S  3 ANDEXEC  8MOVS  90S A0S MOVS/IMM   STOP

.SELF LES,      .SELF LDS,      .SELF INTO,     .SELF IRET,
: LES/LDS    \ op ---  | les/lds instruction  C4-C5
  NEXTB .MREG  .REG  DROP 1 ANDEXEC LES, LDS, STOP

: RET,       \ op ---  | return instruction  C2-C3, CA-CB
  DUP 1 AND 0= IF WDISP ."  SP+" THEN
  8 AND IF ."  FAR"  THEN  .MOI ;

.SELF ROL,      .SELF ROR,      .SELF RCL,      .SELF RCR,
.SELF SHL/SAL,  .SELF SHR,      .SELF SAR,


\ opcode decodes: shifts mov#r/m c0s into/( 14  3 90 crc 12:14 )
: CSHIFT     \ op ---  | secondary instructions c0-c1
  NEXTB  ?DISP BIMM #  .MREG  NIP  3 2/S 7 ANDEXEC
  ROL,  ROR,  RCL,  RCR,  SHL/SAL, SHR,  OOPS  SAR,  STOP

: MOV#R/M    \ op ---  | return instruction  C2-C3, CA-CB
  NEXTB  ?DISP  OVER 1 AND  IF  WDISP  ELSE  BIMM  THEN #
  .MREG  DROP .SIZE  MOV, ;

: INT,       \ op ---  | int instruction  CC-CD
  1 AND IF NEXTB ELSE 3 THEN U.  .MOI ;

: INTO/IRET  \ op ---  | int & iret instructions  CE-CF
  1 ANDEXEC  INTO, IRET, STOP


\ opcode decodes: c0s esc, aas xlat,      ( 29  3 90 crc  9:37 )
: C0S        \ op ---  | display instructions  C0-CF
  DUP 2/ 7 ANDEXEC
  CSHIFT RET, LES/LDS  MOV#R/M  OOPS RET, INT,  INTO/IRET  STOP

: AAS        \ op ---  | does anybody actually use these things?
  <BUILDS  DOES>  NFA .NAME  NEXTB 2DROP ;

AAS AAM,        AAS AAD,

: SHIFTS     \ op ---  | secondary instructions d0-d3
  DUP 2 AND IF CL THEN
  NEXTB  .MREG NIP 3 2/S 7 ANDEXEC
  ROL,  ROR,  RCL,  RCR,  SHL/SAL, SHR,  OOPS  SAR,  STOP

.SELF&DROP XLAT,
\ opcode decodes: d0s esc, loops                      22Jul87crc
: ESC,       \ op ---  | esc instructions d8-DF
  NEXTB .MREG  3 2/S 7 AND U.  7 AND U.  .MOI ;

: D0S        \ op ---  | display instructions  D0-DF
  DUP 8 AND IF ESC, ;S  THEN
  DUP 7 ANDEXEC
  SHIFTS SHIFTS SHIFTS SHIFTS  AAM, AAD, OOPS XLAT, STOP

.SELF LOOPE/Z   .SELF LOOP,     .SELF JCXZ,     .SELF LOOPNE/NZ,

: LOOPS      \ op ---  | display instructions  E0-E3
  NEXTB SEXT  CP @ + .SYMBOL  3 ANDEXEC
  LOOPNE/NZ,  LOOPE/Z  LOOP,  JCXZ,  STOP


\ opcode decodes: in/out call                         23Jul87crc
.SELF IN,       .SELF OUT,      .SELF JMP,

: IN/OUT     \ op ---  | display instructions  E4-E6,EC-EF
  DUP 8 AND IF
       DUP 2 AND  IF  .AL/AX DX  OUT, ELSE
                      DX .AL/AX  IN,  THEN  ELSE
       DUP 2 AND  IF  .AL/AX BIMM # OUT, ELSE
                      BIMM # .AL/AX IN,  THEN  THEN ;

: CALL       \ op ---  | display instructions  E7-EB
  DUP 2 AND IF  DUP 1 AND IF  NEXTB SEXT  CP @ + .SYMBOL \ short
        ELSE  INTER  THEN  ELSE  NEXTW CP @ + .SYMBOL THEN
  3 ANDEXEC CALL, JMP,  JMP,  JMP, STOP


\ opcode decodes: e0s ftest               (  3  2 89 crc  8:27 )
: E0S        \ op ---  | display instructions  E0-EF
  DUP 2 2/S  3 ANDEXEC  LOOPS  IN/OUT CALL  IN/OUT STOP

: FTEST      \ op ---  | display instructions  F6,7:0
  ?DISP OVER 1 AND IF WDISP ELSE BIMM THEN #
  .MREG DROP  .SIZE  TEST, ;

.SELF NOT,      .SELF NEG,      .SELF MUL,
.SELF DIV,      .SELF IDIV,     .SELF REP/NZ,   .SELF REPZ,
.SELF LOCK,     .SELF HLT,      .SELF CMC,      .SELF CLC,
.SELF STC,      .SELF CLI,      .SELF STI,      .SELF CLD,
.SELF STD,      .SELF INC,      .SELF DEC,



\ opcode decodes: mul/div not/neg f6-f7s              24Jul87crc
: MUL/DIV    \ op ext ---  | secondary instructions F6,7:4-7
  .MREG  AX OVER 1 AND IF DX THEN  NIP
  3 2/S 3 ANDEXEC MUL, IMUL, DIV, IDIV, STOP

: NOT/NEG    \ op ext ---  | secondary instructions F6,7:2,3
  .MREG SWAP .SIZE  3 2/S 1 ANDEXEC NOT, NEG, STOP

: F6-F7S     \ op ---  | display instructions  F6,7
  NEXTB  DUP 3 2/S  7 ANDEXEC
  FTEST OOPS NOT/NEG NOT/NEG
  MUL/DIV MUL/DIV MUL/DIV MUL/DIV  STOP




\ opcode decodes: fes fcall/jmp fpush finc(  1  1 88 CRC 14:15 )
: FES        \ op ---  | display instructions  FE
  NEXTB .MREG .B NIP  3 2/S  1 ANDEXEC INC, DEC, STOP

: FCALL/JMP  \ op ext ---  | display call instructions  FF
  .MREG  3 2/S DUP 1 AND IF  ." FAR "  THEN  NIP
  2/ 1 ANDEXEC JMP, CALL,  STOP

: FPUSH      \ op ext ---  | display push instructions  FF
  DUP 4 AND IF .MREG  2DROP PUSH, ;S  THEN OOPS ;

: FINC       \ op ext ---  | display inc/dec instructions  FF
  .MREG  NIP 3 2/S 1 ANDEXEC INC, DEC, STOP



\ opcode decodes: ffs f0s                 (  1 11 95 crc 11:01 )
: FFS        \ op ---  | display instructions  FF
  NEXTB DUP 4 2/S 3 ANDEXEC
  FINC  FCALL/JMP FCALL/JMP  FPUSH   STOP

: F0S        \ op ---  | display instructions  F0-FF
  DUP 15 AND  DUP 7 AND 6 < IF NIP  THEN  EXEC
  LOCK,  OOPS   REP/NZ, REPZ,  HLT, CMC, F6-F7S  F6-F7S
  CLC, STC, CLI, STI, CLD, STD,  FES  FFS                STOP

BASE @ HEX
: ?REP   \ op -- fl | is it a rep prefix?
  FE AND  F2 = ;

: ?OVERRIDE     FE AND  66 = ;  \ op -- fl | size override?
BASE !
\ disassembling: (inst) highs             (  4 12 90 crc  8:16 )
: HIGHS   \ op -- | op codes C0 - FF displayed
  DUP 4 2/S  3 ANDEXEC C0S D0S E0S F0S STOP

: (INST)  \ op ---  | highest level vector table
  255 AND  DUP 6 2/S EXEC LOWS  MEDS  HMEDS  HIGHS  STOP

: ?NEXT   SYMBOLIC @  DUP  IF  DROP
  ASSEMBLER  >NEXT 5 CP @ EDITOR -CSTEXT  0=  THEN ;

.SELF ESC_TO_EXIT              FORTH DEFINITIONS
\   warning: ?next & inst set up for in-line next!




\ frills: dump & ascii print              ( 18  7 88 crc  7:59 )
: (DUMP) \  addr ct ---  | dump as pointed to by reloc
  SPACE  BOUNDS DO  I TC@ 3 .R  LOOP ;

: LASCI   \  addr ct ---  | asci type as pointed to by reloc
  BOUNDS DO  I TC@  127 AND  DUP
    BL ASCII ~ WITHIN 0= IF DROP ASCII . THEN  EMIT  LOOP ;

: HEAD   16 0 DO I OVER + 15 AND 3 .R LOOP DROP ;

  \ N. B: Not responsible for negative counts! -- the MGT.
: DUMP   \  addr ct ---  | dump as pointed to by reloc
  OVER ?CR 11 SPACES HEAD  BEGIN  DUP  WHILE
     CR  SEG @ 5 U.R  OVER 5 U.R
     2DUP 16 MIN >R  R 2DUP (DUMP)  60 TAB LASCI
     R R> MINUS D+  ?TERMINAL IF DROP 0 THEN  REPEAT 2DROP ;
\ disassembling: inst range               (  1 11 95 crc 10:49 )
: INST  \  ---  | display opcode at ip, advancing as needed
  DISASSEMBLER  CR  CP@ >R  FORTH SEG DISASSEMBLER
  @ 5 U.R  ASCII : EMIT  R 4 U.R  2 SPACES
  ?NEXT IF ." macro 'next'"  5 CP +!  ELSE
     NEXTB  BEGIN 1
       OVER ?OVERRIDE IF  DROP 6XS NEXTB 0  ELSE
       OVER ?SEG IF  DROP SEG: NEXTB 0  ELSE
       OVER ?REP IF  DROP F0S  NEXTB 0  THEN  THEN THEN  UNTIL
     (INST) OPS @ CP +!  OPS OFF  IM OFF
     OPSIZE OFF  ADDRSIZE OFF              THEN
  R> CP @ OVER - 2DUP  40 TAB (DUMP)  61 TAB LASCI  ?STACK ;
;s
: RANGE      \  start  end  -- | disassemble over range
  DISASSEMBLER  SWAP CP !  BASE @ >R  HEX
  BEGIN  INST  DUP CP @  U<  UNTIL DROP R> BASE ! ;
\ disassembling: resume disassem          ( 11 10 90 crc 12:22 )
: RESUME   DISASSEMBLER  2 TAB ESC_TO_EXIT  BASE @ >R
  HEX  BEGIN  INST  KEY  DUP CTL M = IF  L  THEN
     DUP CTL N = IF  N THEN
     DUP CTL B = IF  B THEN
     DUP CTL T = IF  TARG 2@  SETSEG  CP !  THEN   \ follow jmps
     LI = UNTIL  R> BASE ! ;
32  ' ESC_TO_EXIT NFA  2DUP 4 + C!  7 + C!

: DISASSEM   \  addr --- | disassemble until esc key
  DISASSEMBLER  DUP SEG @ TARG 2!  CP !  RESUME ;
;s to use: space bar shows next instruction. Ctl m shows current
screen. Ctl n shows next screen, ctl b the previous one. Ctl t
takes the most recently encountered branch or call. Useful for
following spaghetti code.

















































































































































































































































































































































































































\ Filing: multiple screen files           ( 23  7 88 crc 15:07 )
FILING FORTH DEFINITIONS        FORGET TASK
FORTH DEFINITIONS : TASK ;      FILING DEFINITIONS
BASE @ >R DECIMAL               here first over - erase

BLK @ 1+ DUP 1+   HEX THRU




R> BASE !  FILING DEFINITIONS EDITOR FLUSH





\ Filing: multiple screen files           ( 23  7 88 crc 15:14 )
0 CONSTANT MHANDLE
0 CONSTANT MMAXBLK
0 VARIABLE MFILE       3E ALLOT  MFILE HERE OVER - ERASE

: (FR/W)   \ addr blk# r/w ---  | r/w for a file once opened
  MHANDLE IF >R B/BUF U* MHANDLE 0 LSEEK
      0< IF ABORT"  File Seek Error" THEN  DROP
      B/BUF MHANDLE R> IF RDF ELSE WTF THEN
      B/BUF - IF ABORT"  File Size Overflow" THEN
    ELSE ABORT"  File not open!!" THEN ;

: (MR/W)   \ addr blk# r/w ---  | select a file on block #
  OVER MMAXBLK U< IF  (R/W) ;S  THEN
  >R  MMAXBLK 1+ -  R>  (FR/W) ;

\ Filing: multiple screen files           ( 23  7 88 crc 16:57 )
: ADDING:  FILING
  MHANDLE IF ABORT"  File already open" THEN
  R-W  PARSEFILE:  FILE MFILE C/L CMOVE  FILE C/L ERASE
  MFILE (OPF) DUP 0< 0= IF ' MHANDLE !
  [ ' (MR/W) CFA ] LITERAL  'R/W !
  0 0 MHANDLE 2 LSEEK B/BUF U/
  MAXBLK  ' MMAXBLK !  1+ ' MAXBLK +!  DROP  THEN ;

: -ADDED   FILING  MHANDLE -DUP IF (CLF) -DUP IF ." Oops! "
  ELSE ' MHANDLE OFF  MFILE C/L ERASE
  MMAXBLK ' MAXBLK !  ' MMAXBLK OFF  THEN THEN
  [ ' (R/W) CFA ] LITERAL  'R/W ! ;



\ Pausing ?terminal, +blk                 ( 11  4 90 crc 14:09 )
FORTH DEFINITIONS     BASE @ >R HEX
' (?TERMINAL) CFA '?TERMINAL !

CODE +BLK  \ n -- blk# | blk# relative to current block or scr
  AX POP,  UP #) BX MOV,   0 # OFUSER BLK CMP,
  0= IF,  OFUSER SCR AX ADD,  ELSE,  OFUSER BLK AX ADD,  THEN,
  1PUSH

: P?T   (?TERMINAL) IF  (KEY) LI =  ELSE  0  THEN ;
' P?T         CFA '?TERMINAL !

R> BASE !  FORTH DEFINITIONS
\ If this is built into the overlays, add line 10 to screen 3.


\ suspend to DOS from Forth               ( 13 11 95 crc 12:32 )
FORTH DEFINITIONS  ?CR TODAY CR  FILING  FORGET TASK
( : TASK ; ) BASE @ >R DECIMAL  102 NEEDED ,"  HEX
\ 19 50 * 2* CONSTANT SCRSIZE   SCRSIZE 10 / 1+ SEGMENT SAVESCR
\ : SAVESCREEN   VIDEO-SEG @ 0  SAVESCR 4  SCRSIZE  CMOVEL
\   XY@  SAVESCR 0 !L  SAVESCR 2 !L ;
\ : RESTORESCR   SAVESCR 4  VIDEO-SEG @ 0  SCRSIZE  CMOVEL
\   SAVESCR 2 @L  SAVESCR 0 @L  GOTOXY ;
1 +BLK LOAD                     HERE 1+ ," RF.SCR" 0 C,
: SHELL  ( SAVESCREEN ) ?CR  1F MESSAGE  EDITOR FLUSH
  FILING  RHANDLE (CLF) DROP  (SHELL)
  RET C@ 1F AND 1- (SETDEF)  RET 2+ (SETDIR) DROP
  ( RESTORESCR )  [ 2 CSP +! ] LITERAL FILING OPENIT ;
: TASK ;        HERE FIRST OVER - ERASE     WARNING ON
R> BASE ! EDITOR FLUSH   SHELL  ;S from Brad Rodriguez, 23 8 89.

\ suspend to DOS from Forth               (  8 11 90 crc 15:28 )
HERE  ,"  "   0D C,  ( cmdtail )   HERE  0 ,    \  spsave
\  HERE 1+ >R ( % )  ," f:\winnt40\system32\cmd.exe" 0 C,
   HERE 1+ >R ( % )  ," C:\COMMAND.COM" 0 C,   \ pgmspec
\  HERE 1+ >R ( % )  ," A:\COMMAND.COM" 0 C,   \ pgmspec
HERE >R ( ~ )    0 ,  , CS@ , -1 , -1 , -1 , -1 ,    \ paramblk

CODE (SHELL)  CS PUSH,  ES POP,  \ release what we're not using
  ' NEXTSEG #) BX MOV,  4A # AH MOV,  21 INT,
  0D # AH MOV,  21 INT,        \ force dos to flush to disk
  RP PUSH,  IP PUSH,  SP OVER ( spsave) #) MOV,
  R> ( ~ ) #) BX LEA,  R> ( %) #) DX LEA,
  4B00 # AX MOV,  21 INT,                \ run the shell
  ( spsave) #) SP MOV,  IP POP,  RP POP,
  -1 # BX MOV,  4A # AH MOV,  21 INT,    \ how much can we get?
  4A # AH MOV,  21 INT,  NEXT            \ go get it!
\ screens to text convert: load           ( 25  1 89 crc  6:21 )
FILING  FORTH DEFINITIONS  BASE @ DECIMAL
( FORGET TASK
: TASK  ;  )       197 NEEDED SAFEOUTS

: FCR  CTL J EMIT ;      \ setup for WordPerfect

: -EMPTIES  BEGIN DUP BLOCK @ 0= WHILE 1- REPEAT ;

: ABLOCK  DUP BLOCK @  IF  ." \   " DUP .SCR
  FILING CTL I EMIT  .FILENAME  FORTH  FCR
  16 0 DO I OVER .LINE  FCR  LOOP  THEN DROP ;

: BLOCKS  2DUP BOUNDS DO SAVEOUTS OK I 5 .R RESTOREOUTS
  I ABLOCK  ?TERMINAL IF LEAVE THEN LOOP + ;
BASE !  EDITOR FLUSH
\ text to screens convert: load           (  3  3 89 crc  8:07 )
FILING  FORTH DEFINITIONS  FORGET TASK   197 NEEDED SAFEOUTS
FORTH DEFINITIONS  : TASK  ;
BASE @ DECIMAL      FILING DEFINITIONS
: FKEY   0 SP@ 1 HANDLE RDF
  1- IF OK ABORT"  File Read Error"  THEN ;

0 VARIABLE SCRPT                400 VARIABLE SCREEN
0 VARIABLE LINE#

: POINT  SCREEN @ BLOCK SCRPT @ + ;

-->



\ text to screens convert                 (  3  3 89 crc  8:28 )
: READ     PAD  C/L BLANKS  PAD
  BEGIN  FKEY DUP CTL J -  WHILE  OVER C! 1+  REPEAT  2DROP ;

: GRAB
  LINE# @ IF PAD  POINT C/L CMOVE UPDATE  C/L SCRPT +!
  SCRPT @ B/BUF = IF  SCRPT OFF  SCREEN 1+!  THEN  THEN
  LINE# 1+!  LINE# @ 17 = IF LINE# OFF  THEN  ;

: CONVERT     0 0 HANDLE 0  LSEEK  2DROP  SCRPT OFF
  [ SCREEN @ ] LITERAL  SCREEN !  LINE# OFF
  BEGIN READ GRAB  ?TERMINAL UNTIL ;

BASE !  EDITOR FLUSH


\ export screens to file                  (  3  3 89 crc 12:16 )
FILING  FORTH DEFINITIONS     FORGET TASK
FORTH DEFINITIONS : TASK ;
: XPRT  \ blk# ---   | export block to file
  BLOCK B/BUF FILING HANDLE WTF
  B/BUF - IF  OK ABORT" File Write Error " THEN ;

: EXPORT  \ start ct ---  | export blocks in range
  BOUNDS  DO I 5 .R  I XPRT
  ?TERMINAL IF LEAVE THEN LOOP ;

EDITOR FLUSH




\ .envir: print out environment string    (  4  9 89 crc  9:55 )
FORGET TASK                      here first over - erase
FORTH DEFINITIONS : TASK ;       BASE @ HEX
: ->0      \ offset -- offset ct | find 0 in Target seg
  DUP  BEGIN  DUP TC@  WHILE  1+  REPEAT  OVER -  ;

: .>0      \ offset -- offset' | print until 0 in Target seg
  ->0  2DUP LASCI  + 1+  ;

: .ENVIR   \  --  | print environment string
  CR CS@  2C @  -  4 2*S .  ." bytes in the environment."
  SEG 2@  2C @ SETSEG  FUDGE OFF  0
  BEGIN  CR  .>0  DUP TC@ 0=  ?TERMINAL OR  UNTIL
  CR CR 3+  .>0  DROP  SEG 2! ;

DECIMAL  .ENVIR   BASE !  EDITOR FLUSH
\ c@+  c!+  @+  !+                        ( 21  3 90 crc 12:01 )
DEBUG  FORGET TASK         here first over - erase
FORTH DEFINITIONS : TASK ;       BASE @ HEX  >R
CODE C@+   \ addr  --  addr+  c  | get data & postincrement
  AX AX XOR,  DX POP,  DX SI XCHG,  AL LODS,  DX SI XCHG,  2PUSH

CODE @+    \ addr  --  addr+  n  | get data & postincrement
  DX POP,  DX SI XCHG,  AX LODS,  DX SI XCHG,  2PUSH

CODE C!+   \ addr c --  addr+    | place data & postincrement
  CS PUSH,  ES POP,  AX POP,  DI POP,  AL STOS,  DI PUSH,  NEXT

CODE !+    \ addr c --  addr+    | place data & postincrement
  CS PUSH,  ES POP,  AX POP,  DI POP,  AX STOS,  DI PUSH,  NEXT
R> BASE !  EDITOR FLUSH

\ Filing xpurge                           ( 25 10 89 crc 15:41 )
FILING FORTH DEFINITIONS        FORGET TASK
FORTH DEFINITIONS : TASK ;      FILING DEFINITIONS
BASE @ >R DECIMAL

\ : HI    CR R @ 2+ NFA ID. ;
BLK @ 1+ DUP 6 +   HEX THRU


DBUF FLD !
HERE FIRST OVER - ERASE  \  DMY PDIR
R> BASE !  FILING DEFINITIONS EDITOR FLUSH




\ Filing xpurge                           ( 15  2 91 crc 17:13 )
C/L 0D + CONSTANT FLEN         : DBUF  PAD 80 + ;
0 VARIABLE BUILDUP   3E 0D + ALLOT

: .DRV  CURDRV ASCII A + EMIT  ASCII : EMIT  ;

CODE MOD?  \ addr -- m | acquire mode
  4300 # AX MOV,  DX POP,  21 INT,   0007 # CX AND,  CX PUSH,
  NEXT

: GETCURPATH  \  -- | get current path into  PATH .
  PATH C/L ERASE  ASCII \ PATH C!  PATH 1+ CURDRV 1+ GETPATH
  ASCII \  PATH C/L -0S  DUP 1- IF + C! ELSE  2DROP DROP THEN
  DMY  PATH C/L -0S + 4 CMOVE  ;

: .CURPATH   .DRV  GETCURPATH PATH C/L -0S 3 - TYPE ;
\ Filing xpurge                           ( 17 11 89 crc 11:06 )
CODE CHMOD  \ addr --  | change mode to read/write so we can del
  DX POP,  4301 # AX MOV,  CX CX XOR,  21 INT,  NEXT

: ENTRY  \  --- | print & delete directory entry
  BUILDUP  FLEN -0S + >R  R  0D ERASE
  1E +DTA 0D -TRAILING -0S R SWAP CMOVE
\ BUILDUP FLEN -0S DUMP                      KEY DROP
  BUILDUP MOD?  IF  BUILDUP CHMOD  THEN
  BUILDUP (DEL) 0= IF  CR ." Deleting: "  15 +DTA C@ .FMOD
       SPACE  .CURPATH BUILDUP  FLEN -0S  TYPE
       THEN   R> 0D ERASE  ;

CODE (MKDIR)    \ addr --  | create directory
  DX POP,  39 # AH MOV,  21 INT,  1PUSH

\ Filing xpurge                           ( 15  3 90 crc 12:15 )
: DELDIR  \ $addr  ---  | delete all of a directory
  BUILDUP FLEN ERASE  DUP COUNT BUILDUP  SWAP 4 - CMOVE
  1+ SFIRST 0= IF  BEGIN  ENTRY SNEXT  UNTIL  THEN ;

: +PATH  \ $addr -- | add a new path from dir to the list at pad
  FLD @   FLD 1+!         \ save old base, skip ct
  SWAP  BEGIN DUP C@ FLD @ C!  FLD 1+!   \ bring src path
     DUP C@  WHILE  1+  REPEAT  DROP     -4 FLD +! \ trim *.*
  1E +DTA  0D -TRAILING -0S >R  FLD @  R  CMOVE  R> FLD +!
  ASCII \ FLD @ C!  FLD 1+!                \ add new entry
  DMY  FLD @  4 CMOVE  4 FLD +!  \  get *.*
  FLD @ OVER - 1-  OVER C!   \ calculate length
  2 FLD +!  FLD @ 2- ! ;   \ add link to old


\ Filing xpurge                           ( 15  3 90 crc 12:16 )
: PENTRY   \ $addr -- | build a link in chain of directories
  15 +DTA C@ 10 AND
    IF  1E +DTA C@ ASCII . -  IF  +PATH  ELSE  DROP  THEN
  ELSE  DROP  THEN ;

: .PATHS  FLD @  BEGIN  DUP DBUF - WHILE  CR  2- @
   DUP  COUNT -0S TYPE   REPEAT   DROP ;

: PDIR  \ $addr  ---  | grab directories
  GETCURPATH  (ATT) @ >R  17 (ATT) !  >R
  R SFIRST 0= IF  BEGIN  R PENTRY  SNEXT UNTIL THEN
  R> DROP   R> (ATT) ! ;



\ Filing xpurge                           ( 15  2 91 crc 17:13 )
: BUILDIMAGE   \ addr  ---  |  build image for deletes
  CR ." Found:    "  .curpath ( .DRV)  BUILDUP 40 ERASE
  COUNT >R  BUILDUP R CMOVE  BUILDUP R> TYPE ;

: BUILDS  \   --  | build list of directories to work
  DBUF FLD !  DMY PDIR
  DBUF  BEGIN  DUP FLD @ - WHILE
     DUP  BUILDIMAGE  BUILDUP PDIR
  COUNT + 2+  REPEAT  DROP ;

: DELETES \   --  | zap their files
  4 FLD @ C!  DMY FLD @ 1+ 4 CMOVE   FLD @ DELDIR  \ this dir
  DBUF  BEGIN  DUP FLD @  - 0< WHILE
     DUP  DELDIR  COUNT + 2+  REPEAT  DROP ;

\ Filing xpurge                           ( 29 10 90 crc 13:24 )
CODE (RMDIR) \ $addr --- ec | remove dir at addr
  DX POP,  3A # AH MOV,  21 INT,
  U< IF,  AX NEG,  ELSE,  AX AX SUB,  THEN,  1PUSH

: ZAPDIR  \ $addr  ---  |
  DUP COUNT + 5 -  5 ERASE    CR
  DUP 1+ DUP CHMOD  (RMDIR) -DUP IF 5 .R  ."  error "  THEN
  ." Removing: " .curpath ( .DRV)  COUNT -0S TYPE ;

: RMDIR: \  ---  | zap a dir
  0 FNAM: + !  HERE 1+ DUP CHMOD (RMDIR)
  CR  HERE COUNT TYPE
  -DUP IF 6 .R  ABORT"  Directory Delete Error" THEN ;


\ Filing xpurge                           (  5  3 92 crc 15:44 )
: CHMOD:  \  ---  | change mode of a file to r-w
  PARSEFILE:  FILE CHMOD ;

: ZAPS \   --  | zap the directories
  FLD @  BEGIN  DUP DBUF -  WHILE
  2- @   DUP  ZAPDIR ( DUP COUNT 2+ ERASE ) REPEAT
         DROP ;

FORTH DEFINITIONS
: XPURGE   FILING (ATT) @  7 (ATT) !
  BUILDS  DELETES ZAPS  (ATT) ! ;

: MKDIR: \  ---  | make a dir
  FILING PARSEFILE:  FILE (MKDIR) ;

\ pre-define some file names              ( 12  9 89 crc 12:28 )
FILING FORTH DEFINITIONS        FORGET TASK  FILING DEFINITIONS
: SCREENFILE:  <BUILDS PARSEFILE:
  FILE  C/L -0S >R  R C, HERE  R> 1+  DUP ALLOT  CMOVE
  DOES>  RHANDLE (CLF) -DUP IF . ABORT"  oops"  THEN
  FILE C/L ERASE  DUP COUNT  FILE SWAP CMOVE
  R-W  1+ OPENIT ;

SCREENFILE: RF RF.SCR   SCREENFILE: FILECOM OPTIONS\FILECOM.SCR
SCREENFILE: SAVEDRAW OPTIONS\SAVEDRAW.SCR
SCREENFILE: DBLOW DBLOW.SCR

FORTH DEFINITIONS : TASK ;   EDITOR FLUSH



( savesystem image save                   ( 12  9 89 crc 13:07 )
  FILING DEBUG  FORTH DEFINITIONS       FORGET TASK
BASE @ >R DECIMAL
\ : OCTAL   8 BASE ! ;
( : BYE   MON STOP   )                  R> BASE !
HERE FENCE !  FORTH DEFINITIONS : TASK ; PRESENT
BASE @ >R DECIMAL
  366 NEEDED P?T    383 LOAD     FORGET TASK

HEX  0 VARIABLE HOLDER    EDITOR (STAMP) PLACEF - 20 + ALLOT
PLACEF  HOLDER OVER (STAMP) 22 + SWAP - CMOVE   DECIMAL

  385 LOAD  386 LOAD
 HERE 100 ERASE
R> BASE !  FORTH DEFINITIONS   EDITOR FLUSH

\ save image from vectors                 (  7  2 90 crc  7:59 )
HEX  0D CONSTANT TSKSZ  0 VARIABLE TSK TSKSZ ALLOT
: RESTVEC   EMPTY-BUFFERS  LNCTR OFF  R# OFF SCR OFF
  [ ATTRIBUTE @ ] LITERAL  ATTRIBUTE !  CACHE
  CR ." Copyright 1981-1990, Charles Curley " CR ?DICT  EDITOR
  HOLDER PLACEF [ (STAMP) PLACEF - 22 + ] LITERAL   CMOVE
  0 0  DEBUG SAFEIX 0  100 CMOVEL     HOMESEG
  [ 0  3 4 *  @L  ] LITERAL  DUP ASSEMBLER 3 IX! 1 IX!
  [ ' (ABORT) CFA  ] LITERAL  'ABORT !
  TSK 2+  TSK @  TSKSZ  CMOVE   \ restore "task"
  EDITOR  HERE 85 BLANKS  CLEAR$S  (ABORT)  STOP

LATEST PFA CFA  'ABORT !   HERE FENCE !  : TASK ;
TIB 16 +ORIGIN   48 16 - CMOVE    \ get image for boot
LATEST 2- DUP TSK !  TSK 2+ TSKSZ CMOVE  \ save "task"
DECIMAL  ' (ABORT) CFA 'ABORT !
\ save image to disk                      ( 12  7 89 crc 15:56 )
FORTH DEFINITIONS
FILING       HERE FIRST OVER - ERASE
BASE @ HEX   -1  ' OPENIT  32 +  !   BASE !
LS FILING.COM
MKF: FILING.COM  HANDLE >R   ' HANDLE OFF
PARSEFILE: RF.SCR
0 +ORIGIN HERE OVER -  R WTF  10 U.R
R> ' HANDLE !  CLF
LS FILING.COM
  ;s HANDLE  is set to 0 so that it is 0 in the image, which
is necessary to allow the user to open files. Better to do it
here than in the boot code.
     Also, we set the file string to point to RF.SCR, where it
will be at boot.

\ add mem ptr: add size to offset & seg   ( 19  7 90 crc 10:27 )
DEBUG  FORTH DEFINITIONS  FORGET TASK
FORTH DEFINITIONS  : TASK ;    HERE FIRST OVER - ERASE
BASE @ >R HEX           ASSEMBLER  DEFINITIONS
: PUSH,   DUP # =  IF DROP 6A SIZE @ DUP + - C,  SIZE @ ,/C,
  ELSE  PUSH,  THEN  SIZE ON ;

FORTH DEFINITIONS  HERE ASSEMBLER
  AX DI MOV,  AX 4 # SHR,
  AX BX ADD,  DI AX MOV,  0F # AX AND,  RET,

CODE MEM+   \ offset seg displ -- offset' seg' | add as needed
  DX POP,  BX POP,  AX POP,   DUP #) CALL,
  DX AX ADD,  #) CALL,   AX PUSH,  BX PUSH,  NEXT
R> BASE !  EDITOR FLUSH

















\ create a disk file from a boot sector   ( 24  4 90 crc 12:05 )
FORTH DEFINITIONS  BASE @ DECIMAL  filing  429 NEEDED AR/W
FORGET TASK     BASE !
FORTH DEFINITIONS  BASE @ >R HEX      : TASK ;
HERE FIRST OVER - ERASE    FIRST  400 - CONSTANT BUF

: .X  S->D  <# # # ASCII x HOLD  ASCII 0 HOLD  #>  TYPE ;

: BOOTBLK   BUF 0 ADR  BUF B/BUF 2/
  ?CR BOUNDS DO I C@ .X ."  ,"  COL LOOP ;

setdisk: a filing mkf: bootblk.a  outfile bootblk
    closeoutfile ok
setdisk: b filing mkf: bootblk.b  outfile bootblk
    closeoutfile ok
            R>  BASE ! EDITOR FLUSH
\ 8250 Support: load                      ( 21 11 95 crc 16:46 )
\ from code by Paul Cooper, FORTH Dimensions, 12/88
DEBUG   forth definitions       FORGET TASK
: TASK ;    BASE @ >R
HERE FIRST OVER - ERASE

BLK @ 1+  DUP 5 +  HEX  THRU



EDITOR FLUSH   R> BASE !





\ 8250 Support: useful stuff              ( 22 11 95 crc  7:39 )
: ARRAY  \ c:  --  | create array of word values
         \ r:  i -- n | return data at ith location
  <BUILDS  !CSP  ;CODE    AX POP,  AX AX ADD,
  AX BX ADD,  2 [BX] PUSH,  NEXT

: 2ARRAY \ c:  --  | create array of long word values
         \ r:  i -- d | return data at ith location
  <BUILDS  !CSP  ;CODE    AX POP,  AX SHL,  AX SHL,
  AX BX ADD,  4 [BX] PUSH,  2 [BX] PUSH,  NEXT

 1 CONSTANT DAV    \ data available bit mask
20 CONSTANT TBE    \ transmitter holding register empty bit mask
0 VARIABLE B/A     \ baudot or ascii
0 VARIABLE BASEADDR

\ 8250 Support: port addressing           ( 17  5 93 crc 21:49 )
: REGISTER   <BUILDS  C,  DOES> C@ BASEADDR @ + ;

6 REGISTER MSR     \ modem status register
5 REGISTER LSR     \ line status register
4 REGISTER MCR     \ modem control register
3 REGISTER LCR     \ line control register
0 REGISTER DATAL   \ data low register
1 REGISTER DATAH   \ data high register

: COM   <BUILDS  ,  DOES> @ BASEADDR ! ;

3F8 COM COM1     2F8 COM COM2    3E8 COM COM3     2E8 COM COM4

: SELECTBASE   \ keystroke --  base address selected
  EXEC  COM1 COM2 COM3 COM4     STOP    COM1
\ 8250 Support: baud rate tables          ( 21 11 95 crc 16:46 )
ARRAY DIVISORS \ baud rate divisors
  9D2 ,   900 ,   6B8 ,   600 ,   476 ,   417 ,   359 ,   300 ,
  180 ,    C0 ,    60 ,    40 ,    3A ,    30 ,    20 ,    18 ,
   10 ,    0C ,    06 ,     3 ,     2 ,     1 ,

DECIMAL  2ARRAY BAUDRATES \ available baud rates
   45. , ,         50. , ,          66. , ,         75. , ,
  100. , ,        110. , ,         134. , ,        150. , ,
  300. , ,        600. , ,        1200. , ,       1800. , ,
 2000. , ,       2400. , ,        3600. , ,       4800. , ,
 7200. , ,       9600. , ,       19200. , ,      38400. , ,
56000. , ,      11500. , ,       HEX

ARRAY SETUPS
 02 , 0A , 1A , 06 , 0E , 1E ,  3 , 0B , 1B , 07 , 0F , 1F ,
\ 8250 Support: print baud rates          ( 21 11 95 crc 16:56 )
: .BAUD  \ n -- | print out baud rate available, with keystroke
  DUP  SPACE SPACE ASCII A + EMIT  BAUDRATES  6 D.R ;

: .BAUDS  \  print out all available baud rates
  16 0 DO  I 8 MOD 0= IF CR ELSE SPACE THEN  I .BAUD  LOOP ;

: AKEY CR KEY  DUP ASCII A ASCII z  WITHIN
  0= IF  ABORT"  Keystroke Out of Range"  THEN
  BL OR   BL -  DUP EMIT SPACE ;

: PORTREQUEST   CR  0F [ BLK @ 3 + ] LITERAL .LINE
  AKEY ASCII E MIN  DUP ASCII E -
  IF  ASCII A -  DUP SELECTBASE   0F [ BLK @ 3 + ] LITERAL
    (LINE) DROP  SWAP 10 * +  10 TYPE  THEN  ;

\ 8250 Support: get setup                 (  5  7 90 crc 14:09 )
  \ if baudot, set to 5 bits, 1.5 stop, 0 parity
: ASCII/BAUDOT   \ keystroke  --  | select one of
  CR ."  A)scii or B)audot"
  AKEY  ASCII C MIN  DUP ASCII C - IF
  1 AND  DUP  B/A !  IF  4 LCR PC!  THEN THEN ;

: BAUDREQUEST   BASE @ DECIMAL  .BAUDS
  AKEY  ASCII W MIN  DUP ASCII W -
  IF  LCR PC@ DUP 80 OR LCR PC!  >R
    ASCII A - DUP DIVISORS  .s  DATAL  P! R> LCR PC!
    .BAUD  THEN   BASE ! ;




\ 8250 Support: get setup                 ( 28  2 89 crc  8:27 )
: WORDREQUEST
  0D 1 DO CR I ASCII @ + EMIT SPACE
      I [ BLK @ 1+ ] LITERAL .LINE  LOOP  CR
  AKEY  ASCII M MIN  DUP ASCII M -
  IF  ASCII A -  DUP SETUPS  LCR PC!
    1+ [ BLK @ 1+ ] LITERAL  .LINE  THEN ;

: SETSERIAL
  PORTREQUEST   BAUDREQUEST  ASCII/BAUDOT
  B/A @ IF WORDREQUEST THEN  ;

CTL G EMIT  SETSERIAL



\ 8250 Support: messages                  ( 10  1 89 crc 13:13 )
:   7 bits, 1 stop bit,   no parity
:   7 bits, 1 stop bit,  odd parity
:   7 bits, 1 stop bit, even parity
:   7 bits, 2 stop bit,   no parity
:   7 bits, 2 stop bit,  odd parity
:   7 bits, 2 stop bit, even parity
:   8 bits, 1 stop bit,   no parity
:   8 bits, 1 stop bit,  odd parity
:   8 bits, 1 stop bit, even parity
:   8 bits, 2 stop bit,   no parity
:   8 bits, 2 stop bit,  odd parity
:   8 bits, 2 stop bit, even parity


A : COM1        B : COM2        C : COM3        D : COM4
\ plain, dumb terminal                    ( 15  5 93 crc 20:30 )
DECIMAL 390 NEEDED SETSERIAL    HEX
: RCVD LSR PC@ 1 AND ;
: RCV  DATAL PC@ ;
: AWAITXMIT   BEGIN LSR PC@  20 AND  UNTIL ;
: XMIT  AWAITXMIT  DATAL PC! ;
: FLIP  MSR PC@ XOR  MSR PC! ;
: TERM   ?QUIT OFF BEGIN
  RCVD IF  RCV DIRECT DEMIT FORTH  THEN
  ?KEY IF  <KEY>  DUP  LI = IF ?QUIT !  ELSE
        XMIT  THEN THEN   ?QUIT @ UNTIL ;
: TTYPE  0 DO DUP C@ XMIT 1+ LOOP DROP ;
                \ emit   type   gotoxy page    list   cr
: >TERM OUTPUT> XMIT    TTYPE   2DROP  (PAGE)  NLIST  (CR) STOP

EDITOR FLUSH
\ useful, users' vocabulary words         ( 18  3 89 crc  6:33 )
  DEBUG  FORTH DEFINITIONS        FORGET TASK
  FORTH DEFINITIONS : TASK ;      PRESENT
BASE @ >R DECIMAL
HERE FIRST OVER - ERASE

  BLK @ 1+             HEX load



  PAD 100 ERASE
R> BASE !  FORTH DEFINITIONS   EDITOR FLUSH




\ useful, users' vocabulary words         ( 18  3 89 crc  6:33 )
VOCABULARY USERS IMMEDIATE  \ put user interface here

: USEFUL   \ compile into users vocabulary
  ?EXEC  CONTEXT 2@  >R >R  [COMPILE] USERS DEFINITIONS
  BEGIN -FIND IF  STATE @ <  IF  CFA ,  ELSE  CFA EXECUTE  THEN
     ELSE HERE NUMBER  DPL @ 1+
          IF  [COMPILE] DLITERAL  ELSE
              DROP [COMPILE] LITERAL  THEN THEN  ?STACK
  STATE @ 0= UNTIL  R> R> CONTEXT 2!  ;   IMMEDIATE

USEFUL : TEST  DUP . 234 . ;

0 USEFUL VARIABLE FRED


\ code re-definitions                     ( 13  2 90 crc 11:03 )
DEBUG   FORTH DEFINITIONS    FORGET TASK
: TASK ;                     BASE @ >R    HEX
CODE GO  \  seg offset --  | execute subroutine there
  AX POP,  BX POP,   IP PUSH,  RP PUSH,
  CS PUSH,  HERE 8 + #) CX LEA,  CX PUSH,
  BX PUSH,  AX PUSH,  FAR RET,  RP POP,  IP POP,  NEXT

\ test code for the above
\ 0 VARIABLE FOO -2 ALLOT  ASSEMBLER NOP, NOP,  FAR RET,
R> BASE !  EDITOR FLUSH  ;S
    Warning: very dangerous code! passes control to an alien
segment, which must return with a FAR RET. If the stack in rf
isn't enough, it is up to the alien code to use its own stack,
or you can add code here to use  FIRST  (OFUSER 'FIRST SP MOV,).

\ export image to next segment            (  8  5 90 crc 12:35 )
FORTH DEFINITIONS FILING  DEBUG  FORGET TASK
FORTH DEFINITIONS : TASK ;      HERE FIRST OVER - ERASE
BASE @ >R HEX                   CS@ NEXTSEG @ + SETSEG
CODE ZAPSEG   AX AX SUB,  AX DI MOV,  8000 # CX MOV,  CS BX MOV,
  ' NEXTSEG #) BX ADD,  BX ES MOV,  REP, AX STOS,  NEXT

: EXPORT   ZAPSEG  CS@ 0  OVER NEXTSEG @ + 0  100 CMOVEL
  FILING  100 2000 HANDLE TRDF U. ;

: EXPORT:  FILING OPF:   EXPORT  CLF ;

CODE GO   100 CS@ NEXTSEG @ +  #) FAR JMP,
( EXPORT: REAL4TH.COM) EXPORT: RFF.COM  R> BASE !  EDITOR FLUSH
TRACE: GO 4013 STEPS        CS@ NEXTSEG @ + SETSEG  ;S  4000

\ code re-definitions                     ( 21  8 90 crc 14:14 )
FILING CREF DEBUG  FORGET TASK
FORTH DEFINITIONS : TASK ;  BASE @ >R  HEX
CODE TUPPER   \ addr ct ---  | force to upper case
  CX POP,  BX POP,  ASCII z 1+  8 2*S  ASCII a 1-  OR # DX MOV,
  DO,  0 [BX] AL MOV,  AL DL CMP,
     U< IF,  AL DH CMP,  U> IF,  20 # 0 [BX] .B XOR,
     THEN,  THEN,
  BX INC,  LOOP,  NEXT





R> BASE !   EDITOR FLUSH                    ;S
01234567890@`~abcdefghijklmnopqrstuvwxyz{[|\}]
\ #tib for real-forth, code               ( 23  3 89 crc  8:43 )
  DEBUG  FORTH DEFINITIONS        FORGET TASK
  FORTH DEFINITIONS : TASK ;      PRESENT
BASE @ >R HEX
HERE 0 ,
CODE #TIB   UP #) BX MOV,
  OFUSER TIB DI MOV,   AL AL SUB,
  BEGIN,  AL 0 [DI] CMP,  0<> WHILE,  DI INC,  REPEAT,
  OFUSER TIB DI SUB,  #) BX LEA,  DI 0 [BX] MOV,
  BX PUSH,  NEXT

R> BASE !  FORTH DEFINITIONS   EDITOR FLUSH




\ #tib for real-forth, high level         ( 23  3 89 crc  9:41 )
  DEBUG  FORTH DEFINITIONS        FORGET TASK
  FORTH DEFINITIONS : TASK ;      PRESENT
BASE @ >R HEX
HERE 0 ,
: #TIB   [ 2 CSP +! ] LITERAL
  TIB @  DUP BEGIN DUP C@ WHILE  1+  REPEAT
  SWAP -  OVER ! ;

R> BASE !  FORTH DEFINITIONS   EDITOR FLUSH






\ \->/ for real-forth, code               (  7  7 89 crc  9:10 )
  DEBUG  FORTH DEFINITIONS        FORGET TASK
  FORTH DEFINITIONS : TASK ;      PRESENT
BASE @ >R hex

code \->/  \ addr ct --  | patch string for unix
  cx pop,  dx pop,  dx si xchg,
  ascii \  ascii / 100 * or # bx mov,
  do,  al lods,  al bl cmp,
    0= if,  bh -1 [si] mov,  then, loop,  dx ip mov,  next

R> BASE !  FORTH DEFINITIONS   EDITOR FLUSH    ;s
scan a string and replace \s with /s for use on unix



\ write vectors list                      ( 20  2 91 crc 15:59 )
DEBUG FILING  FORTH DEFINITIONS    FORGET TASK
: TASK ;
BASE @ >R    HEX     0 SETSEG   PRINTER LEFT @  0 LEFTS
LS VECTORS.RAW          FILING  MKF: VECTORS.RAW

CODE NORMALIZE   \ addr seg -- daddr | convert from seg
  AX POP,  CX POP,  10 # DX MOV,  DX MUL,  CX AX ADD,
  0 # DX ADC,  AX PUSH,  DX PUSH,  NEXT
1 +BLK LOAD

OUTFILE    .VECS   CLOSEOUTFILE    PRINTER LEFTS
LS VECTORS.RAW          R> BASE !  EDITOR FLUSH



\ write vectors list                      ( 20  2 91 crc 15:59 )
: d.#r  \ d ct ---  | print right justified w/ leading 0s in ct
  <#  0 do  #  loop  #>  type  ;

: .#r   \ n ct ---  | print out int right justified
  0 swap d.#r  ;

: .vec  \ n  --   | print out the segment of the nth vector
  dup  2* 2*  dup  t@  swap  2+  t@
  cr  2dup  normalize  5 d.#r  ascii | emit
  swap 4 .#r  ascii :  emit  4 .#r   5 .r ;

: .vecs \  --  | print out all 256 of them
  100 0 do i .vec loop ;


\ blank the screen                        ( 17  7 92 crc 22:11 )
FORTH DEFINITIONS  ?CR TODAY CR  FORGET TASK    \ : TASK ;
BASE @ >R DECIMAL  55 NEEDED SEC 102 NEEDED ,"  HEX
VOCABULARY SCREEN IMMEDIATE     SCREEN DEFINITIONS
19 50 * 2* CONSTANT SCRSIZE
: SCRSEG   NEXTSEG @ CS@ + ;
: SAVESCREEN   VIDEO-SEG @ 0  SCRSEG 4  SCRSIZE  CMOVEL
  XY@  SCRSEG 0 !L  SCRSEG 2 !L ;

: RESTORESCR   SCRSEG 4  VIDEO-SEG @ 0  SCRSIZE  CMOVEL
  SCRSEG 2 @L  SCRSEG 0 @L  GOTOXY ;
1 +BLK LOAD   R> BASE ! EDITOR FLUSH
FORTH DEFINITIONS
: BLANK   EDITOR FLUSH  SCREEN SAVESCREEN  GET-CURSOR NO.CURSOR
  PAGE  OUT @  RUN  OUT !   SET-CURSOR RESTORESCR ;
BLANK   HERE FIRST OVER - ERASE         : TASK ;
\ blank the screen                        ( 19  5 92 crc 20:34 )
MSSG WRN Out to Lunch "         47 ' WRN C@ - CONSTANT MAXY
(GETTIME) 18 MOD VARIABLE X     MAXY MOD VARIABLE Y
1 (GETTIME) 1 AND 1- 1 SWAP +- VARIABLE XDIR
1 AND 1- +- VARIABLE YDIR    \  0 VARIABLE RAGGED
: WARN WRN .TIME ;
: +X  XDIR @  X +!  X @  1 17 WITHIN 0=
  IF  XDIR @ MINUS  XDIR !  THEN ;
: +Y  YDIR @  Y +!  Y @  1 MAXY WITHIN 0=
  IF  YDIR @ MINUS  YDIR !  THEN ;

: KILL  X @  Y @ GOTOXY  [ ' WRN C@ 8 + ] LITERAL  SPACES ;

: RUN   BEGIN   X @  Y @  GOTOXY  WARN   5 SEC  KILL   +X +Y
( RAGGED 1+!  RAGGED @ 400 MOD 0= IF +X THEN ) 2 SEC  ?STACK
  (GETDATE) (GETTIME) 2DROP  2DROP  ?KEY UNTIL  KEY DROP ;
































\ quickie: swapcom                        ( 15  2 95 crc 13:23 )
DEBUG FILING  FORTH DEFINITIONS    FORGET TASK
: TASK ;                       0 CONSTANT START
BASE @ >R    HEX        : BASEREL   HERE START -  100 + ;
CODE SWAPCOM
HERE  DUP ' START !   DUP FIRST OVER - ERASE    2 +BLK LOAD
  40 # AX MOV,  AX DS MOV,  0 #) AX MOV,  2 #) BX MOV,
  AX 2 #) MOV,  BX 0 #) MOV,
  AX AX SUB,  AX DX MOV,  21 INT,

LS SWAPCOM.COM          FILING  MKF: SWAPCOM.COM
HERE OVER -  CR .S  HANDLE WTF CR  .  CLF  CR .S
LS SWAPCOM.COM         R> BASE !  EDITOR FLUSH



\ quickie: adaptec                        (  7  1 91 crc 16:46 )
DEBUG FILING  FORTH DEFINITIONS    FORGET TASK
: TASK ;                       0 CONSTANT START
BASE @ >R    HEX        : BASEREL   HERE START -  100 + ;
CODE ADAPTEC
HERE  DUP ' START !   DUP FIRST OVER - ERASE    1 +BLK LOAD
     CS AX MOV,  AX SP MOV,  AX ES MOV,  AX DS MOV,
     5 CC00 FAR #) CALL,  AX AX SUB,  AX DX MOV,  21 INT,


LS A:ADAPTEC.COM        FILING  MKF: A:ADAPTEC.COM
HERE OVER -  CR .S  HANDLE WTF CR  .  CLF  CR .S
LS A:ADAPTEC.COM        R> BASE !  EDITOR FLUSH        ;S

go to the bios on the adaptec scsi controller cards at dc00:6.

\ add copyright notices to quickies       ( 18  1 90 crc 13:14 )
EB IF,
  BASEREL  >R ," Released into the Public Domain."
  BASEREL  >R ," This program Copyright 1995 Charles Curley. "
  BASEREL  >R  2 C,  0A C, 0D C,
  HERE   0 [BX] CL MOV,  CH CH XOR,  1 [BX] DX LEA,
    40 # AH MOV,  1 # BX MOV,  21 INT,   RET,

-ROT THEN,
 R>  \ DUP  #) BX LEA,  OVER #) CALL,    \ crlf
 R>         #) BX LEA,  OVER #) CALL,    \ copyright
     \ DUP  #) BX LEA,  OVER #) CALL,    \ crlf
 R>         #) BX LEA,  OVER #) CALL,    \ released
    2DROP \ #) BX LEA,       #) CALL,    \ crlf


\ quickie: ppage                          ( 13  2 90 crc 13:06 )
DEBUG FILING  FORTH DEFINITIONS    FORGET TASK
: TASK ;                       0 CONSTANT START
BASE @ >R    HEX          : BASEREL   HERE START -  100 + ;
CODE PPAGE
HERE  DUP ' START !   DUP FIRST OVER - ERASE   -1 +BLK LOAD

  CTL L # AX MOV,  DX DX XOR,  17 INT,
  AX AX SUB,  AX DX MOV,  21 INT,

LS PPAGE.COM     FILING  MKF: PPAGE.COM
HERE OVER -  CR .S  HANDLE WTF CR  .  CLF  CR .S
LS PPAGE.COM     R> BASE !  EDITOR FLUSH

\ force a form feed on the lpt whose number is in DX in line
\ 7.
\ quickie: nolock                         (  4 12 89 crc 11:49 )
DEBUG FILING  FORTH DEFINITIONS    FORGET TASK
: TASK ;                       0 CONSTANT START
BASE @ >R    HEX        : BASEREL   HERE START -  100 + ;
CODE NOLOCK
HERE  DUP ' START !   DUP FIRST OVER - ERASE   -2 +BLK LOAD
  40 # AX MOV,  AX DS MOV,  17 #) AL MOV,
  70 -1 XOR # AL AND,  AL 17 #) MOV,
  AX AX SUB,  AX DX MOV,  21 INT,

LS NOLOCK.COM    FILING  MKF: NOLOCK.COM
HERE OVER -  CR .S  HANDLE WTF CR  .  CLF  CR .S
LS NOLOCK.COM    R> BASE !  EDITOR FLUSH

\ turns off caps lock (bit 6), num lock (bit 5) and scroll lock
\ (bit 4)
\ quickie: haltsys                        (  1 11 95 crc 18:54 )
DEBUG FILING  FORTH DEFINITIONS    FORGET TASK
: TASK ;                       0 CONSTANT START
BASE @ >R    HEX        : BASEREL   HERE START -  100 + ;
CODE REBOOT
HERE  DUP ' START !   DUP FIRST OVER - ERASE   -3 +BLK LOAD
  0D # AH MOV,  21 INT,         \ synch the file system
  FFF0 F000 FAR #) JMP,


LS REBOOT.COM    FILING  MKF: REBOOT.COM
HERE OVER -  CR .S  HANDLE WTF CR  .  CLF  CR .S
LS REBOOT.COM    R> BASE !  EDITOR FLUSH

\ reboots most intel processors

\ quickie: caplock                        (  4 12 89 crc 12:00 )
DEBUG FILING  FORTH DEFINITIONS    FORGET TASK
: TASK ;                       0 CONSTANT START
BASE @ >R    HEX        : BASEREL   HERE START -  100 + ;
CODE CAPLOCK
HERE  DUP ' START !   DUP FIRST OVER - ERASE   -4 +BLK LOAD
  40 # AX MOV,  AX DS MOV,  17 #) AL MOV,
  40 # AL OR,  AL 17 #) MOV,
  AX AX SUB,  AX DX MOV,  21 INT,

LS CAPLOCK.COM   FILING  MKF: CAPLOCK.COM
HERE OVER -  CR .S  HANDLE WTF CR  .  CLF  CR .S
LS CAPLOCK.COM   R> BASE !  EDITOR FLUSH

\ turns on caps lock (bit 6).

\ time card stuff                         (  3  9 89 crc 19:59 )
filing  FORTH DEFINITIONS       FORGET TASK  107 NEEDED IFTRUE
FORTH DEFINITIONS : TASK ;      PRESENT
BASE @ >R DECIMAL               HERE FIRST OVER - ERASE

: HRS   60 * ;                  : MIN  + ;

: SEXTAL  6 BASE ! ;

\ : LUNCH  CR 24 TAB   ." Lunch: less     :30"  -30 + ;
\ : DINNER CR 23 TAB  ." Dinner: less     :30"  -30 + ;

: ROUND   15 /MOD  SWAP IF  1+  THEN  15 * ;

: MORE  + ;
-->
\ time card stuff                         ( 28  6 89 crc  8:34 )
: .HRS   0 <#  DECIMAL #  SEXTAL #
  DECIMAL  ASCII : HOLD  # # #>  TYPE ;

: FINAL   CR 25 TAB ." Total hours worked: "
  DUP .HRS  + CR ;

: OUT   DUP ."   Out: " .HRS   ROUND +
  ."    Hours worked: " DUP .HRS ;

: IN  DUP CR ." In: " .HRS  15 / 15 *  MINUS ;

: WEEK"  CR  9 TAB  ." Total hours worked the week of "
  ASCII " WORD  HERE COUNT TYPE  ."  : " .HRS ;
R> BASE !  FORTH DEFINITIONS   EDITOR FLUSH       -->

\ time card stuff                         ( 12  7 89 crc  8:31 )
EDITOR DEFINITIONS     BASE @ >R DECIMAL     INTERNAL
: $  <BUILDS  ,"
  DOES>  COUNT  DUP MINUS HLD +!  HLD @ SWAP CMOVE ;

$ MN min "                      $ HR hrs "

: (TIME)      \   ---  addr ct | time ready for printing
  BASE @ >R DECIMAL (GETTIME)  DROP  <#  MN
  256 /MOD SWAP  0 $SIZE  2DROP  HR  0 $SIZE #>  R> BASE ! ;
EXTERNAL
: T   (TIME)  >R SCR @ BLOCK  R# @ +  R CMOVE  UPDATE
  EDITOR RSTR  R> M  PLACEF ON  PLACING  Q ;
HEX PAD FIRST OVER - BLANKS
FORTH DEFINITIONS  MODULE   R> BASE !   editor

\ time card                               ( 18 12 94 crc 12:55 )
decimal  printer  left @  10 lefts   >r
editor flush   -3 blk @ + needed hrs       decimal    0
cr cr ."  Time Card for"  cr ."  Charles Curley" cr
cr    ."  For the Week ending 11 12 94" cr
  cr ." Monday,     5 12 94"
  11 hrs  0 min in    15 hrs 10 min out
         final
  cr ." Tuesday,    6 12 94"
   9 hrs  0 min in    10 hrs  0 min out
         final
\ cr ." Wednesday,  6 12 94"
\  8 hrs 25 min in    19 hrs 50 min out
\        final
-->

\ time card                               ( 18 12 94 crc 12:55 )
\ cr ." Thursday,  21  9 89"
\  8 hrs 55 min in    17 hrs  8 min out
\        final
  cr ." Friday,     9 12 94"
   9 hrs 45 min in    13 hrs 17 min out
  13 hrs 45 min in    17 hrs 10 min out   more
         final
\ cr ." Sunday,    24  9 89"
\  8 hrs 24 min in    17 hrs 27 min out
\        final
week" 11 December 94"
( ?PRINT IFTRUE PAGE  IFEND )  r> printer lefts editor



\ time card                               (  5 12 94 crc  9:18 )
filing mkf: wh941218.tcd  outfile        lnctr off
decimal  printer  left @  10 lefts   >r
editor flush   -5 blk @ + needed hrs       decimal    0
cr cr ."  Time Card for"  cr ."  Charles Curley" cr
cr    ."  For the Week ending 18 12 94"  cr
  cr ." Monday,    12 12 94"
   9 hrs 15 min in    13 hrs  0 min out
         final
  cr ." Tuesday,   13 12 94"
  10 hrs 21 min in    12 hrs  0 min out
  14 hrs  0 min in    14 hrs 43 min out more
         final
  cr ." Wednesday, 14 12 94"
   9 hrs 28 min in    18 hrs  0 min out
         final   -->
\ time card                               ( 18 12 94 crc 13:05 )
  cr ." Thursday,  15 12 94"
  13 hrs  0 min in    15 hrs 51 min out
  16 hrs 31 min in    17 hrs  0 min out   more   final
  cr ." Friday,    16 12 94"
   9 hrs 41 min in    13 hrs  0 min out
  14 hrs 19 min in    17 hrs 15 min out   more   final
  cr ." Saturday,  18 12 94"
  13 hrs 35 min in    14 hrs  0 min out
  14 hrs 25 min in    16 hrs 30 min out   more   final
  cr ." Sunday,    18 12 94"
  11 hrs 54 min in    12 hrs 55 min out          final
week" 18 December 94"
( ?PRINT IFTRUE PAGE  IFEND )  r> printer lefts editor
ok closeoutfile

\ time card                               (  5 12 94 crc  9:34 )
decimal  printer  left @  10 lefts   >r
editor flush   -7 blk @ + needed hrs       decimal    0
cr cr ."  Time Card for"  cr ."  Charles Curley" cr
cr    ."  For the Week ending  4 12 94"  cr
  cr ." Monday,    28 11 94"
   7 hrs 55 min in    12 hrs  7 min out
  13 hrs 20 min in    17 hrs 10 min out more
         final
  cr ." Tuesday,   29 11 94"
  11 hrs 28 min in    13 hrs 19 min out
  15 hrs 20 min in    16 hrs 50 min out more
         final
  cr ." Wednesday, 30 11 94"
  11 hrs 10 min in    13 hrs 22 min out
  13 hrs 50 min in    14 hrs 15 min out more  -->
\ time card                               (  5 12 94 crc  9:35 )
         final
  cr ." Thursday,   1 12 94"
   9 hrs 18 min in    12 hrs 37 min out
  13 hrs 10 min in    15 hrs 03 min out more
         final
  cr ." Friday,     2 12 94"
week"  4 December 94"
( ?PRINT IFTRUE PAGE  IFEND )  r> printer lefts editor







\ Absolute disk read Dos 3.3 or less      (  1  8 89 crc 11:20 )
FILING           FORTH DEFINITIONS        FORGET TASK
  FORTH DEFINITIONS ( : TASK ; )  PRESENT
BASE @ >R HEX                     EDITOR FLUSH
CODE (ADR) \  addr lba dsk --- fl || er fl | absolute disk read
  AX POP,  DX POP,  BX POP,  1 # CX MOV,
  IP PUSH,  BP PUSH,  25 INT,
  CX POP,  BP POP,  IP POP,
  U< IF,  0 # AH MOV,  AX PUSH, \ free -dup
     ELSE,  AX AX SUB,  THEN,  1PUSH

-->  errors:
80 -- failure to respond        40 -- seek failed
20 -- controller failed         10 -- CRC failed
 8 -- DMA failure (??)           4 -- sector not found
 2 -- bad address mark           1 -- bad command (?)
\ Absolute disk write                     ( 29 11 89 crc  9:21 )
CODE (ADW) \  addr blk dsk --- fl || er fl | absolute disk write
  AX POP,  DX POP,  BX POP,  1 # CX MOV,
  IP PUSH,  BP PUSH,  26 INT,
  CX POP,  BP POP,  IP POP,
  U< IF,  0 # AH MOV,  AX PUSH, \ free -dup
     ELSE,  AX AX SUB,  THEN,  1PUSH

FILING CURDRV CONSTANT DSK
: SETDISK:   [COMPILE] CTL 1- ' DSK ! ;

: ADR \  addr lba --- fl || er fl | absolute disk read
  DSK (ADR)  IF HEX .S ABORT"  Disk Read Error"  THEN ;
: ADW \  addr lba --- fl || er fl | absolute disk read
  DSK (ADW)  IF HEX .S ABORT"  Disk Write Error"  THEN ;
HERE FIRST OVER - ERASE  -->
\ (ar/w)                                  (  1  8 89 crc 12:44 )
: ABR \  addr blk ---  | absolute block read
  2*  2DUP  ADR  200 1 D+  ADR ;

: ABW \  addr blk ---  | absolute block read
  2*  2DUP  ADW  200 1 D+  ADW ;

: (AR/W)  \ addr blk fl ---  | absolute read/write to disk
  IF  ABR  ELSE  ABW  THEN ;
DECIMAL
: AR/W   [ ' (AR/W) CFA ] LITERAL  'R/W !   719 ' MAXBLK ! ;

: OR/W   [ 'R/W @       ] LITERAL  'R/W !
  [ MAXBLK ] LITERAL  ' MAXBLK ! ;

R> BASE !  FORTH DEFINITIONS    : TASK ;  EDITOR FLUSH
\ slurping                                ( 21  5 90 crc 11:20 )
-3 BLK @ + NEEDED (AR/W)
FORGET TASK     FORTH DEFINITIONS
: (F->DR/W)  \ addr blk fl ---  | absolute write - file read
  DUP IF  (R/W)  ELSE  (AR/W)  THEN ;

: F->D   [ ' (F->DR/W) CFA ] LITERAL  'R/W ! ;

: (D->FR/W)  \ addr blk fl ---  | absolute read - file write
  DUP IF  (AR/W)  ELSE  (R/W)  THEN ;

: D->F   [ ' (D->FR/W) CFA ] LITERAL  'R/W ! ;

: TASK ;


\ quick port toggle routine               (  8 11 89 crc 16:02 )
debug forget task forth definitions
: task ;   base @ >r hex       here first over - erase
\ code tickle
\   cx cx xor,  301 # dx mov,
\   do,  al inc,  dx al out,  loop,  next

\ : tickles 0 do tickle loop ;

code tickles     cx pop,   301 # dx mov,   here 2- >r
  1 # ah mov,  do,  cx push,  cx cx xor,
    do,  ah al xor,  dx al out,  loop,
    cx pop,  loop,  next                r> constant port

decimal 128 24 + hex 304 pc!
( : task ; )   r> base !  editor flush
\ xref generation                         ( 17  4 90 crc 10:10 )
filing  debug  cref    forget task    page
forth definitions  : task ;        base @ >r
printer   left @ >r  0 lefts
\ filing mkf: xref.txt  page       outfile

hex  .vocs cr .segs cr  decimal
                                cref            cross
debug           cross           filing          cross
disassembler    cross           printer         cross
typing          cross
editor          cross           assembler       cross
forth           cross                   \ closeoutfile

printer  r> lefts  r> base !  editor flush

\  structure defining words for realforth ( 20  7 89 crc  9:38 )
DEBUG FORTH DEFINITIONS    FORGET TASK
: TASK ;
BASE @ >R    DECIMAL

451  463  THRU


here first over - erase
R> BASE !  editor flush






\ start data structure definitions        ( 20  7 89 crc  9:36 )
0 VARIABLE LASTSTRUCT
0 VARIABLE SIZE

: ALLOT0    HERE OVER ERASE ALLOT ;

: STRUCT     \ acts like a C structure, heh heh heh....
  <BUILDS  HERE LASTSTRUCT !        \ point to daughter's pfa
  0 ,                               \ make room for size
  DOES>  <BUILDS  DUP ,             \ our structure flag
  @ ALLOT0 IMMEDIATE                \ allocate room in dict.
    DOES>  DUP @ LASTSTRUCT !       \ at run time
    2+ ;                            \ leave address of struct



\ { }                                     (  5  8 89 crc 12:05 )
: {    SIZE OFF ;

: }    SIZE @ LASTSTRUCT @ ! ;

            \ n.b. ONLY works on granddaughter!
: SIZEOF    \ cccc  -- n | returns size of structure
  -FIND 0= 0 ?ERROR DROP  @ @  [COMPILE] LITERAL  ;  IMMEDIATE

            \ n.b. ONLY works on granddaughter!
: STRUCTCNT \ cccc  --  addr ct | ready for dump, erase, etc.
  IN @  -FIND 0= 0 ?ERROR DROP  SWAP IN !   \ get addr
  CFA  STATE @ IF  ,  ELSE  EXECUTE  THEN   \ compile it?
  [COMPILE] SIZEOF ;  IMMEDIATE             \ get size


;S structure defining words for real4th   ( 20  7 89 crc  9:36 )
preserve the environment
debug temp for easy recompiles

compile rest of file, except dummies later on.



restore environment







;S start data structure definitions       ( 20  7 89 crc  9:36 )
pointer to current stucture: compile and run times!
size of current structure: compile time

allot and fill with 0s. Simplifies debugging.

A word which builds defining words

create a space to save the pointer.....
use the pointer later, in the defining word daughter word

    What the granddaughter words do...
    leave the structure's actual address...



;S { }                                    ( 20  7 89 crc  9:36 )
re-start the counting here.

end of definition for the structure

            \ n.b. ONLY works on granddaughter!
get the size of the given structure. E.g.
SNARK  SIZEOF SNARK  ERASE

            \ n.b. ONLY works on granddaughter!
get the address and count of a given structure. E.g:
: SEE  STRUCTCNT SNARK DUMP ;
This compiles the structure itself and then its count as a
literal.


\ allocator definer                       ( 20  7 89 crc 10:13 )
: <ALLOC>           \ at run time of structure
    DUP 1+ @  LASTSTRUCT @ \ the structure to which it belongs
    -  IF ABORT" Not my structure!"  THEN
    C@ +            \ bring up offset, & add it to the base
    STATE @ IF [COMPILE] LITERAL THEN ;

: ALLOCATOR
  <BUILDS C,        \ size of data in field
  DOES>   <BUILDS   \ an instance
  IMMEDIATE         \ run it at word compile time
  SIZE @ C,         \ its offset into the struct
  LASTSTRUCT @ ,    \ the structure to which it belongs!
  C@ SIZE +!        \ advance to the next structure
    DOES> <ALLOC> ; \ at run time of structure

\ allocator[ defined                      ( 20  7 89 crc 10:26 )
: ALLOCATOR[
  <BUILDS C,        \ size of element in array field
  DOES>   <BUILDS   \ an instance
  IMMEDIATE         \ run it at word compile time
  SIZE @ C,         \ its offset into the struct
  LASTSTRUCT @ ,    \ the structure to which it belongs!
  C@ * SIZE +!      \ advance to the next structure
    DOES> <ALLOC> ; \ at run time of structure







\ allocators defined                      ( 20  7 89 crc 10:16 )
1 ALLOCATOR CHAR                1 ALLOCATOR[ CHAR[
2 ALLOCATOR SHORT               2 ALLOCATOR[ SHORT[
4 ALLOCATOR INT                 4 ALLOCATOR[ INT[
4 ALLOCATOR LONG                4 ALLOCATOR[ LONG[

: UNSIGNED ;    IMMEDIATE  \ syntactical sugar.

: -> ;          IMMEDIATE  \ syntactical sugar.







;S allocator definer                      ( 20  7 89 crc  9:36 )
    Here's what a granddaughter does...
    Test to be sure we're in the correct structure.
    if not, bomb out of compilation, loudly.
    if so, bring up the offset and add it to the base address
    and compile if need be.

define a series of defining words to build up struct fields.
size is given at compile time of daughter.
here's what a daughter does...
granddaughters are immediate.
a byte of offset into the structure, and
the structure to which it belongs
and advance the size to include the one just executed.


;S allocator[ defined                     ( 20  7 89 crc 10:28 )
define a series of defining words to build up array fields.
size is given at compile time of daughter.
here's what a daughter does...
granddaughters are immediate.
a byte of offset into the structure, and
the structure to which it belongs
and advance the size to include the one just executed.








;S allocators defined                     ( 20  7 89 crc  9:36 )
Some sample allocators. Sizes are in bytes.

                                size of each element


make it look more C like.

Not to be confused with  --> .







\ dummy instances for trial               ( 20  7 89 crc 10:18 )
STRUCT FOO  {
    4 INT[ KAZOO                \ 16 bytes
    LONG HARP                   \ 4 bytes
    CHAR NOTE                   \ 1 byte
    }

FOO SNARK       FOO BOJUM

STRUCT BAR {
    CHAR POGO                   \ 1 byte
    INT ALBERT                  \ 4 bytes
    LONG HOWLAND                \ 4 bytes
    }
BAR SWAMP       BAR MUDGE       FOO GEORGE

\ more test goodies                       ( 20  7 89 crc  9:36 )
: TESTCOMPILER   SNARK HARP   SNARK KAZOO  - ;

: TESTIT         BOJUM HARP   SNARK KAZOO  - ;












\ pctools aide                            ( 28  8 89 crc 14:48 )
forget task
forth definitions : task ;
base @ hex
: x   dup u.  base @ >r  decimal
      200 /mod ."  = Sec " u.  hex ."  Disp " u.
      r> base ! ;

: xd  hex  x decimal ;

base !  editor flush forth





 ( TSRFORTH  ) -->                        ( 19  9 89 crc  8:55 )
   TSRFORTH  -  Forth as a terminate and stay resident utility.
by: Rick VanNorman
    1080 Hall Road
    Palm Bay, FL  32905
    (407) 728 0002

This code is released into the public domain.  It may be freely
distributed and used in any way, provided this copyright travels
with it.

(c) 1988 by Rick VanNorman
Thank you for your support.

Originally written for f83 by Rick VanNorman, adapted for
real-FORTH by Charles Curley.
\ TSR FORTH)      this screen useless     ( 19  9 89 crc  8:56 )
CR
CR   ." Creating TSReal-FORTH"
CR   ." [c] 1988 by Rick VanNorman"
CR
\ CR    2 LOAD

\     SAVE-SYSTEM TSRFORTH.COM

CR
\ CR   ." The TSR has been saved on disk as  TSRFORTH.COM"
\ CR   ." Type "TSRFORTH" at the DOS prompt to install it"
\ CR   ." Exiting to DOS..."
CR
\ CR   0 0 BDOS
-->
( LOAD THE TSR)                           ( 13 12 89 crc 10:13 )
FILING DEBUG   FORTH DEFINITIONS  FORGET TASK
FORTH DEFINITIONS    : TASK ;         PRESENT
here first over - erase
\ FROM EDIT.BLK 1 LOAD

DECIMAL  457 474 THRU  ( terminate and stay resident)

TSRX ( FORTH ) DEFINITIONS
\ HERE FENCE !   : TASK ;
editor





;s    \ Bios console/printer interface

The use of Forth as a TSR requires that all console i/o execute
without using BDOS.  This requires a redefinition of the
primitives for  KEY ,  EMIT ,  and  KEY?  in F83.  This
implementation uses only BIOS for all interfaces and is
functionally equivalent to the original BDOS implementation,
with the exception of not responding to control-c.

The following screens should be included in the kernel in place
of the screens containing the (KEY) etc definitions.





;s    \ Devices            Bios console interface  02Jan89rvn

VARIABLE 'KEY   ( holds the current/next keystroke)

CODE (KEY?) ( - f)
   40 INT   1 # AH MOV  22 INT
   0= IF  AX AX SUB  ELSE  -1 # AX MOV  THEN
   AX PUSH  NEXT  END-CODE

CODE //KEY// ( - c)
   0 # AH MOV  22 INT   AX PUSH  NEXT  END-CODE
CODE //EMIT// ( c)
   AX POP  14 # AH MOV   7 # BL MOV  0 # BH MOV
   16 INT  NEXT  END-CODE
CODE //PRINT// ( c)
   AX POP  0 # DX MOV  23 INT  NEXT  END-CODE
;s    \ Devices            Bios console interface  02Jan89rvn

: (KEY) ( - c)
   'KEY C@ IF  'KEY C@  0 'KEY !  EXIT  THEN
   BEGIN  PAUSE  (KEY?)  UNTIL  //KEY//
   DUP  255 AND IF  255 AND  EXIT  THEN
   FLIP 'KEY C!  0 ;

: PR-STAT (S -- f )   TRUE   ( 0 15 BIOS )   ;

: (PRINT)    ( c)   PAUSE  //PRINT//  1 #OUT +! ;
: (CONSOLE)  ( c)   PAUSE  //EMIT//   1 #OUT +! ;

: (EMIT) ( c)
   PRINTING @ IF  DUP (PRINT)  -1 #OUT +!  THEN (CONSOLE) ;

( TSR FORTH)   ;s

And now that the system is properly extended, lets make the TSR.

1. We must be able to define and install new interrupt routines
   in MSDOS and to vector to the old interrupt services.
2. We must track the state of our application.
3. We must be able to save and restore the cpu's state.
4. We must know when we may and may not interrupt the cpu.
5. We must know when the user wants to activate us.
6. We must be able to activate as soon as DOS can allow us.
7. We must terminate the process, reserving memory for it.
8. We must provide a way to exit to the routine interrupted
   preserving the crt in both directions.
9. We must initialize the TSR from a .COM file.

\ real-Forth glue code                    ( 19  9 89 crc 10:57 )
: 2@l       \ seg addr -- d | get 32 bits at addr & seg
  2dup 2+ @l  rot rot @l ;

: 2!l       \ d seg addr -- | store 32 bits at addr & seg
  2dup >r >r !l  r> r> 2+ !l ;









cr 0 +blk  . .s
   ( Installing interrupts)               ( 19  9 89 crc 10:47 )
CODE ENABLE   STI,  NEXT
CODE DISABLE  CLI,  NEXT

VOCABULARY TSRX  TSRX DEFINITIONS

: >INT ( n - seg off)   4 *  0  SWAP ;

: INSTALL ( a n)
   DISABLE  2DUP  >INT 2@L  SWAP ROT 2!
   CS@ ROT 4 + ROT >INT 2!L  ENABLE ;
: UNINSTALL ( a n)
   DISABLE  SWAP 2@  SWAP ROT >INT 2!l  ENABLE ;

: INTERRUPT    0 VARIABLE  0 ,  ASSEMBLER ;
CR 0 +BLK  . .S
   ( Necessary state variables)           ( 19  9 89 crc  9:00 )

0 VARIABLE TSR-ACTIVE
0 VARIABLE DISK-ACTIVE
0 VARIABLE DOS-SP
0 VARIABLE DOS-SS
0 VARIABLE FORTH-SP

0 VARIABLE 'INDOS  0 ,

0 VARIABLE ERR_FLAG

0 VARIABLE MEASURING
0 VARIABLE COUNTER
0 VARIABLE HOTKEY
cr 0 +blk  . .s
   ( Leaving dos, entering forth)         ( 13 12 89 crc 11:28 )

assembler begin,
   AX PUSH,  BX PUSH,  CX PUSH,  DX PUSH,
   SI PUSH,  DI PUSH,  BP PUSH,
   DS PUSH,  ES PUSH,
   SP AX MOV,  CS:  AX  DOS-SP #) MOV,
   SS AX MOV,  CS:  AX  DOS-SS #) MOV,
   STI,

   CS AX MOV,   AX DS MOV,  AX ES MOV,
   FORTH-SP #) BX MOV,  AX SS MOV,  BX SP MOV,
   IP POP,  RP POP,  NEXT

1 ?pairs constant DOS>FORTH
cr 0 +blk  . .s
   ( Leaving forth, returning to dos)     ( 13 12 89 crc 11:31 )

CODE FORTH>DOS
   RP PUSH,  IP PUSH,  SP FORTH-SP #) MOV,

   DOS-SP #) bX MOV,
   DOS-SS #) AX MOV,  AX SS MOV,    bX SP MOV,

   ES POP,  DS POP,
   BP POP,  DI POP,  SI POP,
   DX POP,  CX POP,  BX POP,  AX POP,
   CS: 0 # TSR-ACTIVE #) MOV,
   CS: 0 # HOTKEY     #) MOV,
   IRET,
\ END-CODE
cr 0 +blk  . .s
   ( Interrupts: disk, ioerr)    DECIMAL  ( 13 12 89 crc  9:19 )

INTERRUPT DISK-SERV
   CS:  DISK-ACTIVE #) INC,
   PUSHF,  CS: DISK-SERV S#) FAR CALL,
   CS:  DISK-ACTIVE #) DEC,
   IRET,

INTERRUPT IOERR
   STI,  CS: 1 # ERR_FLAG #) MOV,  0 # AL MOV,  IRET,





cr 0 +blk  . .s
   ( snap hotkey detect)   HEX            ( 13 12 89 crc  9:19 )

assembler begin,
   60 # AL IN,
   038 # AL CMP,  0= IF, ( control key press)
      CS: 0 # MEASURING #) CMP,
      0= IF,  CS: 0 # COUNTER #) MOV,
              CS: 1 # MEASURING #) MOV,  THEN,
   ELSE,
      0B8 # AL CMP,  0= IF, ( control key release)
         CS: 0 # MEASURING #) MOV,
         CS: 3 # COUNTER #) CMP,
         U< IF,  CS: -1 # HOTKEY #) MOV,  THEN,
      THEN,
   THEN,  RET,     1 ?pairs constant SNAPKEY
cr 0 +blk  . .s
   ( Interrupts: keyboard)   HEX          ( 13 12 89 crc  9:19 )

INTERRUPT KBD-SERV
   STI,  AX PUSH,  SNAPKEY #) CALL,  AX POP,
   PUSHF,  CS: KBD-SERV S#) FAR CALL,  IRET,

INTERRUPT KBD-IDLE-SERV
   STI,  PUSHF,  CS: KBD-IDLE-SERV S#) FAR CALL,   CLI,
   CS:  0 #     HOTKEY #) CMP,  0=  IF,  IRET,  THEN,
   CS:  1 # TSR-ACTIVE #) CMP,  0=  IF,  IRET,  THEN,

   CS: 1 # TSR-ACTIVE #) MOV,
   CS: 0 #     HOTKEY #) MOV,

   STI,  DOS>FORTH #) JMP,
cr 0 +blk  . .s
   ( Interrupts: timer)   HEX             ( 13 12 89 crc 10:02 )
INTERRUPT TIMER-SERV
   STI,  PUSHF,  CS: TIMER-SERV S#) FAR CALL,
   CS:  1 # COUNTER #) ADD,
   CS:  0 #      HOTKEY #) CMP,  0=  IF,  IRET,  THEN,
   CS:  1 #  TSR-ACTIVE #) CMP,  0=  IF,  IRET,  THEN,
   CS:  1 # DISK-ACTIVE #) CMP,  0=  IF,  IRET,  THEN,
   ES PUSH,  DI PUSH,
   CS: 'INDOS 2+ #) ES MOV,  CS: 'INDOS #) DI MOV,
   ES: 0 # 0 [DI] .B CMP,
   DI POP,  ES POP,   0<> IF,  IRET,  THEN,
   AX PUSH,  20 # AL MOV,  20 # AL OUT,  AX POP,
   CS: 0 #     HOTKEY #) MOV,
   CS: 1 # TSR-ACTIVE #) MOV,
   STI,   DOS>FORTH #) JMP,
cr 0 +blk  . .s
   ( TSR installation)   HEX              ( 13 12 89 crc  9:20 )

CODE INDOS@ ( - seg off)
   34 # AH MOV,  21 INT,  ES PUSH,  BX PUSH,  CS PUSH,
   ES POP,  NEXT

INDOS@  'INDOS 2!   FORGET INDOS@

: INSTALL-TSR
   DISK-SERV     013 INSTALL
   TIMER-SERV    01C INSTALL
   KBD-IDLE-SERV 028 INSTALL
   KBD-SERV      009 INSTALL
   IOERR         024 INSTALL ;

cr 0 +blk  . .s
   ( Initial termination)   HEX           ( 13 12 89 crc  9:21 )

CODE TERMINATE
   4A00 # AX MOV,  1200 # BX MOV,  21 INT,
   RP PUSH,  IP PUSH,  SP FORTH-SP #) MOV,
   1200 # DX MOV,  ( 64k forth + 2000 forth-crt + 2000 dos-crt)
   3100 # AX MOV,  ( terminate and stay resident)
   21 INT,

CODE UNALLOCATE
   4900 # AX MOV,  21 INT,
   2C #) AX MOV,  AX ES MOV,  4900 # AX MOV,  21 INT,
   CS AX MOV,  AX ES MOV,  NEXT


cr 0 +blk  . .s
   ( interrupt un-install)   HEX          ( 13 12 89 crc 10:12 )

: ?OWNED ( a n)
   SWAP 4 +  OVER >INT @l = IF DROP ;s THEN
   CR ." Interrupt " . abort" is unowned by TSReal-FORTH" stop

: ?OWNER
   DISK-SERV     013 ?OWNED        TIMER-SERV    01C ?OWNED
   KBD-IDLE-SERV 028 ?OWNED        KBD-SERV      009 ?OWNED ;

: UNINSTALL-TSR
   DISK-SERV     013 UNINSTALL     TIMER-SERV    01C UNINSTALL
   KBD-IDLE-SERV 028 UNINSTALL     KBD-SERV      009 UNINSTALL ;


cr 0 +blk  . .s
   ( saving the environment)   DECIMAL    ( 13 12 89 crc  9:36 )
0 variable FORTH-ENV    -2 allot
  ASCII \ C,  HERE  68 ALLOT  68 ERASE  0 ,
0 variable DOS-ENV      -2 allot
  ASCII \ C,  HERE  68 ALLOT  68 ERASE  4096 ,
: WHERE-I-AM ( a \ save path, drive, cursor position, video)
   DUP  1+    filing  0 getpath
   DUP 64 +   curdrv SWAP C!
   DUP 65 +   XY@ ROT 2!
       69 +   @  >R Video-SEG @ 0  cs@ 4096 + R>  4000 CMOVEl ;
: WHERE-I-WAS ( a \ restore path, drive, cursor position, video)
   DUP        filing (setdir) DROP
   DUP 64 +   C@ (setdef)
   DUP 65 +   2@ gotoxy
       69 +   @  cs@ 4096 + SWAP  Video-SEG @ 0  4000 CMOVEl ;
cr 0 +blk  . .s
   ( Restart Forth from DOS and DOS from F( 13 12 89 crc 13:09 )

here 1+ ," rf.scr" 0 c,
: re-open   rhandle 0=
   if  [ 2 csp +!  rot ] literal openit then ;

: RESTART-FORTH
\  ?VMODE 7 = IF  MONO ELSE COLOR THEN
   DOS-ENV WHERE-I-AM   FORTH-ENV WHERE-I-WAS
   IOERR 024 INSTALL  re-open ;

: RESTART-DOS
   FORTH-ENV WHERE-I-AM   DOS-ENV WHERE-I-WAS
   IOERR 024 UNINSTALL
   FORTH>DOS  | ;

   ( tsr)                                 ( 13 12 89 crc 11:53 )

: TSR
   FORTH-ENV WHERE-I-AM
   INSTALL-TSR  TERMINATE
   RESTART-FORTH ;

: <KEY?>
   HOTKEY @ IF  RESTART-DOS RESTART-FORTH  THEN
   [ '?terminal @ , ] ;






   ( signature)                           ( 13 12 89 crc  9:53 )
: d=  dminus d+ or 0= ;

0 variable SIGNATURE -2 allot 1234567890.  , ,

: ALREADY-LOADED
   CR  ." TSR Forth already loaded"
   CR  ." Tap the ALT key to activate"
   CR [[ ax ax sub,  33 int,    smudge

: ?EXISTS    0 cs@ 1- DO
      I SIGNATURE 2@l  1234567890. D=
      IF   ALREADY-LOADED  THEN
   -1 +LOOP ;
cr 0 +blk  . .s

   ( boot the tsr)                        ( 13 12 89 crc  9:53 )
: COPYRIGHT
   CR ." TSR Forth,  F83 v2.1.0  30Jun89"
   CR ." (c) 1989 by Rick VanNorman"
   CR ." Adapted for real-Forth by C. Curley."
   CR
   CR ." A brief tap on the ALT key activates TSReal-FORTH"
   CR   CR ;

: TSR-HELLO   [ TSRX ]   ' rhandle off
   ?EXISTS  COPYRIGHT   FORTH DEFINITIONS   DECIMAL
   ' <KEY?> cfa '?terminal !    ( START)  TSR ;

\ ' TSR-HELLO IS BOOT
cr 0 +blk  . .s

( TSR Forth -- the user interface)        ( 13 12 89 crc 10:05 )

FORTH DEFINITIONS

: BYE   [ TSRX ]
   RESTART-DOS  RESTART-FORTH ;

: DIE   [ TSRX ]
   CR ." ... are you sure that euthanasia is the solution ? "
   KEY DUP EMIT  BL OR  ASCII y - IF ."  continuing ... "  THEN
   ?OWNER UNINSTALL-TSR UNALLOCATE RESTART-DOS ;



cr 0 +blk  . .s

\ extended memory access                  (  1  6 90 crc  8:38 )
  DEBUG  FORTH DEFINITIONS        FORGET TASK
BASE @ >R DECIMAL  FORTH DEFINITIONS  107 NEEDED IFTRUE : TASK ;
       PRESENT   HEX
CODE SIZEEXT  \  -- n | n is size in k above 1m line
  88 # AH MOV,  15 INT,  1PUSH
DECIMAL  SIZEEXT DUP ?CR U. ." kilobytes of extended memory."
IFTRUE   BLK @ 1+ DUP 3 + THRU  OTHERWISE  FORGET SIZEEXT
."  Not loading code."  IFEND    HERE FIRST OVER - ERASE  ?CR
R> BASE !  FORTH DEFINITIONS    ( : TASK ; ) EDITOR FLUSH    ;S

     To use: set up a source address, a destination address and
a count on the stack. Use  SETGDT  to set up the controlling
table. Then call  MOVEXT  to make the move. Both addresses must
be normalised (seg:off -> linear addr), and the count is in
bytes. Also can work within low mem (<1meg).
\ extended memory access                  (  3  6 90 crc 14:20 )
DECIMAL
0 VARIABLE GDT   HERE  48 2- DUP ALLOT  ERASE

CODE NORMALIZE   \ addr seg -- daddr | convert from seg
  AX POP,  CX POP,  16 # DX MOV,  DX MUL,  CX AX ADD,
  0 # DX ADC,  AX PUSH,  DX PUSH,  NEXT

CODE +GDT   \ n -- addr | return nth byte into gdt
  BX POP,  GDT [BX] AX LEA,  1PUSH

CODE A!     \ daddr addr --  | stuff 24 bits of daddr to addr
  BX POP,  AX POP,  AL 2 [BX] MOV,  0 [BX] POP,  NEXT



\ extended memory access                  (  3  6 90 crc 14:24 )
: SETGDT    \ src-daddr  dest-daddr ct --  | set up table
  GDT 48 ERASE  DUP 16 +GDT !  24 +GDT !  \ ct
  26 +GDT A!  \ dest
  18 +GDT A!  \ src
  147 DUP 21 +GDT C!  29 +GDT C!  ; \ access rights (??)

HEX
CODE MOVEEXT  \  -- fl | call extended memory int
  CS PUSH,  ES POP,  IP PUSH,  GDT #) SI LEA,
  10 [SI] CX MOV,  CX SHR,
  87 # AH MOV,  15 INT,  IP POP,
  AH AL MOV,  AH AH SUB,  1PUSH

: EXTMOVE  SETGDT MOVEEXT  \ extended ram move w/ error msg
  -DUP IF  HEX 6 .R  ABORT"  Extended RAM failure."  THEN ;
\ extended memory ram disk                (  3  6 90 crc 14:24 )
: EXTR   \ addr blk# ---  | read extended memory for 1K
  B/BUF U*  10.0000 D+  \ src
  ROT CS@ NORMALIZE ( dst)  B/BUF  EXTMOVE ;

: EXTW   \ addr blk# ---  | read extended memory for 1K
  SWAP CS@ NORMALIZE ( src)  ROT B/BUF U* 10.0000 D+ ( dst)
  B/BUF  EXTMOVE ;

: EXR/W   IF  EXTR  ELSE  EXTW THEN ;

: RAMDISK [ ' EXR/W  CFA ] LITERAL 'R/W ! ;

: OLDDISK [ ' (R/W) CFA ] LITERAL 'R/W ! ;


\ Pseudo-disk for MS-DOS                  (  7  2 90 crc 10:04 )
: BACKUP    \ read disk(s) into pseudo disk
  ?CR MAXBLK 1+  0  DO  PAD I 1  (R/W)   PAD I EXTW
  ?TERMINAL IF LEAVE THEN   I 5 .R  LOOP ;

: BACKDOWN  \  blk#  ---   | write a pseudo disk to disk(s)
  ?CR MAXBLK 1+  0  DO  PAD I EXTR  PAD I 0 (R/W)
  ?TERMINAL IF LEAVE THEN   I 5 .R  LOOP ;








\ data size handlers: 8086                (  3  8 90 crc 12:56 )
CREF  DEBUG  FORTH DEFINITIONS FORGET TASK
FORTH DEFINITIONS : TASK ;  BASE @ >R DECIMAL
HERE FIRST OVER - ERASE

1 +BLK 7 +BLK  HEX THRU

R> BASE !  EDITOR FLUSH   PRESENT        ;S
The idea is to produce portable, cpu-independent data @ and !
words. These can then be used to produce a portable application,
e.g a database. Simply indicate the desired size and action:
0 LONG VARIABLE FOO
1234 SHORT VARIABLE BAR
FOO  LONG @  LONG DUP  BAR SHORT !  PAD LONG !


\ cell manipulators: 8086                 (  6  8 90 crc 10:57 )
IN BLK - CONSTANT CELL
  CODE CELL-     ' 2-  CFA @  LATEST PFA CFA !
  CODE CELL+     ' 2+  CFA @  LATEST PFA CFA !
  CODE CELL/     ' 2/  CFA @  LATEST PFA CFA !
  CODE CELL*     ' 2*  CFA @  LATEST PFA CFA !
  CODE CELL*S    ' 2*S CFA @  LATEST PFA CFA !
  CODE CELL/S    ' 2/S CFA @  LATEST PFA CFA !








\ data size handlers: 8086                (  6  8 90 crc 15:16 )
: CATEGORY      \ r:  ---   | find next word in this category
                \ & execute if run, compile if compiling
                \ c: size  ---  | create a category of words
  <BUILDS  A081 ,  CURRENT @ @ ,   IMMEDIATE
  HERE  VOC-LINK @ ,  VOC-LINK !   C, \ size
  LATEST PFA  2+  DUP CONTEXT !  CURRENT !
  [ HERE CELL+  CELL MINUS CSP +! ]  DOES>  2+  DUP >R
        \ locate the sought word name
  @  BL WORD  HERE COUNT UPPER  HERE SWAP (FIND)
        \ execute it or compile it
  IF  STATE @ <  IF CFA ,  ELSE CFA EXECUTE  THEN  R> DROP
        \ if we don't find it, numeric conversion according
  ELSE  HERE NUMBER  R> CELL+ CELL+ C@ 2/ 2/ 0=  \ size to flag
    IF  IF ABORT"  Number out of range!" THEN  [COMPILE] LITERAL
      ELSE [COMPILE] DLITERAL  THEN  THEN ;
\ data size handlers: 8086                ( 12  9 90 crc 14:34 )
: SEAL    \ nfa  --   | seal a category & isolate it
  [COMPILE] FORTH DEFINITIONS              \ quit vocabulary
  VOC-LINK @  CELL+ CELL+ 1+ PFA LFA  OFF  \ seal it
  VOC-LINK @ @ VOC-LINK !  ;               \ withdraw from vocs

: SIZEOF        \   ---  n  |  size of a category
  [COMPILE] '  DUP CFA @  LITERAL [ CELL CSP +! ]
  - IF  HERE COUNT TYPE  ABORT"  is not a Category!"  THEN
  CELL+ CELL+ CELL+  C@  ;






\ category long for 8086                  ( 13  8 90 crc 15:55 )
4 CATEGORY LONG
CODE @          ' 2@            CFA @  LATEST PFA CFA !
CODE !          ' 2!            CFA @  LATEST PFA CFA !
CODE DROP       ' 2DROP         CFA @  LATEST PFA CFA !
CODE DUP        ' 2DUP          CFA @  LATEST PFA CFA !
CODE SWAP       ' 2SWAP         CFA @  LATEST PFA CFA !
CODE +          ' D+            CFA @  LATEST PFA CFA !

: .  0 D.R ;

: CONSTANT   <BUILDS  SWAP  , ,  DOES>  2@ ;
: VARIABLE   <BUILDS  SWAP  , ,  DOES> ;



\ category long for 8086                  (  8  8 90 crc 14:31 )








\ ad libitam
SEAL
BASE @ HEX
: TESTLONG   LONG 1234567  LONG DUP LONG .  LONG DROP ;
BASE !


\ category short for 8086                 (  8  8 90 crc 14:59 )
2 CATEGORY SHORT
CODE @          ' @             CFA @  LATEST PFA CFA !
CODE !          ' !             CFA @  LATEST PFA CFA !
CODE DROP       ' DROP          CFA @  LATEST PFA CFA !
CODE DUP        ' DUP           CFA @  LATEST PFA CFA !
CODE SWAP       ' SWAP          CFA @  LATEST PFA CFA !
CODE +          ' +             CFA @  LATEST PFA CFA !

: .     .  ;

: CONSTANT   <BUILDS  ,  DOES>  @ ;
: VARIABLE   <BUILDS  ,  DOES> ;



\ category short for 8086                 (  8  8 90 crc 14:59 )








\ ad libitam
SEAL
BASE @ HEX
: TESTSHORT   SHORT 1234  SHORT DUP  SHORT .  SHORT DROP ;
BASE !


















\ dliteral for 8086                       ( 10 12 90 crc 10:15 )
CREF  DEBUG  FORTH DEFINITIONS FORGET TASK
FORTH DEFINITIONS : TASK ;  BASE @ >R HEX
CODE DLIT       \   --  d  | put double literal on the stack
  AX LODS,  AX PUSH,  AX LODS,  1PUSH

: DLITERAL      \  d -- d? | compile into inline literal
  STATE @ IF  -DUP IF  [ ' DLIT CFA ] LITERAL  ,  SWAP , ,
  ELSE  [COMPILE] LITERAL  COMPILE 0  THEN  THEN ; IMMEDIATE

: FOO   [ 1234.5678 ] DLITERAL 2DROP [ 1234. ]  DLITERAL 2DROP ;

: BAR   [ 1234.5678 ] DLITERAL D.    [ 1234. ]  DLITERAL D.    ;

R> BASE !  EDITOR FLUSH   PRESENT      HERE FIRST OVER - ERASE

















\ 0 checks                                (  4 10 90 crc 13:43 )
FORTH DEFINITIONS  DEBUG  FORGET TASK
FORTH DEFINITIONS  : TASK ;  BASE @ >R DECIMAL
CODE 0CHECK  \ addr ct --  fl | true if 0 encounterd
  CX POP,  DX POP,  DX SI XCHG,  BX BX XOR,
  DO,  AL LODS,  AL AL OR,
      0= IF,  1 # BX MOV,  BX CX MOV,  THEN,   LOOP,
  BX PUSH,  DX SI MOV,  NEXT

: CHECKBLKS     \ start end  --  | checksum a range of blocks
  ?CR  DO  HERE DUP  I 1 (R/W)  DUP @ IF  B/BUF  0CHECK
    IF  I 5 .R  THEN  ELSE  DROP  THEN  ?STACK LOOP ;

: CHECKDISK  MAXBLK 1+ 0  CHECKBLKS ;   \ check all blocks
R> BASE !  EDITOR FLUSH   HERE FIRST OVER - ERASE  ;S
check non-binary blocks for spurious zeros in them.
\ write hex calendar file                 ( 10  9 90 crc  8:56 )
filing debug  printer left @  0 lefts   editor flush
filing mkf: calend91.txt

outfile
base @  1 91 12  hex  months  base !
closeoutfile

printer lefts   editor flush







\ dataswap                                ( 21  8 90 crc  9:15 )
FORTH DEFINITIONS  FORGET TASK
FORTH DEFINITIONS  : TASK ;  BASE @ >R DECIMAL
CODE DSWAP  \  addr1 addr2 ct ---   | swap data for ct bytes
  CX POP,  DI POP,  DX POP,  DX IP XCHG,  BX BX SUB,
  DO,  0 [BX+DI] AL MOV,  0 [BX+SI] AH MOV,
    AH 0 [BX+DI] MOV,  AL 0 [BX+SI] MOV,  BX INC,  LOOP,
  DX IP MOV,  NEXT

R> BASE !  EDITOR FLUSH ;s
        Use to swap data in memory, as in data base sorts.





\ checksums                               (  6  9 90 crc 16:54 )
FORTH DEFINITIONS  FORGET TASK
FORTH DEFINITIONS  : TASK ;  BASE @ >R DECIMAL
CODE CHECKSUM   \ addr ct --  dcksum  | byte checksum w/ carry
  CX POP,  DI POP,  DI IP XCHG,  AX AX SUB,  AX DX MOV,
  AX BX MOV,  DO,  AL LODS,  AX DX ADD,  0 # BX ADC,  LOOP,
  DX PUSH,  BX PUSH,  IP DI XCHG,  NEXT

: CHECKBLKS     \ start end  --  | checksum a range of blocks
  0 0  2SWAP  ?CR DO  I 5 .R
    HERE DUP  I 1 (R/W)  B/BUF  CHECKSUM  D+ LOOP ;

: CHECKDISK  MAXBLK 1+ 0  CHECKBLKS ;   \ checksum all blocks
R> BASE !  EDITOR FLUSH   here first over - erase


\ disk cache, n k bytes                   ( 12  9 90 crc 16:12 )
FORTH DEFINITIONS       BASE @ >R DECIMAL
292 NEEDED CMOVEL       102 NEEDED ABORT"

1 +BLK  6 +BLK  HEX THRU

HERE FENCE !    CACHE   7 +BLK LOAD     R> BASE ! ;S

    Uses segments for an n k bytes disk cache. Reads & writes to
files for this version, but that can be changed. The cache table
is in a local variable, chtbl. Each cache entry has one cell,
for the block (if any). The cache is write-through, i.e. blocks
are written to the disk immediately, and then to the cache.
    To change buffer count, change  CHSIZE  & recompile. N.B:
CHSIZE  *must* be a power of 2 for this to work correctly.

\ cache: cache, chtbl, chseg, cuse, chtbl (  4  9 90 crc 11:50 )
VOCABULARY CACHING   IMMEDIATE    CACHING DEFINITIONS

        \ change  CHSIZE  to change buffer count & recompile.
 80 CONSTANT CHSIZE                     \ size of cache in blks
CHSIZE B/BUF 10 */ SEGMENT CACHESEG     \ base segment to use

0 VARIABLE CHTBL  CHSIZE 2* 2- ALLOT    \ the cache table
0 VARIABLE CHUSE

;S      \ debug aid: remove most recent segment from the list
: UNLINK   SEG-LINK @  DUP @ SEG-LINK !
  2+ 2+  @ MINUS  NEXTSEG +! ;



\ cache: entry, empty, scan               ( 19 11 90 crc  9:33 )
CODE ENTRY   \ n --  addr(n) | get address of nth entry in table
  CHTBL #) BX LEA,  AX POP,  AX AX ADD,  BX AX ADD,  1PUSH

: EMPTY   CHTBL  CHSIZE 2*  7F  FILL ;          EMPTY

CODE SCAN   \ blk#  --  addr/0 | 0 if not present, or entry addr
  DX POP,  CHSIZE # CX MOV,  IP PUSH,   DI DI SUB,
  CHTBL #) SI LEA,  DO,  AX LODS,               \ unstructured!!
    AX DX CMP,  0= IF,  SI DI MOV,  2 # DI SUB,  ELSE,  >R >R
    LOOP,  R> R> THEN,  IP POP,  DI PUSH,  NEXT





\ cache: crdf, convert, wtc               ( 30  8 90 crc 11:33 )
CODE CRDF  \  rseg handle ---  fl/ct  | read b/buf into cache
  BX POP,  CS AX MOV,  ' CACHESEG 2+ #) AX ADD,
  DX POP,  DX AX ADD,  AX DS MOV,
  3F # AH MOV,  B/BUF # CX MOV,  DX DX SUB,
  21 INT,  CS PUSH,  DS POP,  U< IF,  AX NEG,  THEN,  1PUSH

: CONVERT       \  addr  --  rseg | get addr for memory move
  CHTBL -  5 2*S ;

: WTC           \ addr tbladdr --  | write to cache memory
  CONVERT  >R  CS@ SWAP   CACHESEG R>  +  0  B/BUF  CMOVEL ;




\ cache: rfc, seek, (read)                ( 30  8 90 crc 11:42 )
: RFC           \ addr tbladdr --  | read from cache memory
  CONVERT  >R  CS@ SWAP   CACHESEG R>  +  0  2SWAP
  B/BUF  CMOVEL ;

: SEEK          \ blk# handle --  | seek in file
  >R  B/BUF  U*  R>  0  LSEEK
  0< IF ABORT"  File Seek Error" THEN  DROP ;

: (READ)        \ rseg blk --   | read from blk to offset
  RHANDLE SEEK  RHANDLE CRDF
  B/BUF - IF  ABORT"  File read error!"  THEN ;




\ cache: cbuffer, read, write             (  4  9 90 crc 15:16 )
: CBUFFER       \ blk#  --  buf# | a buffer
  CHUSE @  DUP 1+  [ CHSIZE 1- ] LITERAL AND  CHUSE !
  ENTRY  >R  R !  R> ;

: READ          \ addr blk#  ---  | get a block via cache
  DUP SCAN  DUP 0= IF  DROP  DUP  CBUFFER
     2DUP  CONVERT  SWAP (READ)  THEN  NIP  RFC  ;

: WRITE         \ addr blk#  ---  | send a block to disk & cache
  2DUP 0 [ 'R/W @ , ]  \ write through cache
  DUP SCAN  DUP 0= IF  DROP  DUP  CBUFFER  THEN  NIP  WTC ;




\ cache: (cr/w), olddisk, cache           ( 30  8 90 crc 11:36 )
: (CR/W)        \ addr blk# fl --   | fl: 0, write
  RHANDLE 0= BADFILE  IF  READ  ELSE  WRITE  THEN ;

FORTH  DEFINITIONS

\ : OLDDISK   EDITOR FLUSH   [ ' (R/W)  CFA ] LITERAL 'R/W ! ;

: CACHE     CACHING EMPTY  [ ' (CR/W) CFA ] LITERAL 'R/W ! ;







\ setbufs: set buffers to 3               ( 14  8 90 crc  9:47 )
FORTH DEFINITIONS
: SETBUFS       \ n --  | set system to have n disk buffers
  FLUSH  EMPTY-BUFFERS  LIMIT SWAP  B/BUF 4 + *  -  'FIRST !
  EMPTY-BUFFERS ;

3 DUP  SETBUFS     FORGET SETBUFS
. ." disk buffers set." cr








\ cache: cpresent                         ( 12  7 95 crc  5:55 )
BASE @ HEX      FORTH DEFINITIONS   \   FORGET TASK

: CPRESENT   BASE @  DECIMAL    PRESENT
  CACHING  CHSIZE 6 U.R
  CACHING  ?CR  CHSIZE 0  DO  I  CHUSE @ +
        [ CHSIZE 1- ] LITERAL AND  ENTRY @  7FFF AND
        DUP MAXBLK < IF  6 .R  COL  ELSE  DROP  THEN  LOOP
  ?CR  BASE ! ;

BASE !  FORTH DEFINITIONS       CPRESENT
\ : TASK ;




















































\ get current language, dos 3.x & up      ( 14 11 90 crc  9:31 )
  DEBUG  FILING   FORTH DEFINITIONS    FORGET TASK
: TASK ;     BASE @ >R    HEX      HERE  FIRST OVER - ERASE

CODE GETCOUNTRY   \  -- fl/cc | get country data to pad
  UP #) BX MOV,  OFUSER DP DX MOV,  PAD HERE - # DX ADD,
  3800 # AX MOV,  21 INT,    U< IF,  CBW,  AX NEG,  AX PUSH,
  ELSE,  BX PUSH,  THEN,  NEXT

1 +BLK  5 +BLK THRU
COUNTRY DECIMAL  R> BASE !  EDITOR FLUSH     ;S
code setcountry  \ cc --   | set the country code
  ax pop,  ff # ah test, 0<> if,  ax bx mov,  38ff # ax mov,
  else,  38 # ah mov,  then,  cx cx xor,  -1 # dx mov,  21 int,
  nop,  0 # cx adc,  cx push,  next    \ N.B. may not work!

\ get current language, dos 3.x & up      ( 14 11 90 crc  8:40 )
: TYPE>0   BEGIN  DUP C@  -DUP WHILE  EMIT 1+  REPEAT  DROP ;

: PRNTR  <BUILDS  C, ,"
  DOES>  DUP 1+ COUNT TYPE  ASCII : EMIT  SPACE  ASCII " EMIT
  C@ PAD + TYPE>0  ASCII " EMIT ;

 2 PRNTR CURRENCY Currency symbol"
 7 PRNTR KS Thousands separator"
 9 PRNTR DC Decimal separator"
0B PRNTR DT Date separator"
0D PRNTR TIME Time separator"
16 PRNTR DATA Data separator"



\ get current language, dos 3.x & up      ( 30  6 92 CRC 21:37 )
: TIMEF   ." Time format: "
  PAD 11 + C@   DUP IF  1 = IF ." 24 hour"  ELSE
     ." Time Error!!" ABORT  THEN
  ELSE  DROP  ." 12 hour " THEN ;

: MAP   PAD 12 +  ." Case Mapping Address: Segment: "
  DUP 2+ @ .  ." Offset: "  @ . ;

CODE ?VER   30 # AH MOV,  21 INT,  DX DX XOR,
  AH DL MOV,  CBW,  2PUSH

: VER  ?VER ." Mess-DOS Version " 1 .R ASCII . EMIT  . ;



\ get current language, dos 3.x & up      ( 14 11 90 crc  9:23 )
: CAL  <BUILDS  C,  DOES> C@ DUP EMIT EMIT ;
ASCII m CAL MM                  ASCII d CAL DD
ASCII y CAL YY

: DSEP    0B PAD + C@ EMIT ;

: DATE0  ." US: "       MM DSEP DD DSEP YY ;
: DATE1  ." European: " DD DSEP MM DSEP YY ;
: DATE2  ." Nihonjin: " YY DSEP MM DSEP DD ;
: DATE3  ." Oops!" ;

: DATEF  PAD C@  3 AND
  ." Date format is "  EXEC  DATE0 DATE1 DATE2 DATE3  STOP


\ get current language, dos 3.x & up      ( 14 11 90 crc  9:04 )
: CUR0  ." precedes value with no space." ;
: CUR1  ." follows value with no space." ;
: CUR2  ." precedes value with one space." ;
: CUR3  ." follows value with one space." ;

: CURS   0F PAD + C@  3 AND
  ." Currency symbol "   EXEC CUR0 CUR1 CUR2 CUR3  STOP

: PLACES   PAD 10 + C@ ." Decimal places in currency: " . ;






\ get current language, dos 3.x & up      ( 15 11 90 crc 11:25 )
: COUNTRY    DECIMAL  CR  VER
  CR ." Country information for country "
  GETCOUNTRY .
  CR  CURRENCY  SPACE  PLACES
  CR  KS SPACE  DC  CR CURS
  CR CR DATEF  SPACE  DT
  CR TIMEF SPACE TIME
  CR CR HEX  MAP  DECIMAL
  CR DATA  ;






\ get current language, dos 3.x & up      ( 14 11 90 crc  9:04 )
FILING  -6 +BLK NEEDED COUNTRY      FORTH DEFINITIONS
: MAKEFNAME    0 <#  ASCII y HOLD  ASCII t HOLD  ASCII c HOLD
  ASCII . HOLD  # # # #>  2DUP TYPE  OVER + OFF  ;

: CREATEF   GETCOUNTRY  MAKEFNAME  FILING
  HANDLE IF ABORT" File Open " ELSE  (CRF)
  DUP 10 .R DUP 0< 0= IF ' HANDLE ! THEN THEN ;

CR CR CREATEF  OUTFILE  CR COUNTRY CR CLOSEOUTFILE






















\ Absolute disk read Dos 4.0 or above     ( 25  1 91 crc 10:49 )
FILING  DEBUG    FORTH DEFINITIONS        FORGET TASK
  FORTH DEFINITIONS ( : TASK ; )  PRESENT
BASE @ >R HEX                     EDITOR FLUSH
CODE (ADR) \  addr lba dsk --- fl || er fl | absolute disk read
  AX POP,  DX POP,  BX POP,  1 # CX MOV,
  IP PUSH,  BP PUSH,  25 INT,
  CX POP,  BP POP,  IP POP,
  U< IF,  0 # AH MOV,  AX PUSH, \ free -dup
     ELSE,  AX AX SUB,  THEN,  1PUSH

-->  errors:
80 -- failure to respond        40 -- seek failed
20 -- controller failed         10 -- CRC failed
 8 -- DMA failure (??)           4 -- sector not found
 2 -- bad address mark           1 -- bad command (?)
\ Absolute disk write                     ( 25  1 91 crc 10:49 )
CODE (ADW) \  addr blk dsk --- fl || er fl | absolute disk write
  AX POP,  DX POP,  BX POP,  1 # CX MOV,
  IP PUSH,  BP PUSH,  26 INT,
  CX POP,  BP POP,  IP POP,
  U< IF,  0 # AH MOV,  AX PUSH, \ free -dup
     ELSE,  AX AX SUB,  THEN,  1PUSH

FILING CURDRV CONSTANT DSK
: SETDISK:   [COMPILE] CTL 1- ' DSK ! ;

: ADR \  addr lba --- fl || er fl | absolute disk read
  DSK (ADR)  IF HEX .S ABORT"  Disk Read Error"  THEN ;
: ADW \  addr lba --- fl || er fl | absolute disk read
  DSK (ADW)  IF HEX .S ABORT"  Disk Write Error"  THEN ;
HERE FIRST OVER - ERASE  -->
\ (ar/w)                                  ( 25  1 91 crc 10:49 )
: ABR \  addr blk ---  | absolute block read
  2*  2DUP  ADR  200 1 D+  ADR ;

: ABW \  addr blk ---  | absolute block read
  2*  2DUP  ADW  200 1 D+  ADW ;

: (AR/W)  \ addr blk fl ---  | absolute read/write to disk
  IF  ABR  ELSE  ABW  THEN ;
DECIMAL
: AR/W   [ ' (AR/W) CFA ] LITERAL  'R/W !   719 ' MAXBLK ! ;

: OR/W   [ 'R/W @       ] LITERAL  'R/W !
  [ MAXBLK ] LITERAL  ' MAXBLK ! ;

R> BASE !  FORTH DEFINITIONS    : TASK ;  EDITOR FLUSH
\ slurping                                ( 21  5 90 crc 11:20 )
-3 BLK @ + NEEDED (AR/W)
FORGET TASK     FORTH DEFINITIONS
: (F->DR/W)  \ addr blk fl ---  | absolute write - file read
  DUP IF  (R/W)  ELSE  (AR/W)  THEN ;

: F->D   [ ' (F->DR/W) CFA ] LITERAL  'R/W ! ;

: (D->FR/W)  \ addr blk fl ---  | absolute read - file write
  DUP IF  (AR/W)  ELSE  (R/W)  THEN ;

: D->F   [ ' (D->FR/W) CFA ] LITERAL  'R/W ! ;

: TASK  ;


\ dump the bios hd table                  ( 14  6 95 crc 18:05 )
  DEBUG ( FILING)  FORTH DEFINITIONS    FORGET TASK
: TASK ;     BASE @ >R    HEX      HERE  FIRST OVER - ERASE

E401 CONSTANT TBL               10 CONSTANT SIZE
E6E1 TBL - SIZE / CONSTANT TBLSZ

: .SELF      \  --  | create a word which prints its name
  <BUILDS DOES> NFA .NAME 3 SPACES ; \ the ultimate in self-doc!

.SELF CYLINDERS                 .SELF HEADS
.SELF SECTORS                   .SELF LANDING

: HEADDER  CR CYLINDERS  HEADS  SECTORS  LANDING ;
-->

\ dump the bios hd table                  ( 14  6 95 crc 17:59 )
: ANENTRY       \ a --- a' | print an entry in the bios table
  CR
  DUP T@  9 .R          \ cylinders
  DUP 2+ T@  9 .R       \ heads
  DUP 0E + T@ 0B .R     \ sectors
  DUP 0C + T@ 0B .R     \ landing zone
  SIZE + ;

: TABLE         \  ---  | print the entire table
  SEG @  F000 SETSEG  HEADDER
\ TBL     3 0  DO  ANENTRY  ?TERMINAL IF LEAVE THEN  LOOP
  TBL TBLSZ 0  DO  ANENTRY  ?TERMINAL IF LEAVE THEN  LOOP
  DROP  SEG ! ;
R> BASE !  EDITOR FLUSH

\ get screens in from serial port         (  4 11 95 crc 10:36 )
forget task forth definitions   : task ;
: local ' (tkey) cfa 'key ! ;
: remote ' xkey cfa 'key ! ;

: listen  0 do  xkey emit  loop ;

: read  0 do  xkey dup emit over c!  1+  loop  drop ;

: get   scr @ block b/buf  read  update ;
editor flush





\ api call                                ( 29  1 91 crc 16:10 )
  DEBUG ( FILING)  FORTH DEFINITIONS    FORGET TASK
: TASK ;     BASE @ >R    HEX      HERE  FIRST OVER - ERASE
CODE FOO
  1680 # AX MOV,  2F INT,  AH AH XOR,  1PUSH





R> BASE !  EDITOR FLUSH





\ get dma values                          ( 14  2 91 crc 16:09 )
( DEBUG ( FILING)  FORTH DEFINITIONS    FORGET TASK
: TASK ;     BASE @ >R    HEX      HERE  FIRST OVER - ERASE
CODE DMA@       \ addr --  val  | get 2 bytes at io addr
  DX POP,  PUSHF,  CLI,
  DX AL IN,  AL AH MOV,  DX INC,  DX AL IN,
  POPF,  1PUSH

: DMA?  DMA@ 5 U.R ;

: CHIP  \ delta addr --   print ut status of a chip
  8 0 DO  DUP DMA?  OVER + LOOP
  2 0 DO  DUP PC@ 3 U.R  OVER +  LOOP  2DROP ;

: CHIPS   HEX CR  1 0 CHIP  CR 2 C0 CHIP ;
R> BASE !  EDITOR FLUSH
\ begin file shipping                     ( 24 11 95 crc 10:01 )
FILING DECIMAL 198 NEEDED XEMIT         FORGET TASK
: TASK ;                                SETUP
: >HOST   [ ' XEMIT CFA ] LITERAL 'EMIT ! ;
: >LOCAL  [ 'EMIT @     ] LITERAL 'EMIT ! ;
0 VARIABLE LEN 0 ,
BASE @ HEX       80 CONSTANT BUFSIZE    BASE !
: AWAIT \ c ---  | await processing on other end
  XKEY  2DUP  -  IF  OK HEX . . FILING CLF
    ABORT" serial failure! "  ELSE  2DROP  THEN ;
1 +BLK  4 +BLK THRU             PURGE

EDITOR FLUSH



\ file shipping                           ( 19 10 94 crc 22:31 )
CODE D+!        \ n addr --- | 16 bit add to 32 bit location
  W POP, CX POP,  AX POP,  AX 0 [W] ADD,
  CX 2 [W] ADC,  NEXT

0 VARIABLE FILEBUF BUFsize 2- ALLOT
0 VARIABLE CHECKSUM 0 ,

: SEND FILEBUF SWAP 2DUP TYPE   \ ct --- | ship 'em out
  -DUP IF BOUNDS  DO I C@ 0 CHECKSUM D+!  LOOP ELSE DROP THEN ;
\ >local  checksum 2@ 5 d.r space  >host ;

: PASS          \ --- ct | read & ship a buffer's worth.
  FILEBUF BUFsize FILING HANDLE RDF  DUP  SEND  ascii A await ;

: SHOWOFF  >LOCAL XY@ >R >R  18 D.R  R> R>  GOTOXY  >HOST ;
\ file shipping                           (  6 10 94 crc 12:04 )
: (SHIP)        \ ---  | ship an entire file
  CHECKSUM 4 ERASE  PURGE  >HOST
  BEGIN  LEN 2@  SHOWOFF  BUFsize MINUS S->D LEN D+!
         PASS  BUFsize - UNTIL  FILING CLF ;

: XTYPE>0   BEGIN  DUP C@  -DUP WHILE  XEMIT 1+  REPEAT  DROP ;

: SENDONE:
  FILING OPF:  FILE XTYPE>0  CTL M XEMIT  .FILENAME
  ASCII A AWAIT  (SHIP)  ;





\ file shipping                           (  7  1 96 crc 14:01 )
HEX
: SENDENTRY     FILING  >HOST
  BASE @  HEX  ASCII A XEMIT             ASCII L AWAIT \ another
  1E +DTA 0D -TRAILING 1- TYPE  CTL M EMIT  ASCII M AWAIT
  1A +DTA 2@  2DUP D.  CTL M EMIT LEN 2!  ASCII N AWAIT \ len
  16 +DTA @   U.  CTL M EMIT             ASCII O AWAIT \ time
  18 +DTA @   U.  CTL M EMIT             ASCII P AWAIT \ date
  15 +DTA c@  U.  CTL M EMIT             ASCII Q AWAIT \ attribs
  XKEY  ASCII S = IF
    >LOCAL  CR  1E +DTA 0D -TRAILING 1- TYPE 2 SPACES   >HOST
    1E +DTA (OPF) DUP 0< 0= IF ' HANDLE !  ASCII O XEMIT
        (SHIP)  CHECKSUM 2@ D.  CTL M EMIT
        ASCII Q AWAIT  >local xy@ 18 spaces gotoxy >host
    ELSE  ASCII A XEMIT  HEX . ABORT" File Opening Error! " THEN
  THEN  BASE !  >LOCAL ;
\ file shipping                           (  6 10 94 crc 12:04 )
: SHIP: \  ---  | send all files
  FILING HANDLE IF  ABORT" File Already Open! " THEN
  'EMIT @ >R  PURGE   >HOST ASCII K XEMIT  >LOCAL
  FILING  FLCT 4 ERASE  BLK @ -DUP IF BLOCK ELSE  TIB @  THEN
  IN @ + C@ IF BL WORD HERE COUNT OVER + 0 SWAP !  ELSE DMY THEN
  SFIRST 0= IF  BEGIN  SENDENTRY  SNEXT UNTIL THEN
  ASCII D XEMIT  R> 'EMIT ! ;

1 +BLK LOADER SHIPPER

: XTEST  [ 1 +BLK ] LITERAL BLOCK XTYPE>0 ;




\ file shipping: routine                  (  4  2 95 crc 10:53 )
editor flush  setup             filing
filing setdir: \crc\bwave\down
ship: nwcspdx*.*                ship: lvractn.*
ship: guntalk*.*
filing setdir: \crc\telix
ship: *.log                     ship: *.slt
ship: telix*.*                  ship: slearn*.*
filing setdir: \crc\bwave
ship: *.bw
ship: *.txt
filing setdir: \crc             ship: inis.zip \ ship: csrc.zip
filing setdir: \c700\source\samples
ship: *.c       ship: *.mak     ship: *.h       ship: *.sts
ship: *.bat
-->
\ file shipping: routine                  (  4 11 95 crc 10:59 )
filing setdir: \c700\source\txtfltrs
ship: *.c       ship: *.mak     ship: *.h       ship: *.sts
ship: *.bat    setdir: \gemul8r3                ship: *.zip
filing setdir: \crc\checking\wamutual           ship: *.*
\ setdir: \msoffice\winword\pmassist       ship: *.doc
filing setdir: \msoffice\winword\template       ship: *.dot
filing setdir: \msoffice\winword\crc            ship: *.*
filing setdir: \msoffice\winword\quotefil       ship: *.*
filing setdir: \crc\fd                          ship: *.*
\      setdir: \        ship: autoexec.bat     ship: config.sys
filing setdir: \crc\bwave\down                  ship: *.zip
setdir: \fxwkspro                       ship: fx_phbk*.*
setdir: \fxwkspro\receive               ship: *.*
setdir: \fxwkspro\keeps                 ship: *.*
filing setdir: \crc\rf                          ship: *.*
















































































































































\ terminal emulator: 8250 control         (  6 12 95 crc 14:17 )
debug FORGET TASK  BASE @ DECIMAL   106 NEEDED MODULE
292 NEEDED PC@            390 loader setserial          hex
380 CONSTANT ACE                ACE     CONSTANT DATA
ACE 2+  CONSTANT IIR            ACE 3+  CONSTANT LCR
ACE 4 + CONSTANT MCR            ACE 5 + CONSTANT LSR
ACE 6 + CONSTANT MSR
CODE SETBAUD   \ n --  | set baud register to n
  LCR # DX MOV,  DX AL IN,  AL BL MOV,  80 # AL OR,  DX AL OUT,
  AX POP,  DX PUSH,  ACE # DX MOV,  DX Al OUT,  ah al mov,
  1 # dx add,  dx al out,  DX POP,  BL AL MOV,  DX AL OUT,  NEXT

: SHOWSTAT  CR ."   baud  data  ier  iir  lcr  mcr  lsr  msr"
  CR LCR PC@  DUP  80 OR  LCR PC!  ACE P@ 6 .R  LCR PC!
  SPACE  ACE 7 BOUNDS DO I PC@ 5 .R LOOP ;
  BLK @ 1+ dup 1+ thru      : TASK ; ( decimal 207 load) BASE !
\ terminal emulator: 8250 control         (  6 10 94 crc 10:37 )
CODE XEMIT \ c --- | send to host
  MSR # DX MOV,  10 # ( cts bit? ) AH MOV,
  BEGIN,  DX AL IN,  AH AL AND,  0<> UNTIL,
  LSR # DX MOV,  20 # ( THRE bit ) AH MOV,
  BEGIN,  DX AL IN,  AH AL AND,  0<> UNTIL,
  AX POP,  DATA # DX MOV,  DX AL OUT,  NEXT

CODE X?KEY \ --- f | is there a char from the host?
  LSR # DX MOV,  DX AL IN,  1 # AX AND,  1PUSH
CODE XKEY  \ --- c | get char from host
  LSR # DX MOV,  1 # ( DR bit ) AH MOV,
  BEGIN,  DX AL IN,  AH AL AND,  0<> UNTIL,
  DATA # DX MOV,  DX AL IN,  AH AH SUB,  1PUSH

: PURGE  BEGIN  X?KEY  WHILE  XKEY EMIT  REPEAT  ;  \   PURGE
\ terminal emulator: 8250 useage          (  6 12 95 crc 14:17 )
               \ 19200 baud
: SETUP   LIT [ 06 , ] SETBAUD  3 ( 8 bits, no parity) LCR PC!
( mcr pc@ 2 or  mcr pc!  ( RTS negated ) showstat ; \ SETUP
' SETUP 2+ CONSTANT RAWBAUD
: XBREAK  \  --  | send a break
  LCR PC@  DUP 40 OR  LCR PC!  DUP DROP  LCR PC! ;

: LOOPBACK   MCR PC@  10 OR   MCR PC! ;  \ run in local mode

: LOOPFRONT  MCR PC@  EF AND  MCR PC! ;  \ talk to outside world

: TEST  LOOPBACK  SHOWSTAT CR
  BEGIN KEY  DUP LI - WHILE XEMIT XKEY EMIT REPEAT DROP
  LOOPFRONT ;
SHOWSTAT    CR
\ 82510 specific goodies                  (  6 12 95 crc 14:44 )
DEBUG   forth definitions       base @ decimal
540 needed ace                  FORGET TASK     base !
: TASK ;                        HERE FIRST OVER - ERASE
decimal         55 needed sec   hex
1d variable ipmaddress
7 ace + constant adr7

BLK @ 1+  DUP 6 +  HEX  THRU    hex

EDITOR FLUSH





\ 82510 specific goodies                  (  7 12 95 crc  7:24 )
ACE 2+  CONSTANT bank
: ->bank        \ n ---  | set the 82510 to the given bank
  5 2*s bank pc! ;

: reg           \ c: offset, bank  ---   |
                \ r:  by  ---  | put by into reg at bank
  <builds c,  ace + ,
  does>  dup c@  ->bank  1+ @  pc! ;

\               register          bank
3 2 reg tmd     4 2 reg imd     7 1 reg icm     1 0 reg ger
4 0 reg mcr     1 1 reg txf     0 0 reg txd     3 3 reg bbcf
7 2 reg rmd     3 0 reg lcr     1 2 reg fmd

: reset  10 icm   0 ->bank ;
\ 82510 specific goodies                  (  7 12 95 crc 12:02 )
: setfifo       \ fifo: 1 byte trigger.
  0c imd  0 fmd ;

: set485        \ --- | 82510 specific setup for rs-485
  reset   purge  LIT [ 0c , ] SETBAUD
  setfifo  ( 0 bbcf)  0 ger  2 mcr
  20 tmd  0 lcr  20 txf
  0 ->bank  ace pc@  5 ace + pc@  2drop  showstat ; set485 cr

CODE ><  AX POP,  AH AL XCHG,  1PUSH
;s




\ 82510 specific goodies                  ( 13 12 95 crc  9:49 )
: exmit 2 mcr ;                 exmit

: awaitxmit  1 ->bank  begin  adr7 pc@  10 and  until ;

: dxmit         \ wait for last char to go, then shut down xmit
  awaitxmit  0 mcr ;

: xemit         \ c --- | send a character.
  awaitxmit  txd ;

: xmitaddr      \ send address w/ 9th bit set.
  0 lcr  20 tmd                 \ run 9 bit mode
  20 txf                        \ 9th bit set
  ipmaddress @ xemit  0 txf ;   \ 9th bit reset

\ 82510 specific goodies                  (  7 12 95 crc 16:07 )
\ exmit xmitaddr
: t  exmit  begin xmitaddr  ?key until  key drop ;

: s 100 0 do i ipmaddress !  xmitaddr loop ;

: u begin  dup xemit  ?key until key 2drop ;

: v  20 0 do  i xemit  key drop  loop ;

: w  1  8 0 do  dup xemit  dup . 2* key drop  loop  drop ;

: x  8 0 do 1 i 2*s  u  loop ;

: y  begin xmitaddr ?key until  key drop ;

\ build dummy messages to insert into pack( 13 12 95 crc 11:08 )
: dummy   <builds  dup ,  0 do c,  loop
  does>  dup @ >r  2+  here  r cmove  r> allot ;

 0  0  0 30  4 dummy sysimgreq
 0  0  1 30  4 dummy cibimgreq
 0  0  2 30  4 dummy getvars
 0  0  6 30  4 dummy gettextatts








\ build dummy packet                      ( 13 12 95 crc 11:43 )
: checksum   ipmaddress @  -rot  do  i c@ +  loop ;

0 variable mssgbuf -2 allot     \ everything except the dest.
0 c,            \ src address (us)
82 c,           \ message id dummy
sysimgreq       \ dummy data
10 c, 3 c,      \ dle etx end of message
here mssgbuf
checksum >< ,   \ checksum build & add to message

here mssgbuf - constant mssglen mssgbuf mssglen dump

: send  hex exmit xmitaddr   ."  space for each char "  cr
  mssglen 0 do   key li = if leave else
  i mssgbuf + c@ dup . xemit  then  loop  0 ->bank ;
\ fast send message                       ( 14 12 95 crc 11:22 )
: fsend  hex exmit xmitaddr
  mssglen 0 do
  i mssgbuf + c@ dup . xemit loop  0 ->bank ;












\ receive message                         ( 14 12 95 crc  9:39 )
;s The *@#! board doesn't seem willing to receive, so I never
went any further than this. Gnrrrrrr.....
0 variable dle                  0 variable etx

: awaitxkey     0 ->bank
  begin  (?terminal) if abort then  x?key until ;

: receive       dle off  etx off  0 ->bank  begin
  awaitxkey  data pc@  dup .
     ctl c = until
  ." checksum: "  awaitxkey  data pc@ .
  awaitxkey  data pc@ . ;



















































































































\ block comparer                          ( 14 12 95 crc 18:46 )
: cpb           \ bk1 bk2 --- fl  | compare two blocks
  block  b/buf rot  block  editor -cstext ;

: cpbs          \ tst strt end ---  | cmp tst across range
  do  dup i cpb  0= if  i 5 .r  then  loop  drop ;

: cpbf          \ strt ---  | compare across entire file
  maxblk swap  do  cr i 4 .r  ascii : emit  i maxblk 1+  i 1+
  cpbs  ?terminal if leave then  loop ;

: nums          \  ---  | put screen #s into blank scrs
  pad b/buf blanks  pad off  cr
  maxblk 1+  0 do  i block  b/buf  pad  editor -cstext  forth
  0= if  i dup block c/l + !  update  i 5 .r  then  loop ;
editor flush
\ block adding code.                      ( 14 12 95 crc 18:07 )
: bk   buffer dup b/buf blanks off update ;

: bks  do i dup 5 .r  bk  ?terminal if leave then  loop ;

editor flush










\ Zapfile: overwrite a file               ( 13  5 97 crc 11:58 )
filing                          forget task
forth definitions               : task ;
0 variable length               0 variable tail
base @  hex
: shipit        \ ct --  | ship count bytes to current file
  -dup if
  filing here over handle twtf          \ write it.
  - if  abort" Write error!!"  then then ;

-->
hex 155 was chosen to get the maximum flux reversals on the
initial writes, followed by all zeros later on.



\ Zapfile: overwrite a file               ( 13  5 97 crc 13:35 )
: zapfile:      \ --- | erase the contents of a file
  in @  filing opf:             \ get the handle
  0 0 handle 2 lseek            \ get file length
  b/buf u/  length !  tail !    \ store counts.
  155  9 0 do                   \ 8 loops, one for each bit
  2/                            \ march that bit!!
  here over  b/buf swap  fill   \ set up a block of data
  0 0 handle 0 lseek  or if abort" Lseek error!! "  then
  length @ -dup if  0 do  b/buf  shipit
      loop  then
  tail @ shipit
  synch  loop  drop     clf     \ force os to write to disk
  in !  rm:                     \ delete it
  synch ;
base !                          editor flush
















\ cpz download                            ( 12  5 88 crc  9:10 )
DECIMAL 201 NEEDED DOREQUEST  FORGET TASK   FORTH DEFINITIONS
: (BYTE)  ( b -- addr ct ) 0 <# BL HOLD # # #> ;   HEX
: BYTE    ( B -- )  (BYTE)  SLTYPE  PURGE ;
HERE FIRST OVER - ERASE
0 VARIABLE FLN -2 ALLOT ," RFS.COM "  0 HERE 1- C!
: OPENIT   FLN 1+  FILING (OPF)  DUP 0< 0= IF ' HANDLE ! THEN ;
: FC@   FILING  DUP  SP@ 1 HANDLE RDF ;
: BYTES   OPENIT  BEGIN FC@  WHILE BYTE REPEAT
  DROP  FILING CLF ;
: DOWNLOAD  SLURP CTL M XEMIT PURGE  BASE @ >R HEX  SPEED @ >R
  12 SPEED ! ASCII E XEMIT PURGE  S." 40:100"  CTL M XEMIT
  PURGE  R SPEED !  BYTES  10 SPEED ! SLURP CTL M XEMIT
  100 MS FN4  CTL M XEMIT 1000 MS SLURP FN1  CTL M XEMIT
  R> SPEED !  R> BASE !  (TERM) ;
: TASK ;  EDITOR FLUSH  DECIMAL  ?CR ?DICT  USING: CM.SCR
















































































\ begin line editor                       ( 17  7 92 crc 19:40 )
FORTH DEFINITIONS    (  DEBUG     )     FORGET TASK
FORTH DEFINITIONS    (  : TASK ;  )     BASE @ DECIMAL
: BELL  CTL G EMIT ;

' (EXPECT) CFA 'EXPECT !

CODE RDROP  ' R> 3 + LATEST PFA CFA !

VOCABULARY EXPECTING IMMEDIATE  EXPECTING DEFINITIONS

  1 +BLK 10 +BLK THRU           HERE FIRST OVER - ERASE

  ' LNED CFA 'EXPECT !          PLACEF ON
  HERE FENCE  !   BASE  !       : TASK ;        EDITOR FLUSH
\ : TT  PAD c/l  2DUP ERASE  2DUP LNED  HEX DUMP ;
\ line editor: variables, constants       ( 25 11 91 CRC 13:44 )
0 VARIABLE CURS                 \ line cursor
0 VARIABLE BUF                  \ holding buffer
0 VARIABLE SIZE                 \ size of line already in buffer
0 VARIABLE PLACEF               \ are we inserting or replacing?
0 VARIABLE NXTLN                \ pointer to next line to place

16 CONSTANT STRINGS             \ number of back strings saved

0 VARIABLE STRARRAY STRINGS 2* 2- ALLOT \ pointer array

' QUERY 6 + C@ CONSTANT STRSIZE \ *very* implementation specifi

: LEFT   XY@ 1- GOTOXY ;

: RIGHT  XY@ 1+ GOTOXY ;
\ line editor: makstrs, up dn history     ( 25 11 91 CRC 13:47 )
HEX  STRSIZE 11 +  FFF0 AND  STRINGS *  4 2/S  SEGMENT HSEG
HSEG VARIABLE HISTSEG

: MAKESTRS      \ construct the string buffer at compile time.
  HSEG HISTSEG !  STRINGS 0  DO  HISTSEG @ STRARRAY I 2* +  !
    0  HISTSEG @  0  !L
    STRSIZE  11 +  4 2/S  HISTSEG +!  LOOP  STRARRAY NXTLN ! ;
MAKESTRS

: UP    2 NXTLN +!  NXTLN @ STRARRAY - 2/
  STRINGS = IF STRARRAY  NXTLN ! THEN ;

: DN    NXTLN @ STRARRAY       \ down one in the string
  = IF [ STRARRAY STRINGS 2* + ] LITERAL NXTLN ! THEN
  -2 NXTLN +! ;                                 DECIMAL
\ line editor: history access             ( 17  7 92 crc 18:44 )
CODE COUNTL   AX AX XOR,  BX POP,  ES POP,  ES: 0 [BX] AL MOV,
  BX INC,  ES PUSH,  BX PUSH,  AX PUSH, NEXT

: TYPEL  DUP IF  0 DO  2DUP  I +  C@L EMIT  LOOP  2DROP
  ELSE  DROP 2DROP  THEN ;

FORTH DEFINITIONS
: HISTORY  EXPECTING STRINGS 0 DO  DN  NXTLN @ @  0
  COUNTL DUP IF CR  I 4 .R SPACE THEN  TYPEL  LOOP  SPACE ;

: HIST HISTORY ;                EXPECTING DEFINITIONS




\ line editor: redraw,                    ( 25  8 92 crc 16:08 )
: REDRAW        \   ---   | re-display the line from cursor
  ERL  BUF @  CURS @ +  SIZE @  CURS @ -
  -DUP IF  DUP >R  TYPE   SPACE  R> 1+  XY@  ROT -  GOTOXY
       ELSE  SPACE LEFT  DROP  THEN ;

: STORESTR      \ --- | store string in array
  CS@  BUF @  NXTLN @ @  1 SIZE @  CMOVEL
  SIZE @  NXTLN @ @ 0  C!L ;

: GETSTR        \ --- | get string from array
  CTL M EMIT  NXTLN @ @  0 COUNTL SIZE !  CS@ BUF @  SIZE @
  CMOVEL  CURS OFF  REDRAW ;



\ line editor: keystrokes                 ( 16  5 91 CRC  8:21 )
: LEFT          \   ---   | action on left arrow
  CURS @  IF  LEFT  -1 CURS +!  ELSE  BELL  THEN ;

: RIGHT         \   ---   | action on right arrow
  CURS @  SIZE @ -  0< IF  CURS 1+!  RIGHT
         ELSE  BELL  THEN ;
: DEL           \   ---   | delete under cursor
  BUF @  CURS @ +  DUP 1+  SWAP  SIZE @  CURS @ -  CMOVE
  CURS @  SIZE @ -  0< IF  -1 SIZE +!
      ELSE  BELL  THEN  REDRAW ;

: REND          \   ---   | move cursor to right end
  SIZE @  CURS @ - -DUP IF  0 DO  RIGHT  LOOP  THEN ;


\ line editor: keystrokes                 ( 18  1 91 CRC 21:14 )
: BKSP    LEFT  DEL ;

: PUT           \ c ---   | put the char in the buffer
  DUP EMIT  BUF @ CURS @  + C!   SIZE @  CURS @  =
  IF  SIZE 1+!  THEN  CURS 1+! ;

: INSRT         \ c ---   | insert the char in the buffer
  BUF @  CURS @ +  DUP 1+  SIZE @  CURS @ -  <CMOVE
  SIZE 1+!  PUT  REDRAW ;

: PLACE   PLACEF C@ IF  INSRT  ELSE  PUT  THEN ;

: INSERTKEY   PLACEF 1 TOGGLE   BELL ;


\ line editor: lefts rights               (  2  3 19 crc  0:02 )
: lefts         \  ---  | move left until next blank
  begin left   buf @ curs @ + c@ bl =
        curs @ 0=  or until ;

: rights        \  ---  | move right until next blank
  begin right  buf @ curs @ + c@ bl =
        size @  curs @ =  or until ;
























\ line editor: line editor                (  3 12 91 CRC 22:06 )
FORTH DEFINITIONS
: LNED          \ addr ct  --   | expect w/ line editing
  EXPECTING  >R  BUF !  CURS OFF  SIZE OFF   NXTLN @
  BEGIN   KEY   DUP 0= IF   KEY  CASE
        ASCII ? OF      rights          ENDOF   \ f5 rights
        ASCII > OF      lefts           ENDOF   \ f4 lefts
        ASCII A OF      history cr      ENDOF   \ f7
        ASCII R OF      INSERTKEY       ENDOF   \ insert key
        ASCII P OF      DN GETSTR       ENDOF   \ dn arrow
        ASCII M OF      RIGHT           ENDOF   \ r. arrow
[




\ line editor: line editor                (  3 12 91 CRC 22:06 )
]
        ASCII K OF      LEFT            ENDOF   \ l. arrow
        ASCII H OF      GETSTR UP       ENDOF   \ up arrow
        ASCII G OF      REND            ENDOF   \ home key
        ENDCASE   ELSE  DUP CTL M -
    IF  DUP 127 = IF  DEL  ELSE  DUP CTL H = IF  BKSP  ELSE
             DUP PLACE  THEN  THEN  THEN  THEN  ?STACK
    0  BUF @ SIZE @ + C!  CTL M =   SIZE @  R =  OR UNTIL
  RDROP   REND  SIZE @  OUT !  SPACE
  NXTLN !  SIZE @  IF  DN STORESTR  THEN ;





































































\ messdos: bios disk access               (  1  1 88 CRC 16:34 )
forget task         107 needed iftrue
: task ;
-1 constant 3.5"    3.5" 0= constant 5.25"
editor flush    1 +blk 5 +blk thru
;s

disk drivers that use IBM PC BIOS calls to access floppy disks.

This code is aimed at recovering non-standard raw screen floppy
diskettes, usually 3.5". The normal DSDD format was 9 sectors
per track; 10 per also works. Also the normal floppy is 80
cylinders. 82 works on some drives.  HD diskettes are not
supported here.


\ messdos: bios disk access               (  1  1 88 CRC 16:34 )
DECIMAL
3.5" IFTRUE                     \  720 k 3.5" floppies
720 CONSTANT B/DRV              1439 CONSTANT MAXBLK   IFEND

5.25"  IFTRUE                   \  360 k 5.25" floppies
360 CONSTANT B/DRV               719 CONSTANT MAXBLK   IFEND

: DRIVE  B/DRV U* DROP OFFSET ! ;







\ messdos: bios disk access               (  1  1 88 CRC 16:34 )
0 variable DISKTABLE  4 ALLOT      DISKTABLE 6 ERASE
CODE +DISK   AX POP,  DISKTABLE # AX ADD,  1PUSH
DECIMAL
5.25" IFTRUE                  720 CONSTANT SEC/DRV
18 CONSTANT SEC/CYL             9 CONSTANT SEC/SIDE  IFEND
3.5"  IFTRUE                 1440 CONSTANT SEC/DRV
18 CONSTANT SEC/CYL             9 CONSTANT SEC/SIDE  IFEND

: CALC  \ addr s#  ---  | calculate t&s, etc, from blk#.
  SEC/DRV  /MOD  0 +DISK C!   \ drive#
  SEC/CYL  /MOD  3 +DISK C!   \ cylinder
  SEC/SIDE /MOD  1 +DISK C!   \ side
                 2 +DISK C! ; \ sector number
: DERROR   -DUP IF  BASE @ HEX  SWAP .  BASE !  8 ERROR  THEN ;

\ messdos: bios disk access               (  1  1 88 CRC 15:18 )
base @ hex
CODE SR/W       \  1 = read, 0 = write
  AX POP, ( fl )  AX AX OR,   \ count --> al  r/w f --> ah
  0= IF,  ( write ) 301 # AX MOV,  ELSE,  201 # AX MOV,  THEN,
  DISKTABLE #) BX LEA,
  0 [BX] DX MOV,  \ drive --> dl  side --> dh
  2 [BX] CX MOV,  \ track --> ch  sect --> cl
  4 [BX] BX MOV,  ( addr --> bx )   CL INC,  13 INT,
  < IF,  AH AL MOV,  ff # AX AND,   ELSE,   AX AX SUB,  THEN,
  1PUSH
: (dR/W)         \  addr blk# fl ---
  OVER 0 MAXBLK WITHIN 0= 6 ?ERROR   ROT 4 +DISK ! \ addr
  >R  DUP + ( 2* ) DUP  CALC  R  SR/W  DERROR
  200  4 +DISK +!  1+   CALC  R> SR/W  DERROR ;
base !
\ messdos: bios disk access               (  1  1 88 CRC 15:18 )
: fr/w  [ 'r/w  @ ] literal  'r/w ! ;

: dr/w  [ ' (dr/w) cfa ] literal  'r/w ! ;











































































































\ messdos: bios disk access               (  1  1 88 CRC 16:34 )
































































