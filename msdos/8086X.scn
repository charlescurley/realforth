**********************  fig-FORTH  MODEL  **********************
*                                                              *
*                    Through the courtesy of                   *
*                                                              *
*                     FORTH INTEREST GROUP                     *
*                        P. O. BOX 1105                        *
*                    SAN CARLOS, CA. 94070                     *
*                                                              *
*                          RELEASE 1                           *
*                    WITH COMPILER SECURITY                    *
*                                                              *
*                    VARIABLE LENGTH NAMES                     *
*                                                              *
*               Distributed by Charles Curley for              *
*                   Atari ST series computers                  *
*****  Further distribution must include the above notice. *****
     ERROR MESSAGES                         06 12 84 CRC
 Empty Stack
 Dictionary Full
 Has Wrong Addressing Mode
 Isn't Unique
 Branch out of Range
 Disk Range ?
 Full Stack
 Disk Error !!!
Bytes (hex) Dictionary space available.
 CMOS only instruction or addressing mode
Personal Data Base C. Curley    Confidential    28 November 1987
  This can't happen!! msg 12
  This can't happen!! msg 13
     ?? Not in dictionary ??
real-FORTH on Atari ST             (c) 1985-87 by Charles Curley
     ERROR MESSAGES                          7  4 85 CRC
 Compilation Only, Use in definitions
 Execution only
 Conditionals not paired
 Definitions not finished
 In protected dictonary
 Use only when loading
 Off Current Screen
 Declare Vocabulary
  This can't happen!! msg 25
 Centronics Interface Printer Failure!!
  This can't happen!! msg 27
  This can't happen!! msg 28
  This can't happen!! msg 29
  This can't happen!! msg 30
  This can't happen!! msg 31
\ Loader file creation screen             (  3  4 90 CRC 19:59 )
1 +BLK  NEEDED TARGET   EDITOR FLUSH
5.25" IFTRUE
FILING R-W MKF: REAL4TH.5IN
FILING    ORIGIN       DPNEW @ OVER -
B/BUF / 1+ B/BUF *  DUP >R  HANDLE   WTF  R> - 6 .R
CR CLF  LS REAL*.*      IFEND

3.5" IFTRUE
FILING R-W MKF: REAL4TH.3IN
FILING    ORIGIN       DPNEW @ OVER -
B/BUF / 1+ B/BUF *  DUP >R  HANDLE   WTF  R> - 6 .R
CR CLF  LS REAL*.*      IFEND

FORTH DEFINITIONS

( LOAD SCREEN -- serial -- Recompiling    (  1  5 88 CRC 17:15 )
DECIMAL  FILING FORTH DEFINITIONS    \ home
   FORGET TASK
        : MARKER ;              DECIMAL
   1 constant true              0 constant false
   3 +LOAD ( loaders    )        5 +LOAD  ( loud quiet )
   8 +LOAD ( disk size flags )
   TODAY

 EDITOR FLUSH

: OCTAL 8 BASE ! ;

   CR HEX 0F MESSAGE DECIMAL CR  : TASK ;
   HERE 1024 BLANKS \ ."  Disposing... " DISPOSE CTL G EMIT

\ trace file creation screen              ( 15  7 89 CRC 11:48 )
-1 +BLK NEEDED TARGET    PRINTER LEFT @ >R   5 LEFTS

\ CR FILING SETDir: \messdos\rf     dir *.*
  CR FILING  curdrv >r ( *!* ) setdrive: h  SETDir: \  dir *.*

FILING R-W CREATEFILE: TRACE.TXT
CR outfile  CR CR 808x

CR CLOSEOUTFILE  DIR *.*

filing ( *!* ) r> (setdef) drop

R> PRINTER LEFT !
FORTH DEFINITIONS  EDITOR

\ Documenting screen                      ( 13  2 87 CRC 11:51 )
DECIMAL  DOCUMENTING  FORTH SCR @
         0  B/DRV 1-  DOCUMENTING SINCE 26  1 87
NECPAGE  SCR !












\       target compiler: loaders, 132col  ( 24  3 88 CRC 20:20 )
FORTH DEFINITIONS
 53 +BLK LOADER TARGET
 24 +BLK LOADER 8086ASM
  3 +BLK LOADER DOCUMENTED
114 +BLK LOADER 808X            : BOTH TARGET 808X ;
  7 +BLK LOADER FILE
  8 +BLK LOADER RENAMES

: ?CR   OUT @ C/L > IF CR THEN ;

\ : 132COL   ?PRINT IF CR CTL \ EMIT THEN ;

\ : 80COL    ?PRINT IF CR CTL Y EMIT THEN ;

\ : 2CONSTANT  CREATE SWAP  , ,    DOES> 2@ ;
\ 68000 addressing setup                  (  3  4 90 CRC 19:47 )
: ?TARGET  \ addr -- fl | flag to indicate target or resident
       WORKSPACE IMAGETOP WITHIN ;
BASE @ HEX
CODE ><   S [ DR0 MOV,   DR0 DR1 MOV,  8 # DR0 LSL,
  8 # DR1 LSR,  FF # DR1 .W AND,  DR1 DR0 .W OR,
  FFFF #L DR0 AND,  DR0 S [ MOV,  NEXT  ;c
\ : f@ DUP  ?TARGET  IF  W@  ><         ;S  THEN f@ ;
: @  DUP  ?TARGET  IF   @  ><         ;S  THEN @  ;
: !  DUP  ?TARGET  IF  >R  ><  R>  !  ;S  THEN !  ;
\ : F! DUP  ?TARGET  IF  >R  ><  R>  ! ;S  THEN F! ;
: ,  HERE ?TARGET  IF      ><  W,     ;S  THEN ,  ;
: COMPILE    ?COMP  R> DUP 2+ >R  @ , ;   <-- rewrite
: T@  FUDGE @ + @  ;
: TC@ FUDGE @ + C@ ;
: ? @ . ;        BASE !
\ compiling aids                          (  2  6 86 CRC 11:37 )
FORTH DEFINITIONS
\ : LOUD  ASSEMBLER (QUIET) ON  ( 132COL ) ;

\ : QUIET ASSEMBLER (QUIET) OFF ( 80COL )  ;

\ editor atCOLD: FLUSH

: SETBUFS \ n --   | set system to have n buffers
  FLUSH B/BUF 6 + * LIMIT SWAP - 'FIRST !
  EMPTY-BUFFERS FLUSH   #BUFS 4 .R ."  Buffers " ;

  #BUFS 32 = IFTRUE 200 SETBUFS IFEND
\ #BUFS 32 = IFTRUE 100 SETBUFS IFEND


\ Target documentor                       ( 13  9 85 CRC       )
CR ." Cross Compilation of 68000 real-FORTH for Atari."
CR CR TARGET ATARI
?CRT 0= IFTRUE PAGE IFEND        WARNING ON
CR 3 VTAB CR ." Atari " 16 BYTE:IN (ABORT)    COUNT TYPE
CR CR 15 MESSAGE CR CR   ." VLIST  of kernel." CR
TVLIST CR CR
  ?CRT 0= IFTRUE PAGE IFEND
  ." Concordance of kernel" CR CR
  CROSS
?CRT 0= IFTRUE PAGE IFEND





\ Document for product release            ( 24  8 86 CRC 17:58 )
DOCUMENTING    SCR @
  300 369 INDEX
  411 419 INDEX
  300 369 SHOW
  411 419 SHOW                  NECPAGE
EDITOR         SCR !









\ flags for conditional compilation       ( 17  3 88 CRC 19:18 )
0 VARIABLE 3.5IN                0 VARIABLE 5.25IN
0 VARIABLE SERIALDISK           0 VARIABLE FLS

: 3.5"     3.5IN @ ;            : 5.25"    5.25IN @ ;
: SERIAL   SERIALDISK @ ;       : FILES    FLS    @ ;

: DOSERIAL   SERIALDISK ON   3.5IN OFF  5.25IN OFF  FLS OFF ;

: DO3INCH    SERIALDISK OFF  3.5IN ON   5.25IN OFF  FLS OFF ;

: DO5INCH    SERIALDISK OFF  3.5IN OFF  5.25IN ON   FLS OFF ;

: DOFILES    SERIALDISK OFF  3.5IN OFF  5.25IN OFF  FLS ON  ;
DOFILES

\ Loader file creation screen             (  3  4 90 CRC 19:59 )
-9 +BLK  NEEDED TARGET  EDITOR FLUSH
SERIAL IFTRUE
FILING R-W MKF: REAL4TH.SER
FILING    ORIGIN       DPNEW @ OVER -
B/BUF / 1+ B/BUF *  DUP >R  HANDLE   WTF  R> - 6 .R
CR CLF  LS REAL*.*      IFEND

FILES IFTRUE
FILING R-W MKF: REAL4TH.FLS
FILING    ORIGIN       DPNEW @ OVER -
B/BUF / 1+ B/BUF *  DUP >R  HANDLE   WTF  R> - 6 .R
CR CLF  LS REAL*.*      IFEND

FORTH DEFINITIONS

\ Redo all 4 versions of rF               ( 17  3 88 CRC 20:09 )
DECIMAL         home pwd
\ DOSERIAL      808X     -1 +LOAD

\ DO3INCH       808X    -11 +LOAD

\ DO5INCH       808X    -11 +LOAD

  DOFILES    (  808X  )  -1 +LOAD







\ Rename files as needed                  (  7  4 88 CRC 18:06 )
filing
delete:  rff.anc
delete:  rfd.anc
rename:: rff.old rff.anc
rename:: rfd.old rfd.anc
rename:: rff.com rff.old
rename:: rfd.com rfd.old
rename:: real4th.fls rff.com
rename:: real4th.3in rfd.com






\ set up file to read in rf.scr goodies   (  4  1 89 CRC 16:18 )
forth definitions
forget task
filing  c: setdir: \messdos\rf
file: rf c:\messdos\rf\rf.scr
: task ;
dir *.*
editor flush








\ copy to floppy disk                     ( 14 11 91 CRC 14:18 )
base @ decimal
(date)  blk @ block  976 + swap cmove flush     base !
'r/w @ >r
editor flush harddisk           disking disking
opening: 8086x                  \ start: this volume
0                               \ destination
sizeof: 8086x                   \ count
10.ds +harddisk                 \ install the floppy
disking verify cr               \ do it
r> 'r/w !                       \ back to usual disk drivers
base @ decimal
(date)  blk @ block  976 + swap cmove update    base !
blank   ;s

last copied:     2  9 92
\ 68000 addressing setup                  (  3  4 88 CRC 12:27 )
\ FORTH DEFINITIONS FORGET TASK   FORTH DEFINITIONS : TASK ;
BASE @ >R HEX
\ ASSEMBLER DEFINITIONS  BEGIN,  \  address in ar0
\   1 # DR1 MOVQ,  WORKSPACE #L AR0 CMP, GE IF,
\   IMAGETOP #L AR0 CMP,  LT IF,     DR1 CLR,   THEN,  THEN,
\  RTS,  1 ?PAIRS  CONSTANT (?TARGET)
FORTH DEFINITIONS

CODE ><      AX POP,  AH AL XCHG,  1PUSH
\ CODE ><   S [ DR0 MOV,   DR0 DR1 MOV,  8 # DR0 LSL,
\   8 # DR1 LSR,  FF # DR1 .W AND,  DR1 DR0 .W OR,
\   FFFF #L DR0 AND,  DR0 S [ MOV,  NEXT  ;C

R> BASE !  -->

\ 68000 addressing setup                  ( 12  8 88 CRC 16:04 )
\ CODE !  S [+ AR0 MOV,  (?TARGET) *+ BSR,  DR1 TST,
\   EQ IF,  HERE >R  S [+ DR0 MOV,  DR0 AR0 [+ .B MOV,
\   8 # DR0 LSR,  DR0 AR0 [ .B MOV,  NEXT
\   THEN,  ' ! 2+ @#L JMP,        ;c

\ CODE ,  OFUSER DP AR0 MOV,  (?TARGET) *+ BSR,  DR1 TST,
\   EQ IF,  2 # OFUSER DP ADDQ,  R> *+ BRA,
\   THEN,  ' , 4+ @#L JMP,        ;C

: TARGETS ;  \ flag for re-compiles
-->




\ 68000 addressing setup                  ( 21 10 92 CRC 11:12 )
\ CODE !  S [+ AR0 MOV,  (?TARGET) *+ BSR,  DR1 TST,
\  EQ IF,  S [+ DR0 MOV,  DR0 AR0 [+ .B MOV,
\   8 # DR0 LSR,  DR0 AR0 [ .B MOV,  NEXT
\   THEN,  S [+ AR0 [ MOV,  NEXT  ;C

\ CODE @  S [ AR0 MOV,  (?TARGET) *+ BSR,  DR1 TST,
\   EQ IF,  AR0 1 &[ DR1 .B MOV,   8 # DR1 LSL,
\           AR0 [ DR1 .B MOV,  DR1 S [ MOV,  NEXT
\   THEN,  AR0 [ S [ MOV,  NEXT  ;C

: ?TARGET  \ addr -- addr fl | indicates target or resident
  DUP  WORKSPACE IMAGETOP WITHIN ;

: ?INTARGET     ( addr )   ?TARGET   0=
  IF  BELL ABORT"  Outside target area! " THEN ;      -->
\ 68000 addressing setup                  ( 21 10 92 CRC 11:11 )
\ CODE @  S [ AR0 MOV,  (?TARGET) *+ BSR,  DR1 TST,
\   EQ IF,  AR0 1 &[ DR1 .B MOV,   8 # DR1 LSL,
\           AR0 [ DR1 .B MOV,  DR1 S [ MOV,  NEXT
\   THEN,  ' @ 2+ @#L JMP,        ;C

: COMPILE   \ <COMPILE> <COMP>
  -FIND 0= 0 ?ERROR DROP , ;        IMMEDIATE

: T@  FUDGE @ + @  ;

: TC@ FUDGE @ + C@ ;

: ? @ . ;
-->

\ old style dictionary traversing         ( 21 10 92 CRC 12:02 )
\ : TRAV   >R
\   BEGIN R + DUP C@ 80 AND UNTIL  RDROP ;

\ : LFA   ?INTARGET  2- ;
\ : CFA   ?INTARGET  2+ ;
\ : PFA   ?INTARGET  1 TRAVERSE 5 + ;
\ : NFA   ?INTARGET  5 - -1 TRAVERSE ;

1 VARIABLE SPEAK

: VERBOSE       SPEAK ON ;

: LACONIC       SPEAK OFF ;


\ frills: dump & ascii print              ( 30 12 87 CRC 20:31 )
;s base @ hex
: (DUMP) \  addr ct ---  | dump as pointed to by reloc
  SPACE  BOUNDS DO  I tC@ 3 .R  LOOP ;
: U.R 0 SWAP D.R ;        : TAB OUT @ - SPACES ;
: LASCI   \  addr ct ---  | asci type as pointed to by reloc
  SPACE  BOUNDS DO  I tC@  7f AND  DUP
    bl ASCII ~ WITHIN 0= IF DROP ASCII . THEN  EMIT  LOOP ;
: HEAD  \ addr --- | headder for dump display
  10 0 DO I OVER + 0f AND 3 .R LOOP DROP ;
  \ N. B: Not responsible for negative counts! -- the MGT.
: DUMP   \  addr ct ---  | dump as pointed to by reloc
  OVER CR 6 SPACES HEAD  BEGIN  DUP  WHILE  CR OVER 5 U.R
     2DUP 10 MIN >R  R 2DUP (DUMP)  36 TAB LASCI
     R R> MINUS D+  ?TERMINAL IF DROP 0 THEN  REPEAT 2DROP ;
base !
















































































































\ Load Screen for 8086 assembler          (  6 12 87 CRC 21:55 )
FORTH DEFINITIONS  \ FORGET TASK  : TASK ;
BASE @ >R DECIMAL
EDITOR   FLUSH  FORTH
VOCABULARY ASSEMBLER   IMMEDIATE
1 17 +THRU

FORTH DEFINITIONS



R> BASE !  EDITOR FLUSH




\ pick & roll in code 68000               ( 13  2 89 CRC 16:42 )
;s  BASE @ HEX  >R
CODE PICK   S [ DR0 MOV,  ( PL IF,)  2 # DR0 ASL,
            0 S 0 &D[ S [ MOV,  ( THEN,)  NEXT ;C
CODE -ROT  S 4 &[ DR0 MOV,  S 8 &[ S 4 &[ MOV,
  S [ S 8 &[ MOV,  DR0 S [ MOV,  NEXT   ;c
R> BASE !      ;s
CODE ROLL   S [ DR0 MOV,  DR0 DR1 MOV,  1 # DR1 SUBQ,
  PL IF,  2 # DR0 ASL,  S DR0 ADD,  DR0 AR0 MOV,  AR0 [ S [ MOV,
  AR0 4 &[ AR1 LEA,  FALSE DR1 DO,  AR0 -[ AR1 -[ MOV,  LOOP,
      AR1 S MOV,  ELSE,  4 # S ADDQ,  THEN,  NEXT ;C
CODE 4DUP  4 1- # DR0 MOVQ,
  FALSE DR0 DO,  S 0C &[ S -[ MOV,  LOOP,  NEXT ;C
CODE TUCK  S [+ AR0 MOV,  S [ S -[ MOV,  AR0 S -[ MOV,  NEXT ;C
R> BASE !

\ 8086 Assembler                          (  6 12 87 CRC 21:59 )
;S
The 8086 Assembler was written by Mike Perry.
To create an assembler language definition, use the defining
word CODE.  It must be terminated with either END-CODE or
its synonym C;.  How the assembler operates is a very
interesting example of the power of CREATE DOES>   Basically
the instructions are categorized and a defining word is
created for each category.  When the nmemonic for the
instruction is interpreted, it compiles itself.

Reworked and modified to run on real-FORTH by Charles Curley,
at the usual address, https://charlescurley.com



\ 8086 Assembler                                      06Apr84map
\ : LABEL  CREATE  [COMPILE] ASSEMBLER   ;
232 CONSTANT DOES-OP
3 CONSTANT DOES-SIZE
: DOES?   ( IP -- IP' F )
   DUP DOES-SIZE + SWAP C@ DOES-OP =  ;
ASSEMBLER DEFINITIONS
\ : C;   ( -- )   END-CODE   ;

: =  = IF -1 ELSE 0 THEN ;    \ due to improper use of flags as
: <  < IF -1 ELSE 0 THEN ;    \ masks in assembler. Tch, tch.
: 0<>  IF -1 ELSE 0 THEN ;
: 0=   IF 0 ELSE -1 THEN ;
: NOT  0= ;
: ON   -1 SWAP ! ;
OCTAL
\ 8086 Assembler   Register Definitions               11OCT83HHL
: REG    11 * SWAP 1000 * OR CONSTANT   ;
: REGS   ( MODE N -- )   SWAP 0 DO  DUP I REG  LOOP  DROP ;

10 0 REGS   AL  CL  DL  BL  AH  CH  DH  BH
10 1 REGS   AX  CX  DX  BX  SP  BP  SI  DI
10 2 REGS   [BX+SI] [BX+DI] [BP+SI] [BP+DI] [SI] [DI] [BP] [BX]
 4 2 REGS   [SI+BX] [DI+BX] [SI+BP] [DI+BP]
 4 3 REGS   ES  CS  SS  DS
 3 4 REGS   #   #)  S#)

: create  create smudge ;
BP CONSTANT RP   [BP] CONSTANT [RP]   ( RETURN STACK POINTER )
SI CONSTANT IP   [SI] CONSTANT [IP]   ( INTERPRETER POINTER )
BX CONSTANT W    [BX] CONSTANT [W]   ;S WORKING REGISTER )
also: sp is data stack, and beware of seg registers
\ Addressing Modes                        ( 22 12 25 CRC 19:58 )
: MD  CREATE 1000 * ,  DOES> @ SWAP 7000 AND = 0<>  ;
0 MD R8?   1 MD R16?   2 MD MEM?   3 MD SEG?   4 MD #?
: REG?   ( n -- f )   7000 AND 2000 < 0<> ;
: BIG?   ( n -- f )   ABS -200 AND 0<>  ;
: RLOW   ( n1 -- n2 )    7 AND ;
: RMID   ( n1 -- n2 )   70 AND ;
0 VARIABLE SIZE   SIZE ON
: .B     ( -- )   SIZE OFF ;
: OP,   ( n op -- )   OR C,  ;
: W,   ( op mr -- )   R16? 1 AND OP,  ;
: SIZE,   ( OP -- OP' )   SIZE @ 1 AND OP,  ;
: ,/C,  ( n f -- )   IF  ,  ELSE  C,  THEN  ;
: RR,   ( mr1 mr2 -- )   RMID SWAP RLOW OR 300 OP,  ;
0 VARIABLE LOGICAL
: B/L?   ( n -- f )   BIG? LOGICAL @ OR  ;
\ Addressing                                          16Oct83map
: MEM,   ( DISP MR RMID -- )   OVER #) =
   IF  RMID 6 OP, DROP ,
   ELSE  RMID OVER RLOW OR ROT ROT [BP] = OVER 0= AND
   IF  SWAP 100 OP, C,  ELSE  SWAP OVER BIG?
   IF  200 OP, ,  ELSE  OVER 0=
   IF  C, DROP  ELSE  100 OP, C,
   THEN THEN THEN THEN  ;
: WMEM,   ( DISP MEM REG OP -- )   OVER W, MEM,  ;
: R/M,   ( MR REG -- )
   OVER REG? IF  RR,  ELSE  MEM,  THEN  ;
: WR/SM,   ( R/M R OP -- )   3 PICK DUP REG?
   IF  W, RR,  ELSE  DROP SIZE, MEM,  THEN  SIZE ON  ;
0 VARIABLE INTER
: FAR    ( -- )   INTER ON  ;
: ?FAR   ( n1 -- n2 )   INTER @ IF  10 OR  THEN  INTER OFF ;
\ Defining Words to Generate Op Codes     ( 11 12 87 CRC 21:13 )
: 1MI  CREATE C,  DOES>  C@ C,  ;
: 2MI  CREATE C,  DOES>  C@ C,  12 C,  ;
: 3MI  CREATE C,  DOES>  C@ C,  DELTA +  HERE - 1-
 DUP -200 177 WITHIN 0= IF ABORT" Branch out of Range" THEN C, ;
 : 4MI  CREATE C,  DOES>  C@ C,  MEM,  ;
: 5MI  CREATE C,  DOES>  C@ SIZE,  SIZE ON ;
: 6MI  CREATE C,  DOES>  C@ SWAP W,  ;
: 7MI  CREATE C,  DOES>  C@ 366 WR/SM, ;
: 8MI  CREATE C,  DOES>  C@ SWAP R16? 1 AND OR  SWAP # =
   IF  C, C,  ELSE  10 OR  C,  THEN  ;
: 9MI  CREATE C,  DOES>  C@  OVER R16?
   IF  100 OR SWAP RLOW OP,  ELSE  376 WR/SM,  THEN  ;
: 10MI CREATE C,  DOES>  C@ OVER CL =
   IF  NIP 322  ELSE  320  THEN  WR/SM,  ;

\ Defining Words to Generate Op Codes                 15MAY84HHL
: 11MI  CREATE C, C,  DOES>  OVER #) =
   IF  NIP C@ INTER @
     IF  1 AND IF  352  ELSE  232  THEN  C,  SWAP , ,  INTER OFF
     ELSE  SWAP HERE - 2- SWAP  2DUP 1 AND SWAP BIG? 0= AND
       IF  2 OP, C,  ELSE  C,  1- ,  THEN  THEN
   ELSE  OVER S#) = IF  NIP #) SWAP  THEN
     377 C, 1+ C@ ?FAR  R/M,  THEN  ;
: 12MI  CREATE C, C, C,  DOES>  OVER REG?
   IF  C@ SWAP RLOW OP,  ELSE  1+ OVER SEG?
     IF  C@ RLOW SWAP RMID OP,
     ELSE  COUNT SWAP C@ C,  MEM,
   THEN THEN  ;
: 14MI  CREATE C,  DOES> C@
   DUP ?FAR C,  1 AND 0= IF  ,  THEN ;

\ Defining Words to Generate Op Codes                 09Apr87TJZ
: 13MI  CREATE C, C,  DOES>  COUNT >R C@ LOGICAL !  DUP REG?
   IF  OVER REG?
     IF  R> OVER W, SWAP RR,  ELSE  OVER DUP MEM? SWAP #) = OR
     IF  R> 2 OR WMEM,  ELSE  ( # ) NIP  DUP RLOW 0= ( ACC? )
     IF  R> 4 OR OVER W, R16? ,/C,
     ELSE  OVER B/L? OVER R16? 2DUP AND
       -ROT 1 AND SWAP NOT 2 AND OR 200 OP,
       SWAP RLOW 300 OR R> OP,  ,/C,
     THEN  THEN  THEN
   ELSE  ( MEM )  ROT DUP REG?
     IF  R> WMEM,
     ELSE  ( # ) DROP  3 PICK B/L? DUP NOT 2 AND 200 OR SIZE,
       -ROT R> MEM,  SIZE @ AND ,/C,  SIZE ON
   THEN  THEN  ;

\ Instructions                                        14MAY84RKG
: TEST,  ( source dest -- )   DUP REG?
   IF  OVER REG?
     IF  204 OVER W, SWAP RR,  ELSE  OVER DUP MEM? SWAP #) = OR
     IF  204 WMEM,  ELSE  ( # ) NIP  DUP RLOW 0= ( ACC? )
     IF  250 OVER W,
     ELSE  366 OVER W,  DUP RLOW 300 OP,
     THEN   R16? ,/C,  THEN  THEN
   ELSE  ( MEM )  ROT DUP REG?
     IF  204 WMEM,
     ELSE  ( # ) DROP  366 SIZE,  0 MEM,  SIZE @ ,/C,  SIZE ON
   THEN  THEN  ;




\ Instructions                                        16Oct83map
HEX
: ESC,  ( source ext-opcode -- )   RLOW 0D8 OP, R/M,  ;
: INT,  ( N -- )   0CD C,  C,  ;
: SEG   ( SEG -- )   RMID 26 OP,  ;

: CS:   CS SEG ;
: DS:   DS SEG ;
: ES:   ES SEG ;
: SS:   SS SEG ;

: XCHG,  ( MR1 MR2 -- )   DUP REG?
   IF  DUP AX =
     IF  DROP RLOW 90 OP,  ELSE  OVER AX =
     IF  NIP  RLOW 90 OP,  ELSE  86 WR/SM,  THEN  THEN
   ELSE  ROT 86 WR/SM,  THEN  ;
\ Instructions                                        18APR83HHL
: MOV,  ( S D -- )   DUP SEG?
   IF  8E C, R/M,  ELSE  DUP REG?
     IF  OVER #) = OVER RLOW 0= AND
       IF  A0 SWAP W,   DROP   ,  ELSE  OVER SEG?
       IF  SWAP 8C C, RR,  ELSE  OVER # =
       IF  NIP DUP R16? SWAP RLOW OVER 8 AND OR B0 OP, ,/C,
       ELSE  8A OVER W, R/M,  THEN THEN THEN
     ELSE  ( MEM ) ROT DUP SEG?
       IF  8C C, MEM,  ELSE  DUP # =
       IF  DROP C6 SIZE, 0 MEM,  SIZE @ ,/C,
       ELSE  OVER #) = OVER RLOW 0= AND
       IF  A2 SWAP W,  DROP   ,   ELSE  88 OVER W, R/M,
   THEN THEN THEN THEN THEN   SIZE ON  ;


\ Instructions                                        12Mar87TJZ
 37  1MI AAA,    D5  2MI AAD,    D4  2MI AAM,    3F  1MI AAS,
0 10 13MI ADC, 0 00 13MI ADD,  2 20 13MI AND, 10 E8 11MI CALL,
 98  1MI CBW,    F8  1MI CLC,    FC  1MI CLD,    FA  1MI CLI,
 F5  1MI CMC,  0 38 13MI CMP,    A6  5MI CMPS,   99  1MI CWD,
 27  1MI DAA,    2F  1MI DAS,    08  9MI DEC,    30  7MI DIV,
       ( esc )   F4  1MI HLT,    38  7MI IDIV,   28  7MI IMUL,
 E4  8MI IN,     00  9MI INC,          ( int )  0CE  1MI INTO,
0CF  1MI IRET,   77  3MI JA,     73  3MI JAE,    72  3MI JB,
 76  3MI JBE,    E3  3MI JCXZ,   74  3MI JE,     7F  3MI JG,
 7D  3MI JGE,    7C  3MI JL,     7E  3MI JLE, 20 E9 11MI JMP,
 75  3MI JNE,    71  3MI JNO,    79  3MI JNS,    70  3MI JO,
 7A  3MI JPE,    7B  3MI JPO,    78  3MI JS,     9F  1MI LAHF,
 C5  4MI LDS,    8D  4MI LEA,    C4  4MI LES,    F0  1MI LOCK,
0AC  6MI LODS,   E2  3MI LOOP,   E1  3MI LOOPE,  E0  3MI LOOPNE,

\ Instructions                                        12Apr84map
       ( mov )   0A4  5MI MOVS,   20  7MI MUL,    18  7MI NEG,
 90  1MI NOP,     10  7MI NOT,  2 08 13MI OR,     E6  8MI OUT,
            8F 07 58 12MI POP,    9D  1MI POPF,
           0FF 36 50 12MI PUSH,   9C  1MI PUSHF,
 10 10MI RCL,     18 10MI RCR,
 F2  1MI REP,     F2  1MI REPNZ,  F3  1MI REPZ,
 C3 14MI RET,     00 10MI ROL,     8 10MI ROR,    9E  1MI SAHF,
 38 10MI SAR,   0 18 13MI SBB,   0AE  5MI SCAS,         ( seg )
 20 10MI SHL,     28 10MI SHR,    F9  1MI STC,    FD  1MI STD,
 FB  1MI STI,    0AA  6MI STOS, 0 28 13MI SUB,          ( test )
 9B  1MI WAIT,          ( xchg )  D7  1MI XLAT, 2 30 13MI XOR,
 C2 14MI +RET,

: BRSIZE   -200 177 WITHIN 0= 5 ?ERROR  ;

\ Structured Conditionals                 ( 10 12 87 CRC 22:23 )
HEX                             109 VARIABLE >>NEXT
75 CONSTANT 0=   74 CONSTANT 0<>   79 CONSTANT 0<
78 CONSTANT 0>=  7D CONSTANT <     7C CONSTANT >=
7F CONSTANT <=   7E CONSTANT >     73 CONSTANT U<
72 CONSTANT U>=  77 CONSTANT U<=   76 CONSTANT U>
71 CONSTANT OV   E3 CONSTANT CX<>0

\ : NEXT    >>NEXT @     #) JMP,  ;
\ : 1PUSH   >>NEXT @ 1-  #) JMP,  ;
\ : 2PUSH   >>NEXT @ 2-  #) JMP,  ;
\ : 3PUSH   >>NEXT @ 3 - #) JMP,  ;
: DO,   HERE  3 ;
: LP   CREATE C,  DOES>  C@ C,  3 ?PAIRS  HERE - 1-
  DUP BRSIZE  C, ;
E2  LP LOOP,    E1  LP LOOPE,   E0  LP LOOPNE,
\ Structured Conditionals                 ( 29 12 87 CRC 21:19 )
: UNTIL,  \ dest.adr 1 br.opcode --
   SWAP 1 ?PAIRS   C,  HERE 1+ - C, ;
: IF,     \ br.opcode -- adr.next.instr 2  | reserve space
   C, 0 C, HERE 2 ;
: ENDIF,  \ adr.instr.after.br 2 -- | patch the forward ref.
   2 ?PAIRS   HERE OVER -  SWAP 1- C! ;
: ELSE,   \ adr.after.br 2 -- adr.after.this.br 2
   2 ?PAIRS   HERE 2+ #) JMP,  HERE SWAP  2 ENDIF, 2 ;
: BEGIN,   HERE 1 ;     \ -- dest.adr 1
: WHILE,  \ dest.adr 1 br.opcode -- adr.after.this 2 dest.adr 1
   IF, 2SWAP ;
: again,   eb until, ;
: REPEAT, \ adr.after.while 2 dest.adr.of.begin 1 --
  again,   ENDIF, ;                     DECIMAL
: THEN,  ENDIF, ;   : END,  UNTIL, ;
































































































































































\ assembler extensions for target compiler( 23 12 19 crc 18:17 )
\ extend the native assembler to save space in memory.
assembler definitions
>next variable >>next   \ initialize to native, patch later

: nextmacro  <builds c,  does>
  c@ >r  >>next @ r -  here  r> 5 + dup allot cmove ;

  0 nextmacro next              1 nextmacro 1push
  2 nextmacro 2push             3 nextmacro 3push

\ : #)  delta - #) ;
forth definitions   ;s



\ Hex word dump                           (  6  2 87 CRC 12:59 )
BASE @ HEX
: TC@  FUDGE @ + C@  ;          : T@  FUDGE @ + @ ;
: (WDUMP) \  from-address-2 cnt-1  ---  | memory displayed
  BOUNDS DO I T@ 0 7 D.R 2 +LOOP ;
\ : HEAD   CR 6 SPACES 0F AND 10 0  \ start  ---  | header
\    DO DUP I + BASE @ 1- AND 3 .R LOOP
\    DROP ."  <<    ASCII   >>" ;
\ : ASCI   OVER +  SWAP   ( from-addr cnt ASCII)
\   DO I TC@ 7F AND  DUP ASCI ~ > IF.  DUP BL < IF. EMIT LOOP ;
: WDUMP  OVER  DUP WHEAD \ from-addr  count ---  | dump
   + SWAP   DO CR I 0 6 D.R I 10 2DUP (WDUMP) SPACE
   ASCI   I  F0 AND F0 = IF I WHEAD THEN
   ?TERMINAL  IF LEAVE  THEN  10 +LOOP CR ;
: DUMP WDUMP ;
 BASE !  FORTH  ."  Word hexdump loaded." CR  ;S
\ 808x       target compiler: load        ( 24 12 87 CRC 10:28 )
EDITOR FLUSH   CR pTODAY CR CR   DECIMAL         WARNING ON
FORTH DEFINITIONS  FORGET TASK
1 +BLK NEEDED COMPILE-ADDR
-42 +BLK NEEDED TARGETS       181 +BLK NEEDED EXIT
( ' WDUMP  ' COMPILE-ADDR < IFTRUE  -1 +LOAD IFEND  )
-2 ( 9) +load   ( asm )         : TASK ;  2 +BLK NEEDED TIBX
: RLOAD DUP BLOCK @ IF  SPEAK @ IF  DUP CR   7 .R SPACE  THEN
      LOAD SPEAK @ IF .S THEN  ELSE DROP THEN ;
: RTHRU  1+ SWAP DO I RLOAD LOOP ;
HEX HERE FIRST OVER - ERASE DECIMAL
0 CONSTANT CPZ                  CPZ 0= CONSTANT CM
  3 +BLK 25 +BLK RTHRU
CR  FORTH DEFINITIONS   pTODAY    ;S
load  25+ & 26+ after  ;s ,  (loop) ,  (+loop) ,  branch  and
0Branch  have been defined in the target memory
\ Target compiler: set fundamentals       ( 12  8 88 CRC 16:00 )
BASE @ HEX                       FORTH  DEFINITIONS
    0 VARIABLE COMPILE-ADDR  \ work-space
COMPILE-ADDR 2100 DUP 2- ALLOT  ERASE \ 8 k. + padding for file
HERE  CONSTANT IMAGETOP
( compile-addr )    0   CONSTANT BASE-ADDR     \ origin --
COMPILE-ADDR CONSTANT WORKSPACE
COMPILE-ADDR BASE-ADDR - CONSTANT DELTA
                                  DELTA FUDGE !
10000 CONSTANT TM             400 CONSTANT   *B/BUF*
     8   *B/BUF*    4     +  *    CONSTANT CO
\ count  b/buf   overhead +  * == count of buffer space
0 VARIABLE 'ORIGIN              : ORIGIN 'ORIGIN @ ;
                              180 CONSTANT US   BASE ! ;S
( compile-addr ) 9000   CONSTANT BASE-ADDR     \ origin --
 D000 CONSTANT TM             400 CONSTANT   *B/BUF*
\ Target compiler: target memory          ( 16 12 87 CRC 22:55 )
BASE @ HEX   \ note the  non-standard memory map!
\ TM   2-  DELTA -    CONSTANT UP
TM  40  -           CONSTANT TOS
TM 1A0  -           CONSTANT BOT
TM 210  -           CONSTANT RTS
TM 400  -           CONSTANT TIBX
TIBX                CONSTANT EM

FORTH DEFINITIONS    BASE  !

0 VARIABLE CHOPLINE   0 , 0 ,

: SETORG    HERE 'ORIGIN ! ;


\ code for floating user pointer          ( 21 10 92 CRC 11:33 )
0 VARIABLE UPARRAY  BL 2- ALLOT   UPARRAY BL ERASE
UPARRAY VARIABLE UDP

: UP,     UDP @ !  2 UDP +! ;
assembler definitions
: UP   HERE DELTA - 2+ UP,  [ TM 2- ] LITERAL ;
forth definitions
: GETUPS   assembler  \ install up addresses in dict.
  UPARRAY  HERE  UDP @ 2+  UPARRAY - DUP ALLOT  CMOVE ;
forth
: MUTATES  [COMPILE] '  DUP  cfa @
  [ ' CHOPLINE cfa @ ] LITERAL
  - IF BELL ABORT" Can't mutate anything but a variable!" THEN
  ! ;

\ Target compiler: compiler addrs         ( 21 10 92 CRC 11:35 )
FORTH  DEFINITIONS
 0 VARIABLE *(.")*               0 VARIABLE *USER*
 0 VARIABLE *DOES>*              0 VARIABLE *COLON*
 0 VARIABLE *(;CODE)*            0 VARIABLE *CONSTANT*
 0 VARIABLE *VARIABLE*           0 VARIABLE *VOCAB*
( 0 VARIABLE *USERCONSTANT* )    0 VARIABLE *;S*
 0 VARIABLE *ABORT*              0 VARIABLE *QUIT*
 0 VARIABLE *@EXEC*
 0 VARIABLE *(LOOP)*             0 VARIABLE *(+LOOP)*
 0 VARIABLE *BRAN*               0 VARIABLE *0BRAN*

 0 VARIABLE *LIT*                0 VARIABLE *CLIT*



\ Target compiler: newforth                 29 09 84 CRC
VOCABULARY NEWFORTH IMMEDIATE        BASE @  HEX
: OF/NF [COMPILE] NEWFORTH DEFINITIONS [COMPILE] FORTH ;
 0 VARIABLE DPOLD   COMPILE-ADDR VARIABLE DPNEW
 0 VARIABLE O/N    \ old/new:  t=new, false=old
  1F  ( 0) VARIABLE TWIDTH   \ target width. 0 = headerless
  1F  ( 0) VARIABLE WID      \ width for a word. use | to make
                             \ an ophan out of it.
: SETOLD   O/N @   IF 0 O/N ! HERE DPNEW !
  DPOLD @ DP ! ( OF*LIT* @ *LIT* !   )
               ( OF*CLIT* @ *CLIT* ! ) THEN ;
: SETNEW   O/N @ 0= IF 1 O/N ! HERE DPOLD !
  DPNEW @ DP ! ( NF*LIT* @ *LIT* !   )
               ( NF*CLIT* @ *CLIT* ! ) THEN ;
DELTA  VARIABLE LAST   \ addr of top of new dictionary
BASE !  ;S
\ Target compiler: ?0s                    ( 12  8 88 CRC 16:09 )
 \ Help detect unresolved forward references --- most useful!
: ?0S  BASE @ HEX CR 15 [ BLK @ ] LITERAL  .LINE
       80 OUT !  DPNEW @ ORIGIN  DO
     I @  0= IF  ?CR  I DELTA - 5 .R  2  ELSE  1  THEN
     ?TERMINAL IF LEAVE THEN  +LOOP BASE ! ;   BASE @ HEX
: TID. PAD BL ASCII _ FILL DUP PFA LFA OVER - \ res.addr
     PAD SWAP CMOVE PAD COUNT 1F AND  2DUP  BOUNDS
     DO I C@ 7F AND I C! LOOP        TYPE SPACE ; BASE !
: THERE  DPNEW @  DELTA - ;
: .HERE  THERE 13 [ BLK @ ] LITERAL .LINE  7 .R ;
: SIZE  DPNEW @  ORIGIN - ;
: .SIZE  SIZE 14 [ BLK @ ] LITERAL  .LINE 7 .R ; ;S
       target here =
       target size =
       Addresses of words containing 0 in them:
\ Target compiler: /smudged               ( 16  2 87 CRC 18:30 )
BASE @ HEX  0 VARIABLE <IMMED> 70 ALLOT  \ st size. Could be 38?
<IMMED> HERE OVER - ERASE       <IMMED> 2+ <IMMED> !
: /SMUDGE <IMMED> @ <IMMED> 2+ 2DUP - IF
  DO I @ BL TOGGLE 2 +LOOP ELSE 2DROP THEN ;
: NFFIND BL WORD HERE DUP COUNT UPPER
  [ ' NEWFORTH  2+ ] LITERAL  @ (FIND) ;
: 'NF  /SMUDGE  NFFIND DUP
   IF SWAP DROP THEN      /SMUDGE 0=
   IF HERE COUNT TYPE SPACE  ." NF? "  0 ERROR THEN ;
: REPLACED:BY     'NF 2- @ SWAP ! ;
: BYTE:IN         'NF 2- @ DELTA + 2+ + ;
: [FROM:NEWFORTH] 'NF 2- @ , ;  IMMEDIATE
: NFSEE:   'NF nfa 2- @ WHERETHEN  R# ! EDIT ;
: NFDUMP   BASE @ HEX  >R DELTA FUDGE !  'NF 2- @ DUP  6 U.R
  10 - -10 AND C/L ( 2DUP)  DUMP ( WDUMP) R> BASE ! ;  BASE !
\ Target compiler: nfcompile              ( 23 10 92 CRC 19:55 )
: <NFCOMPILE>   ?COMP R> DUP 2+ >R  @  , ;

: NFCOMPILE   [ ' <NFCOMPILE> cfa ] LITERAL ,
  'NF 2- @    ,  ;      IMMEDIATE

: NFDIS:   DELTA FUDGE !  'NF 2- @ T@ DISASSEM ;

: NFLIST        \ --  | vlist of newforth
  [ ' NEWFORTH  2+ ] LITERAL  @ (VLST) ;

\ DECIMAL  126 +BLK RLOAD   \ xref load -- not ported to ff yet




\ Target compiler: create-old             ( 14  2 92 CRC 16:47 )
BASE @ HEX
: CREATE-OLD SETOLD FIRST ( TAREA ) PAD - 0< 2 ?ERROR 0 , \ see:
  [COMPILE] NEWFORTH DEFINITIONS
  BL WORD HERE DUP  DUP C@ WIDTH @ MIN 1+ ALLOT \ name
  SPEAK @ IF  DUP COUNT TYPE SPACE  THEN
  80 TOGGLE HERE 1- 80 TOGGLE           \ traverse bits
  LATEST ,  CURRENT @ !         \ update links
  WHERENOW  latest 2- ! ;       \ installs scr & line #s

BASE !





\ Target compiler: create-new             ( 11 12 87 CRC 21:02 )
BASE @ HEX
: CREATE-NEW SETNEW
  SPEAK @  IF  OUT @ 32 > IF CR 6 SPACES THEN  THEN
  IMAGETOP DPNEW @ [ PAD HERE - C/L + ] LITERAL - - 0< 2 ?ERROR
  ( ?-BUF)  WID  @ IF
  BL WORD HERE DUP C@ TWIDTH @ 1F AND MIN 1+ ALLOT
  DUP 80 TOGGLE HERE 1- 80 TOGGLE
  LAST  @ DELTA - , LAST ! THEN
  SPEAK @ IF  BASE  @ HEX HERE DELTA - 5 U.R
      BASE ! SPACE  THEN
  TWIDTH  @ WID ! ;   BASE !




\ boot parameter area access              ( 20  2 89 CRC 10:07 )
0 VARIABLE BOOTS   \ points to base addr: 0 +origin

: +BOOTS   BOOTS @ + DELTA - ;

CODE CHKSM \ addr ct --  |  return byte checksum value
  cx pop,  bx pop,  ax ax sub,  ax dx mov,  1 # dx sub,
  do,  0 [bx] al add,  bx inc,  loop,
  dx ax xor,  1 # ax add,  dx ax and,  1push

: CHECKSUM    \  --  | perform checksum on image, add it in
  ORIGIN  DPNEW @  OVER - 2DUP  CHKSM
  DPNEW @ C!  DPNEW 1+!  1+ CHKSM ." Checksum is: " . ;



\ initialises: easier setup for the colds ( 12  8 88 CRC 16:16 )
    \  send kim paper tape format
\ : SEND  BASE @ HEX  BASE-ADDR DPNEW @ DELTA - OVER - LINES
\   ( LASTLINE for atari stuff ) BASE ! CTL G (EMIT) ;
: INITIALISES  'NF 2- @ DELTA + DUP @ *USER* @ -
    IF ." Invalid user name " 0 ERROR  THEN
    2+ @ ( 11/68k version ) 12 +BOOTS DELTA + + ! ;
;S syntax:  val-1  INITIALISES  username
where  val  is some value, and username is the user variable
it will initialise.
Typical uses:
'NF (EMIT) 2-           INITIALISES 'EMIT
EM US - CO -            INITIALISES 'FIRST

    2+ @ ( 11/68k version ) 12 + COMPILE-ADDR + ! ;

\ Target compiler: nf: nf; ascii txt      ( 14  5 86 CRC 12:25 )
: NF: !CSP CREATE-OLD SMUDGE    [ ' hold cfa @ ] literal , \ cfa
  IMMEDIATE [COMPILE] FORTH ] ;

: NF; [COMPILE] ; ;       IMMEDIATE

: TXT ASCII " WORD  HERE C@ 1+ ALLOT ( ?-BUF)  ;
   IMMEDIATE

: |  ?CR  WID OFF SPEAK @ IF  ."  <orphan>" THEN ;

: MF  CR ?dict  BASE @ HEX
  IMAGETOP DPNEW @ - . ." Target bytes left. " BASE ! ;

: OFDUMP   BASE  @ HEX   >R FUDGE OFF [COMPILE] ' DUP
   6 U.R  16 - -16 AND C/L DUMP R> BASE ! ;
\ Target compiler: literal -- immediate   ( 20 12 25 CRC 22:09 )
BASE @ HEX
: LITERAL
  HERE ?TARGET NIP 0= IF  [COMPILE] LITERAL ELSE
  STATE @ IF  DUP -80 7F WITHIN
  IF *CLIT* @ , C,  ELSE  *LIT* @ , , THEN THEN THEN ;
        IMMEDIATE

: DLITERAL  STATE @ IF SWAP [COMPILE] LITERAL
        [COMPILE] LITERAL  THEN ;                     IMMEDIATE

: IMMEDIATE LAST @ C/L TOGGLE LATEST
        <IMMED> @ ! 2 <IMMED> +! SMUDGE ;
BASE ! ;S
Warning: There is no bounds checking for the <immed> array!!!

\ Target compiler: interpreter            ( 20 12 25 CRC 22:09 )
: INTERPRET   BEGIN -FIND  IF ( fudge @ fudge off  here count
  type  fudge !  space  )      ( found) STATE @ <
  IF  O/N @  IF  ( new ) 2- @  else  2-  THEN ,
    ELSE  2- EXECUTE  THEN
  ELSE  HERE NUMBER DPL @ 1+
    IF [COMPILE] DLITERAL ELSE  DROP [COMPILE] LITERAL
  THEN THEN
\ ?TERMINAL IF IN @ R# ! BLK @ SCR ! ABORT THEN
  AGAIN ;

: V   IN @ NFDUMP IN ! OFDUMP ;
                               1 CONSTANT 1
    2 CONSTANT 2               3 CONSTANT 3
    4 CONSTANT 4               5 CONSTANT 5     ;s
  IF  O/N @  IF  ( new ) 2- @  THEN 2- ,
\ Target compiler: quit -- label          ( 13  5 86 CRC 14:51 )
: NFQUIT BLK OFF [COMPILE] [
  BEGIN BEGIN RP! CR QUERY INTERPRET OK STATE @ 0= UNTIL
     .S ." NK"       AGAIN STOP
: LOAD  DUP BLOCK  @ IF  BASE @ >R
  SPEAK @  IF DUP DECIMAL CR 5 U.R SPACE THEN  HEX
  BLK 2@ >R >R  C/L IN ! BLK ! INTERPRET
  R> R> BLK 2! SPEAK @ IF  ?CR 3 SPACES HEX .S  THEN
  R> BASE !  ELSE DROP THEN ;
: THRU  1+ SWAP DO I LOAD LOOP ;
: CFA 2- @ ;
: ==       ?EXEC SETOLD CURRENT @ >R
  [COMPILE] ASSEMBLER DEFINITIONS CONSTANT
  R> CURRENT ! [COMPILE] FORTH SETNEW ;
: LABEL SETOLD DPNEW @ DELTA - ==
  [COMPILE] ASSEMBLER ;
\ Target compiler: code -- variable       ( 14  5 86 CRC 11:05 )
BASE  @ HEX
: CODE  !CSP IN @ ?EXEC CREATE-NEW
  IN ! HERE DELTA - CREATE-OLD , SMUDGE SETNEW
  HERE DELTA - 2+ ,  [COMPILE] ASSEMBLER ;

: CONSTANT IN @ CREATE-NEW
    IN ! HERE DELTA - *CONSTANT* @ , SWAP   ,
    CREATE-OLD , SETNEW [COMPILE] FORTH ;

: VARIABLE IN @ CREATE-NEW
    IN ! HERE DELTA - *VARIABLE* @ , SWAP   ,
    CREATE-OLD , SETNEW [COMPILE] FORTH ;
 BASE  !   ;S


\ assembler extensions for target compiler( 14  8 88 CRC  8:40 )
ASSEMBLER DEFINITIONS  BASE @ HEX
\ : NEXT    >>NEXT @      HERE  5 DUP ALLOT  CMOVE ;
\ : 1PUSH   >>NEXT @ 1-   HERE  6 DUP ALLOT  CMOVE ;
\ : 2PUSH   >>NEXT @ 2-   HERE  7 DUP ALLOT  CMOVE ;
\ : 3PUSH   >>NEXT @ 3 -  HERE  8 DUP ALLOT  CMOVE ;

: T#)  #) ;                     : #)  DELTA + #) ;
: OFUSER   'NF 2- @  2+ T@  [BX] ;
: ;C ?EXEC ?CSP SMUDGE [COMPILE] FORTH ;
: END-CODE  ;C ;                     : C;  ;C ;
BASE ! FORTH DEFINITIONS

: +LOAD  +BLK  LOAD ;

: +THRU  1+ +BLK SWAP +BLK  DO I ( + )  LOAD LOOP ;
\ Target compiler: vocabulary -- user  68K( 13  5 86 CRC 14:56 )
BASE  @ HEX
\ : VOCABULARY IN @ CREATE-NEW
\     IN ! HERE DELTA - ( *DOES>* , )  *VOCAB* ,  A081 W,
\     LAST @ DELTA - , 0 ,    \ new does>   !!
\     CREATE-OLD , SETNEW [COMPILE] FORTH ;

: USER     IN @ CREATE-NEW
    IN ! HERE DELTA - *USER* @  , SWAP  , \ words for 11!!
    CREATE-OLD , SETNEW [COMPILE] FORTH ;   \ offset is 16 bit

\ : COMPILE   ?COMP R> DUP 2+ >R @ , ;  \ n.b. target only!
BASE !   ;S
    IN ! HERE DELTA - ( *DOES>* @ , )  *VOCAB* ,  A081 ,


\ chop target compiler                    ( 29 12 87 CRC 20:52 )
: GOLDEN  \ -- | saves data to chop xcompiler
  [ ' NEWFORTH   2+ ] LITERAL @ CHOPLINE    !
  [ ' ASSEMBLER  2+ ] LITERAL @ CHOPLINE 2+ !
  HERE                          CHOPLINE 4+ ! ;

: CHOP   [COMPILE] FORTH DEFINITIONS   EDITOR FLUSH  FORTH
  UPARRAY DUP UDP !  BL ERASE
  CHOPLINE 4+ @ DP !  DELTA FUDGE !
  WORKSPACE IMAGETOP OVER - ERASE
  SETNEW  COMPILE-ADDR DP !  SETOLD SETNEW  DELTA LAST !
  <IMMED> 2+ <IMMED> !
  CHOPLINE    @ [ ' NEWFORTH  2+ ] LITERAL !
  CHOPLINE 2+ @ [ ' ASSEMBLER 2+ ] LITERAL !  ;       ;S
WARNING:  no additions to any voc save  NEWFORTH  and  ASSEMBLER
after  GOLDEN  is invoked!!!!!!!!!!!!!!!
\ Target compiler: who                    ( 19 12 87 CRC 17:13 )
: WHO DELTA + 2+ NFA ID. ;














\ Target compiler: : of/nf                ( 11 12 87 CRC 22:03 )
BASE @ HEX
: :   !CSP IN  @ ?EXEC CREATE-NEW
    IN ! HERE DELTA - *COLON* @ ,
    CREATE-OLD  ,  SMUDGE  SETNEW ] ;

NF: OF/NF [COMPILE] NEWFORTH DEFINITIONS [COMPILE] FORTH  NF;


\ ' NFQUIT 4- ' 'NF 40 + !
LATEST pfa lfa OFF      \ break linkage.
 BASE  !




\ Target compiler: nf: x -- [compile]     ( 11  7 86 CRC 11:41 )
BASE  @ HEX
NF: X BLK @    IF ?EXEC THEN R> DROP NF;
80 LATEST 1+ C!                 \ rename it "null"

NF: \ [COMPILE] \ NF;

NF: GAP     0 , NF;

NF: [COMPILE] [COMPILE] [FROM:NEWFORTH]  NF;
 BASE  !   ;S

NF: WHO DELTA + NFA ID.  NF;



\ Target compiler: nf: ;code -- ."        ( 13  5 86 CRC 15:01 )
BASE @ HEX
NF: ;CODE
     *(;CODE)* @ , HERE DELTA - -2  CSP +!    \ adjust csp
     [COMPILE] ASSEMBLER   [COMPILE] [  NF;
\  HERE  is left on the stack. The programmer MUST manually
\ insert it into the proper *xxxxx*  constant
\ e.g. : fred .... ;code ... next  mutates *fred*

\ NF: ASSEMBLER    ASSEMBLER                      NF;

NF: DOES>   *(;CODE)* @ ,  HERE DELTA -  -2 CSP +!  E8 C,
  *DOES>* @ DELTA +  HERE 2+ - , FORTH  NF;   \ in *xxx* consta
 \ absolute .long jsr,
NF: ."           *(.")* @ , [COMPILE]  TXT   NF;
 BASE  !   ;S
\ Target compiler: {         -- }         ( 16  1 87 CRC 18:59 )
NF: {  SETOLD   [COMPILE] FORTH     [COMPILE] [ NF;

NF: }  SETNEW ] [COMPILE] NEWFORTH              NF;

NF: <BUILDS 0 CONSTANT -2 ALLOT NF;

NF: ( [COMPILE] ( NF;

NF: FORTH                      NF;

NF: LITERAL  [COMPILE] LITERAL NF;

NF: SEE: SEE: NF;

NF: WHERE    OF/NF [COMPILE] WHERE   NF;    GOLDEN
\ Target compiler: nf: ;  -- while          09 03 83 CRC
BASE @ HEX
NF: ;      ?CSP NFCOMPILE ;S
     SMUDGE [COMPILE] FORTH [COMPILE] [ NF;
NF: THEN        HERE OVER - SWAP ! NF;
NF: BEGIN       HERE NF;
NF: DO          NFCOMPILE (DO) HERE NF;
NF: LOOP        NFCOMPILE (LOOP)  HERE - , NF;
NF: +LOOP       NFCOMPILE (+LOOP) HERE - , NF;
NF: UNTIL       NFCOMPILE 0BRANCH HERE - , NF;
NF: IF          NFCOMPILE 0BRANCH HERE 0 , NF;
NF: WHILE       NFCOMPILE 0BRANCH HERE 0 , NF;
 BASE  !   ;S
NF: ENDIF       HERE OVER - SWAP ! NF;


\ Target compiler: again  -- stop           09 03 83 CRC
BASE @ HEX
NF: AGAIN       NFCOMPILE BRANCH HERE - , NF;
NF: REPEAT SWAP NFCOMPILE BRANCH HERE - ,
             HERE OVER - SWAP ! NF;
NF: ELSE        NFCOMPILE BRANCH HERE 0 ,
        SWAP HERE OVER - SWAP ! NF;

NF: ASCII  BL WORD HERE 1+ C@ [COMPILE] LITERAL  NF;

NF: STOP    SMUDGE [COMPILE] FORTH [COMPILE] [ NF;
 BASE  !   ;S




\ assembler extensions for target compiler( 14  8 88 CRC  8:40 )
ASSEMBLER DEFINITIONS  BASE @ HEX
: NEXT    >>NEXT @     #) JMP,  ;
: 1PUSH   >>NEXT @ 1-  #) JMP,  ;
: 2PUSH   >>NEXT @ 2-  #) JMP,  ;
: 3PUSH   >>NEXT @ 3 - #) JMP,  ;










\ Target compiler: nf: ;  -- while          09 03 83 CRC
BASE @ HEX
NF: ;      ?CSP COMPILE  [FROM:NEWFORTH] ;S
     SMUDGE [COMPILE] FORTH [COMPILE] [ NF;
NF: THEN        HERE OVER - SWAP ! NF;
NF: BEGIN       HERE NF;
NF: DO          COMPILE [FROM:NEWFORTH] (DO) HERE NF;
NF: LOOP        COMPILE [FROM:NEWFORTH] (LOOP)  HERE - , NF;
NF: +LOOP       COMPILE [FROM:NEWFORTH] (+LOOP) HERE - , NF;
NF: UNTIL       COMPILE [FROM:NEWFORTH] 0BRANCH HERE - , NF;
NF: IF          COMPILE [FROM:NEWFORTH] 0BRANCH HERE 0 , NF;
NF: WHILE       COMPILE [FROM:NEWFORTH] 0BRANCH HERE 0 , NF;
 BASE  !   ;S
NF: ENDIF       HERE OVER - SWAP ! NF;


\ Target compiler: again  -- stop           09 03 83 CRC
BASE @ HEX
NF: AGAIN       COMPILE [FROM:NEWFORTH] BRANCH HERE - , NF;
NF: REPEAT SWAP COMPILE [FROM:NEWFORTH] BRANCH HERE - ,
             HERE OVER - SWAP ! NF;
NF: ELSE        COMPILE [FROM:NEWFORTH] BRANCH HERE 0 ,
        SWAP HERE OVER - SWAP ! NF;

NF: ASCII  BL WORD HERE 1+ C@ [COMPILE] LITERAL  NF;

NF: STOP    SMUDGE [COMPILE] FORTH [COMPILE] [ NF;
 BASE  !   ;S




































































































































































































































































































































































































































































\ debug file builder                      ( 12 12 87 CRC  9:48 )
filing setdrive: c:   setdir: \messdos\f83
14976 load   \ file building code
filing   createfile: rf.blk   closeit
filing   121 130  blockfile: rf.blk    closeit
." File is "  . ." bytes long."
file: rf rf.blk









  real-FORTH decompiler: messages           08 12 84 CRC
     Inline literal, value        = D
     Compiled inline string:
 in-line cfa                    = $
     User variable, current value = D
     Variable, current value      = D
     Constant = D
     Branch on 0 to:
     Unconditional branch to:
     Loop back to:
     +Loop back to:
     ?? Not in dictionary ??
 >>  Immediate  <<
  Disassembled:
  <primitive>
Address Opcode Operand Opcode Operand Mode ASCII
\ 80x86 Source Code: loader               ( 18  1 89 CRC 15:54 )
BASE @ >R       DECIMAL -61 +BLK NEEDED WORKSPACE
EDITOR FLUSH FORTH DEFINITIONS    TODAY  CHOP
SETOLD mf SETNEW   WARNING ON  DECIMAL
   2   10 +THRU   \ source from lit to sp!
 -35  -34 +THRU   \ compiler directives
\ 11   69 +THRU   \ source from (key) on, old overlays
  11   64 +THRU  101 105 +thru \ source from (key) on, new overl
(  73     +LOAD CR (  wdump)
\  CM SERIAL AND IFTRUE  95 98 +THRU  IFEND
SETOLD SETNEW    109 118 +THRU  \ forward references
TXT Copyright 1988-95 C. Curley"
      SETOLD CR mf HEX  DPNEW @ IMAGETOP OVER - ERASE
DECIMAL CR #BUFS . ." Buffers"  R> BASE !
CR EDITOR FLUSH   CHECKSUM

\ base-addr memory map                    ( 16 12 87 CRC 22:43 )
all addresses are offset from base-addr
addr   count   comment
   0       4   jump to cold start
   4       4   jump to warm start
  08       4   "I808X" in radix 36, per fig model
  0C       2   nfa of top of dictionary. Why, I don't know.
  0E       2   backspace characters. Usually 7F & 08
  10       2   user area base address
  12       2   top of parameter stack; orphaned user  S0
  14       2   top of return stack
  16      32   initial values for user variables


      All code which changes segments must restore them.

\ 80x86 : boot parameters area  rot       ( 12  8 88 CRC 16:16 )
SERIAL CM AND IFTRUE  DECIMAL 83 HEX +LOAD   OTHERWISE
  100 DELTA + DP !     SETORG      IFEND  HERE BOOTS !
ASSEMBLER     NOP, 8000 #) JMP, \ cold start, patched later
cr .s         NOP, 8000 #) JMP, \ warm start, patched later
   D301 , 4105 ,      0 ,        7F C, 08 C,     cr .s
\ I808X radix 36   dict top   backspace chrs
3C == COLDS  HERE     ASSEMBLER COLDS 4 - ALLOT
HERE OVER - ERASE

CODE ROT   DX POP,   BX POP,    AX POP,  ( LABEL BPUSH )
  BX PUSH, ( LABEL DPUSH) DX PUSH, ( LABEL APUSH ) AX PUSH,

LABEL >NEXT   AX LODS,  AX W MOV,  0 [W] JMP,

>NEXT ( DELTA +) >>NEXT !                          ;C
\ 80x86 : lit clit ;s drop dup over       ( 24  3 88 CRC 18:12 )
CODE LIT                          AX LODS, 1PUSH  ;C
       'NF LIT   CFA    MUTATES *LIT*

CODE CLIT    ( -- n )      AL LODS,  CBW,  1PUSH  ;C
       'NF CLIT  CFA    MUTATES *CLIT*

CODE ;S   0 [RP] IP MOV,  RP INC,  RP INC,  NEXT  ;C

CODE DROP                          AX POP,  NEXT  ;C

CODE SWAP                DX POP,  AX POP,  2PUSH  ;C

CODE DUP                AX POP,  AX PUSH,  1PUSH  ;C

CODE OVER      DX POP,  AX POP,  AX PUSH,  2PUSH  ;C
\ 80x86 : branch 0branch (of) (loop)      ( 24  3 88 CRC 18:02 )
CODE BRANCH   LABEL BRAN   0 [IP] IP ADD,  NEXT END-CODE
CODE 0BRANCH  ( ?? )    AX POP,  AX AX OR,  BRAN delta + JE,
  LABEL NOBRAN IP INC,  IP INC,  NEXT END-CODE

CODE (OF)  ( ?? ) AX POP,  BX POP,  AX BX CMP,
  NOBRAN delta + JE,  BX PUSH,  BRAN delta + JNE,  ;C

CODE (LOOP)  ( ?? )  1 # AX MOV,  LABEL LP1 AX 0 [RP] ADD,
  LABEL LP2   2 [RP] W MOV,  0 [RP] W CMP,  BRAN delta + JG,
  LABEL LP5   4 # RP ADD,  NOBRAN #) JMP, ;C

CODE EXECUTE   W POP,   0 [W] JMP, END-CODE



\ 80x86 : (+loop) (do) (pause) paws       (  1  1 88 CRC 21:51 )
CODE (+LOOP)  AX POP,   AX 0 [RP] ADD,  8000 # AX TEST,
  LP2 delta + JE,  2 [RP] W MOV,  0 [RP] W CMP,
  LP5 delta + JGE,   BRAN #) JMP,   ;C

CODE (DO)  AX POP,  RP DEC,  RP DEC,  0 [RP] POP,
  ( ??) RP DEC,  RP DEC,  AX 0 [RP] MOV,  NEXT ;C
  ;s   \ call to pause current task.
LABEL (PAUSE)  RP 4 U &[ MOV, ( BEGIN,)  8 U &[ U MOV,
 ( U [ TST,  NE UNTIL,)  4 U &[ RP MOV,  RTS,
  \ call from i/o code definitions inside loops
LABEL PAWS   IP RP -[ MOV,  S RP -[ MOV,
             (PAUSE) *+ BSR,   \ execution resumes here
             RP [+ S MOV,  RP [+ IP MOV,  RTS,


\ 80x86 : i digit pause                   ( 30 12 87 CRC 20:12 )
   \ or expand it out
\ CODE PAUSE  PAWS *+ BSR, NEXT   ;C
        \ temp while we're single tasking.
CODE PAUSE  >>NEXT @          here 2- !  ;C

CODE I                                                       ;C

LABEL FAIL   AX AX SUB,  1PUSH

CODE DIGIT  ( ?? )   ( char base -- n f )
  DX POP,  AX POP,  ASCII 0 # AL SUB,  FAIL delta + JB,
  9 # AL CMP,  > IF,  11 # AL CMP,  FAIL delta + JB,
                 7 # AL SUB,  THEN,
  DL AL CMP,  FAIL delta + JAE,  AL DL MOV,
  TRUE # AX MOV,  2PUSH END-CODE
\ 80x86 : (find)                          ( 18  2 88 crc  9:53 )
CODE (FIND)   W POP,  DI POP,  IP PUSH,  DH DH SUB,
  BEGIN,  DI SI MOV,  0 [W] AL MOV,  0 [SI] AL XOR,
    3F # AL AND,  0= IF,  0 [W] DL MOV,
      BEGIN,  W INC,  SI INC,  0 [W] AL MOV,  0 [SI] AL XOR,
        0<> UNTIL,  7F # AL AND,
      0= IF,  SI POP,  5 # W ADD,  W PUSH,
        1 # AX MOV,  2PUSH
        >R >R THEN,  W INC,  R> R> THEN,  W SI MOV,
    BEGIN,  AL LODS,  80 # AL AND,  0<> UNTIL,
    0 [IP] W MOV,  W W OR,  0= UNTIL,
  SI POP,  W AX MOV,  1PUSH             ;C




















\ 80x86 : enclose                         ( 20  2 89 CRC 10:08 )
  \ addr$ char ---  addr$ off3 off2 off1
CODE ENCLOSE  AX POP,  6 # SP SUB,  SP DI MOV,
  6 [DI] BX MOV,  BX DEC,
  BEGIN,  BX INC,  0 [BX] AL CMP,  0<> UNTIL,
  BX 4 [DI] MOV,  BX DEC,

LABEL ENCL2  BX INC,  0 # 0 [BX] .B CMP,  0<> IF,
  0 [BX] AL CMP,  ENCL2 delta + JNE,
  BX INC,  BX 0 [DI] MOV,  BX DEC,

LABEL ENCL3  BX 2 [DI] MOV,  6 [DI] AX MOV,
  AX 0 [DI] SUB,  AX 2 [DI] SUB,  AX 4 [DI] SUB,  NEXT

  THEN,  BX 0 [DI] MOV,  BX 4 [DI] CMP,  ENCL3 delta + JNE,
  BX INC,  ENCL3 #) JMP,                ;C
\ 80x86 : @execute exec sp@ sp!           (  1  5 88 CRC 17:53 )
CODE @EXECUTE  0 [RP] IP MOV,  RP INC,  RP INC,
               W POP,  0 [W] W MOV,  0 [W] JMP, C;
'NF @EXECUTE CFA  MUTATES *@EXEC*

CODE EXEC   AX POP,  AX SHL,   AX IP ADD,  0 [IP] W MOV,
  0 [RP] IP MOV,  RP INC,  RP INC,   0 [BX] JMP,   ;C

CODE SP!   UP T#) BX MOV,  6 [BX] SP MOV,  NEXT ;C

CODE SP@   SP AX MOV, 1PUSH END-CODE

'NF 0BRANCH CFA  MUTATES *0BRAN*
'NF BRANCH  CFA  MUTATES *BRAN*
'NF ;S      CFA  MUTATES *;S*
'NF (LOOP)  CFA  MUTATES *(LOOP)*
\ 80x86 : (emit) (key) (?terminal) mon    ( 19  8 90 CRC 11:31 )
SERIAL  IFTRUE  DECIMAL 204 CM + LOAD OTHERWISE
LABEL EMASK  7F C,
CODE (EMIT)  2 # AH MOV,  DX POP,
             EMASK T#) DL AND,  ( temp) 21 INT,    NEXT  C;

CODE (KEY)   7 # AH MOV,  21 INT,  AH AH SUB,  1PUSH  C;

CODE (?TERMINAL)  0B # AH MOV,  21 INT,  AL INC,
  0= IF,  7 # AH MOV,  21 INT,  1 # AX MOV,  ELSE,
  AX AX SUB,  THEN,  1PUSH                            C;

CODE MON      AX AX SUB,  AX DX MOV,  21 INT,  C;
IFEND


\ 80x86 : cmove 0= 0< > <                 ( 20  2 89 CRC 10:07 )
CODE CMOVE   CS PUSH,  ES POP,  IP BX MOV,
  CX POP,  DI POP,  IP POP,
  REP, .B MOVS,  BX IP MOV,  NEXT END-CODE

ASSEMBLER  LABEL YES     TRUE # AX MOV,   1PUSH
\          LABEL NO      AX AX SUB,  1PUSH
CODE 0=   AX POP,  AX AX OR,  YES delta + JE,  FAIL #) JMP, ;c

CODE 0<   AX POP,  AX AX OR,  YES delta + JS,  FAIL #) JMP, ;c

CODE >   (  n1 n2 -- f )
  AX POP,  BX POP,  AX BX CMP,  YES delta + JG, FAIL #) JMP, ;c

CODE <
  AX POP,  BX POP,  AX BX CMP,  YES delta + JL, FAIL #) JMP, ;c
\ 80x86 : = u< 2drop u*                   ( 24  3 88 CRC 18:05 )
CODE =
  AX POP,  BX POP,  AX BX CMP,  YES delta + JE,  FAIL #) JMP, ;c

CODE U<      ( n1 n2 -- f )
  AX POP,  BX POP,  AX BX CMP,  YES delta + JB,  FAIL #) JMP, ;c

CODE 2DROP  AX POP,  AX POP,  NEXT  ;C

CODE U*      ( n1 n2 -- d )
  AX POP,  BX POP,  BX MUL,  DX AX XCHG,  2PUSH END-CODE





\ 80x86 : u/ 2+ 1+                        ( 19 12 87 CRC  8:47 )
CODE U/   ( d1 n1 -- Remainder Quotient )
  BX POP,  DX POP,  AX POP,  BX DX CMP,  U>=  \ divide by zero?
  IF,  -1 # AX MOV,  AX DX MOV,  ELSE,  BX DIV,  THEN,  2PUSH
  END-CODE


CODE 1+    AX POP,  AX INC,  1PUSH END-CODE

CODE 2+    AX POP,  AX INC,  AX INC,  1PUSH END-CODE






\ 80x86 : and or xor rp! leave >r r> r    ( 15  7 93 CRC  8:50 )
CODE AND   BX POP,  AX POP,  BX AX AND,  1PUSH END-CODE

CODE OR    BX POP,  AX POP,  BX AX OR,   1PUSH END-CODE

CODE XOR   BX POP,  AX POP,  BX AX XOR,  1PUSH END-CODE

CODE RP!   UP T#) BX MOV,  8 [BX] RP MOV,  NEXT ;C

CODE LEAVE  0 [RP] AX MOV,  AX 2 [RP] MOV,  NEXT ;C

CODE >R   RP DEC,  RP DEC,  0 [RP] POP,  NEXT  ;C

CODE R>   0 [RP] PUSH,  RP INC,  RP INC,  NEXT  END-CODE

CODE R    0 [RP] PUSH,                          NEXT     ;C
\ 80x86 : + - d+                          ( 16 12 87 CRC 23:07 )
CODE +   BX POP,  AX POP,  BX AX ADD,  1PUSH END-CODE

CODE -   BX POP,  AX POP,  BX AX SUB,  1PUSH END-CODE

CODE D+  ( d1 d2 -- dsum )
  AX POP,  DX POP,  BX POP,  CX POP,  CX DX ADD,  BX AX ADC,
  2PUSH END-CODE








\ 80x86 : minus dminus s->d               (  4  4 90 CRC 19:43 )
CODE MINUS   AX POP,  AX NEG,  1PUSH END-CODE

CODE DMINUS   BX POP,  CX POP,  AX AX SUB,  AX DX MOV,
  CX DX SUB,  BX AX SBB,  2PUSH END-CODE

CODE S->D   AX POP,  CWD,  AX PUSH,  DX PUSH, NEXT  END-CODE



;S
CODE S->D   AX POP,  CWD,  AX DX XCHG,  2PUSH   END-CODE




\ 80x86 : -dup 2dup +! toggle             ( 19 12 87 CRC  9:04 )
CODE -DUP   AX POP,  0 # AX CMP,
  0<> IF,  AX PUSH,  THEN,  1PUSH END-CODE

CODE 2DUP   AX POP,  DX POP,  DX PUSH,  AX PUSH,  2PUSH ;C

CODE +!   BX POP,  AX POP,  AX 0 [BX] ADD,  NEXT END-CODE

CODE TOGGLE   AX POP,  BX POP,   AX 0 [BX] XOR,  NEXT ;C

;S
CODE WITHIN  \ n l1 l2 --- fl | is n between lim1 & lim2 incl.?
 1 # DR0 MOVQ,  S [+ DR1 MOV,   S [+ DR2 MOV,
 S [ DR1 CMP,  LT IF,  DR0 CLR,  THEN,
 S [ DR2 CMP,  GT IF,  DR0 CLR,  THEN,  DR0 S [ MOV,  NEXT ;C

\ 80x86 : @ c@ !                          ( 19 12 87 CRC  9:39 )
CODE @     (  addr -- n )
   BX POP,  0 [BX] PUSH,  NEXT END-CODE

CODE C@     (  addr -- char )
   BX POP,  AX AX SUB,  0 [BX] AL MOV,  1PUSH END-CODE

CODE !     (  n addr -- )
   BX POP,  0 [BX] POP,  NEXT END-CODE







\ 80x86 : c!    2- 1- on off 1+!          ( 19 12 87 CRC  9:41 )
CODE C!   BX POP,  AX POP,  AL 0 [BX] MOV,  NEXT END-CODE

CODE 2-   AX POP,  AX DEC,  AX DEC,  1PUSH END-CODE

CODE 1-   AX POP,  AX DEC,  1PUSH END-CODE

CODE ON   BX POP,  1 # 0 [BX] MOV,  NEXT END-CODE

CODE OFF   BX POP,  0 # 0 [BX] MOV,  NEXT END-CODE

CODE 1+!   BX POP,  0 [BX] INC,  NEXT END-CODE




















\ 80x86 : m* pick 2swap                   (  2  1 88 CRC 12:48 )
CODE M*
  AX POP,  BX POP,  BX IMUL,  AX push,  dx PUSH, next  END-CODE

CODE PICK    ( nm ... n2 n1 k -- nm ... n2 n1 nk )
  BX POP,  BX SHL,  SP BX ADD,  -2 [BX] AX MOV,  1PUSH END-CODE

CODE 2SWAP   ( d1 d2 -- d2 d1 )
  BX POP,  CX POP,  AX POP,  DX POP,  CX PUSH,  3PUSH  END-CODE

;S
CODE M*
  AX POP,  BX POP,  BX IMUL,  DX AX XCHG,  2PUSH END-CODE



































\ 80x86 : : ; constant variable           (  4  4 88 CRC 17:37 )
: :     GAP  ( ?exec) GAP ( !csp) GAP ( current)  @
        GAP  ( context)  !  GAP  ( create)  GAP  (  ] )
   ;CODE  W INC,  W INC,  RP DEC,  RP DEC,
   IP 0 [RP] MOV,  W IP MOV, NEXT ;C   IMMEDIATE
MUTATES *COLON*
: ;   GAP ( ?csp) GAP ( compile) ;S GAP ( smudge)
      GAP ( [ ) ;                                     IMMEDIATE

: CONSTANT  GAP ( create) GAP ( smudge) GAP ( , )
   ;CODE  2 [W] PUSH,  NEXT  ;C         MUTATES *CONSTANT*

: VARIABLE  CONSTANT  ;CODE
  W INC,  W INC,  W PUSH,  NEXT  ;C     MUTATES *VARIABLE*


\ 80x86 : user some constants +origin     (  4  4 88 CRC 17:38 )
: USER   CONSTANT
  ;CODE  2 [W] AX MOV,  UP T#) AX ADD,  1PUSH END-CODE
  MUTATES *USER*

    5 CONSTANT 5              40 CONSTANT C/L
    0 CONSTANT 0               1 CONSTANT 1
    2 CONSTANT 2               3 CONSTANT 3
    4 CONSTANT 4              20 CONSTANT BL

*B/BUF*  CONSTANT B/BUF   400 *B/BUF* / CONSTANT B/SCR

CODE +ORIGIN  AX POP,
  0 +BOOTS # AX ADD, 1PUSH ;C


\   11  Source Code: tib    -  'limit       13 12 84 CRC
    |   6 USER S0
       0A USER TIB                0C USER WIDTH
       0E USER WARNING            10 USER FENCE
       12 USER DP                 14 USER VOC-LINK
       16 USER 'KEY               18 USER 'EXPECT
       1A USER '?TERMINAL         1C USER 'EMIT
       1E USER 'TYPE              20 USER 'GOTOXY
       22 USER 'PAGE              24 USER 'LIST
       26 USER 'CR
       28 USER 'R/W               2A USER 'QUIT
       2C USER 'ABORT             2E USER 'CREATE
       30 USER 'FIRST             32 USER 'LIMIT
     ( 34 dummy for vocabs )   |  36 USER VLFTH
     ( 38 dummy for vocabs )   |  3A USER BOTSTACK           ;S
  leave gap to 40 for expansion of initialised user variables
\   11  Source Code: blk    -  first      ( 15  2 87 CRC 14:12 )
   40 USER BLK                42 USER IN
   44 USER OUT                46 USER SCR
   48 USER OFFSET             4A USER CONTEXT
   4C USER CURRENT            4E USER STATE
   50 USER BASE               52 USER DPL
   54 USER FLD                56 USER CSP
   58 USER R#                 5A USER HLD
   5C USER USE                5E USER PREV

\ |  60 USER CURSEG          |  62 USER MEMPTR    \ scr 187
\ |  60 USER >MEM            |  62 USER +HEAD     \ scr 222
: FIRST   'FIRST   @  ;         : LIMIT   'LIMIT   @  ;



\ 80x86 : here allot , c, term i/o        (  4  4 90 CRC 19:44 )
CODE HERE   UP T#) BX MOV,  OFUSER DP PUSH,  NEXT  C;

: ALLOT  ( n -- )      DP +!   ;
CODE ,   UP T#) BX MOV,  OFUSER DP AX MOV,             \  here
  2 # OFUSER DP ADD,                                   \ 2 allot
  AX BX MOV,              0 [BX] POP,  NEXT END-CODE   \ !
CODE C,   UP T#) BX MOV,
  OFUSER DP AX MOV,  OFUSER DP INC,
  AX BX MOV,  CX POP,  CL 0 [BX] MOV,  NEXT END-CODE   \ c!

: KEY             PAUSE  'KEY       @EXECUTE    STOP
: EMIT   OUT 1+!  PAUSE  'EMIT      @EXECUTE    STOP
: PAGE                  'PAGE @ EXECUTE  OUT OFF ;
: CR                    'CR   @ EXECUTE  OUT OFF ;
: R/W        PAUSE  'R/W       @EXECUTE    STOP
\ 80x86 : traverse latest pfa             (  4  4 90 CRC 19:45 )
: ?TERMINAL  PAUSE  '?TERMINAL @EXECUTE    STOP

LABEL (TRAV)   BEGIN,  CX BX ADD,  80 # 0 [BX] .B TEST,
  0<> UNTIL,  RET,
CODE TRAVERSE  CX POP,  BX POP,  (TRAV) #) CALL,  BX PUSH,
  NEXT  ;C

: LATEST CURRENT @ @ ;

: LFA   2- 2- ;                CODE CFA   ;C

CODE PFA   1 # CX MOV,  BX POP,  (TRAV) #) CALL,
  5 # BX ADD,  BX PUSH, NEXT                         ;C
CODE NFA   -1 # CX MOV,  BX POP,  5 # BX SUB,
  (TRAV) #) CALL,  BX PUSH,  NEXT                   ;C
\ 80x86 : space (page) ?align             ( 19 12 87 CRC 11:43 )
: SPACE    BL EMIT  ;

: (PAGE)   0C EMIT  ;

\ : ?ALIGN  ;    immediate


























\ 68000 : !csp ?error ?comp ?exec ?loading( 15  2 86 CRC       )
: !CSP      SP@ CSP ! ;

: ?ERROR    SWAP IF GAP   ( error) ELSE DROP THEN ;

: ?COMP     STATE @ 0=   11 ?ERROR ;

: ?EXEC     STATE @      12 ?ERROR ;

: ?PAIRS    -  13 ?ERROR ;

: ?CSP      SP@ CSP @ - 14 ?ERROR ;

: ?LOADING  BLK @ 0= 16 ?ERROR ;


\ 68000 : compile [ smudge hex bounds     ( 12  2 87 CRC 17:15 )
: COMPILE    ?COMP  R> DUP 2+ >R @ , ;

: [          STATE OFF ;  IMMEDIATE

: ]          C0 STATE ! ;

: SMUDGE     LATEST BL TOGGLE ;

: HEX        10 BASE ! ;          : DECIMAL    0A BASE ! ;

: BOUNDS  OVER + SWAP ;




\ 80x86 : fill erase within abort quit    ( 20  2 89 CRC 10:37 )
CODE FILL  AX POP,  CS PUSH,  (  start-addr count char -- )
  ES POP,  CX POP,  DI POP,  REP,  AL STOS,  NEXT C;

CODE ERASE   AX AX SUB,    'NF FILL CFA 3 + #) JMP, C;

CODE BLANKS  20 # AX MOV,  'NF FILL CFA 3 + #) JMP, C;

: WITHIN   ( n1 min max -- f ) >R  OVER > SWAP R> > OR 0= ;

: QUIT   'QUIT  @EXECUTE STOP   'NF QUIT  CFA MUTATES *QUIT*

: ABORT  'ABORT @EXECUTE STOP   'NF ABORT CFA MUTATES *ABORT*

: TYPE   'TYPE  @EXECUTE STOP

\ 80x86 : (;code) <builds does>           ( 19 12 87 CRC 16:01 )
: (;CODE) R> LATEST PFA CFA ! ;
        'NF (;CODE) CFA MUTATES *(;CODE)*

: <BUILDS   0 CONSTANT -2 ALLOT ;   \ new <builds ... does>
HERE DELTA - MUTATES *DOES>* ?CR

LABEL DODOES
  SP RP XCHG,  IP PUSH,  SP RP XCHG,  IP POP,
  W INC,  W INC,  W PUSH,  NEXT

: DOES>  COMPILE (;CODE)
  { ASSEMBLER DODOES NEWFORTH } LITERAL E8 C,
  HERE 2+ - ,   ; IMMEDIATE         \ absolute .long jsr,


\ 80x86 : count (type) -trailing (.") (cr)(  8  3 88 CRC 17:44 )
CODE COUNT   \  DUP 1+ SWAP C@ ;
   BX POP,  AX AX SUB,  0 [BX] AL MOV,  BX INC,  BX PUSH,
   1PUSH END-CODE

\ : (TYPE) -DUP IF BOUNDS DO R C@ EMIT LOOP  ELSE DROP THEN ;
: (TYPE)   -DUP  IF  0  DO  DUP I + C@ EMIT  LOOP  THEN  DROP ;
CODE -TRAILING   BX POP,  DI POP,  20 # AL MOV,
 BEGIN,  AL -1 [DI+BX] CMP,
     0= IF, >R >R  BX DEC,  0= UNTIL,  R> R> THEN,
  DI PUSH,  BX PUSH,  NEXT        ;C

: (.") R COUNT DUP 1+ R> + >R TYPE ;
   'NF (.")           CFA  MUTATES *(.")*

: (CR)  ."   " ;
\ 68000 : ." (expect) expect query        ( 13  4 86 CRC       )
: ." ASCII "  STATE @
     IF COMPILE (.") GAP ( word)  HERE C@ 1+ ALLOT
     ELSE GAP ( word) HERE COUNT TYPE THEN ;          IMMEDIATE

: (EXPECT) OVER + OVER          \ add for atari/ibm pc keyboard
     DO KEY DUP 0E +ORIGIN C@ =   OVER 0F +ORIGIN C@ = OR
        IF DROP 08 OVER R = DUP R> 2- + >R - ELSE
          DUP 0D = IF LEAVE DROP BL 0 ELSE  DUP THEN R C!
        0 R 1+ C! THEN   EMIT ( DROP)  LOOP     DROP ;

: EXPECT  PAUSE 'EXPECT  @EXECUTE  STOP

: QUERY TIB @ 50  EXPECT  IN OFF  ;


\ 68000 : x hold pad word (number)        ( 12  2 87 CRC 17:20 )
: X       BLK @ IF ?EXEC THEN R> DROP ;         IMMEDIATE
: HOLD    -1 HLD +!  HLD @ C! ;
: PAD     HERE 44 + ;
                          \  gap = block
: WORD BLK @ IF BLK @  GAP  ELSE  TIB @ THEN IN @ + SWAP
  ENCLOSE HERE 22 BLANKS IN +! OVER - >R  R HERE C!
  + HERE 1+ R> CMOVE ;
CODE UPPER   \ addr ct ---  | force to upper case
  CX POP,  BX POP,  ASCII z 1+  8 2*S  ASCII a 1-  OR # DX MOV,
  DO,  0 [BX] AL MOV,  AL DL CMP,
     U< IF,  AL DH CMP,  U> IF,  20 # 0 [BX] .B XOR,
     THEN,  THEN,  BX INC,  LOOP,  NEXT       ;C
: (NUMBER) BEGIN 1+ DUP >R C@ BASE @ DIGIT
  WHILE SWAP BASE @ U* DROP ROT BASE  @ U* D+
       DPL @ 1+ IF DPL 1+! THEN R> REPEAT R> ;
\ 68000 : number -find error id.          ( 29  5 86 CRC 17:14 )
: NUMBER 0 0 ROT DUP 1+ C@ ASCII - = DUP >R + -1
  BEGIN DPL ! (NUMBER) DUP C@ BL -
      WHILE DUP C@ ASCII . - 0 ?ERROR 0 REPEAT
  DROP R> IF DMINUS THEN ;

: -FIND BL WORD HERE COUNT UPPER HERE CONTEXT @ @ (FIND)
  DUP 0= IF DROP HERE LATEST (FIND) THEN ;

: ERROR   WARNING @ 0<
  IF ABORT THEN HERE COUNT TYPE ."  ? "
  GAP ( message) SP!  BLK @ IF IN @ BLK @ THEN
  QUIT                                STOP

: ID. PAD BL ASCII _ FILL DUP PFA LFA OVER -
     PAD SWAP CMOVE PAD COUNT 1F AND TYPE SPACE ;
\ 68000 : b/drv maxblk drive empty-buffers(  3  2 88 CRC 17:21 )
DECIMAL
3.5" IFTRUE                 \  720 k 3.5" floppies
720 CONSTANT B/DRV              1439 CONSTANT MAXBLK   IFEND

5.25"  SERIAL OR  FILES OR  IFTRUE    \  360 k 5.25" floppies
360 CONSTANT B/DRV               719 CONSTANT MAXBLK   IFEND

: DRIVE  B/DRV U* DROP OFFSET ! ;

: SETU/P    FIRST DUP USE !  PREV ! ;

: EMPTY-BUFFERS FIRST LIMIT OVER - ERASE SETU/P ;



\ 80x86 : create {compile] literal +buf up(  3  4 90 CRC 20:30 )
: CREATE  'CREATE   @EXECUTE     STOP

: [COMPILE] -FIND 0= 0 ?ERROR DROP CFA , ;            IMMEDIATE

: LITERAL   ( n -- )
  STATE @ IF  DUP -80 7F WITHIN  IF
  COMPILE  CLIT C,  ELSE  COMPILE LIT ,  THEN THEN ;  IMMEDIATE

CODE UPDATE    UP T#) BX MOV,  OFUSER PREV DI MOV,
  8000 # 0 [DI] OR,  NEXT   ;C

CODE +BUF   UP T#) BX MOV,   AX POP,  B/BUF 4 + # AX ADD,
  OFUSER 'LIMIT AX CMP,  0= IF,  OFUSER 'FIRST AX MOV,  THEN,
  AX PUSH,  OFUSER PREV AX SUB,  1PUSH  ;C

\ 68000 : dliteral ?stack interpret immed   26  2 85 CRC
: DLITERAL  STATE @ IF SWAP [COMPILE] LITERAL
        [COMPILE] LITERAL  THEN ;                   IMMEDIATE

: ?STACK  S0 @ SP@            U< 1 ?ERROR
               SP@ BOTSTACK @ U< 7 ?ERROR ;
\ fixed so that tos & bos are user variables for multitasking

: INTERPRET   BEGIN -FIND  IF  ( found) STATE @ <
        IF CFA , ELSE  CFA EXECUTE THEN
        ELSE HERE NUMBER  DPL @ 1+
        IF [COMPILE] DLITERAL ELSE DROP [COMPILE] LITERAL THEN
        THEN ?STACK AGAIN     STOP

: IMMEDIATE LATEST C/L TOGGLE ;

\ 68000 : vocabulary forth definitions (  ( 12  2 87 CRC 17:27 )
: VOCABULARY <BUILDS  A081   , CURRENT @ CFA ,
       HERE VOC-LINK @ , VOC-LINK ! DOES>
       2+ CONTEXT ! ;
MUTATES *VOCAB*         ( Romable vocabulary !!!!!)

: FORTH  VLFTH CONTEXT  ! ;                           IMMEDIATE

: DEFINITIONS  CONTEXT @ CURRENT ! ;

: (  ASCII ) WORD      ;                              IMMEDIATE

;s
CODE ?DR   \ -- n | return current active drive

  NEXT ;C
\ 80x86 : back (quit) (abort)             (  2  7 88 CRC 16:05 )
DECIMAL \ patch today's date into (abort). automated version ctl
(DATE)  BLK @ BLOCK  555 + SWAP CMOVE  UPDATE
: BACK      HERE - , ;

: (QUIT)   BLK OFF [COMPILE] [  BEGIN BEGIN
  RP! CR QUERY INTERPRET  STATE @ 0= UNTIL ."  OK" AGAIN STOP

: (ABORT) SP! DECIMAL CR ." real-FORTH 1.3 24 12 19"
   [COMPILE] FORTH  DEFINITIONS  OFFSET OFF   QUIT  STOP

SERIAL 0= IFTRUE DECIMAL 209  LOAD   IFEND
FILES IFTRUE  DECIMAL 210 211 THRU   IFEND



\ 80x86 : iob +iob emp startup            ( 14  2 95 CRC 17:01 )
| -1 VARIABLE EMPT  \ should be a constant when we rom

LABEL  STRTUP  ." strtup = " STRTUP 6 U.R

FILES IFTRUE            FILENAME 1+
} SP! EMPT @ IF EMPT OFF EMPTY-BUFFERS THEN   SETU/P
  LITERAL     OPENIT  ABORT {
ASSEMBLER LABEL SEGMENT 0 ,     FORTH
                                       OTHERWISE

} SP! EMPT @ IF EMPT OFF EMPTY-BUFFERS THEN   SETU/P
                     ABORT {
                                      IFEND


\ 80x86 : setsup                          ( 20  2 89 CRC 10:09 )
LABEL SETSUP
  10 +BOOTS T#) DI MOV,              \ set destination
  DI UP T#) MOV,                     \ set user area pointer
  0C +BOOTS # IP MOV,                \ from addr
  CLD,

\ move user area stuff out from cold start area
  REP,  .B MOVS,

  STRTUP # IP MOV,  RET,  \ execute cold start orphan

;s   register usage:
  cx -- count of bytes to move
  di -- destination
  ip -- source
\ user pointer table                      ( 29 12 87 CRC 20:54 )
label useraddrs
getups













\ 80x86 : Memory setup                    (  9  3 88 CRC 20:41 )
     \ do setup for memory here. Return highest addr in dr0
LABEL SETSTUF                       \ top of available memory
SERIAL IFTRUE   FE00 # AX MOV,   OTHERWISE
     6 T#) AX MOV,   0 # AL MOV,  IFEND
  AX DX MOV,  \ save for user area patches
  0 +BOOTS T#) BX LEA,
  TM   TOS - #  AX  SUB,           AX 12 [BX] MOV, \ tos
  TOS  BOT - #  AX  SUB,           AX 46 [BX] MOV, \ bos
  BOT  RTS - #  AX  SUB,           AX 14 [BX] MOV, \ rts
  RTS TIBX - #  AX  SUB,           AX 16 [BX] MOV, \ tib
  US #  AX  SUB,  AX CX   MOV,     AX 10 [BX] MOV, \ uarea
  'NF VLFTH CFA 2+  T@ 2+ #  AX  ADD,  \ get offset into user
  ( of forth vocab )               AX 20 [BX] MOV, \ voc-link
  100        #  CX  SUB,           CX 3E [BX] MOV, \ limit
  CO         #  CX  SUB,           CX 3C [BX] MOV, \ first
\ register usage for setstuf              (  4  4 90 CRC 20:11 )
  2 # DX SUB,    USERADDRS T#) IP LEA,
  BEGIN,  AX LODS,  0 # AX CMP,  0<>  WHILE,
     AX BX MOV,  DX 0 [BX] MOV,  REPEAT,
  RET, ;S

  2 # DX SUB,    USERADDRS T#) BP LEA,
  BEGIN,  0 [BP] BX MOV,  0 # BX CMP,  0<>  WHILE,
     2 # BP ADD,  DX 0 [BX] MOV,  REPEAT,
  RET, ;S

for this & last screen:
 bx -- point to base parameter area
 cx -- top of memory
 ax -- calculated value

















\ 80x86 : cold                            (  4  3 95 CRC 16:18 )
CODE COLD    LABEL COLDSTART
  CS AX MOV,  AX DS MOV,  AX ES MOV,  AX SS MOV,
SERIAL IFTRUE  100 T#) SP LEA,  IFEND
  SETSTUF #) CALL,  COLDS # CX MOV,
  ( *!*) HERE DELTA - D +  CM SERIAL AND 4 * + #) JMP,

LABEL WARM   10 # CX MOV,
  CS AX MOV,  AX DS MOV,  AX ES MOV,  AX SS MOV,
 FILES IFTRUE  CS SEGMENT T#) MOV,  IFEND
SERIAL IFTRUE  100 T#) SP LEA,  IFEND
  ( *!* )  SETSUP #) CALL,
  'NF RP! CFA T@ #) JMP, ;C

;s
CX contains the number of words moved into the user area.
\ 80x86 : +buf update                     (  3  4 90 CRC 20:30 )
;S   moved to 163 so the UP initialisation in COLD will work

CODE UPDATE    UP T#) BX MOV,  OFUSER PREV DI MOV,
  8000 # 0 [DI] OR,  NEXT   ;C

CODE +BUF   UP T#) BX MOV,   AX POP,  B/BUF 4 + # AX ADD,
  OFUSER 'LIMIT AX CMP,  0= IF,  OFUSER 'FIRST AX MOV,  THEN,
  AX PUSH,  OFUSER PREV AX SUB,  1PUSH  ;C

;S
: +BUF   B/BUF 4 + + DUP LIMIT = IF DROP FIRST THEN
       DUP PREV @ - ;

: UPDATE  PREV @ @ 8000 OR PREV @ ! ;

\ 68000 : arithmetic stuff -- +- to mod   ( 22  5 86 CRC 16:56 )
: +-      0< IF  MINUS THEN ;
: D+-     0< IF DMINUS THEN ;
: ABS     DUP  +-  ;
: DABS    DUP D+-  ;
: MIN     2DUP      > IF SWAP THEN DROP ;

: MAX     2DUP      < IF SWAP THEN DROP ;


: M/      OVER >R >R DABS
              R ABS U/ R> R XOR +- SWAP R> +- SWAP ;
: *       U* DROP ;
: /MOD    >R S->D R> M/ ;
: /       /MOD SWAP DROP ;
: MOD     /MOD      DROP ;
\ 68000 : more arithmetic, number output  ( 18  6 86 CRC 11:13 )
: */MOD   >R M* R> M/ ;
: */      */MOD SWAP DROP ;
: M/MOD   >R 0 R U/ R> SWAP >R U/ R> ;
: SPACES  0 MAX -DUP IF 0 DO SPACE LOOP THEN ;
: <#      PAD   HLD ! ;              \ must be moi to use w/
: #>      2DROP HLD @ PAD   OVER - ; \ wp-forth &/or tasker !!!!
: SIGN    ROT 0< IF ASCII - HOLD THEN ;
: #   BASE @ M/MOD ROT 9 OVER < IF 7 + THEN ASCII 0 + HOLD ;

: #S      BEGIN # 2DUP OR 0= UNTIL ;
: D.R     >R SWAP  OVER  DABS  <#  #S  SIGN #>
          R> OVER  -  SPACES  TYPE ;
: D.      0 D.R SPACE ;
: .R      >R S->D R> D.R ;      : .       S->D D. ;
: ?       @ . ;                 : C?      C@ . ;
\ 68000 : vlist buffer                    ( 13  4 86 CRC       )
: VLIST   CR  CONTEXT @  @
     BEGIN OUT @ C/L >   IF  CR THEN
        DUP ID. SPACE SPACE PFA  LFA  @
        DUP 0=  ?TERMINAL OR UNTIL   DROP            ;

: BUFFER   USE @ DUP >R BEGIN +BUF UNTIL  USE !
        R @ 0< IF R 2+ R @ 7FFF AND 0       R/W  THEN
        R ! R PREV ! R> 2+ ;







\ 68000 : block (line) .line message load ( 27 10 86 CRC 13:17 )
: BLOCK   PAUSE OFFSET @ + >R PREV @ DUP @ R - DUP +
    IF BEGIN +BUF 0= IF DROP R BUFFER DUP R 1 R/W 2- THEN
       DUP @ R - DUP + 0= UNTIL DUP PREV ! THEN R> DROP 2+ ;

: (LINE)  >R C/L B/BUF */MOD R>  + BLOCK + C/L ;
: .LINE   (LINE) -TRAILING TYPE ;

: MESSAGE WARNING @ IF ( we have disk ) -DUP
       IF 1 OFFSET @ - .LINE THEN ELSE  \ 4 is fig std.
          ." msg # " .  THEN ;

: LOAD  BLK @ >R  IN @ >R  IN OFF BLK !  INTERPRET
        R> IN !   R> BLK ! ;

: --> ?LOADING IN OFF BLK 1+! ;               IMMEDIATE
\ 68000 : #bufs flush                     ( 17 10 85 CRC       )

: #BUFS  LIMIT FIRST - 0  B/BUF 4 + U/ \ number of buffers
     SWAP IF ." Bad buffers!"  EMPT ON COLD  THEN ;

: FLUSH  #BUFS  1+  0 DO 7FFF BUFFER DROP LOOP ;










\ messdos: bios disk access               (  1  1 88 CRC 16:34 )
SERIAL FILES  OR  IFTRUE   ;S  IFEND
LABEL DISKTABLE  6 ALLOT      DISKTABLE DELTA + 6 ERASE
CODE +DISK   AX POP,  DISKTABLE # AX ADD,  1PUSH C;
DECIMAL
5.25" IFTRUE                  720 CONSTANT SEC/DRV
18 CONSTANT SEC/CYL             9 CONSTANT SEC/SIDE  IFEND
3.5"  IFTRUE                 1440 CONSTANT SEC/DRV
18 CONSTANT SEC/CYL             9 CONSTANT SEC/SIDE  IFEND

: CALC  \ addr s#  ---  | calculate t&s, etc, from blk#.
  SEC/DRV  /MOD  0 +DISK C!   \ drive#
  SEC/CYL  /MOD  3 +DISK C!   \ cylinder
  SEC/SIDE /MOD  1 +DISK C!   \ side
                 2 +DISK C! ; \ sector number
: DERROR   -DUP IF  BASE @ HEX  SWAP .  BASE !  8 ERROR  THEN ;
\ messdos: bios disk access               (  1  1 88 CRC 15:18 )
SERIAL IFTRUE  DECIMAL 201 203 THRU ;S  IFEND
FILES  IFTRUE  DECIMAL 212 213 THRU ;S  IFEND
CODE SR/W       \  1 = read, 0 = write
  AX POP, ( fl )  AX AX OR,   \ count --> al  r/w f --> ah
  0= IF,  ( write ) 301 # AX MOV,  ELSE,  201 # AX MOV,  THEN,
  DISKTABLE T#) BX LEA,
  0 [BX] DX MOV,  \ drive --> dl  side --> dh
  2 [BX] CX MOV,  \ track --> ch  sect --> cl
  4 [BX] BX MOV,  ( addr --> bx )   CL INC,  13 INT,
  < IF,  AH AL MOV,  FF # AX AND,   ELSE,   AX AX SUB,  THEN,
  1PUSH  C;
: (R/W)         \  addr blk# fl ---
  OVER 0 MAXBLK WITHIN 0= 6 ?ERROR   ROT 4 +DISK ! \ addr
  >R  DUP + ( 2* ) DUP  CALC  R  SR/W  DERROR
  200  4 +DISK +!  1+   CALC  R> SR/W  DERROR ;
\ 68000 : ' index list (list)               25 12 84 CRC
: ' -FIND 0= 0 ?ERROR DROP [COMPILE] LITERAL ;        IMMEDIATE

: INDEX   CR  1+  SWAP    DO CR R  5 .R
   SPACE  0  R .LINE  ?TERMINAL  IF  LEAVE  THEN   LOOP ;

: LIST    'LIST @EXECUTE STOP

: (LIST)    DECIMAL
   CR  DUP  SCR !  ." scr # "   .  10 0
   DO  CR R 3 .R SPACE R SCR @ .LINE  LOOP CR ;





\   11  Source Code: fix forget             18  4 85 CRC
| : PFUI   TIB OVER U< IF TIB - THEN  ;

| : PFUI2  PFUI >R PFUI R>         U< ;

: FORGET   [COMPILE] '  NFA  DUP FENCE @ PFUI2 15 ?ERROR
   >R  VOC-LINK @                  BEGIN
     R OVER PFUI2 WHILE [COMPILE] FORTH  DEFINITIONS
     @ DUP VOC-LINK !  REPEAT      BEGIN
        DUP 2- 2- BEGIN PFA LFA @ DUP R PFUI2  UNTIL
     OVER 2- !  @ -DUP 0= UNTIL   R> DP ! ;





\ 68000 : (create)                        (  2  1 88 CRC 16:03 )
: (CREATE)     FIRST HERE 0A0 + U< 2 ?ERROR
  -FIND IF DROP NFA ID.   4 MESSAGE SPACE THEN
\ c/l out @ < if cr then  \ debug temp!
\ here count type  space  \ debug temp!
  HERE  DUP C@ WIDTH @ MIN 1+ ALLOT
  DUP A0 TOGGLE HERE 1- 80 TOGGLE
  LATEST , CURRENT @ ! HERE 2+ , ;








\   11  Source Code: begin -- while         29 07 84 CRC
: BEGIN       ?COMP HERE 1 ;                          IMMEDIATE
: THEN        ?COMP 2 ?PAIRS HERE OVER - SWAP ! ;     IMMEDIATE
: ENDIF       [COMPILE]  THEN  ;                      IMMEDIATE
: DO          COMPILE (DO) HERE 3 ;                   IMMEDIATE
: LOOP        3 ?PAIRS COMPILE (LOOP)  BACK ;         IMMEDIATE
: +LOOP       3 ?PAIRS COMPILE (+LOOP) BACK ;         IMMEDIATE
: UNTIL       1 ?PAIRS COMPILE 0BRANCH BACK ;         IMMEDIATE
: END         [COMPILE]  UNTIL ;                      IMMEDIATE
: AGAIN       1 ?PAIRS COMPILE BRANCH  BACK ;         IMMEDIATE
: REPEAT      >R >R [COMPILE] AGAIN R> R> 2-
                    [COMPILE] ENDIF ;                 IMMEDIATE
: IF          COMPILE 0BRANCH HERE 0 , 2 ;            IMMEDIATE
: ELSE        2 ?PAIRS COMPILE BRANCH HERE 0 ,
       SWAP 2 [COMPILE] ENDIF 2 ;                     IMMEDIATE
: WHILE       [COMPILE] IF 2+ ;                       IMMEDIATE
















\ Overlay Code -- after Greg Stevenson      23 12 81 CRC
DECIMAL
| 1010 CONSTANT SEGSIZE
\ |    0 VARIABLE CURSEG       |         0 VARIABLE MEMPTR
|  60 USER CURSEG          |  62 USER MEMPTR
| : @SEG  DUP CURSEG ! BLOCK  DROP ;  \ Block #-1 ---
| : DESCRIPTORS CURSEG @ BLOCK ;      \ --- addr
| : OBJECT  DESCRIPTORS 14 + ;        \ --- addr
| : NEXTSEG  SEGSIZE MEMPTR +! ;      \ ---
| : ?SEGS     PAD 4 + @   PAD 2+ @ -  \ --- n
        SEGSIZE /MOD SWAP IF 1+ THEN ;
| : RESTOREDES   DESCRIPTORS  4 + @  DP        !
                 DESCRIPTORS  6 + @  CURRENT @ !
                 DESCRIPTORS  8 + @  CONTEXT @ !
                 DESCRIPTORS 10 + @  VOC-LINK  !  ;
." ."
\ Overlay Code -- after Greg Stevenson      29 04 86 crc
DECIMAL
| : SAVEDES        \      ---
                     PAD           OFF    \ overlay marker
    [COMPILE] ' NFA  PAD    2+       !    \ start addr
    HERE             PAD   4 +       !    \ end addr
    LATEST           PAD   6 +       !    \ dictionary link 1
    CONTEXT @ @      PAD   8 +       !    \ dictionary link 2
    VOC-LINK @       PAD  10 +       ! ;  \ dictionary link 3
." ." ;S

Syntax:     SAVEDES   <WORDNAME>
    PAD  is used as a holding area & contents are placed in all
blocks of the image array.


\ Overlay Code -- after Greg Stevenson      18 02 83 CRC
DECIMAL
: SAVEOVER                     \ Block #-1 ---
   [COMPILE] FORTH  SAVEDES
   PAD 2+ @ MEMPTR !
   ?SEGS DUP PAD 12 + !
   BOUNDS           DO
       I BUFFER DROP    \ why read the thing
       I @SEG UPDATE
       PAD DESCRIPTORS 14 CMOVE
       MEMPTR @ OBJECT SEGSIZE CMOVE
       NEXTSEG I 5 .R  LOOP FLUSH ;
." ." ;S
     Syntax:      <BLOCK#>   SAVEOVER  <WORDNAME>
where <BLOCK#> is the starting block and <WORDNAME> is the first
word to be saved to the virtual array.
\ Overlay Code -- after Greg Stevenson      23 12 81 CRC
DECIMAL
: BRING                         \ Block #-1  ---
  [COMPILE] FORTH  DUP @SEG RESTOREDES
  DESCRIPTORS    2+ @ MEMPTR !
  DESCRIPTORS 12 +  @     \ # of segments
   BOUNDS           DO
        I @SEG
        OBJECT MEMPTR @ SEGSIZE CMOVE NEXTSEG
        46 EMIT LOOP CR ;
." ." ;S
       syntax:   <BLOCK#>  BRING
  where <BLOCK#> is the starting block of a previously saved
overlay.


\ frills: dump & ascii print              ( 30 12 87 CRC 20:31 )
: (DUMP) \  addr ct ---  | dump as pointed to by reloc
  SPACE  BOUNDS DO  I C@ 3 .R  LOOP ;
: U.R 0 SWAP D.R ;        : TAB OUT @ - SPACES ;
: LASCI   \  addr ct ---  | asci type as pointed to by reloc
  SPACE  BOUNDS DO  I C@  7f AND  DUP
    bl ASCII ~ WITHIN 0= IF DROP ASCII . THEN  EMIT  LOOP ;
: HEAD  \ addr --- | headder for dump display
  10 0 DO I OVER + 0f AND 3 .R LOOP DROP ;

  \ N. B: Not responsible for negative counts! -- the MGT.
: DUMP   \  addr ct ---  | dump as pointed to by reloc
  OVER CR 6 SPACES HEAD  BEGIN  DUP  WHILE  CR OVER 5 U.R
     2DUP 10 MIN >R  R 2DUP (DUMP)  36 TAB LASCI
     R R> MINUS D+  ?TERMINAL IF DROP 0 THEN  REPEAT 2DROP ;

\ frills: see, other toys                 (  1  1 88 CRC 13:30 )
\ : SEE  CR ."   dr sd sc tk  addr "
\   CR 0 +DISK 6 (DUMP) ;

: U.  0 D. ;

: .S  SP@ U.  OVER U. DUP U. ;

























\   cross reference utility. Ken Bell     ( 12  9 86 CRC  1:02 )
-FIND QU IFTRUE 2DROP OTHERWISE  : QU  DROP 0 ; IFEND

\ cfa in host ---    | cross printed out
: (WHO)   SPACE COL @ >R [ ' NEWFORTH  2+ ] LITERAL @
   BEGIN  PFA DUP 2- @ DELTA + DUP @ *COLON* @ = IF 2+ \ targ p
     BEGIN  DUP @  HEX ( CR .S)  CASE
      R          OF  OVER  NFA TID.  COL      QU  ENDOF
      *LIT*   @ OF 2+  ENDOF    *;S* @     OF QU  ENDOF
      *@EXEC* @ OF QU  ENDOF
      *(.")*  @ OF DUP 2+  C@ 1+ +                ENDOF

-->



\   cross reference utility. Ken Bell     ( 29 04 86 crc       )
      *(;CODE)* @ OF   QU                           ENDOF

      *(LOOP)*  @ OF 2+  ENDOF  *(+LOOP)* @ OF 2+  ENDOF
      *BRAN*    @ OF 2+  ENDOF  *0BRAN*   @ OF 2+  ENDOF
    [ 'NF COMPILE     @ 2+ ] LITERAL  OF 2+   ENDOF
ENDCASE   -DUP WHILE 2+ REPEAT ELSE DROP THEN LFA @ DUP 0=
             UNTIL R> 2DROP   OUT @ IF CR THEN ;

    BLK @ 1+ DUP 1+ RTHRU \  ."  Disposing " DISPOSE  CR
;S
      *(;CODE)* @ OF DUP 4 +  @  *DOES>*
              = IF 4 +  ELSE QU THEN             ENDOF
           \ debugging version
?TERMINAL OR UNTIL R> 2DROP   OUT @ IF CR THEN ;  CR .S
  \   *ABORT* @ OF QU  ENDOF    *QUIT* @  OF QU  ENDOF
\ cross reference utility. Target compiler( 29 04 86 crc       )
: LOC   \ nfa  ---  nfa | print out screen & line # if can
  DECIMAL ' WHERETHEN OVER U< IF SPACE lfa 2- @ WHERETHEN  C/L /
  14 [ BLK @ 1+ ] LITERAL .LINE 3 .R SPACE .SCR SPACE THEN ;

: (CROSS)   CR BASE @ SWAP  \ nfa --- | start cross reference
  BEGIN DUP PFA 2- @ [ ' QUIT 2- @ ] LITERAL -
  IF 15 [ BLK @ 1+ ] LITERAL .LINE  SPACE  DUP TID. 30 TAB
  COL DUP LOC PFA DUP (WHO)
  DUP 2- @ DELTA + 2- @ 0=    \ is target link = 0 ?
  ELSE PFA 0 THEN  ?STACK \  CR .S
  ?TERMINAL OR SWAP LFA @ DUP 0=   \ is host link = 0 ?
  ROT OR UNTIL  DROP BASE ! ;

: WHO:   CR BASE @ 15 [ BLK @ 1+ ] LITERAL .LINE SPACE
  [COMPILE]  'NF HERE COUNT TYPE DUP C>N LOC (WHO) BASE ! ;
\ target vlist    utility. Target compiler( 29 04 86 crc       )
: TVLIST  CR BASE @  [ ' NEWFORTH  2+ ] LITERAL  @
    BEGIN PFA DUP 2- @ [ ' QUIT 2- @ ] LITERAL -
    IF DUP NFA TID. 3 SPACES  OUT @ C/L > IF CR THEN
    DUP 2- @ DELTA + 2- @ 0= ELSE 0 THEN \ is target link = 0 ?
\   10 TAB .S  OVER NFA ID. 20 TAB \ testing stuff
    ?TERMINAL OR SWAP LFA @ DUP 0= \ is host link = 0 ?
    ROT OR ( CR ?STACK) UNTIL  DROP BASE ! ;

: CROSS   [ ' NEWFORTH  2+ ] LITERAL @ (CROSS) ;

: 'CROSS  'NF c>n (CROSS) ; ;S \ start cross at given word
\ e.g  'cross fred  begins a cross ref at  fred .

Line number
Words using:
















































\ strand hosted terminal code             ( 29  4 88 CRC  6:58 )
CODE NYBBL   \ n -- nlo nhi | encode byte into two bytes
   AX POP,  AH AH SUB,  AX DX MOV,  4 # CL MOV,  DX CL SHR,
   0F # AL AND,  30 # AL OR,  30 # DL OR,  2PUSH         ;C

CODE DENYBBL   \ blo bhi -- b | reverse nybbl
  AX POP,  0F # AX AND,  4 # CL MOV,  AX CL SHL,  AX DX MOV,
  AX POP,  0F # AX AND,  DX AX OR,  1PUSH                ;C

CODE ><      AX POP,  AH AL XCHG,  1PUSH    ;C

1 VARIABLE DLY

: (EMIT)  DLY @ 0 DO  LOOP  <EMIT> ;   ;s


\ 6809 Host-system intf. v.2 -- xmitb - rxb 23 08 85 BJR
: XMITB       NYBBL  (EMIT) (EMIT)  ; \ sends lonybl, hinbyl

: XMITW       DUP ><   XMITB  XMITB ; \ sends hibyte, lobyte

: RXB         (KEY)  (KEY)  DENYBBL ; \ expects lonybl, hinyb










\ 6809 Host-system intf. v.2 -- (r/w)       23 08 85 BJR
: READ     1F (EMIT) 31 (EMIT)  XMITW
                              B/BUF BOUNDS DO RXB I C! LOOP ;

: WRITE    1F (EMIT) 30 (EMIT)  XMITW
                              B/BUF BOUNDS DO I C@ XMITB LOOP ;

: (R/W)    OVER MAXBLK > 6 ?ERROR
           OVER       0< 6 ?ERROR
           IF READ ELSE WRITE THEN ;






\ stand alone (key) (emit) (?terminal)    (  9  3 88 CRC 20:40 )
ASSEMBLER   1F8 == CTL-A  ASSEMBLER  CTL-A 2+ == DATA-A
LABEL ?KEY  CTL-A # DX MOV,  DX AL IN,  1 # AL AND,  RET,

CODE <EMIT>  CTL-A # DX MOV,  4 # AH MOV,
  BEGIN, DX AL IN,  AH AL AND,  0<> UNTIL,
  DATA-A # DX MOV,  AX POP,  DX AL OUT,  NEXT     C;

CODE (KEY)   BEGIN,  ?KEY #) CALL, 0<> UNTIL,
  DATA-A # DX MOV,  DX AL IN,  AH AH SUB,  1PUSH  C;

CODE (?TERMINAL)   ?KEY #) CALL,  0= IF,  AX AX SUB,  ELSE,
 DATA-A # DX MOV,  DX AL IN,  1 # AX MOV,  THEN,  1PUSH    C;

CODE MON  C; 0 +BOOTS 'NF MON CFA DELTA + !

\ terminal i/o: 8250 control              ( 15  7 89 CRC 11:25 )
LABEL LSR  3FD ,     LABEL DATA 3F8 ,     LABEL EMASK  7F C,
LABEL ?KEY   LSR T#) DX MOV,  DX AL IN,  1 # AX AND,  RET,

CODE (?TERMINAL) \ --- f | is there a char from the host?
  ?KEY #) CALL,  0<> IF,  DATA T#) DX MOV,  DX AL IN,
  1 # AL MOV,  THEN,  1PUSH                          ;C

CODE <EMIT> \ c --- | send to host
  LSR T#) DX MOV,  20 # ( thre bit ) AH MOV,
  BEGIN,  DX AL IN,  AH AL AND,  0<> UNTIL,  AX POP,
  EMASK T#) AL AND,  DATA T#) DX MOV,  DX AL OUT,  NEXT  ;C

CODE (KEY)  \ --- c | get char from host
  BEGIN,  ?KEY #) CALL,  0<> UNTIL,
  DATA T#) DX MOV,  DX AL IN,  1PUSH  ;C
\ CM rom self-boot routine                ( 20  2 89 CRC 10:22 )
ASSEMBLER      DE DELTA + DP !        SETORG
  AA C,  55 C,   0 C,      \ preboot data
  CS AX MOV,  AX DS MOV,   1C ( *&* ) T#) IP LEA,
  AX LODS,  AX CX MOV,  CX SHR,  \ len
  AX LODS,  AX ES MOV,           \ dest seg
  AX LODS,  AX DI MOV,           \ dest offset
  ES PUSH,  DI PUSH,             \ "return" address
  CLD,                           \ 'upward' move.
  REP, MOVS,  FAR RET,           \ move & go to it

( *&* )
\  len       dest seg  offset
  2000 ,      40  ,    100 ,


\ terminal i/o: 8250 control              ( 15  7 89 CRC 11:42 )
  \ i/o locations for various 8250 machines
  \ chassis master i/o locations
LABEL LSR  115 ,     LABEL DATA 110 ,     LABEL EMASK  7F C,

  \ ibm pc serial port locations
LABEL LSR  3FD ,     LABEL DATA 3F8 ,     LABEL EMASK  7F C,

























\ mess-dos interface:                     (  2  7 88 CRC 20:10 )
| : DOCMD  ( do a command from the command line               )
  80 COUNT DUP IF  CR  >R  TIB @  R CMOVE  80 OFF
    TIB @ R> + OFF  IN OFF  INTERPRET  ELSE  2DROP  THEN ;

| : CMDBOOT    RP! BLK OFF [COMPILE] [
  { 'NF (QUIT) CFA } LITERAL 'QUIT !  DOCMD  QUIT STOP









\ mess-dos interface:                     ( 17  3 88 CRC 19:03 )
LABEL FILENAME TXT RF.SCR " 0 HERE 1- C!
0 CONSTANT RHANDLE              0 CONSTANT WHANDLE

: BADFILE  ( fl -  )  IF
  {  'NF RHANDLE CFA 2+ } LITERAL OFF
  {  'NF WHANDLE CFA 2+ } LITERAL OFF
  ."  File not open!!" ABORT  THEN ;

CODE (OPF) \ addr --- handle/ec | open file at addr
  DX POP,   3D02 # AX MOV,  21 INT,
  U< IF,  AX NEG,  THEN,  1PUSH        ;C




\ mess-dos interface:                     (  7  4 88 CRC 16:21 )
CODE LSEEK   \ dfaddr handle type --- fl/dfaddr |
  AX POP,  ( type )  BX POP, \ handle
  CX POP,  DX POP,  ( dfaddr)   42 # AH MOV,  21 INT,
  U< IF,  AX NEG,  1PUSH  THEN,  AX PUSH,  DX PUSH,  NEXT ;C

: OPENIT   \ addr ---  | open a file
  (OPF)  DUP 0< BADFILE  DUP
  {  'NF RHANDLE CFA 2+ } LITERAL !
  {  'NF WHANDLE CFA 2+ } LITERAL !
  0 0 RHANDLE 2  LSEEK  B/BUF U/  1-
  {  'NF MAXBLK  CFA 2+ } LITERAL !  DROP ;




\ mess-dos interface:                     (  4  3 95 CRC 16:22 )
CODE RDF   \ addr count handle --- ct/er | read from addr for
    \ count bytes to file/handle. Return count read or error.
  3F # AH MOV,    BEGIN,  >R >R
  BX POP,  CX POP,  DX POP,
  SEGMENT T#) DS MOV,
  21 INT,  U< IF,  AX NEG,  THEN,
  CS PUSH,  DS POP,    1PUSH          ;C

CODE WTF   \ addr count handle --- ct/er | read to addr for
    \ count bytes from file/handle. Return count read or error.
  40 # AH MOV,   R> R>  AGAIN,           ;C




\ mess-dos interface:                     ( 17  3 88 CRC 19:08 )
: (R/W)   \ addr blk# r/w ---  | r/w for a file once opened
  RHANDLE 0= BADFILE   >R B/BUF U*
  R IF RHANDLE ELSE WHANDLE THEN  0 LSEEK
  0< IF ."  File Seek Error"  ABORT THEN  DROP
  B/BUF R> IF  RHANDLE RDF  ELSE  WHANDLE WTF  THEN
  B/BUF - IF ."  File Size Overflow"  ABORT  THEN  ;









































\      @L C@L !L C!L                      ( 20  2 89 CRC 10:10 )
CODE @L   BX POP,  ES POP,  ES: 0 [BX] AX MOV,  1PUSH  ;C

CODE C@L   BX POP,  ES POP, ES: 0 [BX] AL MOV,
  AH AH XOR,  1PUSH  ;C

CODE C!L ( byt seg adr )
  BX POP,  ES POP,  AX POP,  ES: AL 0 [BX] MOV,  NEXT  ;C

CODE !L ( n seg adr -- )
  BX POP,  ES POP,  AX POP,  ES: AX 0 [BX] MOV,  NEXT  ;C





\ CMOVEL p@, etc.                         ( 20  2 89 CRC 10:09 )
CODE CMOVEL  ( sseg sptr dseg dptr cnt )
  SI BX MOV,  CX POP,  DI POP,  ES POP,  SI POP,
  DS POP,  REP, .B MOVS,
  CS PUSH,  DS POP,  BX SI MOV,  NEXT  ;C

CODE PC@   \ p# -- c | fetch from i/o space
  DX POP,  DX AL IN,  AH AH SUB,  1PUSH                   ;C
CODE P@    \ p# -- n | fetch from i/o space
  DX POP,  DX AX IN,  1PUSH                               ;C

CODE PC!   \ c p# -- | store to i/o space
  DX POP,  AX POP,  DX AL OUT,  NEXT                      ;C
CODE P!    \ n p# -- | store to i/o space
  DX POP,  AX POP,  DX AX OUT,  NEXT                      ;C

\ relocation words                        ( 16  8 88 CRC 16:06 )
: 2@  DUP 2+ SWAP  @ SWAP @ ;  : 2!  DUP 2+ ROT SWAP  !  ! ;
CODE CS@  CS PUSH,  NEXT   ;C
0 VARIABLE SEG                \ keeps relocation factor
HERE DELTA - 0 , CONSTANT FUDGE \ in 2nd word, seg in first. You
: (T@)   SEG 2@ ROT +  @L ;   \ dump/dis any segment w/ any
                              \ relocation you want by setting
: (TC@)  SEG 2@ ROT + C@L ;   \ FUDGE & SEG  correctly.

: SEG?  SEG @ 0 D. ;            : SETSEG   SEG ! ;

: HOMESEG   CS@ SETSEG FUDGE OFF ;

'NF (T@) CFA VARIABLE 'T@       'NF (TC@) CFA VARIABLE 'TC@

: T@   'T@ @EXECUTE STOP        : TC@  'TC@ @EXECUTE STOP
\ frills: dump & ascii print              ( 16  8 88 CRC 16:08 )
DECIMAL                         : U.  0 D. ;
: (DUMP) \  addr ct ---  | dump as pointed to by reloc
  SPACE  BOUNDS DO  I TC@ 3 .R  LOOP ;
: LASCI   \  addr ct ---  | asci type as pointed to by reloc
  SPACE  BOUNDS DO  I TC@  127 AND  DUP
    BL ASCII ~ WITHIN 0= IF DROP ASCII . THEN  EMIT  LOOP ;
: HEAD  \ addr --- | headder for dump display
  16 0 DO I OVER + 15 AND 3 .R LOOP DROP ;
: TAB  OUT @ - SPACES ;
  \ N. B: Not responsible for negative counts! -- the MGT.
: DUMP   \  addr ct ---  | dump as pointed to by reloc
  OVER CR 6 SPACES HEAD  BEGIN  DUP  WHILE  CR OVER 0 5 D.R
     2DUP 16 MIN >R  R 2DUP (DUMP)  54 TAB LASCI
     R R> MINUS D+  ?TERMINAL IF DROP 0 THEN  REPEAT 2DROP ;

































( improved overlays                       (  4  1 89 crc  7:42 )
\ 0 VARIABLE >MEM      ( --> mem to pick up          )
\ 0 VARIABLE +HEAD     ( --> start in first block    )
|  60 USER >MEM            |  62 USER +HEAD

| : HEAD@+    +HEAD @  2 +HEAD +!  ;

| : NEWBLK    BUFFER  DUP B/BUF ERASE  UPDATE ;

| : ADVANCE   DUP >MEM +!  CMOVE   ASCII . EMIT ;






( improved overlays                       (  4  1 88 crc  8:04 )
| : GETDICT   ( addr ---  | build overlay restoration info     )
  2+ +HEAD !              ( set pointer past raw block flag  )
  [COMPILE] ' NFA 2- DUP      ( starting point               )
    >MEM !        HEAD@+ !    ( starting point               )
  HERE            HEAD@+ !    ( top of dictionary            )
  CURRENT @       HEAD@+ !    ( current vocabulary           )
  CONTEXT @       HEAD@+ !    ( context                      )
  VOC-LINK @      HEAD@+ !    ( vocabulary chain start       )
  VOC-LINK   BEGIN  @  -DUP   ( vocabulary chain             )
      WHILE  DUP 2- @ HEAD@+  !  repeat
  HEAD@+ OFF ;                ( end of data                  )




( improved overlays                       (  4  1 88 crc  8:24 )
| : SETDICT   ( addr ---  | build overlay restoration info     )
  2+ +HEAD !              ( set pointer past raw block flag  )
  HEAD@+ @          >MEM !    ( starting point               )

  HEAD@+ @            DP !    ( top of dictionary            )
  HEAD@+ @       CURRENT !    ( current vocabulary           )
  HEAD@+ @       CONTEXT !    ( context                      )
  HEAD@+ @      VOC-LINK ! ;  ( vocabulary chain start       )

| : SETVOCS   ( addr ---  | install vocabulary link pointers   )
  +HEAD !                     ( set pointer                  )
  VOC-LINK   BEGIN  @  -DUP   ( vocabulary chain             )
      WHILE  HEAD@+ @  OVER 2- !  REPEAT  ;


( improved overlays                       (  4  1 89 crc  7:42 )
: SAVEOVER  ( blk# ---  | save overlays to blk# from given word)
  DUP NEWBLK  DUP >R  GETDICT    ( dict info stored            )
  >MEM @  +HEAD @  B/BUF OVER R> -  -  ( src, dest, ct         )
  ADVANCE
  BEGIN  >MEM @  HERE  U< WHILE
  1+  >MEM @  OVER NEWBLK 2+ B/BUF 2-  ADVANCE  REPEAT
  DROP FLUSH ;








( improved overlays                       (  4  1 88 crc  8:25 )
: BRING     ( blk# ---  | restore overlays from blk#         )
  DUP  BLOCK  DUP SETDICT         ( set dictionary info      )
  +HEAD @ OVER  - >R              ( offset to voc-link data  )
  +HEAD @                         ( begin at voc-link data   )
  BEGIN  DUP @ WHILE 2+ REPEAT 2+ ( skip voclinx for now     )
  OVER - >R  R +  ( SRC)  >MEM @  ( dest                     )
     B/BUF R> -  ADVANCE  DUP     ( move first block to mem  )
  BEGIN  >MEM @  HERE  U< WHILE
  1+  DUP BLOCK 2+  >MEM @  B/BUF 2-  ADVANCE  REPEAT
  DROP
  BLOCK R> + SETVOCS ;




















































\ 68000 : forward refs 1                    17  2 85 CRC
     0A      3 BYTE:IN (CR) C!
   0D        4 BYTE:IN (CR) C!





   'NF R  CFA 2+  -2 BYTE:IN I    !
   'NF 2- CFA 2+  -2 BYTE:IN CFA  !






\   11 Source Code: forward refs 2          07 07 83 CRC

*COLON* @ -2 BYTE:IN : !
   00 BYTE:IN :                REPLACED:BY ?EXEC
   02 BYTE:IN :                REPLACED:BY !CSP
   04 BYTE:IN :                REPLACED:BY CURRENT
   08 BYTE:IN :                REPLACED:BY CONTEXT
   0C BYTE:IN :                REPLACED:BY CREATE
   0E BYTE:IN :                REPLACED:BY ]
   10 BYTE:IN :                REPLACED:BY (;CODE)






\   11 Source Code: forward refs 3          15 07 83 CRC
   00 BYTE:IN ;                REPLACED:BY ?CSP
   02 BYTE:IN ;                REPLACED:BY COMPILE
   06 BYTE:IN ;                REPLACED:BY SMUDGE
   08 BYTE:IN ;                REPLACED:BY [
   *COLON*   @ -2 BYTE:IN ;    !
   *(;CODE)* @  2 BYTE:IN VARIABLE  !
   *(;CODE)* @  2 BYTE:IN USER !

   00 BYTE:IN CONSTANT         REPLACED:BY CREATE
   02 BYTE:IN CONSTANT         REPLACED:BY SMUDGE
   04 BYTE:IN CONSTANT         REPLACED:BY ,
   06 BYTE:IN CONSTANT         REPLACED:BY (;CODE)

    6 BYTE:IN ?ERROR           REPLACED:BY ERROR

\ 80x86 Source Code: forward refs 4       ( 24 12 87 CRC 15:38 )


   0F BYTE:IN ."               REPLACED:BY WORD
   1D BYTE:IN ."               REPLACED:BY WORD
   0C BYTE:IN WORD             REPLACED:BY BLOCK

   18 BYTE:IN ERROR            REPLACED:BY MESSAGE

80  'NF X CFA  3 - DELTA + C!    \ make it null






















































\ 80x86 Source Code: forward refs 8       ( 12  8 88 CRC 16:25 )
ASSEMBLER  COLDSTART 4 +BOOTS -  2 BOOTS @ + !
           WARM  8 +BOOTS -  6 BOOTS @ + ! FORTH
LAST @ DELTA -       0C BOOTS @ +    !  \ 0E = backspace
EM US -       10 BOOTS @ +           !  \  uarea
ASSEMBLER TOS 12 BOOTS @ +           !  \  TOS
 RTS          14 BOOTS @ +           !  \  top of return stack
TIBX                  INITIALISES TIB
  1F                  INITIALISES WIDTH
   1                  INITIALISES WARNING
DPNEW @ DELTA -  DUP  INITIALISES FENCE
                      INITIALISES DP
EM US - 38 + ( user)  INITIALISES VOC-LINK  \ for 4th vocab
'NF (KEY)       CFA   INITIALISES 'KEY
'NF (EXPECT)    CFA   INITIALISES 'EXPECT
;S  fill in boot parameters
\ 68000 : forward refs 8                  (  2  7 88 CRC 16:09 )
'NF (?TERMINAL) CFA          INITIALISES '?TERMINAL
'NF (EMIT)      CFA          INITIALISES 'EMIT
'NF (TYPE)      CFA          INITIALISES 'TYPE
'NF 2DROP       CFA          INITIALISES 'GOTOXY
'NF (PAGE)      CFA          INITIALISES 'PAGE
'NF (LIST)      CFA          INITIALISES 'LIST
'NF (CR)        CFA          INITIALISES 'CR
'NF (R/W)       CFA          INITIALISES 'R/W
SERIAL IFTRUE  'NF (QUIT) OTHERWISE  'NF CMDBOOT  IFEND
                CFA          INITIALISES 'QUIT
'NF (ABORT)     CFA          INITIALISES 'ABORT
'NF (CREATE)    CFA          INITIALISES 'CREATE
TIBX      US - CO - 100 -    INITIALISES 'FIRST
TIBX      US -      100 -    INITIALISES 'LIMIT
;S  fill in more boot parameters
\   11 Source Code: forward refs 9        ( 12  8 88 CRC 16:24 )
     FORTH
A081                40 BOOTS @ +          !  \  dummy vocs
LAST @ DELTA -      42 BOOTS @ +          !  \  vlfth
0000                44 BOOTS @ +          !  \  vlnk
     \ voc-link points to this guy.
BOT                   INITIALISES BOTSTACK
SPEAK @ IFTRUE CR ."  Forward references resolved."  IFEND
WARNING ON  CR .HERE
CR .SIZE  SPEAK @ IFTRUE ?0S IFEND  DECIMAL
CR 08 BYTE:IN (ABORT)    COUNT TYPE   CR 15 MESSAGE    CR
     DPNEW @ C/L ERASE




\ 808sux disassembler. Bleah.                         23Sep87crc
-->
For user information, see screens 41-42 and their shadows.

Coding techniques taken from other disassemblers I have written,
for 68k, LSI-11, 6502 and 65816. Questions, comments, and bomb
threats should be addressed to:

     Charles Curley

     https://charlescurley.com





\ Load screen: 8086 disassembler                      24Jul87crc
FORTH DEFINITIONS  BASE @ >R DECIMAL
\ FORGET TASK                     : TASK ;
\ SCR @  BLK @ 1-  LIST  SCR !
VOCABULARY DISASSEMBLER      IMMEDIATE

  1  36 +THRU
\ 242 277 THRU
               ?STACK
R> BASE !






\ Useful stuff:                           (  9 12 87 CRC 21:51 )
\ CODE SEXT   DR0 CLR,  S [ DR0 MOV,  DR0 .W EXT,  DR0 S [ MOV,
\    NEXT  ;c

\ CODE NIP   S [+ S [ MOV,  NEXT        ;c
code exit  0 [rp] IP mov,  rp inc, rp inc, next
\ : EXIT  ;S  ;
\ BASE @ HEX
\ CR FILING SETDIR: \MESSDOS\F83     DIR *.*
\ OPENFILE: F.COM     COMPILE-ADDR C000 HANDLE RDF  U.
\ DELTA FUDGE !  CLOSEIT         BASE !

: .NAME  \ nfa ---  | print name whose nfa is on the stack
  COUNT 31 AND BOUNDS  DO I C@ 127 AND EMIT LOOP SPACE ;
EXIT
: EXEC  2* R> + PERFORM   ;
\ 2/s, 2*s, other utils                               23Jul87crc
EXIT
CODE 2/S     \ n ct --- n' | shift n right ct times
   CX POP   AX POP  AX CL SHR  1PUSH  END-CODE

CODE 2*S     \ n ct --- n' | shift n left ct times
   CX POP   AX POP  AX CL SHL  1PUSH  END-CODE

: STOP[  ?CSP REVEAL  [COMPILE] [ ; IMMEDIATE

: C?  C@ . ;

: COL   #OUT @  - SPACES ;   \ n ---  | go to column n



\ relocation words                                    12Aug87crc
EXIT
VARIABLE RELOC  0 ,  ?CS: 0 RELOC 2! \ keeps relocation factor
: (T@)   RELOC 2@ ROT +  @L ; \ in first word, seg in 2nd. You
                              \ dump/dis any segment w/ any
: (TC@)  RELOC 2@ ROT + C@L ; \ relocation you want by setting
                              \ RELOC  correctly.
: SETSEG   RELOC 2+ ! ;       : HOMESEG   ?CS: SETSEG ;

: SEG?  RELOC 2+ @ U. ;

DEFER T@                       DEFER TC@
: MEMORY    ['] (TC@) IS TC@       ['] (T@) IS T@ ;   MEMORY

: DUMPBOOT   MEMORY  HOMESEG  [ ' BOOT >BODY @ , ] ;
' DUMPBOOT  IS BOOT
\ cp, cp related words, relocation words              12Aug87crc
0 VARIABLE CP         DISASSEMBLER DEFINITIONS
: CP@    CP @  ;
\ CODE CP@  CP #) AX MOV  1PUSH   END-CODE

: OOPS   CR CR .S
  CTL G EMIT   ABORT"  Oops!"  STOP

: NEXTB  CP@ TC@    CP 1+! ;

: NEXTW  CP@ T@   2 CP +! ;

\ : .MOI       \  ---  | have the current word print out its nam
\   LATEST [COMPILE] LITERAL  COMPILE .NAME ;   IMMEDIATE


\ lookahead for disp addressing modes                 27Jul87crc
0 VARIABLE OPS \ operand count
0 VARIABLE IM  \ 2nd operand extension flag/ct

: ?DISP      \ op ext --- op ext | does MOD operand have a disp?
  DUP 6 2/S  DUP 3 =  OVER 0=  OR
  0= IF  IM !  ELSE
     0= IF DUP 7 AND 6 = IF 2 IM ! THEN  THEN  THEN ;








\ addressing modes selfprinters                       27Jul87crc
\ : .SELF         \  --  | create a word which prints its name
\   <BUILDS DOES> NFA .NAME ;  \ the ultimate in self-doc!

.SELF AL        .SELF AX        .SELF [BX+SI]   .SELF ES
.SELF CL        .SELF CX        .SELF [BX+DI]   .SELF CS
.SELF DL        .SELF DX        .SELF [BP+SI]   .SELF SS
.SELF BL        .SELF BX        .SELF [BP+DI]   .SELF DS
.SELF AH        .SELF SP        .SELF [SI]      .SELF #
.SELF CH        .SELF BP        .SELF [DI]      .SELF #)
.SELF DH        .SELF SI        .SELF [BP]      .SELF S#)
.SELF BH        .SELF DI        .SELF [BX]
.SELF RP        .SELF [RP]      \ return stack pointer
.SELF IP        .SELF [IP]      \ interpreter pointer
.SELF W         .SELF [W]       \ working register

\ symbol table for forth re-entry locations           24Jul87crc
HEX  : .SYMBOL  FFFF AND U. ; DECIMAL ;S
6 CONSTANT SYMBOLCT     0 VARIABLE SYMBOLS -4 ALLOT  ASSEMBLER
>NEXT ,  >NEXT 1- ,  >NEXT 2- ,  >NEXT 3 - ,  ' BRANCH >BODY ,
' (LOOP) 5 + ,       DISASSEMBLER
.SELF NEXT      .SELF 1PUSH     .SELF 2PUSH     .SELF 3PUSH
.SELF BRAN1     .SELF PLOOP

: ?SYMBOL    \ a -- a n | if n = -1 then no symbol, else index
  TRUE  RELOC 2+ @  ?CS: = IF \ iff in code segment.
    SYMBOLCT 0 DO OVER I 2* SYMBOLS + @ =
      IF DROP I LEAVE THEN LOOP THEN ;

: .SYMBOL    \ a ---  | print symbol name else value
  ?SYMBOL  DUP 0< IF DROP U.  EXIT THEN  SWAP U. EXEC
  NEXT 1PUSH  2PUSH  3PUSH  BRAN1  PLOOP  STOP         ;S
\ symbolic debugging, forth style                     17Jul87crc
FORTH DEFINITIONS
0 VARIABLE SYMBOLIC  SYMBOLIC ON

DISASSEMBLER DEFINITIONS
: SYMBOL  <builds [COMPILE] ' nfa ,  [COMPILE] ' nfa ,
  DOES> SYMBOLIC @ IF 2+ THEN @ .NAME ;

.SELF W

SYMBOL BX BX W   SYMBOL [BX] [BX] [W]
SYMBOL SI SI IP  SYMBOL [SI] [SI] [IP]
SYMBOL BP BP RP  SYMBOL [BP] [BP] [RP]



\ Addressing mode decodes                             16Jul87crc
: .16REG     \ r# ---  | register printed out
  7 AND  EXEC  AX CX DX BX  SP BP SI DI  STOP

: .8REG      \ r# ---  | register printed out
  7 AND  EXEC  AL CL DL BL  AH CH DH BH  STOP

: .SEG       \ s# ---  | register printed out
  3 2/S 3 AND  EXEC  ES CS SS DS   STOP

: 0DISP      \  ---  | do if displacement is 0
  ." 0 "  ;

: BDISP      \  ---  | do if displacement is byte
  CP@  IM @ +  TC@ SEXT U.  OPS 1+! IM OFF ;

\ Addressing mode decodes                             17Jul87crc
: WDISP      \  ---  | do if displacement is word
  CP@  IM @ +  T@  U.  2 OPS +!  IM OFF ;

: (.R/M)     \ op ext ---  | print a register
  SWAP 1 AND  IF .16REG ELSE .8REG THEN  IM OFF ;

: .R/M       \ op ext --- op ext | print r/m as register
  2DUP        (.R/M) ;

: .REG       \ op ext --- op ext | print reg as register
  2DUP  3 2/S (.R/M) ;

: .DISP      \ op ext --- op ext | print displacement
  DUP 6 2/S  3 AND  EXEC  0DISP BDISP WDISP .R/M STOP

\ Addressing mode decodes                             31Jul87crc
: BIMM       \  ---  | do if immed. value is byte
  CP@  IM @ +  TC@      .  1 OPS +!  IM OFF ;

: SHOWDISP   \ op ext --- op ext | show disp and reg
  .DISP
  DUP  7 AND EXEC  [BX+SI]  [BX+DI]  [BP+SI]  [BP+DI]
                   [SI]     [DI]     [BP]     [BX]      STOP
HEX
: .MREG     \ op ext --- op ext | register(s) printed out + disp
  DUP C7 AND 6 = IF  WDISP #)  ELSE
  DUP C0 AND C0 - IF  SHOWDISP  ELSE .R/M  IM OFF  THEN  THEN ;

DECIMAL                         .SELF .B        .SELF .W
: .SIZE      \ op ---  | decodes for size
  1 AND  EXEC  .B  .W   STOP
\ opcode decodes: seg: pop, push, segtb   ( 27  1 88 crc  9:09 )
0 VARIABLE SEGTB  -4 ALLOT
ASCII E C, ASCII C C,  ASCII S C,  ASCII D C,

: SEG:       \ op ---  | print segment overrides
  3 2/S 3 AND SEGTB + C@ EMIT  ." S:" ;

: POP,       \ op ---  | print pops
  DUP 8 = IF OOPS THEN  .SEG  .MOI ;

: PUSH,      \ op ---  | print pushes
  .SEG  .MOI ;
BASE @ HEX
: ?SEG   \ op -- fl | is opcode a segment override?
  DUP 3E =  OVER 36 = OR  OVER 2E = OR  SWAP 26 =  OR ;
BASE ! ;S
\ opcode decodes: p/p adjusts p/seg p/adj             15Jul87crc
: P/P        \ op --- | pushes or pops
  DUP 1 AND  EXEC  PUSH, POP,  STOP

.SELF DAA,      .SELF DAS,      .SELF AAA,      .SELF AAS,

: ADJUSTS    \ op ---  | the adjusts
  3 2/S  3 AND  EXEC  DAA,  DAS,  AAA,  AAS,  STOP

: P/SEG      \ op ---  | push or seg overrides
  DUP 5 2/S  1 AND EXEC  P/P SEG:      STOP

: P/ADJ      \ op ---  | pop or adjusts
  DUP 5 2/S  1 AND EXEC  P/P ADJUSTS  STOP


\ opcode decodes: 0gp add, or, 0group                 14Jul87crc
: 0GP        \ op --- op | opcode decoded & printed
  DUP 4 AND IF  DUP 1 AND
            IF WDISP ELSE BIMM THEN  #
            1 AND IF AX ELSE AL THEN  ELSE
  NEXTB  OVER 2 AND
         IF  .MREG .REG  ELSE  ?DISP .REG .MREG
  THEN  2DROP THEN  ;

.SELF ADD,      .SELF ADC,      .SELF AND,      .SELF XOR,
.SELF OR,       .SELF SBB,      .SELF SUB,      .SELF CMP,

: 0GROUP     \ op ---  | select 0 group to print
  DUP 0GP 3 2/S 7 AND  EXEC
  ADD,  OR,   ADC,  SBB,  AND,  SUB,  XOR,  CMP,  STOP

\ opcode decodes: lows .reggp regs                    30Jul87crc
: LOWS       \ op ---  |  0-3f opcodes printed out
  DUP        7 AND  EXEC
  0GROUP  0GROUP  0GROUP  0GROUP
  0GROUP  0GROUP  P/SEG   P/ADJ  STOP

: .REGGP     \ op ---  | register group defining word
  <builds  DOES>  SWAP  .16REG  nfa .NAME ;

.REGGP INC,     .REGGP DEC,     .REGGP PUSH,    .REGGP POP,

: POP,       \ op ---  | handle illegal opcode for cs pop
  DUP 56 AND 8 = IF ." illegal," DROP  ELSE  POP,  THEN ;

: REGS       \ op ---  | 40-5f opcodes printed out
  DUP 3 2/S 3 AND EXEC  INC, DEC, PUSH, POP,   STOP
\ opcode decodes: branches meds           ( 14  3 88 crc 12:32 )
.SELF O,        .SELF NO,       .SELF B/NAE,    .SELF NB/AE,
.SELF E/Z,      .SELF NE/NZ,    .SELF BE/NA,    .SELF NBE/A,
.SELF S,        .SELF NS,       .SELF P/PE,     .SELF NP/PO,
.SELF L/NGE,    .SELF NL/GE,    .SELF LE/NG,    .SELF NLE/JG,

: .BRANCH    \ op ---  | branch printed out w/ dest.
  NEXTB SEXT  CP@ + .SYMBOL  ASCII J EMIT   15 AND EXEC
  O,    NO,   B/NAE, NB/AE, E/Z,   NE/NZ, BE/NA, NBE/A,
  S,    NS,   P/PE,  NP/PO, L/NGE, NL/GE, LE/NG, NLE/JG,  STOP
HEX
: INS&OUTS  FE AND DUP 6C = IF DX [DI] .SIZE ." INS,"   ELSE
   DUP 6E = IF [SI] DX .SIZE ." OUTS,"  ELSE OOPS  THEN THEN ;

: MEDS       \ op ---  | 40-7f opcodes printed out
  DUP 4 2/S  3 AND EXEC  REGS  REGS  INS&OUTS .BRANCH  STOP
\ opcode decodes: 2ndaries 80/81, 83s     ( 10  3 88 crc 12:30 )
: 80/81      \ op ---  | secondary at 80 or 81
  NEXTB  ?DISP OVER 1 AND  IF WDISP ELSE BIMM THEN  # .MREG
  BEGIN  [  >R >R ]
  SWAP .SIZE  3 2/S 7 AND  EXEC
  ADD, OR,  ADC, SBB, AND, SUB, XOR, CMP,   STOP

: 83S        \ op ---  | secondary at 83
  NEXTB  ?DISP BIMM #  .MREG
  [ R> R> ] AGAIN  STOP






\ opcode decodes: 1gp test xchg movrm/reg movd        16Jul87crc
: 1GP        \ op ---  | r/m reg opcodes
  <builds LATEST ,  DOES> @ >R  NEXTB  ?DISP .REG .MREG  2DROP
  R> .NAME ;

1GP TEST,       1GP XCHG,       .SELF LEA,      .SELF MOV,

: MOVRM/REG  NEXTB  ?DISP .REG .MREG  2DROP  MOV, ; \ 88-89

: MOVD       NEXTB        .MREG .REG  2DROP  MOV, ; \ 8A-8B






\ opcode decodes: movs>m 8movs                        17Jul87crc
HEX
: MOVS>M     \ op ---  | display instructions  8C-8E
  NEXTB  OVER 8D = IF  .MREG .REG  LEA,  ELSE
    OVER 8F = IF  .MREG  [ ' POP, cfa ] LITERAL .NAME  ELSE
    SWAP 1 OR SWAP  \ 16 bit moves only, folks!
    OVER 2 AND IF  .MREG DUP .SEG  ELSE
     ( ?DISP) DUP .SEG .MREG  THEN  MOV,  THEN THEN  2DROP ;

: 8MOVS      \ op ---  | display instructions  80-8F
  DUP 2/ 7 AND EXEC  80/81 83S TEST, XCHG,
                     MOVRM/REG  MOVD  MOVS>M  MOVS>M  STOP

DECIMAL


\ opcode decodes: 98-9F                               15Sep87crc
.SELF XCHG,     .SELF CBW,      .SELF CWD,      .SELF CALL,
.SELF WAIT,     .SELF PUSHF,    .SELF POPF,     .SELF SAHF,
.SELF LAHF,     .self nop,

: INTER      \ ---  | decode interseg jmp or call
  NEXTW .SYMBOL  ." : " NEXTW U. ;

: CALLINTER  \ ---  | decode interseg call
  INTER  CALL, ;

: 9HIS       \ op ---  | 98-9F decodes
  7 AND EXEC
  CBW,  CWD,  CALLINTER WAIT,  PUSHF,  POPF, SAHF, LAHF,  STOP


\ opcode decodes: 90-9F xchg movs/cmps                15Sep87crc
: XCHGA      \ op ---  | 98-9F decodes
  DUP 7 AND IF  AX .16REG  XCHG,  ELSE  NOP, DROP  THEN ;

: 90S        \ op ---  | 90-9F decodes
  DUP 3 2/S 1 AND EXEC  XCHGA  9HIS  STOP

.SELF MOVS,     .SELF CMPS,

: MOVS       \ op ---  | A4-A5 decodes
  .SIZE  MOVS, ;





\ opcode decodes: cmps .al/ax movs/acc .test          21Jul87crc
: CMPS       \ op ---  | A6-A7 decodes
  .SIZE  CMPS, ;

: .AL/AX     \ op ---  | decodes for size
  1 AND  EXEC  AL AX STOP

: MOVS/ACC   \ op ---  | A0-A3 decodes
  DUP 2 AND IF  .AL/AX  WDISP #)  ELSE
      WDISP #)  .AL/AX  THEN MOV, ;

.SELF TEST,     .SELF STOS,     .SELF LODS,     .SELF SCAS,

: .TEST      \ op ---  | A8-A9 decodes
  DUP 1 AND IF WDISP ELSE BIMM THEN #  .AL/AX TEST, ;

\ opcode decodes: stos lods scas a0s movs/imm         21Jul87crc
: STOS   ( op --- )  .SIZE  STOS, ;
: LODS   ( op --- )  .SIZE  LODS, ;
: SCAS   ( op --- )  .SIZE  SCAS, ;

: A0S        \ op ---  | A0-AF decodes
  DUP 2/ 7 AND EXEC
  MOVS/ACC MOVS/ACC  MOVS       CMPS
  .TEST    STOS      LODS       SCAS       STOP

: MOVS/IMM   \ op ---  | B0-BF decodes
  DUP 8 AND IF  WDISP # .16REG  ELSE  BIMM # .8REG  THEN
  MOV, ;



\ opcode decodes: hmeds les/lds ret,                  21Jul87crc
: HMEDS      \ op ---  | op codes 80 - C0 displayed
  DUP 4 2/S  3 AND EXEC  8MOVS  90S A0S MOVS/IMM   STOP

.SELF LES,      .SELF LDS,      .SELF INTO,     .SELF IRET,

: LES/LDS    \ op ---  | les/lds instruction  C4-C5
  NEXTB .MREG  .REG  DROP 1 AND EXEC LES, LDS, STOP

: RET,       \ op ---  | return instruction  C2-C3, CA-CB
  DUP 1 AND 0= IF WDISP ."  SP+" THEN
  8 AND IF ."  FAR"  THEN  .MOI ;




\ opcode decodes: mov#r/m c0s into/iret int, mov#r/m  21Jul87crc
: MOV#R/M    \ op ---  | return instruction  C2-C3, CA-CB
  NEXTB  ?DISP  OVER 1 AND  IF  WDISP  ELSE  BIMM  THEN #
  .MREG  MOV, 2DROP ;

: INT,       \ op ---  | int instruction  CC-CD
  1 AND IF NEXTB ELSE 3 THEN U.  .MOI ;

: INTO/IRET  \ op ---  | int & iret instructions  CE-CF
  1 AND EXEC  INTO, IRET, STOP

: C0S        \ op ---  | display instructions  C0-CF
  DUP 2/ 7 AND EXEC
  OOPS RET, LES/LDS  MOV#R/M  OOPS RET, INT,  INTO/IRET  STOP


\ opcode decodes: shifts esc,                         22Jul87crc
: AAS        \ op ---  | does anybody actually use these things?
  <builds LATEST ,  DOES>  @ .NAME  NEXTB 2DROP ;

AAS AAM,        AAS AAD,

.SELF ROL,      .SELF ROR,      .SELF RCL,      .SELF RCR,
.SELF SHL/SAL,  .SELF SHR,      .SELF SAR,

: SHIFTS     \ op ---  | secondary instructions d0-d3
  DUP 2 AND IF CL THEN
  NEXTB  .MREG NIP 3 2/S 7 AND EXEC
  ROL,  ROR,  RCL,  RCR,  SHL/SAL, SHR,  OOPS  SAR,  STOP

: XLAT,   DROP .MOI ;

\ opcode decodes: d0s esc, loops                      22Jul87crc
: ESC,       \ op ---  | esc instructions d8-DF
  NEXTB .MREG  3 2/S 7 AND U.  7 AND U.  .MOI ;

: D0S        \ op ---  | display instructions  D0-DF
  DUP 8 AND IF ESC, EXIT THEN
  DUP 7 AND EXEC
  SHIFTS SHIFTS SHIFTS SHIFTS  AAM, AAD, OOPS XLAT, STOP

.SELF LOOPE/Z   .SELF LOOP,     .SELF JCXZ,     .SELF LOOPNE/NZ,

: LOOPS      \ op ---  | display instructions  E0-E3
  NEXTB SEXT  CP@ + .SYMBOL  3 AND EXEC
  LOOPNE/NZ,  LOOPE/Z  LOOP,  JCXZ,  STOP


\ opcode decodes: in/out call                         23Jul87crc
.SELF IN,       .SELF OUT,      .SELF JMP,

: IN/OUT     \ op ---  | display instructions  E4-E6,EC-EF
  DUP 8 AND IF
       DUP 2 AND  IF  .AL/AX DX  OUT, ELSE
                      DX .AL/AX  IN,  THEN  ELSE
       DUP 2 AND  IF  .AL/AX BIMM # OUT, ELSE
                      BIMM # .AL/AX IN,  THEN  THEN ;

: CALL       \ op ---  | display instructions  E7-EB
  DUP 2 AND IF  DUP 1 AND IF  NEXTB SEXT  CP@ + .SYMBOL \ shor
        ELSE  INTER  THEN  ELSE  NEXTW CP@ + .SYMBOL THEN
  3 AND EXEC CALL, JMP,  JMP,  JMP, STOP


\ opcode decodes: e0s ftest                           24Jul87crc
: E0S        \ op ---  | display instructions  E0-EF
  DUP 2 2/S  3 AND  EXEC  LOOPS  IN/OUT CALL  IN/OUT STOP

: FTEST      \ op ---  | display instructions  F6,7:0
  ?DISP OVER 1 AND IF WDISP ELSE BIMM THEN #
  .MREG DROP  .SIZE  TEST, ;

.SELF NOT,      .SELF NEG,      .SELF MUL,      .SELF IMUL,
.SELF DIV,      .SELF IDIV,     .SELF REP/NZ,   .SELF REPZ,
.SELF LOCK,     .SELF HLT,      .SELF CMC,      .SELF CLC,
.SELF STC,      .SELF CLI,      .SELF STI,      .SELF CLD,
.SELF STD,      .SELF INC,      .SELF DEC,      .SELF PUSH,



\ opcode decodes: mul/div not/neg f6-f7s              24Jul87crc
: MUL/DIV    \ op ext ---  | secondary instructions F6,7:4-7
  .MREG  AX OVER 1 AND IF DX THEN  NIP
  3 2/S 3 AND EXEC MUL, IMUL, DIV, IDIV, STOP

: NOT/NEG    \ op ext ---  | secondary instructions F6,7:2,3
  .MREG SWAP .SIZE  3 2/S 1 AND EXEC NOT, NEG, STOP

: F6-F7S     \ op ---  | display instructions  F6,7
  NEXTB  DUP 3 2/S  7 AND EXEC
  FTEST OOPS NOT/NEG NOT/NEG
  MUL/DIV MUL/DIV MUL/DIV MUL/DIV  STOP




\ opcode decodes: fes fcall/jmp fpush finc(  1  1 88 CRC 14:15 )
: FES        \ op ---  | display instructions  FE
  NEXTB .MREG .B NIP  3 2/S  1 AND EXEC INC, DEC, STOP

: FCALL/JMP  \ op ext ---  | display call instructions  FF
  .MREG  3 2/S DUP 1 AND IF  ." FAR "  THEN  NIP
  2/ 1 AND EXEC JMP, CALL,  STOP

: FPUSH      \ op ext ---  | display push instructions  FF
  DUP 4 AND IF .MREG  2DROP PUSH, EXIT THEN OOPS ;

: FINC       \ op ext ---  | display inc/dec instructions  FF
  .MREG  NIP 3 2/S 1 AND EXEC INC, DEC, STOP



\ opcode decodes: ffs f0s                 ( 27  1 88 crc  9:06 )
: FFS        \ op ---  | display instructions  FF
  NEXTB DUP 4 2/S 3 AND EXEC
  FINC  FCALL/JMP FCALL/JMP  FPUSH   STOP

: F0S        \ op ---  | display instructions  F0-FF
  DUP 15 AND  DUP 7 AND 6 < IF NIP  THEN  EXEC
  LOCK,  OOPS   REP/NZ, REPZ,  HLT, CMC, F6-F7S  F6-F7S
  CLC, STC, CLI, STI, CLD, STD,  FES  FFS                STOP

BASE @ HEX
: ?REP   \ op -- fl | is it a rep prefix?
  FE AND  F2 = ;
BASE !


\ disassembling: (inst) highs                         23Sep87crc
: HIGHS   \ op -- | op codes C0 - FF displayed
  DUP 4 2/S  3 AND EXEC C0S D0S E0S F0S STOP

: (INST)  \ op ---  | highest level vector table
  255 AND  DUP 6 2/S EXEC LOWS  MEDS  HMEDS  HIGHS  STOP

.SELF ESC_TO_EXIT

FORTH DEFINITIONS






\ frills: dump & ascii print                          16Jul87crc
: (DUMP) \  addr ct ---  | dump as pointed to by reloc
  SPACE  BOUNDS DO  I TC@ 3 .R  LOOP ;

: LASCI   \  addr ct ---  | asci type as pointed to by reloc
  SPACE  BOUNDS DO  I TC@  127 AND  DUP
    BL ASCII ~ WITHIN 0= IF DROP ASCII . THEN  EMIT  LOOP ;
: HEAD  \ addr --- | headder for dump display
  16 0 DO I OVER + 15 AND 3 .R LOOP DROP ;

  \ N. B: Not responsible for negative counts! -- the MGT.
: DUMP   \  addr ct ---  | dump as pointed to by reloc
  OVER CR 6 SPACES HEAD  BEGIN  DUP  WHILE  CR OVER 5 U.R
     2DUP 16 MIN >R  R 2DUP (DUMP)  54 TAB LASCI
     R R> MINUS D+  ?TERMINAL IF DROP 0 THEN  REPEAT 2DROP ;

\ disassembling: inst disassem            ( 24  3 88 crc 21:00 )
: INST  \  ---  | display opcode at ip, advancing as needed
  DISASSEMBLER  CR
  CP@ >R R 6 U.R  R TC@ 3 .R 2 SPACES
  NEXTB  DUP ?SEG IF SEG: NEXTB  THEN
         DUP ?REP IF F0S  NEXTB  THEN
  (INST)  OPS @ CP +!  OPS OFF  IM OFF
  R> CP@ OVER - 2DUP  35 TAB (DUMP)
  55 TAB LASCI  ?STACK   ;

: DISASSEM   \  addr --- | disassemble until esc key
  DISASSEMBLER  2 TAB ESC_TO_EXIT  CP !  BASE @ >R  HEX
  BEGIN  INST  (KEY)  DUP CTL M = IF SCR @ LIST THEN
     DUP CTL N = IF  SCR 1+!  SCR @ LIST  THEN
     CTL [ = UNTIL  R> BASE ! ;
32  ' ESC_TO_EXIT  nfa 2DUP 4 + C!  7 + C!
\ integrate into decompiler  dis: un:                 23Sep87crc
: DIS:  ( HOMESEG   RELOC OFF)   ' CFA @ DISASSEM ;
EXIT
: SEE    \ cfa ---   | disassemble if unknown or code
  ' DUP @ [ HIDDEN ] DEFINITION-CLASS
  6 = IF  DUP @ DOES?  NIP  IF  (SEE)
           ELSE  HOMESEG @ DISASSEM  THEN
      ELSE  (SEE)  THEN ;

: UN:  SEE ;    \ made with the un: nut, of course
\S
: FRED  ;  \ temp for use with trial code.




\ Comments: Addressing modes:                          8Jul87crc
Intel name         Mnemonic      E.g.
Register           rr            AX AX SUB
Immediate          #             -1 # AX MOV
Direct             #)            UP #) BX MOV
Register Indirect  [rX]          AX [BX] ADD
Base addressing    dsp [Bx]      ' DP 2+ @ [BX] AX MOV
Indexed            dsp [xI]      20 [SI] AX MOV
Based Indexed      dsp [Bx+xI]   1024 [BP+DI] AX MOV
String             implied       LDS
Port Direct        dsp           AX 44 OUT
Port Indirect      rr            AL DX OUT

  |   7 |   6 |   5 |   4 |   3 |   2 |   1 |   0 |
  |    op1    |       op2       |       op1       |
  |  - mod -  |   --- reg ---   |   --- r/m ---   |
\ test code                                           24Jul87crc
FORGET FRED        HEX
VARIABLE FRED                  CODE TEST   AX AX SUB
  CLC STI  0 [BP+SI] DEC   1234 [BX+SI] BYTE DEC
  0 [SI] CALL   2345 [SI] FAR CALL  34 [BP] PUSH
  5 [W] MUL  0 [BX+SI] IDIV  rep repz hlt cmc
  1234 # 0 [RP] TEST   AX NOT  AL NEG
  86 # 0 [RP] BYTE TEST  AX DX OUT  5 # AL IN
  AX CL SHR  0 [RP] ROR  5 [W] -1 1 ESC  XLAT  AAM
  0 [BX] AX LDS  12 # 5 [W] BYTE MOV  45 INT
  14 # AL MOV   1234 # BP MOV            BYTE SCAS
  FRED #) AL MOV   MOVS  BYTE CMPS   12 # AX TEST AX LODS
                                        -->



\ test code                                           31Jul87crc
  AX CX XCHG  CBW CWD  WAIT
  AX BX ADC   ES PUSH  ES POP  AAA     AX ES MOV
  50 # 200 [BX] ADD
  BX BX SUB  BYTE 20 # 1234 [BX] OR   50 # 20 [BX] BYTE ADD
  5000 # FRED #) ADD   BL 0 [RP] MOV    0 [RP] BL MOV
            0= IF  500 #) BX LEA  FRED #) POP
    ES:     0 [BX] AX ADD   ES PUSH  THEN      NEXT END-CODE

HERE  : SEE  [ 2 CSP +! ]  ['] TEST @  LITERAL OVER -  DUMP ;
FLUSH  EDITOR   BLK @ 1- LIST  FRED 6 U.R SPACE  DIS: TEST





\ User Notes & comments                               28Jul87crc
If you have Henry Laxen's decompiler installed, then load
scr 36. Otherwise fix screen 36 for your decompiler, or ignore
3) below. To use the disassembler:

1) enter  <addr> DISASSEM . This will begin disassembling at
   addr. E.g. 1234 DISASSEM.

2) enter  DIS: <wordname> . This will disassemble the code
   field address of  <wordname> , regardless of the type of
   the word. E.g. DIS: 0

3) enter  SEE <wordname> . If  <wordname>  is a code definition,
   the code at its code field address will be disassembled.
   E.g. SEE DUP

\ User Notes & comments                               28Jul87crc
To add to the symbol table: 1) add code to calculate the address
and add it into the table  SYMBOLS . 2) Increment  SYMBOLCT  by
the correct amount. 3) Add a  .SELF  for each new symbol, and
4) add the new  .SELF  daughter words to the execution array in
.SYMBOL . Then re-compile the disassembler.

The FORTH registers are shown by name: IP, W, RP. This may be
turned off, and the Intel names substituted with the switch
SYMBOLIC , in the  FORTH  vocabulary.






\ 808sux disassembler. Bleah.                         28Jul87crc
Note that errors may yet exist in this disassembler. If so,
when you find one, please report it to me so that I can fix it
and propagate the fix. Thank you.

   Sources: The 8086/8088 Primer, Morse, Hayden
            iAPX 86/88, 186/188 User's Manual, Intel

























































































































































































\ write#s for sector checking                   14:22 21Dec87crc
: write#  \ blk# --  | write block# with its block number
  dup block ! update ;

: write#s  \ start ct  --  | write ct block#s from start
  bounds cr  do  i write#  i 5 .r  loop ;

: read#    \ blk#  --  #  | read first cell of a block
  block @ ;

: read#s   \ start ct  --  | read ct blocks & verify their #s
  bounds  cr do  i read#  i 2dup  -
     if  10 .r 6 .r  else 2drop  then loop  cr ;

: verify   \ start ct --  | check out a range of blocks
  2dup  write#s  read#s ;
































































\ F83Y : Forth-83 with separated heads--MSDOS version
Kernel compiled with Meta compiler.  Produces KERNEL.COM.


*************************************************************
***           Based on F83 version 2.1.0 by               ***
***                                                       ***
***    Henry Laxen         and    Michael Perry           ***
***    1259 Cornell Avenue        1125 Bancroft Way       ***
***    Berkeley, California       Berkeley, California    ***
***    94706                      94702                   ***
***                                                       ***
*************************************************************
    Heads separation by:     J. D. Hopper
                             P.O. Box 2782
                             Stanford, Ca.  94305
\ Target System Setup                          10:00 008Apr87TJZ
ONLY FORTH   META ALSO FORTH
256 DP-T !  HERE   8000 + ' TARGET-ORIGIN >BODY !    IN-META
2 LOADALL ( System Source Screens )
CR .( Unresolved references: ) CR   .UNRESOLVED
CR .(     Statistics: )  CR .( Last Host Address:         )
[FORTH] HERE U.          CR .( First Target Code Address: )
META 256 THERE U.        CR .( Last Target Code Address:  )
META HERE-T THERE U. META 256 THERE  SVYSEG DUP YSTART !-T
HERE-Y + HERE-Y YDP UP @-T + !-T
DUP THERE ONLY FORTH ALSO SP@ SWAP -
                         CR .( Free Symbol Table bytes:   ) U.
      ( MS-DOS only )   ONLY FORTH ALSO DOS  ' NOOP IS HEADER
   ONLY FORTH ALSO DOS .ELAPSED SAVE   KERNEL.COM   FORTH
CR .( Now return to the DOS and type: )
CR .( KERNEL SFORTH.BLK <CR> )  CR .( OK <CR> )
\ Declare the Forward References  and Version #       04Apr84map
: ]]   ]   ;
: [[   [COMPILE] [   ; FORTH IMMEDIATE META


FORWARD: DEFINITIONS
FORWARD: [



\ Macros for inline NEXT, 1PUSH, and 2PUSH. faster by about 12%
\ and it costs only 400 bytes, or 3.82% increase in size.
\ H: 2PUSH  META ASSEMBLER DX PUSH AX PUSH
\           AX LODS   AX W MOV   0 [W] JMP ;
\ H: 1PUSH  META ASSEMBLER AX PUSH AX LODS AX W MOV 0 [W] JMP ;
\ H: NEXT   META ASSEMBLER AX LODS   AX W MOV   0 [W] JMP ;
\ Boot up Vectors and NEXT Interpreter                06Jul87crc
ASSEMBLER LABEL ORIGIN
HERE 8000 + #) JMP   \ jump to cold start: will be patched
HERE 8000 + #) JMP   \ jump to warm start: will be patched

LABEL BPUSH BX PUSH  LABEL DPUSH DX PUSH  LABEL APUSH AX PUSH

LABEL >NEXT   AX LODS   AX W MOV   0 [W] JMP

  H: 3PUSH  META ASSEMBLER  BPUSH #) JMP  ;       \ MACRO JUMPS
  H: 2PUSH  META ASSEMBLER  DPUSH #) JMP  ;
  H: 1PUSH  META ASSEMBLER  APUSH #) JMP  ;
  H: NEXT   META ASSEMBLER  >NEXT #) JMP  ;



\                                                     02Feb87TJZ
HERE-T ,-Y  ( valid "previous" CFA for "CREATE )

HERE-Y HERE-T CNHASH !-Y ( first entry in >NAME hash table )

HERE-T DUP 100 + CURRENT-T !   ( harmless )

HERE-Y VOCABULARY FORTH   FORTH DEFINITIONS

0 OVER 2+ !-Y ( link )  ( ASCII F 3 AND = 2, 3 = #THREADS )

\ 6 +, IS 2+ FOR CFA>BODY, THEN 2 IS THIRD THREAD, SO 4 + MORE
2+ SWAP  ( 6 ) 14 + !-T ( thread 6 NOT 2 )  IN-META



\ Run Time Code for Defining Words                     9Jul87crc
ASSEMBLER LABEL NEST
   W INC   W INC   RP DEC   RP DEC   IP 0 [RP] MOV   W IP MOV
   NEXT  META
CODE EXIT     (S -- )
   0 [RP] IP MOV   RP INC   RP INC   NEXT END-CODE

CODE UNNEST   ' EXIT @-T ' UNNEST !-T   END-CODE
ASSEMBLER LABEL DODOES
  SP RP XCHG   IP PUSH   SP RP XCHG   IP POP
\   W INC   W INC   W PUSH   NEXT   talk about duplicate code...
LABEL DOCREATE
  W INC   W INC   W PUSH   NEXT
META


\ Run Time Code for Defining Words                    11Sep87crc
VARIABLE UP




LABEL DOCONSTANT
                   2 [W]    PUSH  NEXT   END-CODE

LABEL DOUSER-VARIABLE
                   2 [W] AX MOV   UP #) AX ADD   1PUSH  END-CODE

CODE (LIT)   (S -- n )
   AX LODS   1PUSH END-CODE

CODE CLIT    (S -- n )   AL LODS  CBW  1PUSH END-CODE
\ Meta Defining Words                                  3Aug87crc
T: LITERAL   (S n -- ) DUP -128 127 BETWEEN  IF
  [TARGET] CLIT C,-T  ELSE  [TARGET] (LIT) ,-T  THEN T;
T: DLITERAL  (S d -- )
   [TARGET] (LIT) ,-T   [TARGET] (LIT) ,-T   T;
T: ASCII     (S -- )
   [COMPILE] ASCII   [[ TRANSITION ]] LITERAL [META]  T;
T: [']   (S -- )
   'T >BODY @   [[ TRANSITION ]] LITERAL  [META]   T;
: CONSTANT   (S n -- )
   RECREATE   [[ ASSEMBLER DOCONSTANT ]] LITERAL ,-T
   DUP ,-T   CONSTANT   ;




\ Identify numbers and forward References             06Apr84map
FORWARD: <(;CODE)>
T: DOES>     (S -- )
   [FORWARD] <(;CODE)>   HERE-T  ( DOES-OP ) 232 C,-T
   [[ ASSEMBLER DODOES ]] LITERAL HERE 2+ - ,-T  T;
: NUMERIC   (S -- )
   [FORTH] HERE [META] NUMBER   DPL @ 1+ IF
      [[ TRANSITION ]] DLITERAL [META]
   ELSE   DROP   [[ TRANSITION ]] LITERAL [META]   THEN  ;
: UNDEFINED   (S -- )
   HERE-T   0 ,-T
   IN-FORWARD  [FORTH] CREATE [META] TRANSITION
   [FORTH] ,   FALSE ,   [META]
   DOES>   FORWARD-CODE   ;


\ Meta Compiler Compiling Loop                        14Nov86TJZ
[FORTH] VARIABLE T-IN      META
: ]   (S -- )
   STATE-T ON   IN-TRANSITION   BEGIN  >IN @ T-IN !
   DEFINED IF   EXECUTE   ELSE
      COUNT NUMERIC? IF   NUMERIC   ELSE
         T-IN @ >IN !   UNDEFINED   THEN THEN
   STATE-T @ 0= UNTIL   ;
T: [   (S -- )
   IN-META   STATE-T OFF   T;
T: ;   (S -- )
   [TARGET] UNNEST   [[ TRANSITION ]] [   T;
: :   (S -- )
   TARGET-CREATE   [[ ASSEMBLER NEST ]] LITERAL ,-T   ]   ;


\ Run Time Code for Control Structures                04OCT83HHL
CODE BRANCH   (S -- )
LABEL BRAN1   0 [IP] IP MOV   NEXT END-CODE
CODE ?BRANCH   (S f -- )
  AX POP   AX AX OR   BRAN1 JE   IP INC   IP INC   NEXT END-CODE











\ Meta Compiler Branching Words                       01AUG83HHL
T: BEGIN   ?<MARK   T;
T: AGAIN   [TARGET] BRANCH   ?<RESOLVE   T;
T: UNTIL   [TARGET] ?BRANCH  ?<RESOLVE   T;
T: IF      [TARGET] ?BRANCH  ?>MARK      T;
T: THEN    ?>RESOLVE    T;
T: ELSE
     [TARGET] BRANCH    ?>MARK   2SWAP ?>RESOLVE   T;
T: WHILE   [[ TRANSITION ]] IF   T;
T: REPEAT
   2SWAP   [[ TRANSITION ]] AGAIN   THEN   T;





\ Run Time Code for Control Structures                20May87TJZ
CODE (LOOP)   (S -- )   1 # AX MOV
LABEL PLOOP   AX 0 [RP] ADD   BRAN1 JNO
  6 # RP ADD   IP INC   IP INC   NEXT END-CODE

CODE (+LOOP)   (S n -- )
  AX POP   PLOOP #) JMP   END-CODE









\ Run Time Code for Control Structures                23Jul87crc
HEX
CODE (DO)   (S l i -- )   AX POP   BX POP
LABEL PDO   RP DEC   RP DEC   0 [IP] DX MOV   DX 0 [RP] MOV
  IP INC   IP INC   8000 # BX ADD   RP DEC   RP DEC
  BX 0 [RP] MOV   BX AX SUB   RP DEC   RP DEC   AX 0 [RP] MOV
  NEXT END-CODE
DECIMAL

CODE (?DO)   (S l i -- )
  AX POP   BX POP   AX BX CMP
  PDO JNE   0 [IP] IP MOV   NEXT END-CODE

CODE BOUNDS     DX POP AX POP AX DX ADD 2PUSH  END-CODE


\ Meta compiler Branching & Looping                   01AUG83HHL
T: ?DO
   [TARGET] (?DO)   ?>MARK   T;
T: DO
   [TARGET] (DO)    ?>MARK   T;
T: LOOP
   [TARGET] (LOOP)    2DUP 2+   ?<RESOLVE   ?>RESOLVE   T;
T: +LOOP
   [TARGET] (+LOOP)   2DUP 2+   ?<RESOLVE   ?>RESOLVE   T;







\ Execution Control                              9:27 28Oct87crc
ASSEMBLER >NEXT META CONSTANT >NEXT
CODE EXECUTE   (S cfa -- )
   W POP   0 [W] JMP END-CODE
CODE PERFORM   (S addr-of-cfa -- )
   W POP   0 [W] W MOV   0 [W] JMP END-CODE
LABEL DODEFER   (S -- )
   2 [W] W MOV  0 [W] JMP   END-CODE
LABEL DOUSER-DEFER
   2 [W] AX MOV  UP #) AX ADD
   AX W MOV      0 [W] W MOV  0 [W] JMP   END-CODE

CODE NOOP   END-CODE    >NEXT  ' NOOP !-T
CODE PAUSE  NEXT   END-CODE


\ Execution Control                                   20May87TJZ
CODE I   (S -- n )
  0 [RP] AX MOV   2 [RP] AX ADD   1PUSH END-CODE

CODE J   (S -- n )
  6 [RP] AX MOV   8 [RP] AX ADD   1PUSH END-CODE  DECIMAL

CODE (LEAVE)   (S -- )
LABEL PLEAVE   4 # RP ADD
  0 [RP] IP MOV   RP INC   RP INC   NEXT END-CODE

CODE (?LEAVE)   (S f -- )
   AX POP   AX AX OR   PLEAVE JNE   NEXT END-CODE

T: LEAVE   [TARGET] (LEAVE)   T;
T: ?LEAVE  [TARGET] (?LEAVE)  T;
\ 16 and 8 bit Memory Operations                      22Aug83map
CODE @     (S addr -- n )
   BX POP   0 [BX] PUSH   NEXT END-CODE
CODE !     (S n addr -- )
   BX POP   0 [BX] POP   NEXT END-CODE
CODE C@     (S addr -- char )
   BX POP   AX AX SUB   0 [BX] AL MOV   1PUSH END-CODE
CODE C!     (S char addr -- )
   BX POP   AX POP   AL 0 [BX] MOV   NEXT END-CODE







\ CMOVE  CMOVE>  PLACE                                13Nov86TJZ
CODE CMOVE      (S  from to count -- )
        CLD   IP BX MOV   DS AX MOV   AX ES MOV
        CX POP   DI POP   IP POP
        REP   BYTE MOVS   BX IP MOV   NEXT END-CODE
CODE CMOVE>   (S from to count -- )
        STD   IP BX MOV   DS AX MOV   AX ES MOV   CX POP
        CX DEC DI POP IP POP   CX DI ADD   CX IP ADD   CX INC
        REP   BYTE MOVS   BX IP MOV   CLD   NEXT END-CODE
CODE PLACE      (S from cnt to -- )
        BX POP   AX POP   AL 0 [BX] MOV
        BX INC BX PUSH AX PUSH
        CLD   IP BX MOV   DS AX MOV   AX ES MOV
        CX POP   DI POP   IP POP
        REP   BYTE MOVS   BX IP MOV   NEXT END-CODE

\ VIDEO-SEG ?VMODE VMODE.SET                          29Nov86TJZ

VARIABLE VIDEO-SEG

CODE ?VMODE     ( --- N1 )
                15 # AH MOV 16 INT  AH AH SUB
                1PUSH END-CODE

HEX
: VMODE.SET     ( --- )
                ?VMODE 7 =
                IF      0B000
                ELSE    0B800   THEN VIDEO-SEG ! ;
DECIMAL


\ VTYPE                                               29Nov86TJZ
VARIABLE ATT  BASE @ HEX 707 HERE-T 2- !-T   BASE !

CODE VTYPE  ( string length x y -- )
        AX POP DX POP BX POP BX PUSH DX PUSH AX PUSH BX DX ADD
        AL DH MOV  BX BX XOR  2 # AH MOV 16 INT
        160 # AX MOV BX POP BX MUL AX DI MOV
        AX POP AX SHL AX DI ADD
        CX POP  BX POP BX DI XCHG
        ES PUSH
        VIDEO-SEG #)  AX MOV   AX ES MOV ( save addr.)
\       ATT #) AH MOV
        HERE    0 [DI] AL MOV   ES: AL 0 [BX] MOV
                DI INC BX INC
          ( ES: AH 0 [BX] MOV ) BX INC
        LOOP    ES POP   NEXT   END-CODE
\ 16 bit Stack Operations                             28Nov86TJZ
DECIMAL

CODE SP@        (S -- n )
                SP AX MOV   1PUSH END-CODE

CODE SP!        (S n -- )
                SP POP   NEXT END-CODE

CODE RP@        (S -- addr )
                RP AX MOV   1PUSH END-CODE

CODE RP!        (S n -- )
                RP POP   NEXT END-CODE


\ 16 bit Stack Operations                             29Jan87TJZ


CODE DROP       (S n1 -- )
                AX POP   NEXT END-CODE

CODE DUP        (S n1 -- n1 n1 )
                AX POP   AX PUSH   1PUSH END-CODE

CODE SWAP       (S n1 n2 -- n2 n1 )
                DX POP   AX POP   2PUSH END-CODE

CODE OVER       (S n1 n2 -- n1 n2 n1 )
                DX POP   AX POP   AX PUSH   2PUSH END-CODE


\ 16 bit Stack Operations                        9:35 28Oct87crc
CODE NIP      (S n1 n2 -- n2 )
   AX POP   DX POP   1PUSH END-CODE
CODE TUCK     (S n1 n2 -- n2 n1 n2 )
   AX POP   DX POP   AX PUSH   2PUSH END-CODE

CODE ROT   (S n1 n2 n3 --- n2 n3 n1 )
   DX POP   BX POP    AX POP   3PUSH END-CODE
CODE -ROT   (S n1 n2 n3 --- n3 n1 n2 )
   BX POP   AX POP    DX POP   3PUSH END-CODE

CODE FLIP   (S n1 -- n2 )
  AX POP   AH AL XCHG   1PUSH END-CODE

CODE ?DUP   (S n1 -- [n1] n1 )
  AX POP  0 # AX CMP  0<> IF  AX PUSH  THEN  1PUSH END-CODE
\ 16 bit Stack Operations                       17:42  6Nov87crc
CODE R>     (S -- n )
  0 [RP] AX MOV   RP INC   RP INC   1PUSH END-CODE

CODE >R     (S n -- )
  AX POP   RP DEC   RP DEC   AX 0 [RP] MOV   NEXT END-CODE

CODE R@     (S -- n )
  0 [RP] AX MOV   1PUSH END-CODE

CODE PICK    (S nm ... n2 n1 k -- nm ... n2 n1 nk )
  BX POP   BX SHL   SP BX ADD   0 [BX] AX MOV   1PUSH END-CODE

: ROLL  >R R@ PICK  SP@ DUP 2+ R>  1+ 2* CMOVE>  DROP ;


\ 16 bit Logical Operations                           20May87TJZ
CODE AND     (S n1 n2 -- n3 )
   BX POP   AX POP   BX AX AND   1PUSH END-CODE

CODE OR      (S n1 n2 -- n3 )
   BX POP   AX POP   BX AX OR    1PUSH END-CODE

CODE XOR      (S n1 n2 -- n3 )
   BX POP   AX POP   BX AX XOR   1PUSH END-CODE

CODE NOT     (S n -- n' )
   AX POP   AX NOT   1PUSH END-CODE




\ Logical Operations                                  28Nov86TJZ
CODE ON   (S addr -- )
  BX POP   TRUE # 0 [BX] MOV   NEXT END-CODE

CODE OFF   (S addr -- )
  BX POP   FALSE # 0 [BX] MOV   NEXT END-CODE










\ -1! 0! INCR DECR                              13:35 30Oct87crc
CODE INCR       ( A1 --- )
                BX POP  0 [BX] INC NEXT END-CODE

CODE DECR       ( A1 --- )
                BX POP  0 [BX] DEC NEXT END-CODE

\S
CODE -1!        ( addr -- )
  END-CODE    ' ON  @-T  ' -1! !-T   \ save 8 bytes. No slower.
                                     \ by aliasing them.
CODE 0!         ( addr -- )
  END-CODE    ' OFF @-T  ' 0! !-T



\ 16 bit Arithmetic Operations                        02Jul87crc
CODE +   (S n1 n2 -- sum )
  BX POP   AX POP   BX AX ADD   1PUSH END-CODE
CODE NEGATE   (S n -- n' )
  AX POP   AX NEG   1PUSH END-CODE
CODE -       (S n1 n2 -- n1-n2 )
  BX POP   AX POP   BX AX SUB   1PUSH END-CODE
CODE ABS   (S n -- n )
  AX POP   AX AX OR   0< IF   AX NEG   THEN   1PUSH END-CODE
CODE +!   (S n addr -- )
  BX POP   AX POP   AX 0 [BX] ADD   NEXT END-CODE

1 CONSTANT 1
2 CONSTANT 2      3 CONSTANT 3
( 4 ) 16 CONSTANT #THREADS

\ 16 bit Arithmetic Operations                        08Nov86TJZ
CODE 2*   (S n -- 2*n )
   AX POP   AX SHL   1PUSH END-CODE
CODE 2/   (S n -- n/2 )
   AX POP   AX SAR   1PUSH END-CODE

CODE U2/  (S u -- u/2 )
   AX POP   AX SHR   1PUSH END-CODE

CODE 8*   (S n -- 8*n )
   AX POP   AX SHL   AX SHL   AX SHL   1PUSH END-CODE
CODE 1+    AX POP   AX INC   1PUSH END-CODE
CODE 2+    AX POP   AX INC   AX INC   1PUSH END-CODE
CODE 1-    AX POP   AX DEC   1PUSH END-CODE
CODE 2-    AX POP   AX DEC   AX DEC   1PUSH END-CODE

\ 16 bit Arithmetic Operations   Unsigned Multiply    22Aug83map
CODE UM*      (S n1 n2 -- d )
  AX POP   BX POP   BX MUL   DX AX XCHG   2PUSH END-CODE


\ : U*D   (S n1 n2 -- d )   UM*   ;


























\ 16 bit Arithmetic Operations   Unsigned Divide      24Jul87crc
CODE UM/MOD   (S d1 n1 -- Remainder Quotient )
  BX POP   DX POP   AX POP   BX DX CMP  U>=  ( divide by zero? )
  IF   -1 # AX MOV  AX DX MOV  ELSE  BX DIV  THEN  2PUSH
  END-CODE

\S

  IF   -1 # AX MOV   AX DX MOV   2PUSH   THEN
  BX DIV   2PUSH END-CODE






\    bit Comparison Operations                        02Jul87crc
ASSEMBLER  LABEL YES     TRUE # AX MOV   1PUSH
           LABEL NO      AX AX SUB  1PUSH
CODE 0=      (S n -- f )
   AX POP   AX AX OR   YES JE   NO #) JMP END-CODE
CODE 0<      (S n -- f )
   AX POP   AX AX OR   YES JS   NO #) JMP END-CODE
CODE 0>   (S n -- f )
   AX POP   AX AX OR   YES JG   NO #) JMP END-CODE
CODE 0<>  (S n -- f )
   AX POP   AX AX OR   YES JNE  NO #) JMP END-CODE
CODE =       (S n1 n2 -- f )
   AX POP   BX POP   AX BX CMP   YES JE    NO #) JMP END-CODE
: <>         (S n1 n2 -- f )    = NOT   ;
: ?NEGATE    (S n1 n2 -- n3 )   0< IF    NEGATE   THEN   ;

\ 16 bit Comparison Operations                  10:01 28Oct87crc
CODE   U<   (S n1 n2 -- f )
   AX POP   BX POP   AX BX CMP   YES JB    NO #) JMP END-CODE
CODE   U>   (S n1 n2 -- f )
   AX POP   BX POP   BX AX CMP   YES JB    NO #) JMP END-CODE
CODE <   (S n1 n2 -- f )
   AX POP   BX POP   AX BX CMP   YES JL    NO #) JMP END-CODE
CODE >   (S n1 n2 -- f )
   AX POP   BX POP   AX BX CMP   YES JG    NO #) JMP END-CODE

CODE MIN  AX POP   BX POP   AX BX CMP
          < IF BX PUSH NEXT THEN 1PUSH C;

CODE MAX  AX POP   BX POP   AX BX CMP
          > IF BX PUSH NEXT THEN 1PUSH C;

\ 32 bit Memory Operations                            02Jul87crc
: BETWEEN   (S n1 min max -- f ) >R  OVER > SWAP R> > OR NOT ;
: WITHIN   (S n1 min max -- f )   1- BETWEEN  ;

CODE 2@     (S addr -- d )
   BX POP   0 [BX] AX MOV   2 [BX] DX MOV
   2PUSH  END-CODE

CODE 2!     (S d addr -- )
   BX POP   0 [BX] POP  2 [BX] POP
   NEXT  END-CODE

CODE FALSE   END-CODE  ASSEMBLER NO  ' FALSE !-T
CODE TRUE    END-CODE  ASSEMBLER YES ' TRUE  !-T
CODE 0       END-CODE  ASSEMBLER NO  ' 0     !-T

\ 32 bit Memory and Stack Operations             9:52  9Nov87crc
CODE 2DROP     (S d -- )
   AX POP   AX POP   NEXT END-CODE
CODE 2DUP     (S d -- d d )
   AX POP   DX POP   DX PUSH   AX PUSH   2PUSH END-CODE
CODE 3DUP     (S d -- d d )
   AX POP   DX POP   BX POP   BX PUSH  DX PUSH  AX PUSH
   3PUSH   END-CODE
CODE 2SWAP     (S d1 d2 -- d2 d1 )
   BX POP   CX POP   AX POP   DX POP
   CX PUSH  3PUSH END-CODE
CODE 2OVER     ( d1 d2 --- d1 d2 d1 )
   W POP  CX POP  AX POP  DX POP
   DX PUSH  AX PUSH  CX PUSH  3PUSH


\ 32 bit Arithmetic Operations                   9:38 28Oct87crc
CODE D+  (S d1 d2 -- dsum )
  AX POP   DX POP   BX POP   CX POP   CX DX ADD   BX AX ADC
  2PUSH END-CODE
CODE DNEGATE  (S d# -- d#' )
  BX POP   CX POP   AX AX SUB   AX DX MOV
  CX DX SUB   BX AX SBB   2PUSH END-CODE
CODE S>D      (S n -- d )
   AX POP   CWD   AX DX XCHG   2PUSH   END-CODE
CODE DABS   (S d# -- d# )
   DX POP DX PUSH   DX DX OR   ' DNEGATE @-T JS   NEXT  END-CODE





\ 32 bit Arithmetic Operations                  14:14 28Oct87crc
: D-    (S d1 d2 -- d3 )   DNEGATE D+   ;
: ?DNEGATE  (S d1 n -- d2 )     0< IF   DNEGATE   THEN   ;
: 4DUP     (S d1 d2 -- d1 d2 d1 d2 )
   2OVER 2OVER ;











\ 32 bit Comparison Operations                  14:14 28Oct87crc
: D0=   (S d -- f )        OR 0= ;
: D=    (S d1 d2 -- f )    D-  D0=  ;
: DU<   (S ud1 ud2 -- f )   ROT SWAP 2DUP U<
   IF   2DROP 2DROP TRUE
   ELSE  <> IF   2DROP FALSE  ELSE  U<  THEN
   THEN  ;
: D<    (S d1 d2 -- f )   2 PICK OVER =
   IF   DU<   ELSE  NIP ROT DROP <  THEN  ;
: D>    (S d1 d2 -- f )    2SWAP D<   ;
: DMIN  (S d1 d2 -- d3 )   4DUP D> IF   2SWAP   THEN   2DROP ;
: DMAX  (S d1 d2 -- d3 )   4DUP D< IF   2SWAP   THEN   2DROP ;




\ Mixed Mode Arithmetic                               04OCT83HHL
: *D   (S n1 n2 -- d# )
   2DUP  XOR  >R  ABS  SWAP  ABS  UM*  R>  ?DNEGATE  ;
: M/MOD   (S d# n1 -- rem quot )
   ?DUP
   IF  DUP >R  2DUP XOR >R  >R DABS R@ ABS  UM/MOD
     SWAP R> ?NEGATE
     SWAP R> 0< IF  NEGATE OVER IF  1- R@ ROT - SWAP  THEN THEN
     R> DROP
   THEN  ;

: MU/MOD  (S d# n1 -- rem d#quot )
   >R  0  R@  UM/MOD  R>  SWAP  >R  UM/MOD  R>   ;



\ 16 bit multiply and divide                          04OCT83HHL
: *   (S n1 n2 -- n3 )   UM* DROP   ;
: /MOD  (S n1 n2 -- rem quot )   >R  S>D  R>  M/MOD  ;
: /     (S n1 n2 -- quot )   /MOD  NIP  ;
: MOD   (S n1 n2 -- rem )    /MOD  DROP  ;
: */MOD  (S n1 n2 n3 -- rem quot )
   >R  *D  R>  M/MOD  ;
: */    (S n1 n2 n3 -- n1*n2/n3 )     */MOD  NIP  ;








\ Task Dependant USER Variables                       10Dec86TJZ
USER DEFINITIONS
VARIABLE  TOS         ( TOP OF STACK )
VARIABLE  ENTRY       ( ENTRY POINT, CONTAINS MACHINE CODE )
VARIABLE  LINK        ( LINK TO NEXT TASK )
VARIABLE  SP0         ( INITIAL PARAMETER STACK )
VARIABLE  RP0         ( INITIAL RETURN STACK )
VARIABLE  DP          ( DICTIONARY POINTER )
\ VARIABLE  #OUT        ( NUMBER OF CHARACTERS EMITTED see 123)
\ VARIABLE  #LINE       ( THE NUMBER OF LINES SENT SO FAR )
VARIABLE  OFFSET      ( RELATIVE TO ABSOLUTE DISK BLOCK 0 )
VARIABLE  BASE        ( FOR NUMERIC INPUT AND OUTPUT )
VARIABLE  HLD         ( POINTS TO LAST CHARACTER HELD IN PAD )
VARIABLE  FCB         ( POINTS TO FCB OF CURRENTLY OPEN FILE )
VARIABLE  IN-FCB      ( POINTS TO FCB OF CURRENTLY OPEN FILE )
VARIABLE  PRINTING
\ System VARIABLEs                                    29Oct86TJZ
VARIABLE  YDP       ( HEADER SEG POINTER )
DEFER     EMIT      DEFER KEY? DEFER KEY DEFER TYPE
META DEFINITIONS
VARIABLE  SCR       ( SCREEN LAST LISTED OR EDITED )
VARIABLE  PRIOR     ( USED FOR DICTIONARY SEARCHES )
VARIABLE  STATE     ( COMPILATION OR INTERPRETATION )
VARIABLE  WARNING   ( GIVE USER DUPLICATE WARNINGS IF ON )
VARIABLE  DPL       ( NUMERIC INPUT PUNCTUATION )
VARIABLE  R#        ( EDITING CURSOR POSITION )
VARIABLE  LAST      ( POINTS TO NFA OF LATEST DEFINITION )
VARIABLE  CSP       ( HOLDS STACK POINTER FOR ERROR CHECKING )
VARIABLE  CURRENT   ( VOCABULARY WHICH GETS DEFINITIONS )
8 CONSTANT #VOCS    ( THE NUMBER OF VOCABULARIES TO SEARCH )
VARIABLE  CONTEXT   ( VOCABULARY SEARCHED FIRST )
   HERE THERE #VOCS 2* DUP ALLOT ERASE
\ System Variables                                    10Dec86TJZ
VARIABLE  'TIB      ( ADDRESS OF TERMINAL INPUT BUFFER )
VARIABLE  WIDTH     ( WIDTH OF NAME FIELD )
VARIABLE  VOC-LINK  ( POINTS TO NEWEST VOCABULARY )
VARIABLE  BLK       ( BLOCK NUMBER TO INTERPRET )
VARIABLE  >IN       ( OFFSET INTO INPUT STREAM )
VARIABLE  SPAN      ( NUMBER OF CHARACTERS EXPECTED )
VARIABLE  #TIB      ( NUMBER OF CHARACTERS TO INTERPRET )
VARIABLE  END?      ( TRUE IF INPUT STREAM EXHAUSTED )
VARIABLE  #OUT        ( NUMBER OF CHARACTERS EMITTED )
VARIABLE  #LINE       ( THE NUMBER OF LINES SENT SO FAR )





\ Devices                     Strings           14:20 28Oct87crc
   32 CONSTANT BL      8 CONSTANT BS         7 CONSTANT BELL
VARIABLE CAPS
CODE FILL         (  start-addr count char -- )
   CLD   DS AX MOV   AX ES MOV   AX POP   CX POP   DI POP
   REP   AL STOS   NEXT END-CODE
: ERASE      (S addr len -- )   0 FILL   ;
: BLANK      (S addr len -- )   BL FILL   ;
CODE COUNT   (S addr -- addr+1 len )
   BX POP   AX AX SUB   0 [BX] AL MOV   BX INC   BX PUSH
   1PUSH END-CODE             \S
CODE LENGTH  (S addr -- addr+2 len )    \ REALLY WORD COUNT
   BX POP   0 [BX] AX MOV   BX INC   BX INC   BX PUSH
   1PUSH END-CODE
: MOVE   ( from to len -- )
   -ROT   2DUP U< IF   ROT CMOVE>   ELSE   ROT CMOVE   THEN ;
\ Devices                     Strings           14:24 28Oct87crc
ASSEMBLER LABEL >UPPER
  ASCII a # AL CMP  0>=
  IF   ASCII z 1+ # AL CMP   0< IF   32 # AL SUB   THEN
  THEN   RET

CODE UPC   (S char -- char' )
  AX POP   >UPPER #) CALL   1PUSH   END-CODE

CODE UPPER      (S addr len -- )
  CX POP  BX POP  BEGIN   CX CX OR   0<>
    WHILE  0 [BX] AL MOV  ASCII a # AL CMP
    >UPPER #) CALL  AL 0 [BX] MOV  BX INC  CX DEC
                REPEAT  NEXT   END-CODE         \S


\ here pad -trailing                                  13Jul87crc
CODE HERE       (S -- adr )
   UP #) BX MOV  DP [BX] AX MOV  1PUSH END-CODE

: PAD    (S -- addr )   HERE 80 +   ;

: -TRAILING   (S addr len -- addr len' )
   DUP 0 ?DO   2DUP + 1- C@   BL <> ?LEAVE   1-   LOOP   ;








\ Devices                     Strings                 09Nov86TJZ
LABEL NOMORE   DX SI MOV   CX PUSH   NEXT
CODE COMP      (S addr1 addr2 len -- -1 | 0 | 1 )
   SI DX MOV   CX POP   DI POP   SI POP   NOMORE JCXZ
   DS AX MOV  AX ES MOV   REPZ   BYTE CMPS   NOMORE JE
LABEL MISMATCH   0< IF  -1 # CX MOV  ELSE  1 # CX MOV  THEN
   NOMORE #) JMP END-CODE
\ S   Don't need w/o  search
CODE CAPS-COMP  (S addr1 addr2 len -- -1 | 0 | 1 )
   SI DX MOV   CX POP   DI POP   SI POP
   BEGIN   NOMORE JCXZ   0 [SI] AL MOV  >UPPER #) CALL  SI INC
             AL AH MOV   0 [DI] AL MOV  >UPPER #) CALL  DI INC
     AL AH CMP  MISMATCH JNE   CX DEC
   AGAIN   END-CODE
: COMPARE   (S addr1 addr2 len -- -1 | 0 | 1 )
   CAPS @ IF   CAPS-COMP   ELSE   COMP   THEN   ;
\ MSDOS 2 interface, LONG primatives                  24Nov86TJZ

VARIABLE OSF

CREATE FCDOS ASSEMBLER SI PUSH BP PUSH  CS: OSF #) INC
  33 INT  CS: OSF #) DEC   BP POP SI POP RET




CODE XFDOS ( DX CX BX AX ES DS-CX BX AX CY)    DI POP  ES POP
 AX POP BX POP CX POP DX POP  DS PUSH DS PUSH   DI DS MOV
 FCDOS #) CALL  DS POP ES POP -1 # DX MOV  U>= IF  DX DX XOR
 THEN  CX PUSH  BX PUSH  AX PUSH  DX PUSH  NEXT END-CODE


\ ?CS: @L C@L !L C!L                                  24Nov86TJZ
CODE ?CS: ( -- CS )  CS PUSH NEXT END-CODE

CODE @L BX POP DS POP 0 [BX] AX MOV CS BX MOV BX DS MOV 1PUSH C;

CODE C@L BX POP DS POP 0 [BX] AL MOV AH AH XOR CS BX MOV
   BX DS MOV 1PUSH END-CODE

CODE C!L ( byt seg adr )  BX POP  DS POP  AX POP  AL 0 [BX] MOV
   CS BX MOV  BX DS MOV  NEXT END-CODE

CODE !L ( n seg adr -- ) BX POP  DS POP  AX POP  AX 0 [BX] MOV
   CS BX MOV  BX DS MOV  NEXT END-CODE



\ Devices    Terminal IO via MS-DOS                   12Nov86TJZ
\ For MS-DOS, comment out the CP/M screen and load this one.

CODE <BDOS>  (S n fun -- m )
             AX POP   AL AH MOV   DX POP   33 INT   AH AH SUB
             1PUSH END-CODE

CODE FDOS    (S     )
             DX POP  AX POP   AL AH MOV   33 INT   AH AH SUB
             AX PUSH BX PUSH NEXT END-CODE

DEFER BDOS      ' <BDOS> IS BDOS

: (OS)          BDOS 255 AND ;


\ PSC   Print Spool Control                           24Nov86TJZ
CODE PSC        ( DX AL --- DS SI AL )
                AX POP     1 # AH MOV DX POP    \ GET AL & DX
                CS BX MOV  BX DS MOV            \ SET DS TO CS
                SI PUSH    BP PUSH              \ SAVE SI & BP
                47 INT     SI BX XCHG           \ DO IT
                BP POP     SI POP               \ GET BP & SI
                DS PUSH    BX PUSH              \ PUSH SI & DS
                0 # AH MOV AX PUSH              \ PUSH AL & AH=0
                CS BX MOV  BX DS MOV            \ DS = CS
                NEXT END-CODE                   \ WER'E DONE





\ 0SPOOL QRESUME SET.CNT                              24Nov86TJZ
: 0SPOOL        ( --- )                 \ CLEAR OUT SPOOL LIST
                0 3 PSC 2DROP DROP ;

: QRESUME       ( --- )                 \ RE-ENABLE SPOOLER
                0 5 PSC 2DROP DROP ;

: SET.CNT       ( A1 --- A1 )           \ CONVERT TO COUNTED $
                64 OVER C! 64 0
                DO      I 1+ OVER + C@ 0=
                        IF      I OVER C! LEAVE
                        THEN
                LOOP    ;



\ SPACKET  QLIST  QRESUME                             24Nov86TJZ
CREATE SPACKET 5 ALLOT       \ PACKET USED BY SPOOLER

VARIABLE QVAL 0 ,            \ SPOOLED NAMES OFFSET & SEGMENT

: QLIST.1       ( --- A1 )      \ GET FIRST SPOOLED FILENAME
                0 4 PSC DROP 2DUP 64 + QVAL 2!
                ?CS: HERE 1+ 64 CMOVEL HERE SET.CNT ;

: QLIST.NEXT    ( --- A1 )      \ GET NEXT SPOOLED FILENAME
                QVAL 2@ 2DUP 64 + QVAL 2!
                ?CS: HERE 1+ 64 CMOVEL HERE SET.CNT ;




\ SPACKET  "SPOOL                                     26Nov86TJZ

: "SPOOL        ( A1 --- )      \ SPOOL FILENAME A1
                HERE OVER C@ 1+ CMOVE           \ GET STRING
                0 0 PSC NIP NIP 255 <>          \ 255 IS GOOD
                ABORT" Spooler NOT Installed"   \ CHK SPOOLER
                0 SPACKET C!                    \ SETUP PACKET
                HERE DUP COUNT + OFF            \ NULL TRAIL
                1+ SPACKET 1+ !                 \ OFFSET
                ?CS: SPACKET 3 + !              \ SEGMENT
                SPACKET 1 PSC                   \ SPOOLIT
                2DROP DROP ;                    \ IGNORE RETURN

: FSPOOL        ( --- T1 )      \ SPOOL <FILENAME>
                BL WORD "SPOOL ;

\ BDOS2  OS2                                          06Jul87crc
CODE BDOS2      ( CX DX AX -- CX DX AX )
                AX POP   DX POP   CX POP  AL AH MOV  33 INT
                CX PUSH    2PUSH                     END-CODE

: OS2           BDOS2 255 AND ;
: GETDATE       ( --- Y MD ) 0 0 42 OS2 DROP ;
: SETDATE       ( NM Y --- ) SWAP 43 OS2 >R 2DROP R> 255 =
                IF      CR ." Invalid DATE " THEN ;

: GETTIME       ( --- HM Sh ) 0 0 44 OS2 DROP ;

: SETTIME       ( HM Sh --- ) SWAP 45 OS2 >R 2DROP R> 255 =
                IF      CR ." Invalid TIME " THEN ;

: .##           0 <# # # #> TYPE ;
\ <.TIME> .TIME <.DATE> .DATE                         03Dec86TJZ
: <.HM>       ( D1 --- N1 )
              SWAP 0 256 UM/MOD .## ." :" .## ;

: <.SH>       ( N1 --- )
              ." :" 0 256 UM/MOD .## ." ." .## ;

: <.TIME>     BASE @ >R DECIMAL SWAP 0 256 UM/MOD .## ." :" .##
                               ." :" 0 256 UM/MOD .## ." ." .##
              R> BASE ! SPACE ;

: .TIME       GETTIME <.TIME> ;
: <.DATE>     ( D1 --- ) BASE @ >R DECIMAL
              0 256 UM/MOD 1 .R ." /" 1 .R ." /" . R> BASE ! ;
: .DATE       GETDATE <.DATE> ;

\ TTIME T>B B>T TIMEIT TIME-RESET TIME-ELAPSED        02Dec86TJZ

VARIABLE STIME 0 , VARIABLE TTIME 0 ,

: T>B   0 256 UM/MOD 100 * + SWAP 0 SWAP
        0 256 UM/MOD >R 6000 *D D+ R> 1000 * 360 *D D+ ;

: B>T   0 100 UM/MOD >R 100 UM/MOD SWAP TTIME C!
                     R>  60 UM/MOD SWAP TTIME 1+ C!
                         60   /MOD      TTIME 3 + C!
                                        TTIME 2+ C! ;

: TIME-RESET    GETTIME T>B STIME 2! ;  \ RESET TIMER

: TIME-ELAPSED  GETTIME T>B STIME 2@ D- ; ( - D1 ) \ BINARY

\ B>SEC .ELAPSED TIMER SEC-ELAPSED                    08Apr87TJZ

: B>SEC         ( D1 - N1 )     \ CONVERT DOUBLE BINARY TO
                0 100 UM/MOD DROP \ SECONDS, OVERFLOW AT 18 HRS
                  100 UM/MOD NIP ;

: .ELAPSED      CR ." Elapsed time = " TIME-ELAPSED
                B>T TTIME 2@ <.TIME> ;

: TIMER         TIME-RESET INTERPRET .ELAPSED ;

: SEC-ELAPSED   ( --- N1 )  \ RETURN ELAPSED SECONDS < 18 HRS
                TIME-ELAPSED B>SEC ; ( -- N1 )
: 10TH-ELAPSED  ( --- N1 )
                TIME-ELAPSED 0 100 UM/MOD DROP 10 UM/MOD NIP ;

\ SECONDS  PAUSE-FUNC TENTHS                          08Apr87TJZ

DEFER PAUSE-FUNC        ' NOOP IS PAUSE-FUNC

: SECONDS       ( N1 --- )      \ PAUSE FOR N1 SECONDS
                STIME 2@ >R >R >R TIME-RESET
                BEGIN   PAUSE  PAUSE-FUNC
                        R@ SEC-ELAPSED > 0=
                UNTIL   R> DROP R> R> STIME 2! ;

: TENTHS        ( N1 --- )      \ PAUSE FOR N1 SECONDS
                STIME 2@ >R >R >R TIME-RESET
                BEGIN   PAUSE  PAUSE-FUNC
                        R@ 10TH-ELAPSED > 0=
                UNTIL   R> DROP R> R> STIME 2! ;

\ MINUTES HOURS                                       24Apr87TJZ


: MINUTES       ( N1 --- )      \ PAUSE FOR N1 MINUTES
                0 MAX   0 ?DO   60 SECONDS      LOOP ;

: HOURS         ( N1 --- )      \ PAUSE FOR N1 HOURS
                0 MAX   0 ?DO   60 MINUTES      LOOP ;
HEX
CODE BIOSKEY?   ( --- f1 )
                1 # AH MOV
                16 INT  0=
                IF       0 # AX MOV
                ELSE    -1 # AX MOV
                THEN    1PUSH END-CODE
DECIMAL
\ NKEY                                                12May87TJZ
: <KEYFILTER>   ( C1 --- C1 ) DUP 127 >
        IF      127 AND 72 OVER = IF DROP   5 EXIT THEN
                        75 OVER = IF DROP  19 EXIT THEN
                        77 OVER = IF DROP   4 EXIT THEN
                        80 OVER = IF DROP  24 EXIT THEN
                        81 OVER = IF DROP   3 EXIT THEN
                        73 OVER = IF DROP  18 EXIT THEN
                        71 OVER = IF DROP  30 EXIT THEN
                        83 OVER = IF DROP 127 EXIT THEN
                        82 OVER = IF DROP  22 EXIT THEN
                       115 OVER = IF DROP   1 EXIT THEN
                       116 OVER = IF DROP   6 EXIT THEN
                        59 OVER = IF DROP  31 EXIT THEN
                        128 OR    \ MASK UP ABOVE 127
        THEN    ; DEFER KEYFILTER ' <KEYFILTER> IS KEYFILTER
\ (KEY?)  (KEY)  (CONSOLE)                            24Apr87TJZ

DEFER BGSTUFF   ' NOOP IS BGSTUFF       \ BACKGROUND STUFF
CODE INTON      STI NOP NEXT END-CODE
CODE INTOFF     CLI NOP NEXT END-CODE

: (KEY?)        (S -- f ) BGSTUFF BIOSKEY? ;
\               0 1050 @L 0 1052 @L <> ;

: (KEY)         (S -- CHAR )
                BEGIN   PAUSE KEY? UNTIL
                        0 7 BDOS ?DUP 0=
                IF      0 7 BDOS 128 OR
                THEN    KEYFILTER ;


\ (CONSOLE)                                           15Dec86TJZ


: (CONSOLE)     (S char -- )
                PAUSE   6 BDOS DROP #OUT INCR
                #OUT @ 79 >     \ if at right edge
                IF \    13 6 BDOS DROP  \ Output a CR
                   \    10 6 BDOS DROP  \ and a LF
                        #OUT OFF        \ fix counters
                        #LINE @ 1+ 24 MIN #LINE !
                THEN    ;





\ <KEY?>  <KEY>                                       24Apr87TJZ

\ These are the same words, but are used by debug

: <KEY?>        (S -- f )
                BIOSKEY? ;

: <KEY>         (S -- CHAR )
                BEGIN   PAUSE <KEY?> UNTIL
                        0 7 BDOS ?DUP 0=
                IF      0 7 BDOS 128 OR
                THEN    KEYFILTER ;




\ CMOVEL  YSTART  YSEG  MEMCHK                        17Apr87TJZ

CODE CMOVEL  ( sseg sptr dseg dptr cnt )
            CLD  SI BX MOV  CX POP  DI POP  ES POP  SI POP
  DS POP  CX CX OR  0<> IF  REP BYTE MOVS THEN
  CS AX MOV  AX DS MOV  AX ES MOV  BX SI MOV  NEXT END-CODE

CODE CMOVEL>  ( sseg sptr dseg dptr cnt )
            STD  SI BX MOV  CX POP  DI POP  ES POP  SI POP
            DS POP  CX CX OR  0<>
            IF  CX DEC CX DI ADD CX SI ADD CX INC
            REP BYTE MOVS THEN
            CS AX MOV  AX DS MOV  AX ES MOV  BX SI MOV  CLD
            NEXT END-CODE


\ y segment stuff                                     17Apr87TJZ


VARIABLE YSTART         \ HEAD  START SEGMENT
VARIABLE YSEG           \ HEAD  SEGMENT
VARIABLE #SEGS          \ TOTAL SEGMENTS USED BY FORTH
VARIABLE EXED           \ SAVED WITH EXE EXTENSION
       0 EXED  !-T      \ DEFAULT TO NON EXE
HEX 2000 #SEGS !-T      \ INITIALIZE TO 128K
DECIMAL
: MEMCHK ABORT" Insufficient Memory" ;





\ DOSVER SETYSEG                                      04Feb87TJZ
HEX
: MEMSET        ( N1 --- )
                0 0 ROT 4A00 ?CS: DUP XFDOS >R 2DROP DROP R> ;

: DOSVER 0 30 BDOS 0FF AND ;
: SETYSEG       ( --- ) \ SETS HEAD SEGMENT + MORE SPACE
                DOSVER 2 < ABORT" Must have DOS >=2"
                YSTART @ 0= EXED @ 0= AND
                IF -1000 #SEGS +! YSEG OFF THEN
                #SEGS @ ( 2000 = 128k ) MEMSET  MEMCHK
                YSTART @
                IF ?CS: YSTART @ TUCK OVER 1000 + DUP YSEG !
                    0 YDP @ CMOVEL ( ystart ) DP ! YSTART OFF
                THEN #OUT OFF 18 ( 24 DECIMAL ) #LINE ! ;
DECIMAL
\ more yseg primatives                                02Jul87crc
\ : YHERE (S -- yaddr )    YDP @ ;
CODE YHERE       (S -- adr )
   UP #) BX MOV  YDP [BX] AX MOV  1PUSH END-CODE
\  YDP # BX MOV UP #) BX ADD 0 [BX] AX MOV 1PUSH END-CODE
\ : YS: (S w -- yseg w )   YSEG @ SWAP ;
CODE YS:  ( W -- YSEG W ) AX POP YSEG #) DX MOV 2PUSH END-CODE

: YC@ (S yaddr -- char ) YS: C@L ;
: YC! (S yaddr -- char ) YS: C!L ;
: Y@  (S ad -- n )       YS: @L ;
: Y!  (S n yaddr -- )    YS: !L ;
: Y,  (S n -- )          YHERE Y!  2 YDP +! ;
: YCSET (S byte yaddr -- )  TUCK YC@ OR SWAP YC! ;
: YHASH (S ystr vocaddr -- thread )
    SWAP 1+ YC@ #THREADS 1- AND 2* + ;
\ Devices                 Terminal Input and Output   03Dec86TJZ
CODE PR-STATUS  ( N1 --- F1 )
                DX POP          \ PRINTER NUMBER
                2 # AH MOV      SI PUSH    BP PUSH
                23 INT          BP POP     SI POP
                AH AL MOV       0 # AH MOV
                1PUSH      END-CODE

HEX             \ 90 is printer not busy & printer selected.
: ?PRINTER.READY ( --- F1 )     0 PR-STATUS ( 90 AND ) 90 = ;
DECIMAL

: (PRINT)       (S char -- )
                BEGIN   PAUSE  ?PRINTER.READY
                UNTIL   5 BDOS DROP  #OUT INCR ;

\ (EMIT) CRLF (TYPE) SPACE SPACES BACKSPACES BEE13:32  5Dec87crc
DEFER CR        DEFER PEMIT     ' (PRINT) IS PEMIT
: (EMIT) (S char -- )
         PRINTING @ IF DUP PEMIT #OUT DECR THEN (CONSOLE) ;
: CRLF   (S -- )  13 EMIT   10 EMIT   #OUT OFF
         #LINE DUP @ 1+ 24 MIN SWAP ! ;
: (TYPE) (S addr len -- ) 0 ?DO  COUNT EMIT LOOP DROP ;

: SPACE  (S -- )     BL EMIT   ;

: (SPACES) (S n -- )   0 MAX   0 ?DO   SPACE   LOOP   ;
DEFER SPACES  ' (SPACES) IS SPACES

: BACKSPACES   (S n -- )     0 ?DO   BS EMIT -2 #OUT +! LOOP  ;

: BEEP   (S -- )     BELL EMIT #OUT DECR ;
\ Devices   System Dependent Control Characters       25Mar87TJZ
: BS-IN   (S n c -- 0 | n-1 ) >R DUP
        IF      1-   BS
        ELSE    BELL THEN EMIT #OUT DUP @ 2- 0 MAX SWAP ! R> ;
: (DEL-IN)   (S n c -- 0 | n-1 ) >R DUP
        IF      1-  #OUT @ BS EMIT SPACE #OUT ! BS
        ELSE    BELL
        THEN    EMIT #OUT DUP @ 2- 0 MAX SWAP ! R> ;
: BACK-UP (S n c -- 0 c )
          >R DUP BACKSPACES   DUP SPACES   BACKSPACES   0  R> ;
: RESET-IN (S c -- ) FORTH   TRUE ABORT" Reset"  ;
DEFER RES-IN    ' RESET-IN IS RES-IN
: P-IN    (S c -- c ) PRINTING @ NOT PRINTING !  ;
: ESC-IN  (S C -- ) >R 2DUP + @ EMIT 1+ R> ;


\ Devices                     Terminal Input          19Dec86TJZ
: CR-IN    (S m a n c -- m a m C )
           >R SPAN !   OVER   BL EMIT R>  ;
: (CHAR)   (S a n char -- a n+1 CHAR )
           DUP >R 3DUP EMIT + C!   1+  R> ;

DEFER CHAR      DEFER ^CHAR ' CHAR IS ^CHAR
DEFER DEL-IN

VARIABLE KEYTBL
CREATE NORM-KEYTBL
 ] ^CHAR   ^CHAR  ^CHAR  RES-IN ^CHAR  ^CHAR   ^CHAR  ^CHAR
   DEL-IN  ^CHAR  ^CHAR  ^CHAR  ^CHAR  CR-IN   ^CHAR  ^CHAR
   P-IN    ^CHAR  ^CHAR  ^CHAR  ^CHAR  BACK-UP ^CHAR  ^CHAR
   BACK-UP ^CHAR  ^CHAR  ESC-IN ^CHAR  ^CHAR   ^CHAR  ^CHAR [

\ Devices                     Terminal Input          15Jan87TJZ
: EXPECT   (S adr len -- )
  DUP SPAN !   SWAP 0   ( len adr 0 )
  BEGIN   2 PICK OVER - ( len adr #so-far #left )
  WHILE   KEY DUP BL <
    IF   DUP 2* KEYTBL @ + PERFORM DROP
    ELSE DUP 127 = IF   DEL-IN   ELSE   CHAR   THEN  DROP
    THEN REPEAT    2DROP DROP   ;

: TIB           (S -- adr )   'TIB @  ;

: QUERY         (S -- )
                TIB 80 EXPECT  SPAN @ #TIB !
                BLK OFF  >IN OFF  ;


\ Devices                     BLOCK I/O               03Dec86TJZ
    2 CONSTANT #BUFFERS
 1024 CONSTANT B/BUF
 1024 CONSTANT B/REC
    1 CONSTANT REC/BLK
   43 CONSTANT B/FCB
      VARIABLE DISK-ERROR
   -2 CONSTANT LIMIT
\S
     #BUFFERS 1+ 8 * 2+ CONSTANT >SIZE
LIMIT B/BUF #BUFFERS * -  CONSTANT FIRST
FIRST >SIZE - CONSTANT INIT-R0
: >BUFFERS   (S -- adr )   FIRST  >SIZE - ;
: >END       (S -- adr )   FIRST  2-  ;
: BUFFER#    (S n -- adr )   8* >BUFFERS +   ;
: >UPDATE    (S -- adr )   1 BUFFER# 6 +  ;
\                                                     03Dec86TJZ

       #BUFFERS 1+ 8 * 2+ CONSTANT >SIZE
LIMIT B/BUF #BUFFERS * -  CONSTANT FIRST
FIRST >SIZE - CONSTANT INIT-R0

: >BUFFERS   (S -- adr )   FIRST  >SIZE - ;
: >END       (S -- adr )   FIRST  2-  ;

: BUFFER#    (S n -- adr )   8* >BUFFERS +   ;
: >UPDATE    (S -- adr )   1 BUFFER# 6 +  ;





\ Devices                     BLOCK I/O               13Nov86TJZ
DEFER READ-BLOCK    (S buffer-header -- )
DEFER WRITE-BLOCK   (S buffer-header -- )
: <.FILE>   (S adr -- )
   COUNT ?DUP IF  ASCII @ + EMIT ." :"  THEN
   8 2DUP -TRAILING TYPE + ." ." 3 TYPE SPACE  ;
: FILE?   (S -- )   FCB @ <.FILE>  ;
: SWITCH   (S -- )   FCB @ IN-FCB @ FCB ! IN-FCB !  ;
VOCABULARY DOS   DOS DEFINITIONS
: DISK-ABORT   (S fcb a n -- )
   TYPE ."  in "  <.FILE>  ABORT  ;
: ?DISK-ERROR  (S fcb n -- )
   DUP DISK-ERROR !
   IF  " Disk error" DISK-ABORT  ELSE  DROP  THEN  ;


\ Devices                     BLOCK I/O               14Nov86TJZ

CREATE FCB1   B/FCB ALLOT

: CLR-FCB    (S fcb -- )    DUP  B/FCB ERASE 1+ 11 BLANK ;

: (SET-DMA)  (S adr -- )    26 BDOS  DROP ;

DEFER SET-DMA ' (SET-DMA) IS SET-DMA

: BREC#      (S fcb -- adr )   14 + ;
: RECORD#    (S fcb -- adr )   33 + ;
: MAXREC#    (S fcb -- adr )   38 + ;
: OPENFLG    (S fcb -- adr )   42 + ;


\ CLOSE  !FILES                                       13Nov86TJZ

: DOS-ERR?      (S -- f )   255 =    ;

: CLOSE         (S fcb -- )
                DUP     OPENFLG DUP C@ 0 ROT C! \ ALWAYS OFF
                IF      16 BDOS DOS-ERR?
                        ABORT" Close error"
                ELSE    DROP
                THEN    ;

: !FILES        (S fcb -- )
                FCB @ OVER <> IF    FCB @ CLOSE THEN
             IN-FCB @ OVER <> IF IN-FCB @ CLOSE THEN
                DUP FCB !  IN-FCB !  ;

\ IN-RANGE  REC-READ  REC-WRITE                       08Jun87TJZ
: IN-RANGE   (S fcb -- fcb )
   DUP MAXREC# @ OVER RECORD# @ U<  DUP DISK-ERROR !
   IF  1 BUFFER# ON  " Out of Range" DISK-ABORT  THEN  ;

: /REC-READ   (S fcb -- )
   DUP IN-RANGE  33 BDOS  ?DISK-ERROR ;

: /REC-WRITE  (S fcb -- )
   DUP IN-RANGE  34 BDOS  ?DISK-ERROR ;

DEFER REC-READ          ' /REC-READ  IS REC-READ
DEFER REC-WRITE         ' /REC-WRITE IS REC-WRITE



\ Devices                     BLOCK I/O               28Nov86TJZ
\S
: SET-IO       (S buf-header -- file buffer rec/blk 0 )
   DUP 2@ REC/BLK * OVER RECORD# !
   SWAP 4 + @ ( buf-addr )   REC/BLK 0  ;
: FILE-READ   (S buffer-header -- )
   SET-IO
   DO   2DUP SET-DMA  DUP REC-READ   RECORD# INCR B/REC +
   LOOP  2DROP  ;
: FILE-WRITE   (S buffer-header -- )
   SET-IO
   DO   2DUP SET-DMA  DUP REC-WRITE  RECORD# INCR B/REC +
   LOOP  2DROP  ;
: FILE-IO   (S -- )
   ['] FILE-READ IS READ-BLOCK  ['] FILE-WRITE IS WRITE-BLOCK ;

\ SOME BLOCK I/O TEST CODE                            14Nov86TJZ
\S FORTH DEFINITIONS
CREATE SOURCE-BUF 1026 ALLOT

: GET-BLOCK     (S blk# -- )
                [ DOS ] SOURCE-BUF (SET-DMA)
                IN-FCB @ >R
                      R@ RECORD# !
                B/REC R@ BREC#   !
                   R@ R> 33 BDOS ?DISK-ERROR ;
DOS DEFINITIONS
\S

Use this source buffer for compiling from, it avoids the
overhead associated with block.

\ Devices                     BLOCK I/O               28Nov86TJZ

: SET-IO        (S buf-header -- file buffer rec/blk 0 )
                DUP 2@ ( REC/BLK * ) OVER
                DUP BREC# B/REC SWAP !  \ 1K READ/WRITE
                RECORD# ! SWAP 4 + @ ( buf-addr )   ;
: FILE-READ     (S buffer-header -- )
                SET-IO 2DUP SET-DMA  DUP REC-READ
                RECORD# INCR 2DROP  ;
: FILE-WRITE    (S buffer-header -- )
                SET-IO 2DUP SET-DMA  DUP REC-WRITE
                RECORD# INCR 2DROP  ;
: FILE-IO       (S -- )
                ['] FILE-READ IS READ-BLOCK
                ['] FILE-WRITE IS WRITE-BLOCK ;

\ .EXE file support                            12:08 014Nov86TJZ
CODE XCKSUM ( add cnt startv seg - cksum )
  DS POP  AX POP  CX POP  BX POP
  HERE   0 [BX] AX ADD  BX INC  BX INC  CX DEC  LOOP
  CS PUSH  DS POP  1PUSH          END-CODE
HEX
LABEL  SUVEC  100 , 0 ,
LABEL  SEXE     DS SUVEC 2+ #) MOV  DS AX MOV  1000 # AX ADD
  AX ES MOV  UP #) BX MOV  YDP [BX] CX MOV  CX SI MOV
  SI DEC  SI DI MOV   AX AX XOR  AX YSTART #) XCHG  AX SHR
  AX SHR  AX SHR  AX SHR   SUVEC 2+ #) AX ADD   DS PUSH
  AX DS MOV  CX CX OR  0<>  IF STD REPZ BYTE MOVS CLD THEN
  DS POP  ES YSEG #) MOV   SUVEC S#) FAR JMP
CREATE EHMT 5A4D , 0 , 0 , 0 , 2 , 0 , 0FFFF , 0FFF0 ,
   0FFFC , 0 , [ASSEMBLER] SEXE , 0FFF0 , 1C , 0 , 0 , 0 ,
DECIMAL
\ Devices                     BLOCK I/O               08Nov86TJZ
FORTH DEFINITIONS
: CAPACITY   (S -- n )
   [ DOS ]   FCB @ MAXREC# @ 1+ ( 0 8 UM/MOD NIP ) ;
: LATEST?   (S n fcb -- fcb n | a f ) DISK-ERROR OFF
   SWAP OFFSET @ + 2DUP   1 BUFFER# 2@   D=
   IF   2DROP   1 BUFFER# 4 + @   FALSE   R> DROP  THEN  ;
: ABSENT?   (S n fcb -- a f )
   LATEST?  FALSE #BUFFERS 1+ 2
   DO  DROP 2DUP I BUFFER# 2@ D=
     IF  2DROP I LEAVE  ELSE  FALSE  THEN
   LOOP  ?DUP
   IF  BUFFER# DUP >BUFFERS 8 CMOVE   >R  >BUFFERS DUP 8 +
     OVER R> SWAP  -  CMOVE>     1 BUFFER# 4 + @ FALSE
   ELSE  >BUFFERS 2! TRUE  THEN  ;

\ Devices                     BLOCK I/O               09Nov86TJZ
: UPDATE   (S -- )   >UPDATE ON   ;
: DISCARD  (S -- )   1 >UPDATE ! ( 1 BUFFER# ON ) ;
: MISSING   (S -- )
   >END 2- @ 0< IF  >END 2- OFF  >END 8 - WRITE-BLOCK  THEN
   >END 4 - @  >BUFFERS 4 + ! ( buffer )  1 >BUFFERS 6 + !
   >BUFFERS DUP 8 + #BUFFERS 8* CMOVE>   ;
: (BUFFER)   (S n fcb -- a )   PAUSE  ABSENT?
   IF  MISSING  1 BUFFER#   4 + @  THEN  ;
: BUFFER   (S n -- a )   FCB @ (BUFFER)  ;
: (BLOCK)    (S n fcb -- a ) (BUFFER)  >UPDATE @ 0>
   IF  1 BUFFER#  DUP READ-BLOCK  6 + OFF  THEN  ;
VARIABLE LASTFCB VARIABLE LASTBLK VARIABLE LASTADDR
: BLOCK                   FCB    @ (BLOCK)  LASTBLK ON ;
: IN-BLOCK  (S n -- a )   IN-FCB @ (BLOCK)  LASTBLK ON ;

\ Devices                     BLOCK I/O               23Jan87TJZ
: EMPTY-BUFFERS   (S -- )
   FIRST LIMIT OVER - ERASE
   >BUFFERS #BUFFERS 1+ 8* ERASE
   FIRST 1 BUFFER#   #BUFFERS 0
   DO   DUP ON  4 +  2DUP !   SWAP B/BUF + SWAP  4 +
   LOOP   2DROP LASTBLK ON  ;
: SAVE-BUFFERS   (S -- )
   1 BUFFER#   #BUFFERS 0
   DO   DUP @ 1+
     IF  DUP 6 + @ 0< IF  DUP WRITE-BLOCK  DUP 6 + OFF  THEN
       8 + THEN   LOOP   DROP   ;
: FLUSH   (S -- )
   SAVE-BUFFERS  ( 0 BLOCK DROP  ) EMPTY-BUFFERS  ;
: VIEW#    (S -- addr )    FCB @ 40 +   ;

\ Devices                     BLOCK I/O               14Nov86TJZ
DOS DEFINITIONS
: FILE-SIZE     (S fcb -- n )
                DUP BREC# 128 SWAP !  \ 128 BYTE FOR FILESIZ
                DUP 35 BDOS  DROP
                DUP RECORD# @ SWAP BREC# B/REC SWAP ! ;

: OPEN-FILE     (S -- )
                IN-FCB @ DUP OPENFLG C@ 0=
        IF      DUP 15 BDOS DOS-ERR?
                IF      ." Open error in " <.FILE> ABORT
                THEN    DUP OPENFLG 1 SWAP C!
        THEN    DUP FILE-SIZE 1- 0 8 UM/MOD NIP SWAP MAXREC# ! ;

HEX 5C CONSTANT DOS-FCB   DECIMAL

\ NEW FILE INTERFACE STUFF                            13Nov86TJZ


FORTH DEFINITIONS

: DEFAULT    (S -- )   [ DOS ]   FCB1 DUP IN-FCB !  DUP FCB !
   CLR-FCB   DOS-FCB 1+ C@ BL <>
   IF   DOS-FCB FCB1 12 CMOVE  OPEN-FILE   THEN   ;

: (LOAD)     (S n -- )   FCB @ >R   BLK @ >R   >IN @ >R
   >IN OFF  BLK !   IN-FCB @ FCB !   RUN   R> >IN !   R> BLK !
   R> !FILES OPEN-FILE ;

DEFER LOAD


\ Interactive Layer           Number Input            28Nov86TJZ
ASSEMBLER LABEL FAIL   AX AX SUB   1PUSH
CODE DIGIT     (S char base -- n f )
  DX POP   AX POP   AX PUSH   ASCII 0 # AL SUB  FAIL JB
  9 # AL CMP  > IF  17 # AL CMP  FAIL JB  7 # AL SUB  THEN
  DL AL CMP   FAIL JAE   AL DL MOV
  AX POP   TRUE # AX MOV   2PUSH END-CODE

: DOUBLE?   (S -- f )      DPL @ 1+   0<> ;

: CONVERT   (S +d1 adr1 -- +d2 adr2 )
   BEGIN  1+  DUP >R  C@  BASE @  DIGIT
   WHILE  SWAP  BASE @ UM*  DROP  ROT  BASE @ UM*  D+
      DOUBLE?  IF  DPL INCR THEN  R>
   REPEAT  DROP  R>  ;

\ Interactive Layer           Number Input      17:06  6Nov87crc
: (NUMBER?)   (S adr -- d flag )
   0 0  ROT  DUP 1+  C@  ASCII -  =  DUP  >R  -  DPL ON
   BEGIN   CONVERT  DUP C@  ASCII , ASCII / BETWEEN
   WHILE   DPL OFF
   REPEAT  -ROT  R> IF  DNEGATE  THEN   ROT C@ BL =  ;

: NUMBER?   (S adr -- d flag )
   FALSE  OVER COUNT BOUNDS
   ?DO  I C@ BASE @ DIGIT NIP IF  DROP TRUE LEAVE THEN  LOOP
   IF  (NUMBER?)  ELSE  DROP  0 0 FALSE  THEN  ;

: (NUMBER)   (S adr -- d# )
   NUMBER? NOT ?MISSING  ;
DEFER NUMBER

\ Interactive Layer           Number Output           28Nov86TJZ

: HOLD   (S char -- )   HLD DECR HLD @ C!   ;
: <#     (S -- )     PAD  HLD  !  ;
: #>     (S d# -- addr len )    2DROP  HLD  @  PAD  OVER  -  ;
: SIGN   (S n1 -- )  0< IF  ASCII -  HOLD  THEN  ;
: #      (S -- )
  BASE @ MU/MOD ROT 9 OVER < IF  7 + THEN ASCII 0  +  HOLD  ;
: #S     (S -- )     BEGIN  #  2DUP  OR  0=  UNTIL  ;

: HEX        (S -- )   16 BASE !  ;
: DECIMAL    (S -- )   10 BASE !  ;
: OCTAL      (S -- )    8 BASE !  ;



\ Interactive Layer           Number Output           24FEB83HHL
: (U.)  (S u -- a l )   0    <# #S #>   ;
: U.    (S u -- )       (U.)   TYPE SPACE   ;
: U.R   (S u l -- )     >R   (U.)   R> OVER - SPACES   TYPE   ;

: (.)   (S n -- a l )   DUP ABS 0   <# #S   ROT SIGN   #>   ;
: .     (S n -- )       (.)   TYPE SPACE   ;
: .R    (S n l -- )     >R   (.)   R> OVER - SPACES   TYPE   ;

: (UD.) (S ud -- a l )  <# #S #>   ;
: UD.   (S ud -- )      (UD.)   TYPE SPACE   ;
: UD.R  (S ud l -- )    >R   (UD.)   R> OVER - SPACES   TYPE  ;

: (D.)  (S d -- a l )   TUCK DABS   <# #S   ROT SIGN  #>   ;
: D.    (S d -- )       (D.)   TYPE SPACE   ;
: D.R   (S d l -- )     >R   (D.)   R> OVER - SPACES   TYPE   ;
\ Interactive Layer           Parsing                 09Nov86TJZ
LABEL DONE   ASSEMBLER
  CX PUSH   NEXT

CODE SKIP   (S addr len char -- addr' len' )
  AX POP   CX POP   DONE JCXZ   DI POP   DS DX MOV   DX ES MOV
  REPZ BYTE SCAS   0<> IF   CX INC   DI DEC   THEN
  DI PUSH   CX PUSH   NEXT   END-CODE

CODE SCAN   (S addr len char -- addr' len' )
  AX POP   CX POP   DONE JCXZ   DI POP
  DS DX MOV   DX ES MOV  CX BX MOV
  REP BYTE SCAS    0=  IF   CX INC   DI DEC   THEN
  DI PUSH   CX PUSH   NEXT   END-CODE


\ /STRING                                             13Nov86TJZ


CODE /STRING    (S addr len n -- addr' len' )
                AX POP   BX POP      BX PUSH
             AX BX CMP   <=
        IF   AX BX XCHG  \ AX = SMALLER OF AX BX
        THEN    BX POP   DX POP
             AX DX ADD   DX PUSH
             AX BX SUB   BX PUSH     NEXT END-CODE
\S

\ : /STRING       (S addr len n -- addr' len' )
\                 OVER MIN   ROT OVER +   -ROT -   ;


\ BLKCHK                                              28Nov86TJZ

CODE BLKCHK     ( --- F1 ) ( --- A1 B/BUF )   \ & pops up one
                BLK #) AX MOV LASTBLK #) AX CMP 0=
                IF      FCB # BX MOV   UP #) BX ADD
                       0 [BX] AX MOV   LASTFCB #) AX CMP 0=
                        IF       0 [RP] IP MOV     \ POP OUT !!
( WATCHIT HERE )                 RP INC   RP INC
( WE POP OUT OF CALLER )         LASTADDR #) DX MOV
                                    B/BUF #  AX MOV 2PUSH
                        THEN
                THEN    -1 # AX MOV 1PUSH END-CODE
\S
Was block N1 same as last block, and is the fcb the same as
the last fcb, if both are true, return a1 and b/buf + pop out.

\ PARSE-WRD                                           16Nov86TJZ

CODE PARSE-WRD  ( C1 A1 N1 --- A2 N2 )
                CX POP   DX POP
                AX POP   RP DEC   RP DEC   AX 0 [RP] MOV
                CX PUSH
                >IN #) AX MOV   AX CX CMP   <=
        IF      CX AX MOV            \ AX = SMALLER OF AX CX
        THEN    AX DX ADD   DX PUSH  AX CX SUB
        0 [RP]  AX MOV    CX<>0
        IF      DI POP   DS DX MOV   DX ES MOV
                REPZ BYTE SCAS   0<>
                IF   CX INC   DI DEC   THEN
                DI PUSH
        THEN

\ PARSE-WRD CONTINUED                                 16Nov86TJZ

        AX POP AX PUSH AX PUSH
        0 [RP] AX MOV   RP INC   RP INC     CX<>0
        IF    DI POP DS DX MOV   DX ES MOV  CX BX MOV
              REP BYTE SCAS    0=  IF   CX INC   DI DEC   THEN
              DI PUSH
        THEN  AX POP       BX POP   BX AX SUB
              DX POP    BX DX XCHG      DX PUSH  AX PUSH
              CX AX MOV
              AX AX OR   0<>
        IF    TRUE # AX ADD
        THEN  AX BX SUB   BX >IN #) MOV NEXT     END-CODE



\ SOURCE                                              16Nov86TJZ

: (SOURCE)      (S -- addr len ) \ ONLY GO THROUGH BLOCK ONCE
                BLK @
                IF      BLKCHK  \ LEAVES IF SAME BLK
                        IF      BLK @ DUP BLOCK SWAP LASTBLK !
                                FCB @ LASTFCB !
                                DUP LASTADDR !  B/BUF
                        THEN
                ELSE    TIB #TIB @   THEN  ;

DEFER SOURCE




\ Interactive Layer           Parsing                 16Nov86TJZ
\S
: (SOURCE)      (S -- addr len )  \ SPECIAL VERSION OF (SOURCE)
                BLK @
                IF      BLKCHK
                        IF      BLK @ DUP GET-BLOCK LASTBLK !
                                FCB @ LASTFCB !
                        THEN    SOURCE-BUF B/BUF
                ELSE    TIB #TIB @
                THEN    ;
DEFER SOURCE

: PARSE-WORD   (S char -- addr len )
               >R  SOURCE TUCK  >IN @ /STRING
               R@ SKIP OVER.SWAP.R> SCAN PARSE2 ;

\  PARSE SUFIX WORD                                   28Nov86TJZ
: PARSE         (S char -- addr len )
                >R   SOURCE >IN @ /STRING   OVER SWAP R> SCAN
                >R OVER -  DUP R>  0<> -  >IN +!  ;

DEFER 'WORD     (S -- adr )     ' HERE IS 'WORD

CODE SUFIX.BL   ( A1 -- A1 )
                32 ( A BLANK ) # DX MOV
                BX POP     BX PUSH AX AX SUB   0 [BX] AL MOV
                AX BX ADD  BX INC  AX DX XCHG  AL 0 [BX] MOV
                NEXT END-CODE

: WORD          (S char -- addr )
                SOURCE PARSE-WRD 'WORD PLACE 'WORD SUFIX.BL ;

\ Interactive Layer           Parsing                 12Nov86TJZ


: >TYPE (S adr len -- )
        TUCK PAD SWAP CMOVE   PAD SWAP TYPE  ;

: .(    (S -- ) ASCII ) PARSE >TYPE  ; IMMEDIATE

: (     (S -- ) ASCII ) PARSE 2DROP  ; IMMEDIATE

: \S    (S -- ) END? ON ;  IMMEDIATE





\ Interactive Layer           Dictionary              08MAY84HHL
CODE TRAVERSE (S addr direction -- addr' )
  CX POP   BX POP   CX BX ADD  ES PUSH  YSEG #) ES MOV
  BEGIN  ES: 0 [BX] AL MOV  128 # AL AND  0= WHILE  CX BX ADD
  REPEAT   ES POP  BX PUSH   NEXT END-CODE
: DONE?   (S n -- f )
   STATE @ <>   END? @ OR   END? OFF   ;
: FORTH-83   (S -- )   FORTH DEFINITIONS CAPS OFF  ;
HEX
: CNHASH ( CFA-YA )  0FE00 AND FLIP ;  DECIMAL
: CNSRCH ( CFA YA MAXYA - NFA failf ) SWAP 2+ 2+
  BEGIN 2DUP > WHILE ( cfa mxy nfa )
    DUP YC@ 31 AND + 1+ DUP Y@
    3 PICK = IF -ROT 2DROP 1- -1 TRAVERSE FALSE EXIT THEN
    6 + REPEAT   2DROP TRUE ;

\ Interactive Layer           Dictionary              23Jul87crc
CODE N>LINK  ' 2- @-T  ' N>LINK !-T  END-CODE  \ : N>LINK  2- ;
CODE L>NAME  ' 2+ @-T  ' L>NAME !-T  END-CODE  \ : L>NAME  2+ ;
CODE BODY>   ' 2- @-T  ' BODY>  !-T  END-CODE  \ : BODY>   2- ;
CODE >BODY   ' 2+ @-T  ' >BODY  !-T  END-CODE  \ : >BODY   2+ ;
: NAME>   1 TRAVERSE   1+ Y@  ;
: LINK>   L>NAME   NAME>   ;
: >NAME ( cfa - nfa ) DUP CNHASH DUP Y@ SWAP
    2+ Y@ ( cfa sya mxya ) CNSRCH ABORT" name not found" ;
: >LINK   >NAME   N>LINK   ;
: >VIEW   >LINK   2-   ;
: VIEW>   2+   LINK>   ;
CODE HASH   (S str-addr voc-ptr -- thread )
            CX POP   BX POP   BX INC   0 [BX] AL MOV
            #THREADS 1- # AX AND
            AX SHL   CX AX ADD   1PUSH END-CODE
\ Interactive Layer           Dictionary              05OCT83HHL
CODE (FIND)   (S here alf -- cfa flag | here false )
  DX POP   DX DX OR  0= IF   AX AX SUB   1PUSH   THEN
  YSEG #) ES MOV
  BEGIN   DX BX MOV   BX INC   BX INC
    DI POP  ( here )  DI PUSH   ES: 0 [BX] AL MOV
    0 [DI] AL XOR   63 # AL AND   0=
    IF  BEGIN  BX INC   DI INC   ES: 0 [BX] AL MOV
          0 [DI] AL XOR   0<> UNTIL   127 # AL AND   0=
        IF   DI POP   ES: 1 [BX] AX MOV   AX PUSH   DX BX MOV
          BX INC  BX INC  ES: 0 [BX] AL MOV   64 # AL AND   0<>
          IF   1 # AX MOV   ELSE   -1 # AX MOV   THEN
          DS PUSH  ES POP    1PUSH
    THEN  THEN   DX BX MOV  ES: 0 [BX] DX MOV
  DX DX OR   0=  UNTIL  DS PUSH  ES POP
                                 AX AX SUB   1PUSH   END-CODE
\ I2*+@DUP                                            24Jul87crc
CODE DROP.CONTEXT.I2*+@DUP   ( A1 --- N1 )
                AX POP       0 [RP] AX MOV   2 [RP] AX ADD
                AX SHL    CONTEXT # BX MOV       AX BX ADD
                0 [BX] PUSH     0 [BX] PUSH       NEXT END-CODE
                                \ DUP PRIOR @ OVER PRIOR ! =

CODE PRIOR.CHECK ( N1 --- N1 F1 )
                AX POP  AX PUSH  PRIOR #) BX MOV
                AX PRIOR #) MOV        AX BX CMP   0<>
                IF      FALSE # AX MOV 1PUSH
                THEN     TRUE # AX MOV 1PUSH
                         END-CODE
\S              ELSE     TRUE # AX MOV 1PUSH
                THEN     END-CODE

\ OVER.SWAP.HASH.@                                    28Nov86TJZ


CODE OVER.SWAP.HASH.@
                AX POP   DX POP   DX PUSH   DX PUSH   AX PUSH
                CX POP   BX POP   BX INC   0 [BX] AL MOV
                #THREADS 1- # AX AND
                AX SHL   CX AX ADD   AX BX MOV
                0 [BX] AX MOV 1PUSH END-CODE







\ Interactive Layer           Dictionary              28Nov86TJZ
: FIND   (S addr -- cfa flag | addr false )
   DUP C@ IF   PRIOR OFF   FALSE   #VOCS 0
     DO   DROP.CONTEXT.I2*+@DUP
       IF   PRIOR.CHECK
         IF   DROP FALSE
         ELSE   OVER.SWAP.HASH.@ (FIND)  DUP ?LEAVE
       THEN THEN   LOOP
   ELSE  DROP END? ON  ['] NOOP 1  THEN  ;

: ?UPPERCASE   (S adr -- adr )
   CAPS @ IF  DUP COUNT UPPER   THEN  ;

: DEFINED   (S -- here 0 | cfa [ -1 | 1 ] )
   BL WORD  ?UPPERCASE  FIND   ;

\ Interactive Layer           Interpreter             02Jul87crc
: ?STACK  (S -- )   ( System dependant )
   SP@ SP0 @ SWAP U<   ABORT" <top"
   SP@ PAD U<   ABORT" Overflow"   ;

DEFER STATUS  (S -- )

: INTERPRET   (S -- )
   BEGIN   ?STACK  DEFINED
     IF     EXECUTE
     ELSE   NUMBER  DOUBLE? NOT IF  DROP  THEN
     THEN   FALSE DONE?
   UNTIL   ;

: PRINT         ( --- )
  PRINTING ON CONTROL Q PEMIT #OUT DECR INTERPRET PRINTING OFF ;
\ Extensible Layer            Compiler                02Jul87crc
: ALLOT  (S n -- )      DP +!   ;

        \ : ,      (S n -- )   HERE !   2 ALLOT   ;
CODE ,  ( N --- )
  UP #) BX MOV  DP [BX] AX MOV                     \ here
  2 # CX MOV  CX DP [BX] ADD                       \ 2 allot
  AX BX MOV  CX POP  CX 0 [BX] MOV  NEXT END-CODE  \ !

        \ : C,     (S char -- )   HERE C!   1 ALLOT ;
CODE C, ( N --- )
  UP #) BX MOV  DP [BX] AX MOV  DP [BX] INC   \ here  1 allot
  AX BX MOV  CX POP  CL 0 [BX] MOV  NEXT END-CODE  \ c!



\ COMPILE IMMEDIATE LITERAL ASCII CONTROL              3Aug87crc
: COMPILE   (S -- )   R> DUP 2+ >R   @ ,   ;
: IMMEDIATE (S -- )   64 ( Precedence bit ) LAST @ YCSET  ;
: LITERAL   (S n -- )  DUP -128 127 BETWEEN  IF
  COMPILE CLIT C,  ELSE  COMPILE (LIT) ,  THEN ;   IMMEDIATE
: DLITERAL    (S d# -- )
      SWAP   [COMPILE] LITERAL  [COMPILE] LITERAL  ; IMMEDIATE
: ASCII     (S -- n )   BL WORD   1+ C@
   STATE @ IF   [COMPILE] LITERAL   THEN   ; IMMEDIATE
: CONTROL   (S -- n )   BL WORD   1+ C@  31 AND
   STATE @ IF   [COMPILE] LITERAL   THEN   ; IMMEDIATE
: ALIGN  ( HERE 1 AND IF  BL C,  THEN )  ; IMMEDIATE
: EVEN   ( DUP 1 AND + ) ;  IMMEDIATE
\ : CTL   [COMPILE] CONTROL ;  IMMEDIATE


\ Extensible Layer            Compiler                08Oct83map
: CRASH   (S -- )
   TRUE ABORT"  Uninitialized execution vector."  ;
: ?MISSING   (S f -- )
  IF   'WORD COUNT TYPE   TRUE ABORT"  ?"   THEN   ;
: '   (S -- cfa )   DEFINED 0= ?MISSING   ;
: ['] (S -- )       ' [COMPILE] LITERAL   ; IMMEDIATE
: [COMPILE]   (S -- )   ' ,   ; IMMEDIATE
: (")    (S -- addr len )   R> COUNT 2DUP + EVEN >R  ;
: (.")   (S -- )            R> COUNT 2DUP + EVEN >R   TYPE   ;
: ,"   (S -- )
   ASCII " PARSE  TUCK 'WORD PLACE  1+ ALLOT ALIGN  ;
: ."   (S -- )   COMPILE (.")   ,"   ;   IMMEDIATE
: "    (S -- )   COMPILE (")    ,"   ;   IMMEDIATE


\ Interactive Layer           Dictionary              08Apr87TJZ
VARIABLE FENCE
: TRIM   (S faddr voc-addr -- )
   #THREADS 0 DO   2DUP @ BEGIN   2DUP U> NOT WHILE Y@ REPEAT
      NIP OVER !   2+   LOOP   2DROP   ;
: (FRGET)   (S code-addr view-addr -- )
   DUP FENCE @ U< ABORT" Below fence"  ( ca va )
   OVER VOC-LINK @ BEGIN   2DUP U< WHILE   @ REPEAT
   DUP VOC-LINK !  ( ca va ca pt ) NIP
   BEGIN   DUP WHILE   2DUP #THREADS 2* - TRIM   @   REPEAT
   DROP   YDP !   DP !  ;
: FORGET   (S -- )
   BL WORD ?UPPERCASE DUP CURRENT @ HASH @ (FIND) 0= ?MISSING
   DUP >VIEW (FRGET)   ;


\ Extensible Layer            Compiler                 7Oct87crc
DEFER WHERE
DEFER ?ERROR
: (?ERROR)   (S adr len f -- )
   IF  >R >R   SP0 @ SP!   PRINTING OFF
       BLK @ IF  >IN @ BLK @ WHERE  THEN
       R> R> SPACE TYPE SPACE   QUIT
   THEN  2DROP  ;
: (ABORT")   (S f -- )
   R@ COUNT ROT ?ERROR   R> COUNT + EVEN >R   ;
: ABORT"   (S -- )
    COMPILE (ABORT")  ," ;   IMMEDIATE
: ABORT   (S -- )
   TRUE ABORT" "  ;


\ Extensible Layer            Structures              03Apr84map
: ?CONDITION   (S f -- )
   NOT ABORT" Conditionals Wrong"   ;
: >MARK      (S -- addr )    HERE 0 ,   ;
: >RESOLVE   (S addr -- )    HERE SWAP !   ;
: <MARK      (S -- addr )    HERE    ;
: <RESOLVE   (S addr -- )    ,   ;

: ?>MARK      (S -- f addr )   TRUE >MARK   ;
: ?>RESOLVE   (S f addr -- )   SWAP ?CONDITION >RESOLVE  ;
: ?<MARK      (S -- f addr )   TRUE   <MARK   ;
: ?<RESOLVE   (S f addr -- )   SWAP ?CONDITION <RESOLVE  ;

: LEAVE   COMPILE (LEAVE)   ; IMMEDIATE
: ?LEAVE  COMPILE (?LEAVE)  ; IMMEDIATE

\ Extensible Layer            Structures              01Oct83map
: BEGIN   ?<MARK                                   ; IMMEDIATE
: THEN    ?>RESOLVE                                ; IMMEDIATE
: DO      COMPILE (DO)   ?>MARK                    ; IMMEDIATE
: ?DO     COMPILE (?DO)  ?>MARK                    ; IMMEDIATE
: LOOP
    COMPILE (LOOP)  2DUP 2+ ?<RESOLVE ?>RESOLVE    ; IMMEDIATE
: +LOOP
    COMPILE (+LOOP) 2DUP 2+ ?<RESOLVE ?>RESOLVE    ; IMMEDIATE
: UNTIL   COMPILE ?BRANCH    ?<RESOLVE             ; IMMEDIATE
: AGAIN   COMPILE  BRANCH    ?<RESOLVE             ; IMMEDIATE
: REPEAT  2SWAP [COMPILE] AGAIN   [COMPILE] THEN   ; IMMEDIATE
: IF      COMPILE  ?BRANCH  ?>MARK                 ; IMMEDIATE
: ELSE    COMPILE  BRANCH ?>MARK  2SWAP ?>RESOLVE  ; IMMEDIATE
: WHILE   [COMPILE] IF                             ; IMMEDIATE

\ Extensible Layer            Defining Words          28Nov86TJZ
: ,VIEW  (S -- )   BLK @ DUP IF  VIEW# @ 1024 * +  THEN Y, ;
: "CREATE   (S str -- )  WARNING @  IF DUP FIND NIP IF
     DUP  CR  COUNT TYPE ."  isn't unique " THEN  THEN ( str )
   ALIGN  YHERE 2- Y@ CNHASH  HERE CNHASH  <> IF
     YHERE HERE CNHASH Y! ( >NAME hash entry ) THEN    ,VIEW
   YHERE OVER CURRENT @ HASH DUP @  Y,  ( link  ) ! ( current )
   YHERE LAST ! ( remember nfa )
   YHERE ?CS: ROT  DUP C@  WIDTH @  MIN 1+ >R  ( yh cs str )
   YHERE YS: R@ CMOVEL ( copy str ) R> YDP +! ALIGN ( nam )
   128 SWAP YCSET   128 YHERE 1- YCSET   ( delimiter Bits )
   HERE Y, ( CFA in header )
   YHERE HERE CNHASH 2+ Y! ( valid stopper in next n hash entry)
   COMPILE [ [FORTH] ASSEMBLER DOCREATE , META ]   ;
: CREATE   (S -- )
   BL WORD  ?UPPERCASE  "CREATE  ;
\ Extensible Layer            Defining Words          04OCT83HHL
: !CSP   (S -- )  SP@ CSP !   ;
: ?CSP   (S -- )  SP@ CSP @ <> ABORT" Stack Changed"   ;
: HIDE   (S -- )  LAST @ DUP N>LINK Y@ SWAP CURRENT @ YHASH ! ;
: REVEAL (S -- )  LAST @ DUP N>LINK    SWAP CURRENT @ YHASH ! ;
: (;USES)     (S -- )   R> @  LAST @ NAME>  !  ;
VOCABULARY ASSEMBLER
: ;USES       (S -- )   ?CSP   COMPILE  (;USES)
    [COMPILE] [   REVEAL   ASSEMBLER   ; IMMEDIATE
: (;CODE)     (S -- )   R>    LAST @ NAME>  !  ;
: ;CODE       (S -- )   ?CSP   COMPILE  (;CODE)
    [COMPILE] [   REVEAL   ASSEMBLER   ; IMMEDIATE
: DOES>   (S -- )   COMPILE (;CODE)   232 ( CALL ) C,
  [ [FORTH] ASSEMBLER DODOES META ] LITERAL
  HERE 2+ - ,   ; IMMEDIATE

\ Extensible Layer            Defining Words          27Sep83map
: [   (S -- )   STATE OFF   ;   IMMEDIATE
: ]   (S -- )
   STATE ON   BEGIN   ?STACK   DEFINED DUP
   IF      0> IF    EXECUTE   ELSE   ,   THEN
   ELSE   DROP   NUMBER  DOUBLE?
      IF          [COMPILE] DLITERAL
      ELSE DROP   [COMPILE] LITERAL   THEN
   THEN   TRUE DONE? UNTIL   ;
: :   (S -- )
   !CSP   CURRENT @ CONTEXT !   CREATE HIDE    ]
   ;USES   NEST ,
: ;   (S -- )
   ?CSP   COMPILE UNNEST   REVEAL   [COMPILE] [
   ;   IMMEDIATE

\ Extensible Layer            Defining Words           7Oct87crc
: RECURSIVE (S -- )     REVEAL ;   IMMEDIATE
: CONSTANT   (S n -- )  CREATE ,   ;USES DOCONSTANT ,

: VARIABLE  (S -- )     CREATE 0 ,   ; \ USES DOCREATE ,
                                       \ unnecessary!
: DEFER   (S -- )       CREATE   ['] CRASH ,  ;USES   DODEFER ,
DODEFER RESOLVES <DEFER>
: DEFERS  (S T1 -- )    ' >BODY @ , ; IMMEDIATE
: UNDEFER (S T1 -- )    ' >BODY DUP @ >BODY @ SWAP ! ;
: VOCABULARY   (S -- )  CREATE   #THREADS 0 DO   0 ,  LOOP
                        HERE  VOC-LINK @ ,  VOC-LINK !
                        DOES>   CONTEXT !  ;
 RESOLVES <VOCABULARY>
: DEFINITIONS   (S -- ) CONTEXT @ CURRENT !   ;

\ Extensible Layer            Defining Words          03Apr84map
: 2CONSTANT
   CREATE   , ,     (S d# -- )
   DOES>   2@   ;   (S -- d# )   DROP
: 2VARIABLE
   0 0 2CONSTANT   (S -- )
   DOES>        ;  (S -- addr )   DROP

VARIABLE AVOC
: CODE   (S -- )      CREATE  HIDE   HERE DUP 2- !
   CONTEXT @ AVOC !   ASSEMBLER  ;
ASSEMBLER DEFINITIONS
: END-CODE   AVOC @ CONTEXT !   REVEAL   ;
FORTH DEFINITIONS   META IN-META


\ Extensible Layer            Defining Words          13Apr84map
VARIABLE #USER
VOCABULARY USER   USER DEFINITIONS
: ALLOT   (S n -- )
   #USER +!   ;
' CREATE  ( avoid recursion: leave address for , in CREATE )
: CREATE  (S -- )
   [ , ]     #USER @ ,   ;USES  DOUSER-VARIABLE ,
: VARIABLE     (S -- )
   CREATE   2 ALLOT   ;
: DEFER   (S -- )
   VARIABLE   ;USES   DOUSER-DEFER  ,
FORTH DEFINITIONS   META IN-META



\ Extensible Layer            ReDefining Words        30Jan87TJZ
: >IS   (S cfa -- data-address )
   DUP @
   DUP [  [ASSEMBLER] DOUSER-VARIABLE META ] LITERAL = SWAP
   DUP [  [ASSEMBLER] DOUSER-DEFER    META ] LITERAL = SWAP
   DROP   OR IF   >BODY @ UP @ +   ELSE    >BODY   THEN   ;

: (IS)      (S cfa --- )
   R@ @  >IS !   R> 2+ >R   ;

: IS    (S cfa --- ) STATE @
        IF  COMPILE (IS)  ELSE  ' >IS !  THEN ; IMMEDIATE




\ (=:)  =:                                            26May87TJZ
\S

CODE    (=:)    ( N1 --- )
                IP BX MOV       IP INC IP INC
                0 [BX] AX MOV   AX INC AX INC   AX BX MOV
                0 [BX] POP      NEXT            END-CODE

: =:            ( N1 T1 --- )
                STATE @
                IF      COMPILE (=:)
                ELSE    ' >BODY !
                THEN    ; IMMEDIATE



\ INCR>  DECR>                                        30Jan87TJZ
\S

CODE    INCR>   ( --- )
                IP BX MOV       IP INC IP INC
                0 [BX] AX MOV   AX INC AX INC   AX BX MOV
                0 [BX] AX MOV   AX INC          AX 0 [BX] MOV
                NEXT            END-CODE

CODE    DECR>   ( --- )
                IP BX MOV       IP INC IP INC
                0 [BX] AX MOV   AX INC AX INC   AX BX MOV
                0 [BX] AX MOV   AX DEC          AX 0 [BX] MOV
                NEXT           END-CODE


\ +!>                                                 26May87TJZ
\S

CODE    +!>     ( N1 --- )
                CX POP
                IP BX MOV       IP INC IP INC
                0 [BX] AX MOV   AX INC AX INC   AX BX MOV
                0 [BX] AX MOV   CX AX ADD       AX 0 [BX] MOV
                NEXT            END-CODE

: !>            ( N1 T1 --- )
                STATE @
                IF      COMPILE (=:)
                ELSE    ' >BODY !
                THEN    ; IMMEDIATE

\ Initialization              High Level        13:35 30Oct87crc
: RUN   (S -- )
   STATE @ IF   ]   STATE @ NOT IF   INTERPRET   THEN
           ELSE   INTERPRET   THEN   ;
: QUIT  (S -- )
  SP0 @ 'TIB !    BLK OFF   [COMPILE] [
  BEGIN BEGIN   RP0 @ RP! STATUS QUERY  RUN
                STATE @ NOT UNTIL   ."  ok"   AGAIN  ;

DEFER BOOT      DEFER INITSTUFF ' NOOP IS INITSTUFF
: WARM   (S -- )
   TRUE ABORT" Warm Start"   ;
: COLD   (S -- )
  SETYSEG VMODE.SET INITSTUFF  \  7 att c!
  BOOT LASTBLK ON  LASTADDR OFF QUIT   ;

\ Initialization              High Level              27Nov86TJZ

1 CONSTANT INITIAL

: OK   (S -- )   INITIAL LOAD   ;

: START   (S -- )
   EMPTY-BUFFERS    DEFAULT   ;

DEFER BYEFUNC   ' FLUSH IS BYEFUNC

: BYE   ( -- )
        BYEFUNC FCB @ CLOSE IN-FCB @ CLOSE
        CR CR ." Goodby" CR 0 0 BDOS  ; \ RECOVER


\ Initialization              Low Level               11OCT83HHL
[FORTH] ASSEMBLER
HERE ORIGIN 6 + - ORIGIN 4 + !-T  ( WARM ENTRY )  ASSEMBLER
  ' WARM >BODY # IP MOV   NEXT
HERE ORIGIN 3 + - ORIGIN 1+ !-T  ( COLD ENTRY )  ASSEMBLER
  CS AX MOV   AX DS MOV   AX SS MOV   AX ES MOV
  6 #) AX MOV   0 # AL MOV   AX ' LIMIT 2+ #) MOV
  #BUFFERS B/BUF * # AX SUB  AX ' FIRST 2+ #) MOV
  >SIZE # AX SUB   AX RP MOV
  RP0 # W MOV   UP #) W ADD   RP 0 [W] MOV
  200 # AX SUB  AX 'TIB #) MOV
  SP0 # W MOV   UP #) W ADD  AX 0 [W] MOV   AX SP MOV
  ' COLD >BODY # IP MOV   NEXT
  IN-META


\ Initialize User Variables                           12Jan87TJZ
HERE UP !-T             ( SET UP USER AREA )
 0 , ( TOS )   0 , ( ENTRY )   0 , ( LINK )
 INIT-R0 256 - , ( SP0 )   INIT-R0 , ( RP0 )
 0 , ( DP )  ( Must be patched later )
\  0 , ( #OUT )  0 , ( #LINE )  \ SEE SCREEN 41
 0 , ( OFFSET )
10 , ( BASE ) 0 , ( HLD )
 0 , ( FILE )
 0 , ( IN-FILE )
 FALSE , ( PRINTING )
 0 , ( YDP ) ( Must be patched later, see scr 1 )
' (EMIT) ,   ( EMIT )
' (KEY?) ,   ( KEY? )
' (KEY)  ,   ( KEY  )
' (TYPE) ,   ( TYPE )
\ Resident Tools                                      12Jun87crc
: DEPTH      (S -- n )   SP@ SP0 @ SWAP - 2/   ;
VARIABLE MAX.S
: .S         (S -- )    DEPTH 0< ABORT" Stack UNDERFLOW !! "
        DEPTH ?DUP MAX.S @ 1 < IF 4 MAX.S ! THEN
        IF DUP ."  [" 1 .R ." ]" 0 SWAP 1- MAX.S @ 1- MIN
                DO I PICK 7 U.R SPACE -1 +LOOP
        ELSE    ."  Stack Empty. "  THEN ;
: .ID     (S nfa -- )
   DUP 1+ DUP YC@ ROT YC@ 31 AND 0
   ?DO DUP 127 AND EMIT   128 AND
     IF   ASCII _ 128 OR   ELSE  1+ DUP YC@  THEN
   LOOP 2DROP SPACE ;
: DUMP    (S addr len -- )
   0 DO   CR DUP 6 U.R SPACE  16 0 DO   DUP C@ 3 .R 1+   LOOP
   16 +LOOP   DROP   ;
\ For Completeness                                    27Nov86TJZ

: RECURSE   (S -- ) LAST @ NAME> ,  ;  IMMEDIATE

: H.        (S N1 --- ) BASE @ >R HEX U. R> BASE ! ;

VARIABLE LMARGIN    0 LMARGIN !-T
VARIABLE RMARGIN   70 RMARGIN !-T
VARIABLE TABSIZE    8 TABSIZE !-T

: ?LINE   (S n -- )
        #OUT @ +  RMARGIN @ > IF CR LMARGIN @ SPACES THEN ;
: ?CR   (S -- )   0 ?LINE  ;
: TAB   #OUT @ TABSIZE @ MOD TABSIZE @ SWAP - SPACES ;


\ Resolve Forward References                          21Dec83map

' (.") RESOLVES <(.")>   ' (") RESOLVES <(")>
' (;CODE) RESOLVES <(;CODE)>
' (;USES) RESOLVES <(;USES)>   ' (IS) RESOLVES <(IS)>
' (ABORT") RESOLVES <(ABORT")>
 [ASSEMBLER] DOCREATE META RESOLVES <VARIABLE>
 [ASSEMBLER] DOUSER-DEFER META RESOLVES <USER-DEFER>
 [ASSEMBLER] DOUSER-VARIABLE META RESOLVES <USER-VARIABLE>







\ Resolve Forward References                          09Nov86TJZ

\ ' SWAP RESOLVES SWAP
\ ' + RESOLVES +               ' OVER RESOLVES OVER

' DEFINITIONS RESOLVES DEFINITIONS
' [ RESOLVES [              ' 2+ RESOLVES 2+
' 1+ RESOLVES 1+            ' 2* RESOLVES 2*

\ ONLY NEEDED BY MAX AND MIN, WHICH ARE NOW CODE
\ ' 2DUP RESOLVES 2DUP

' ?MISSING RESOLVES ?MISSING
' QUIT RESOLVES QUIT        ' RUN RESOLVES RUN
' ABORT RESOLVES ABORT

\ MORE RESOLVED REFERENCES                            03Dec86TJZ



' .         RESOLVES .          ' .R        RESOLVES .R
' #>        RESOLVES #>         ' #         RESOLVES #
' <#        RESOLVES <#         ' CR        RESOLVES CR
' INTERPRET RESOLVES INTERPRET  ' DECIMAL   RESOLVES DECIMAL
' SPACE     RESOLVES SPACE      ' WORD      RESOLVES WORD
' CMOVEL    RESOLVES CMOVEL     ' =         RESOLVES =






\ Initialize DEFER words                              12Nov86TJZ
   ' (LOAD) IS LOAD
\  ' (KEY?) IS KEY?             ' (KEY) IS KEY
   ' CRLF IS CR
   ' FILE-READ IS READ-BLOCK    ' FILE-WRITE IS WRITE-BLOCK
   ' NOOP IS WHERE              ' CR IS STATUS
   ' (SOURCE) IS SOURCE
   ' START IS BOOT
   ' (NUMBER) IS NUMBER
   ' (CHAR) IS CHAR              ' (DEL-IN) IS DEL-IN
   ' (?ERROR) IS ?ERROR





\ Initialize Variables                                12Nov86TJZ
' FORTH >BODY CURRENT !-T
' FORTH >BODY CONTEXT !-T
' NORM-KEYTBL >BODY KEYTBL !-T
HERE-T  DP UP @-T + !-T               ( INIT USER DP )
#USER-T @ #USER !-T                   ( INIT USER VAR COUNT )
TRUE  CAPS !-T                        ( SET TO IGNORE CASE )
TRUE WARNING !-T                      ( SET TO ISSUE WARNINGS )
31 WIDTH !-T                          ( 31 CHARACTER NAMES )
VOC-LINK-T @ VOC-LINK !-T             ( INIT VOC-LINK )






\ Further Instructions                                11OCT83HHL
EXIT
****************************************************************
***                                                          ***
***      Thus we have created a hopefully running            ***
***      Forth system for the 8086.  After this file         ***
***      has been compiled, it is saved as a CMD file        ***
***      called KERNEL86.CMD on the disk.  To generate       ***
***      a system you must now leave the Meta Compiler       ***
***      and fire up KERNEL with the file EXTEND86.BLK       ***
***      on the execute line.  Be sure to prefix a B:        ***
***      if necessary.  ( KERNEL86 EXTEND86.BLK )            ***
***      Once you have fired it up, type START and it        ***
***      will compile the applications.  Good Luck.          ***
***                                                          ***
****************************************************************
\ Further Instructions                                24Nov86TJZ
EXIT
****************************************************************
***                                                          ***
***      Thus we have created a hopefully running            ***
***      Forth system for the 8086.  After this file         ***
***      has been compiled, it is saved as a CMD file        ***
***      called KERNEL86.CMD on the disk.  To generate       ***
***      a system you must now leave the Meta Compiler       ***
***      and fire up KERNEL with the file EXTEND86.BLK       ***
***      on the execute line.  Be sure to prefix a B:        ***
***      if necessary.  ( KERNEL86 EXTEND86.BLK )            ***
***      Once you have fired it up, type START and it        ***
***      will compile the applications.  Good Luck.          ***
***                                                          ***
****************************************************************
\ Target System Setup                                 18may86jdh

Make Room for HOST definitions
Set up the address where Target Compiled Code begins
Set up the address where the Target Headers begin
Set up the HOST address where Target Image resides


Load the Source Screens that define the System

Move YSEG down to follow dictionary
Set YSTART and YDP
Save the System as DOS .COM file, ready to be executed



\ Declare the Forward References                      27Jan84map
]]     We will need the FORTH version of ] quite often.
[[     The same is true for [[.


DEFINIITONS  To avoid finding DEFINITIONS in the ONLY vocabulary
[            To avoid finding [ in the TRANSITION vocabulary









\ Boot up Vectors and NEXT Interpreter                02Feb87TJZ

The first 8 bytes in the system are vectors to the Cold and Warm
start entries.  You can freely jump to them in code anytime.
The DPUSH and HPUSH labels are space savers.  We jump to them
in several CODE words when we want to push their contents on the
Parameter Stack.
>NEXT is where all the action is.  It is the guts of the Forth
Virtual Machine.  It must advance the interpretive pointer held
in the IP register pair and jump indirect to what it points to.


We define a few macros here to make our life a little easier
later.  Using NEXT as a macro allows us to put it inline later.


















\ Run Time Code for Defining Words                    23JUL83HHL
RP    Used to hold the depth of the return stack
NEST  The runtime code for :  It pushs the current IP onto
   the return stack and sets the IP to point to the parameter
   field of the word being executed.
EXIT
     Pop an entry off the return stack and place it into the
     Interpretive Pointer.  Terminates a Hi Level definition.
UNNEST   Same as exit.  Compiled by ; to help decompiling.
DODOES
   The runtime portion of defining words.  First it pushes the
   IP onto the return stack and then it pushes the BODY address
   of the word being executed onto the parameter stack.
DOCREATE   Leave a pointer to its own parameter field on the
   stack.  This is also the runtime for variable.

\ Run Time Code for Defining Words                     3Aug87crc
UP   Holds a pointer to the current USER area. ( multitasking )
@USER    A subroutine called from code level words that returns
   the contents of a particular user variable.
!USER    A subroutine called from code level words that sets
   the contents of a particular user variable.

DOCONSTANT   The run time code for CONSTANT.  It takes the
   contents of the parameter field and pushes it onto the stack.
DOUSER       The run time code for USER variables.  Places a
   pointer to the current version of this variable on the stack.
   Needed for multitasking.
(LIT)     The runtime code for literals.  Pushes the following
   two bytes onto the parameter stack and moves the IP over
   them.  It is compiled by the word LITERAL.
CLIT   byte version of (LIT)
\ Meta Defining Words                                  3Aug87crc
LITERAL
   Now that code field of (LIT) & CLIT are known, define LITERAL
DLITERAL
   Both LITERAL and DLITERAL are TRANSITION words, ie IMMEDIATE
ASCII
   Compile the next character as a literal.
[']
   Compile the code field of the next word as a literal.
CONSTANT
   Define a CONSTANT in the Target.  We also save its value
   in META for use during interpretation.




\ Identify numbers and forward References             02AUG83HHL
<(;CODE)>    Forward reference for code to patch code field.
DOES>
   Compile the code field for (;CODE) and a CALL instruction
   to the run time for DOES, called DODOES.
NUMERIC
   Make a number out of this word and compile it as either
   a single or double precision literal.  NUMERIC is only
   called if the word is known to be a number.
UNDEFINED
   Creates a forward reference "on the fly".  The symbol is
   kept in the FORWARD vocabulary and it is initialized to
   unresolved.  When executed it either compiles itself or links
   into a backwards pointing chain of forward references.


\ Meta Compiler Compiling Loop                        10MAR83HHL
T-IN   Needed to save a pointer into the input stream for later.
]
   Start compiling into the TARGET system.  Always search
   TRANSITION before TARGET for immediate words.  If word is
   found, execute it.  It must compile itself.  If word is not
   found, convert it to a number if it is numeric, otherwise it
   is a forward reference.
[
   Sets STATE-T to false to exit the Meta Compiling loop above.
;
   Compile the code field of UNNEST and terminate compilation
:
   Create a target word and set its code field to NEST.


\ Run Time Code for Control Structures                05MAR83HHL
BRANCH    Performs an unconditional branch.  Notice that we
   are using absolute addresses insead of relative ones. (fast)
?BRANCH   Performs a conditional branch.  If the top of the
   parameter stack in True, take the branch.  If not, skip
   over the branch address which is inline.










\ Meta Compiler Branching Words                       10MAR83HHL
These are the META versions of the structured conditionals
found in FORTH.  They must compile the correct run time
branch instruction, and then Mark and Resolve either forward
or backward branches.  These are very analogous to the
regular conditionals in Forth.  Since they are in the
TRANSITION vocabulary, which is searched before the TARGET
vocabulary, they will be executed instead of the TARGET
versions of these words which are defined much later.







\ Run Time Code for Control Structures                07JUL83HHL
LOOP-EXIT   is a common routine used by (LOOP) and (+LOOP)
   It is called when the loop has terminated and is exited
   normally.
(LOOP)      the runtime procedure for LOOP.  Branches back to
   the beginning of the loop if there are more iterations to
   do.  Otherwise it exits.  The loop counter is incremented.
LOOP-BRANCH   A common routine needed twice in the 8080
   implementation of (+LOOP).
(+LOOP)
   Increment the loop counter by the value on the stack and
   decide whether or not to loop again.  Due to the wierdness
   of the 8080, you have to stand on your head to determine
   the conditions under which you loop or exit.


\ Run Time Code for Control Structures                28AUG83HHL
(DO)  The runtime code compiled by DO. Pushes the inline address
   onto the return stack along with values needed by (LOOP).
(?DO)
   The runtime code compiled by ?DO.  The difference between
   ?DO and DO is that ?DO will not perform any iterations if
   the initial index is equal to the final index.
BOUNDS
   Given address and length, make it ok for DO ... LOOP.







\ Meta compiler Branching & Looping                   10MAR83HHL
These are again the TRANSITION versions of the immediate words
for looping.  They compile the correct run time code and then
Mark and Resolve the various branches.












\ Execution Control                                   06SEP83HHL
>NEXT     The address of the inner interpreter.
EXECUTE   the word whose code field is on the stack.  Very
   useful for passing executable routines to procedures!!!
PERFORM   the word whose code field is stored at the address
   pointed to by the number on the stack.  Same as @ EXECUTE
DO-DEFER  The runtime code for deferred words.  Fetches the
   code field and executes it.
DOUSER-DEFER   The runtime code for User deferred words.  These
   are identical to regular deferred words except that each
   task has its own version.
GO
     Execute code at the given address.
NOOP      One of the most useful words in Forth.  Does nothing.
PAUSE     Used by the Multitasker to switch tasks.

\ Execution Control                                   01Oct83map
I           returns the current loop index.  It now requires
   a little more calculation to compute it than in FIG Forth
   but the tradeoff is a much faster (LOOP).  The loop index
   is stored on the Return Stack.
J           returns the loop index of the inner loop in
   nested DO .. LOOPs.
(LEAVE)
   Does an immediate exit of a DO ... LOOP structure.  Unlike
   FIG Forth which waits until the next LOOP is executed.
(?LEAVE)
   Leaves if the flag on the stack is true.  Continues if not.
LEAVE   I have to do this to be 83-Standard.



\ 16 and 8 bit Memory Operations                      05MAR83HHL
@
   Fetch a 16 bit value from addr.
!
  Store a 16 bit value at addr.
C@
   Fetch an 8 bit value from addr.
C!
   Store an 8 bit value at addr.







\ Block Move Memory Operations                        05MAR83HHL
CMOVE
   Move a set of bytes from the from address to the to address.
   The number of bytes to be moved is count.  The bytes are
   moved from low address to high address, so overlap is
   possible and in fact sometimes desired.
CMOVE>
   The same as CMOVE above except that bytes are moved in the
   opposite direction, ie from high addresses to low addresses.







































\ 16 bit Stack Operations                             02AUG83HHL
SP@
     Return the address of the next entry on the parameter stack
SP!  ( Warning, this is different from FIG Forth )
     Sets the parameter stack pointer to the specified value.
RP@
     Return the address of the next entry on the return stack.
RP!  ( Warning, this is different from FIG Forth )
     Sets the return stack pointer to the specified value.







\ 16 bit Stack Operations                             05MAR83HHL
DROP
     Throw away the top element of the stack.
DUP
     Duplicate the top element of the stack.
SWAP
     Exchange the top two elements on the stack.
OVER
   Copy the second element to the top.







\ 16 bit Stack Operations                             11MAR83HHL
TUCK       swap over
   Tuck the first element under the second one.
NIP        swap drop
   Drop the second element from the stack.
ROT
   Rotate the top three element, bringing the third to the top.
-ROT       rot rot
   The inverse of ROT.  Rotates the top element to third place.
FLIP
   Exhange the hi and low halves of a word.
?DUP       dup if dup then
   Duplicate the top of the stack if it is non-zero.



\ 16 bit Stack Operations                             26Sep83map
R>
   Pops a value off of the return stack and pushes it onto the
   parameter stack.  It is dangerous to use this randomly!
>R
   Pops a value off of the parameter stack and pushes it onto
   return stack.  It is dangerous to use this randomly!
R@
   Copies the value on the return stack to the parameter stack.
PICK   Reaches into the stack and grabs an element, copying it
   to the top of the stack.  For example, if the stack has 1 2 3
   Then 0 PICK is 3, 1 PICK is 2, and 2 PICK is 1.
ROLL
   Similar to SHAKE and RATTLE.  Should be avoided.
   1 ROLL is SWAP, 2 ROLL is ROT, etc.
   ROLL can be useful, but it is slow.
\ 16 bit Logical Operations                           05MAR83HHL
AND
   Returns the bitwise AND of n1 and n2 on the stack.

OR
   Returns the bitwise OR of n1 and n2 on the stack.

XOR
   Returns the bitwise Exclusive Or of n1 and n2 on the stack.

NOT
  Does a ones complement of the top.  Equivalent to -1 XOR.

TRUE FALSE     Constants for clarity.
YES            Push a true flag on the stack and jump to next
NO             Push a false flag on the stack and jump to next
\ Logical Operations 83HHL                            16Oct83map
CSET  Set the contents of addr so that the bits that are 1 in n
      are also 1 in addr.  Equivalent to DUP C@ ROT OR SWAP C!
CRESET
   Set the contents of addr so the the bits that are 1 in n
   are zero in addr.  Equivalent to DUP C@ ROT NOT AND SWAP C!
CTOGGLE   Flip the bits in addr by the value n.  Equivalent to
         DUP C@ ROT XOR SWAP C!
ON
   Set the contents of addr to TRUE
OFF
   Set the contents of addr to FALSE




















\ 16 bit Arithmetic Operations                        05MAR83HHL
+
   Add the top two numbers on the stack and return the result.
NEGATE
   Turn the number into its negative.  A twos complement op.
-
   Subtracts n2 from n1 leaving the result on the stack.

ABS
   Return the absolute value of the 16 bit integer on the stack
+!
   Increment the value at addr by n.  This is equivalent to
   the following:   DUP @ ROT + SWAP ! but much faster.
0 1    Frequently used constants
2 3    Are faster and more code efficient.

\ 16 bit Arithmetic Operations                        26Sep83map
2*
   Double the number on the Stack.
2/
   Shift the number on the stack right one bit.  Equivalent to
   division by 2 for positive numbers.
U2/
   16 bit logical right shift.

8*
   Multiply the top of the stack by 8.

1+    Increment the top of the stack by one.
2+    Increment the top of the stack by two.
1-    Decrement the top of the stack by one.
2-    Decrement the top of the stack by two.
\ 16 bit Arithmetic Operations   Unsigned Multiply    26Sep83map
You could write a whole book about multiplication and division,
and in fact Knuth did.  Suffice it to say that UM* is the basic
multiplication primitive in Forth.  It takes two unsigned 16 bit
integers and returns an unsigned 32 bit result.  All other
multiplication functions are derived from this primitive one.

It probably isn't particularly fast or elegant, but that is
because I never liked arithmetic and I stole this implementation
from FIG Forth anyway.




U*D is a synonym for UM*

\ 16 bit Arithmetic Operations   Division subroutines 05MAR83HHL

These are various subroutines used by the division primitive in
Forth, namely U/.  Again I must give credit for them to FIG
Forth, since if I can't even understand multiply,
divide would be completely hopeless.










\ 16 bit Arithmetic Operations   Unsigned Divide      05MAR83HHL
UM/MOD
   This is the division primitive in Forth.  All other division
   operations are derived from it.  It takes a double number,
   d1, and divides by by a single number n1.  It leaves a
   remainder and a quotient on the stack.  For a clearer
   understanding of arithmetic consult Knuth Volume 2 on
   Seminumerical Algorithms.








\ 16 bit Comparison Operations                        05MAR83HHL
0=
  Returns True if top is zero, False otherwise.
0<
  Returns true if top is negative, ie sign bit is on.
0>
  Returns true if top is positive.
0<>
  Returns true if the top is non-zero, False otherwise.
=
   Returns true if the two elements on the stack are equal,
   False otherwise.
<>   Returns true if the two element are not equal, else false.
?NEGATE   Negate the second element if the top is negative.


\ 16 bit Comparison Operations                        27Sep83map
U< Compare the top two elements on the stack as unsigned
   integers and return true if the second is less than the
   first.  Be sure to use U< whenever comparing addresses, or
   else strange things will happen beyond 32K.
U> Compare the top two elements on the stack as unsigned
   integers.  True if n1 > n2 unsigned.
<  Compare the top two elements on the stack as signed
   integers and return true if n1 < n2.
>  Compare the top two elements on the stack as signed
   integers and return true if n1 > n2.

MIN     Return the minimum of n1 and n2
MAX     Return the maximum of n1 and n2
BETWEEN  Return true if min <= n1 <= max, otherwise false.
WITHIN   Return true if min <= n1 < max, otherwise false.
\ 32 bit Memory Operations                            09MAR83HHL
2@
   Fetch a 32 bit value from addr.


2!
   Store a 32 bit value at addr.









\ 32 bit Memory and Stack Operations             9:52  9Nov87crc
2DROP
   Drop the top two elements of the stack.
2DUP
   Duplicate the top two elements of the stack.
3DUP    Duplicate the top three elements of the stack.
2SWAP
   Swap the top two pairs of numbers on the stack.  You can use
   this operator to swap two 32 bit integers and preserve
   their meaning as double numbers.
2OVER
   Copy the second pair of numbers over the top pair.  Behaves
   like  OVER  for 32 bit integers.
4DUP    Duplicate the top four elements of the stack.
2ROT    rotates top three double numbers.

\ 32 bit Arithmetic Operations                        05MAR83HHL
D+
   Add the two double precision numbers on the stack and
   return the result as a double precision number.


DNEGATE
   Same as NEGATE except for double precision numbers.


S>D
   Take a single precision number and make it double precision
   by extending the sign bit to the upper half.
DABS
   Return the absolute value of the 32 bit integer on the stack

\ 32 bit Arithmetic Operations                        06Apr84map
D2*
   32 bit left shift.
D2/
   32 bit arithmetic right shift. Equivalent to divide by 2.



D-   Subtract the two double precision numbers.
?DNEGATE    Negate the double number if the top is negative.






\ 32 bit Comparison Operations                        01Oct83map
D0=     Compare the top double number to zero.  True if d = 0
D=      Compare the top two double numbers.  True if d1 = d2
DU<     Performs unsigned comparison of two double numbers.
D<      Compare the top two double numbers.  True if d1 < d2
D>      Compare the top two double numbers.  True if d1 > d2
DMIN    Return the lesser of the top two double numbers.
DMAX    Return the greater of the the top two double numbers.








\ Mixed Mode Arithmetic                               27Sep83map
This does all the arithmetic you could possibly want and even
more.  I can never remember exactly what the order of the
arguments is for any of these, except maybe * / and MOD, so I
suggest you just try it when you are in doubt.  That is one
of the nice things about having an interpreter around, you can
ask it questions anytime and it will tell you the answer.

*D  multiplys two singles and leaves a double.
M/MOD  divides a double by a single, leaving a single quotient
   and a single remainder. Division is floored.
MU/MOD  divides a double by a single, leaving a double quotient
   and a single remainder. Division is floored.



\ 16 bit multiply and divide                          27Sep83map

*/ is a particularly useful operator, as it allows you to
do accurate arithmetic on fractional quantities.  Think of
it as multiplying n1 by the fraction n2/n3.  The intermediate
result is kept to full accuracy.  Notice that this is not the
same as * followed by /.  See Starting Forth for more examples.









\ Task Dependant USER Variables                       24Mar84map

TOS      Saved during Task switching.
ENTRY    Jumped to during multitasking.
LINK     Points to next task in the circular queue
SP0      Empty parameter stack for this task.
RP0      Empty return stack for this task.
DP       Size of dictionary.  Next available location.
#OUT     Number of characters sent since last CR.
#LINE    Number of CR's sent since last page.
OFFSET   Added to all block references.
BASE     The current numeric base for number input output.
HLD      Points to a converted character during numeric output.
FILE     Allows printing of one file while editing another.
IN-FILE  Allows printing of one file while editing another.
PRINTING  indicates whether printing is enabled.
\ System VARIABLEs                                    15MAY86JDH
YDP      Size of headers.  Next available location.
EMIT     Sends a character to the output device.

SCR      Holds the screen number last listed or edited.
PRIOR    Points to the last vocabulary that was searched.
DPL      The decimal point location for number input.
WARNING  Checked by WARN for duplicate warnings.
R#       The cursor position during editing.
HLD      Points to a converted character during numeric output.
LAST     Points to the name of the most recently CREATEd word.
CSP      Used for compile time error checking.
CURRENT  New words are added to the CURRENT vocabulary.
#VOCS    The number of elements in the search order array.
CONTEXT  The array specifying the search order.

\ System Variables                                    02AUG83HHL
'TIB     Points to characters entered by user.
WIDTH    Number of characters to keep in name field.
VOC-LINK Points to the most recently defined vocabulary.
BLK      If non-zero, the block number we are interpreting.
>IN      Number of characters interpreted so far.
SPAN     Number of characters input by EXPECT.
#TIB     Used by WORD, when interpreting from the terminal.
END?     True if input stream exhausted, else false.







\ Devices                     Strings                 02AUG83HHL
BL BS BELL     Names for BLank, BackSpace, and BELL
CAPS           If true, then convert names to upper case
FILL
   FILL the string starting at start-addr for count bytes
   with the character char.  Both BLANK and ERASE are
   special cases of FILL.

ERASE      Fill the string with zeros
BLANK      Fill the string with blanks
COUNT     Given the address on the stack, returns the address
   plus one and the byte at that address.  Useful for strings.
LENGTH    Given the address on the stack, returns the address
   plus two and the two byte contents of the address.
MOVE
   Move the specified bytes without overlapping.
\ Devices                     Strings                 06Apr84map
>UPPER
   subroutine which converts character in AX to upper case.
UPC
   Convert a Char to upper Case
UPPER
   Take the string at the specified address and convert it to
   upper case.  It converts the string in place, so be sure to
   make a copy of the original if you need to use it later.
HERE      Return the address of the top of the dictionary
PAD       Floating Temporary Storage area.
-TRAILING   Return the address and length of the given string
   ignoring trailing blanks.



\ here pad -trailing                                  26Jun87crc
This is a somewhat faster and smaller version of  HERE .


PAD  in code for speed. It is used all over the place, folks.






for comparison:
my definition of  HERE .
the old one.
And in high level
   again
\ Devices                     Strings                 06Apr84map
COMP   This performs a string compare.  If the two strings are
   equal, then COMPARE returns 0.  If the two strings differ,
   then COMPARE returns -1 or +1.  -1 is returned if string 1
   is less than string 2.  +1 is returned if string 1 is
   greater than string 2.  All comparisons are relative to
   ASCII order.
CAPS-COMP
   The code on this screen handles the case where case is not
   significant.  Each character is converted to upper case
   before the comparison is made.  Thus, lower case a and upper
   case A are considered identical.
COMPARE
   Performs a string compare. If CAPS is true, characters from
   both strings are converted to upper case before comparing.

\ MSDOS 2 interface

OSF    Operating Sys call in progress flag.

FCDOS called by other assembler code to do INT 21 (DOS call).
  BP and SI are the critical FORTH registers.  Create is used
  here to force force lable into target dictionary. OSF is set
  during the DOS call, can be tested by interrupt routines
  which call non-reentrant DOS functions.

XFDOS : call INT 21 with most any reg combination used.








?CS: : leave FORTH CS on stack

@L : ( seg adr - n ) load word long

C@L : ( seg adr - byt) char load long


C!L : ( byt seg adr -) char store long


!L : ( n seg adr -- ) word store long


\ Devices      Terminal IO via CP/M BIOS              06Apr84map
BDOS     Load up the registers and do a DOS system call.
   return the result placed in the A register on the
   stack.

(KEY?)
   Returns true if the user pressed a key, otherwise false.
(KEY)
   Pauses until a key is ready, and returns it on the stack.
(EMIT)   Sends the character to the terminal.






































































































































































































































\                                                     18may86jdh
CMOVEL : ( sseg sptr dseg dptr cnt ) move char block long.
YSTART : if non-zero, ptr to start of headers after dictionary.
   Used to set DP in this case.
YSEG : SEG for header segment
MEMCHK : abort with memory error message if true
DOSVER : get DOS version number
SETYSEG : move headers after dictionary to their own segment.
  Reserves 100k space (DOS 2.x required).  Copies headers to
  the alloted space






































\ more YSEG primatives                                15MAY86JDH







Probably should have YALLOT also for completeness.  Wasn't
   needed very often.






\ Devices                     Terminal Output         19Apr84map
KEY?  Usually set to (KEY?), to sense keyboard status.
KEY   Usually set to (KEY) to get a character from the user.
CR     Typically set to CRLF, above.
PR-STAT  Return printer status, if implemented, else TRUE
(PRINT)  The value of the DEFERRED word EMIT when you
   want to send a character to the printer.
(EMIT)  sends a character to both the console and the printer.

CRLF     Sends a carriage return line feed sequence.
TYPE   Display the given string on the terminal.
SPACE        Send a space to the terminal
SPACES       Send a set of spaces to the terminal
BACKSPACES   Send a set of Backspaces to the terminal.
BEEP         Ring the bell on the terminal

















\ Devices   System Dependent Control Characters       05Oct83map
BS-IN
   If at beginning of line, beep, otherwise back up 1.
(DEL-IN)
   If at beginning of line, beep, otherwise back up and erase 1.
BACK-UP
   Wipe out the current line by overwriting it with spaces.
RES-IN
   Reset the system to a relatively clean state.
P-IN
   Toggle the printer on or off





\ Devices                     Terminal Input          16FEB84MAP
CR-IN
   Finish input and remember the number of chars in SPAN
(CHAR)
   Process an ordinary character by appending it to the buffer.
CHAR  is usually (CHAR). Executed for most characters.
DEL-IN is usually (DEL-IN). Executed for delete characters.

CC   Points to current control character table.
CC-FORTH
   Handle each control character as a special case.  This
   generates an execution array which is indexed into by
   EXPECT to do the right thing when it receives a control
   character.


\ Devices                     Terminal Input          29Sep83map
EXPECT
   Get a string from the terminal and place it in the buffer
   provided.  Performs a certain amount of line editing.
   Saves the number of characters input in the Variable SPAN.
   Processes control characters per the array pointed to by CC.



TIB     Leaves address of text input buffer.
QUERY   Get more input from the user and place it at TIB.





\ Devices                     BLOCK I/O               11Mar84map
These variables are used by the BLOCK IO part of the system.
Unlike FIG Forth the buffers are managed in a true least
recently used scheme.  The are maintained in memory as an array
of 8 byte entries, whose format is defined at left.  Whenever
a BLOCK is referenced its pointer is moved to the head of the
array, so the most recently used buffer is first. Thus multiple
references are very fast.  Also we have eliminated the need for
a null at the end of each BLOCK buffer so that the size of a
buffer is now exactly 1024 bytes.
The format of entries in the buffer-pointer array is:
   0-1 is Block Number         2-3 is Pointer to File
   4-5 is Address of Buffer    6-7 is Update Flag
BUFFER#   Return the address the the nth buffer pointer.
>END      Return a pointer to just past the last buffer packet.
>UPDATE   Return a pointer to the update flag.
















\ Devices                     BLOCK I/O               04Apr84map
READ-BLOCK   performs physical read.
WRITE-BLOCK   performs physical write.
.FILE   (S adr -- )
  print filename in fcb at adr.
FILE?   (S -- ) print name of current file.
SWITCH   exchange in-file and file.

DOS  vocabulary for native file system interface words.
!FILES  sets both file pointers to the specified file.
DISK-ABORT   (S fcb a n -- )
  print error message and file name.
?DISK-ERROR  (S fcb n -- )
  report disk error.


\ Devices                     BLOCK I/O               14Nov86TJZ
FCB1         The default File Control Block
CLR-FCB      Initialize the specified FCB.
SET-DMA      CP/M system call to set dma address
RECORD#      Pointer to the specified Ramdom Record
MAXREC#      Pointer to the largest record allowed
IN-RANGE     Makes sure that the Random Record is
   within Range.  Issues error message if it isn't.
REC-READ     Do a Random Access read
REC-WRITE    Do a Random Access write






































\ Devices                     BLOCK I/O               03Apr84map
SET-IO  common set-up for file reads and writes.


FILE-READ  read 1024 bytes from a file.



FILE-WRITE  write 1024 bytes to a file.



FILE-IO  set block read and writes to use files.



















\ SOME BLOCK I/O TEST CODE                            14Nov86TJZ


CREATE SOURCE-BUF 1026 ALLOT      SOURCE-BUF 1026 ERASE

: GET-BLOCK     (S BLK# -- )
                [ DOS ] MYBUFFER (SET-DMA)
                IN-FCB @ >R
                      R@ RECORD# !
                B/REC R@ BREC#   !
                      R> 33 BDOS ;





( .EXE file support                            12:19 04/22/86 )
XCKSUM  checksums a block of memory using word addition ( cnt
   must be even )
SUVEC  startup vector, for a long jump to HEX 100 to set up
   CS correctly.  Currently the .EXE header has CS set at
   0FFF0h which fakes out the loader to set CS to the same
   as the Program Sement Prefix.  This makes the long jump
   unnecessary, but we put it in so we could easily make
   the .EXE header more conventional.
SEXE  entry point specified by .EXE header.  Sets the seg part
   of SUVEC, moves FORTH headers up to seg after DS (YSEG),
   does long jump thru SUVEC to start system.
EHMT  empty .EXE header.  Entries 0Eh and 16h are SS and CS,
   set to -10h, somewhat questionable.  If they are changed,
   10h and 14h must be changed to compensate.

\ Devices                     BLOCK I/O               11Mar84map

CAPACITY     The number of blocks in the current file
LATEST?   For increased performance we first check to see if the
   block we want is the very first one in the list.   If it is
   return the buffer address and false, and exit from the word
   that called us, namely ABSENT?.  Otherwise we return as
   though nothing had happened.
ABSENT?
   Search through the block/buffer list for a match.  If it is
   found, bring the block packet to the top of the list and
   return a false flag and the address of the buffer.  If the
   block is not found, return true, indicating it is absent,
   and the second parameter is garbage.


\ Devices                     BLOCK I/O               01Apr84map
UPDATE   Mark the most recently used buffer as modified.
DISCARD  Mark the most recently used buffer as unread.
MISSING   Writes the least recently used buffer to disk if it
   was modified, and moves all of the buffer pointers down by
   one, making the first one available for the new block.  It
   then assigns the newly available buffer to the new block.
(BUFFER)  assigns a buffer to the specified block in the given
  file. No disk read is performed. Leaves the buffer address.
BUFFER  assigns a buffer to the specified block.
  No disk read is performed. Leaves the buffer address.
(BLOCK) Leaves the address of a buffer containing the given
  block in the given file. Reads the disk if necessary.
BLOCK   Leaves the address of a buffer containing the given
  block. Reads the disk if necessary.
IN-BLOCK  like BLOCK, but for the IN-FILE.
\ Devices                     BLOCK I/O               24Mar84map
EMPTY-BUFFERS
   First wipe out the data in the buffers.  Next initialize the
   buffer pointers to point to the right addresses in memory
   and set all of the update flags to unmodified.
SAVE-BUFFERS
   Write back all of the updated buffers to disk, and mark them
   as unmodified.  Use this whenever you are worried about
   crashing or losing data.
FLUSH     Save and empties the buffers. Used for changing disks.
  The phrase " 0 BLOCK DROP " is a kludge for CP/M. Some
  systems do extra buffering in the BIOS, and you must access
  a new block to be sure the old one is actually written to disk
VIEW#  returns address of the view# field for this file.


\ Devices                     BLOCK I/O               03Apr84map

FILE-SIZE    Return the size of the file in records.
DOS-ERR?     Returns true if a DOS error occurred.
OPEN-FILE
   Open the current file and tell user if you can't.
   Determine the size of the file and save it for error check.
DOS-FCB      The address where the DOS puts a parsed FCB
DEFAULT   Opens the default file per the execute line.  Move the
   already parsed file control block into FCB1, and open the
   file.  This does nothing if no file was given.
(LOAD)
   Load the screen number that is on the stack.  The input
   stream is diverted from the terminal to the disk.
LOAD    Interpret a screen as if it were type in .

















\ Interactive Layer           Number Input            30Sep83map
DIGIT
  Returns a flag indicating whether or not the character is a
  valid digit in the given base.  If so, returns converted
  value and true,  otherwise returns char and false.
DOUBLE?   Returns non-zero if period was encountered.
CONVERT
   Starting with the unsigned double number ud1 and the string
   at adr1, convert the string to a number in the current base.
   Leave result and address of unconvertable digit on stack.






\ Interactive Layer           Number Input            06Oct83map
(NUMBER?)
   Given a string containing at least one digit, convert it
   to a number.
NUMBER?
   Convert the count delimited string at addr to a double
   number.  NUMBER? takes into account a leading minus sign,
   and stores a pointer to the last delimiter in DPL.
   The string must end with a blank.
   Leaves a true flag if successful.
(NUMBER)
   Convert the count delimited string at addr to a double
   number.  (NUMBER) takes into account a leading minus sign,
   and stores a pointer to the last period in DPL.  Note the
   string must end with a blank or an error message is issued.
NUMBER   Convert a string to a number.  Normally (NUMBER)
\ Interactive Layer           Number Output           03Apr84map
HOLD     Save the char for numeric output later.
<#       Start numeric conversion.
#>       Terminate numeric conversion.
SIGN     If n1 is negative insert a minus sign into the string.
#        Convert a single digit in the current base.

#S       Convert a number until it is finished.

HEX        All subsequent numeric IO will be in Hexadecimal.
DECIMAL    All subsequent numeric IO will be in Decimal.
OCTAL      All subsequent numeric IO will be in Octal.




\ Interactive Layer           Number Output           02AUG83HHL
(U.)   Convert an unsigned 16 bit number to a string.
U.     Output as an unsigned single number with trailing space.
U.R    Output as an unsigned single number right justified.

(.)    Convert a signed 16 bit number to a string.
.      Output as a signed single number with a trailing space.
.R     Output as a signed single number right justified.

(UD.)  Convert an unsigned double number to a string.
UD.    Output as an unsigned double number with a trailing space
UD.R   Output as an unsigned double number right justified.

(D.)   Convert a signed double number to a string.
D.     Output as a signed double number with a trailing space.
D.R    Output as a signed double number right justified.
\ Interactive Layer           Parsing                 03Apr84map
DONE
   A common exit routine for SKIP and SCAN.
SKIP
   Given the address and length of a string, and a character to
   look for, run through the string while we continue to find
   the character.  Leave the address of the mismatch and the
   length of the remaining string.

SCAN
   Given the address and length of a string, and a character to
   look for, run through the string until we find
   the character.  Leave the address of the match and the
   length of the remaining string.


\ Interactive Layer           Parsing                 01Oct83map
/STRING     Index into the string by n.  Returns addr+n and
   len-n.
PLACE       Move the characters at from to to with a preceding
   length byte of len.
(SOURCE)    Returns the string to be scanned.  This is the
   default value of the deferred word SOURCE.
SOURCE      Return a string from the current input stream.
PARSE-WORD
   Scan the input stream until char is encountered.  Skip over
   leading chars.  Update >IN pointer.
   Leaves the address and length of the enclosed string.
PARSE
   Scan the input stream until char is encountered.
   Update >IN pointer.
   Leaves the address and length of the enclosed string.
































































































\ Interactive Layer           Parsing                 03Apr84map
'WORD   Leaves the same address as WORD.
   In this system, 'WORD is the same as HERE.
WORD
   Parse the input stream for char and return a count delimited
   string at here.  Note there is always a blank following it.
>TYPE
   TYPE for multitasking systems.
.(     Type the following string on the terminal.
(    The Forth Comment Character.  The input stream is skipped
  until a ) is encountered.
\S  comment to end of screen.




\ Interactive Layer           Dictionary              08MAY84HHL
TRAVERSE
   Run through a name field in the specified direction.
   Terminate when a byte whose high order bit is on is detected.
DONE?
   True if the input stream is exhaused or state doesn't match
FORTH-83   Let's hope so.

CNHASH  given CFA, get pointer into >NAME hash table in YSEG.

CNSRCH  search for CFA between YA and MAXYA in YSEG.  Return
   NFA and failure flag.




\ Interactive Layer           Dictionary              08Oct83map
N>LINK       Go from name field to link field.
L>NAME       Go from link field to name field.
BODY>        Go from body to code field.
NAME>        Go from name field to code field.
LINK>        Go from link field to code field.
>BODY        Go from code field to body.
>NAME        Go from code field to name field.
>LINK        Go from code field to link field.
>VIEW        Go from code field to view field.
VIEW>        Go from view field to code field.
HASH   Given a string address and a pointer to a set of
   vocabulary chains, returns the actual thread.  Uses the
   first character of the string to determine which thread.


\ Interactive Layer           Dictionary              08Oct83map
(FIND)
   Does a search of the dictionary based on a pointer to a
   vocabulary thread and a string.   If it finds the string
   in the chain, it returns a pointer to the CFA field
   inside the header.  This field contains the code field
   address of the body.  If it was an immediate word the
   flag returned is a 1.  If it is non-immediate the flag
   returned is a -1.
   If the name was not found, the string address is returned
   along with a flag of zero. Note that links point to
   links, and are absolute addresses.




































\ Interactive Layer           Dictionary              03Apr84map
#THREADS   The number of seperate linked lists per vocabulary.
FIND
   Run through the vocabulary list searching for the name whose
   address is supplied on the stack.  If the name is found,
   return the code field address of the name and a non-zero
   flag.  The flag is -1 if the word is non-immediate and 1 if
   it is immediate.  If the name is not found, the string
   address is returned along with a false flag.

?UPPERCASE
  Convert the given string to upper case if CAPS is true.
DEFINED    Look up the next word in the input stream.  Return
   true if it exists, otherwise false. Maybe ignore case.


\ Interactive Layer           Interpreter             05MAR83HHL
?STACK
   Check for parameter stack underflow or overflow and issue
   appropriate error message if detected.
STATUS   Indicate the current status of the system.
INTERPRET
   The Forth Interpret Loop.  If the next word is defined,
   execute it, otherwise convert it to a number and push it
   onto the stack.







\ Extensible Layer            Compiler                 3Aug87crc
ALLOT    Allocate more space in the dictionary


,        Set the value on the stack into the dictionary and
         advance its pointer.




C,       Same as , except uses an 8 bit value





\ Extensible Layer            Compiler                 3Aug87crc
COMPILE     Compile the following word when this def. executes
IMMEDIATE   Mark the last Header as an Immediate word.
LITERAL  Compile the single integer from the stack as a literal.
  This version looks for byte literals & compiles appropriately.
DLITERAL
  Compile the double integer from the stack as a literal.
ASCII    Compile the next character in the input stream as a
  literal Ascii integer.
CONTROL  Compile the next character in the input stream as a
  literal Ascii Control Character.
ALIGN    Used to force even addresses.
EVEN     Makes the top of the stack an EVEN number.



\ Extensible Layer            Compiler                08Oct83map
CRASH   Default routine called by execution vectors.

?MISSING  Tell user the word does not exist.

'        Return the code field address of the next word
[']      Like ' only used while compiling
[COMPILE]   Force compilation of an immediate word
(")    Return the address and length of the inline string
(.")   Type the inline string.  Skip over it.
,"     Add the following text till a " to the dictionary.
."     Compile the string to be typed out later.
"      Compile the string, return pointer later.



\ Interactive Layer           Dictionary              27Sep83map
FENCE   Limit address for forgetting.
TRIM   (S faddr voc-addr -- )
   Change the 4 hash pointers in a vocabulary so that they are
   all less than a specified value, faddr.

(FORGET)   (S code-addr relative-link-addr -- )
   Forgets part of the dictionary.  Both the code address and
   the header address are specified, and may be independant.
   (FORGET) resets all of the links and releases the space.

FORGET   (S -- )
   Forget all of the code and headers before the next word.



\ Extensible Layer            Compiler                11Mar84map
WHERE  Locates the screen and position following an error.
?ERROR  Maybe indicate an error. Change this to alter ABORT"
(?ERROR)
   Default for ?ERROR. Conditionally execute WHERE and type
   message.

(ABORT")
   The Runtime code compiled by ABORT". Uses ERROR, and
   updates return stack.
ABORT"
   If the flag is true, issue an error message and quit.
ABORT
       Stop the system and indicate an error.


\ Extensible Layer            Structures              03Apr84map
?CONDITION
   Simple compile time error checking.  Usually adequate
>MARK        Set up for a Forward Branch
>RESOLVE     Resolve a Forward Branch
<MARK        Set up for a Backwards Branch
<RESOLVE     Resolve a Backwards Branch

?>MARK       Set up a forward Branch with Error Checking
?>RESOLVE    Resolve a forward Branch with Error Checking
?<MARK       Set up for a Backwards Branch with Error Checking
?<RESOLVE    Resolve a backwards Branch with Error Checking

LEAVE and ?LEAVE could be non-immediate in this system,
  but the 83 standard specifies an immediate LEAVE, so they
  both are for uniformity.
\ Extensible Layer            Structures              27JUL83HHL
These are the compiling words needed to properly compile
the Forth Conditional Structures.  Each of them is immediate
and they must compile their runtime routines along with
whatever addresses they need.  A modest amount of error
checking is done.  If you want to rip out the error checking
change the ?> and ?< words to > and < words, and
all of the 2DUPs to DUPs and the 2SWAPs to SWAPs.  The rest
should stay the same.







\ Extensible Layer            Defining Words          03Apr84map
,VIEW   Calculate and compile the VIEW field of the header.
"CREATE   Use the string at str to make a header, and initialize
  the code field.  First we check for duplicates.  Then we make
  entry in >NAME hash table if appropriate.  Next lay down the
  view field. Then we hook in to the correct thread an make the
  link field.  We set up LAST so that it points to our name
  field.  Then we copy the name to YSEG and delimit the name
  field bits.  Then we make the pointer in the YSEG to the CFA.
  Then we add a stopper entry to >NAME hash table in case of a
  large ALLOT or end of dictionary. Finally we lay down the
  code field.

CREATE   Make a header for the next word in the input stream.


\ Extensible Layer            Defining Words          06MAR83HHL
!CSP        Save the current stack level for error checking.
?CSP        Issue error message if stack has changed.
HIDE        Removes the Last definition from the Header
            Dictionary.
REVEAL      Replaces the Last definition in the Header
            Dictionary.
(;USES)     Set the code field to the contents of following cell
ASSEMBLER   Define the vocabulary to be filled later.
;USES       Similar to the traditional ;CODE except used when
            run time code has been previously defined.
(;CODE)     Set the code field to the address of the following.
;CODE       Used for defining the run time portion of a defining
            word in low level code.
DOES>       Specifies the run time of a defining word in high
            level Forth.
\ Extensible Layer            Defining Words          23JUL83HHL
[     Stop compiling and start interpreting
]     The Compiling Loop.  First sets Compile State.  Looks up
   the next word in the input stream and either executes it
   or compiles it depending upon whether or not it is immediate.
   If the word is not in the dictionary, it converts it to a
   number, either single or double precision depending on
   whether or not any punctuation was present.  Continues until
   input stream is empty or state changes.
:    Defines a colon definition. The definition is hidden until
   it is completed, or the user desires recursion.  The runtime
   for : adds a nesting level.
;     Terminates a colon definition.  Compiles the runtime code
   to remove a nesting level, and changes STATE so that
   compilation will terminate.

\ Extensible Layer            Defining Words          15Dec86TJZ
RECURSIVE   Allow the current definition to be self referencing
CONSTANT    A defining word that creates constants.  At runtime
   the value of the constant is placed on the stack.
VARIABLE    A defining word to create variables.  At runtime
   the address of the variable is placed on the stack.
DEFER    Defining word for execution vectors.  These are
   initially set to display an error message.  They are
   initialized with IS. DEFERS, installs the contents of a
defered word in the current definition being defined. This is
used to make a new word the defered word also, sort of a list.
VOCABULARY
   Defines a new Forth vocabulary.  VOC-LINK is a chain in
   temporal order and used by FORGET.  At runtime a vocabulary
   changes the search order by setting CONTEXT.
DEFINITIONS Subsequent definitions will be placed into CURRENT.
\ Extensible Layer            Defining Words          06Oct83map
2CONSTANT
   Create a double number constant.  This is defined for
   completeness, but never used, so the code field is discarded.
2VARIABLE
   Create a double length variable.  This is defined for
   completeness, but never used, so the code field is discarded.
   as appropriate.
AVOC   A variable that hold the old CONTEXT vocabulary
CODE is the defining word for FORTH assembler definitions.
   It saves the context vocabulary and hides the name.

END-CODE    terminates a code definition and restores vocs.



\ Extensible Layer            Defining Words          07SEP83HHL
#USER     Count of how many user variables are allocated
USER      Vocabulary that holds task versions of defining words
ALLOT     Allocate some space in the user area for a task.
   When used with CREATE, you can define arrays this way.
CREATE    Define a word that returns the address of the next
   available user memory location.
VARIABLE  Define a task type variable.  This is similar to the
   old FIG version of USER.
DEFER     Defines an execution vector that is task local.






\ Extensible Layer            ReDefining Words        07SEP83HHL
>IS   Maps a code field into a data field.  If the word is in
   the USER class of words, then the data address must be
   calculated relative to the current user pointer.  Otherwise
   it is just the parameter field.

(IS)     The code compiled by IS.  Sets the following DEFERred
   word to the address on the parameter stack.
IS       Depending on STATE, either sets the following DEFERred
   word immediatly or compiles the setting for later.






\ assignment                                          11Feb87TJZ


(=:)    ( N1 --- )
                Primitive used by the following definitions,
                gets compiled into colon definition, and stores
                value on the stack into the following defs
                body field.

=:    ( N1 T1 --- )
                Used to assign values into the body of the
                following definition, like variables or
                constants.



\ assignment                                          11Feb87TJZ


INCR>   ( --- )
        Increment the body of the word following, used to
        modify the following constant or variable.

DECR>   ( --- )
        Decrement the body of the word following, used to
        modify the following constant or variable.






\ assignment                                          11Feb87TJZ


+!>     ( N1 --- )
        Increment the body field of the following definition
        by value n1 on the stack.










\ Initialization              High Level              24JUL83HHL
RUN
   Allows for multiline compilation.  Thus you may enter a :
   definition that spans several lines.
QUIT
   The main loop in Forth.  Gets more input from the terminal
   and Interprets it.  Responds with OK if healthy.
BOOT   The very first high level word executed during cold start
WARM   Performs a warm start, jumped to by vector at hex 104

COLD   The high level cold start code.  For ordinary forth,
   BOOT should initialize and pass control to QUIT.




\ Initialization              High Level              24JUL83HHL
INITIAL   The screen number to load for an application.
OK        Loads in an application from the INITIAL screen
START     Used to compile from a file after meta compilation
   has finished.
BYE     Returns control to CP/M.  First it moves the heads
   down next to the code such that the system is contiguous
   when saved.  Calculates the size in pages.








\ Initialization              Low Level               06MAR83HHL

WARM   Initialize the warm start entry point in low memory
   and jump immediately into hi level
COLD   Initialize the cold start entry point in low memory
   Then calculate how much space is consumed by CP/M and
   round it down to an even HEX boundary for safety.  We
   then patch FIRST and LIMIT with this value and calculate
   the locations of the return stack and the Terminal Input
   buffer.  We also set up the initial parameter stack and
   finally call the Hi Level COLD start routine.





\ Initialize User Variables                           27JUL83HHL
Finally we must initialize the user variables that were defined
earlier.  User variables are relocatable, and sit on the top of
the dictionary in whatever task they occur in.  They must be
laid down in the exact same order as their definitions.











\ Resident Tools                                      27Sep83map
DEPTH      Returns the number of items on the parameter stack
.S
   Displays the contents of the parameter stack non
   destructively.  Very useful when debugging.

.ID
   Display the variable length name whose name field address
   is on the stack.  If it is shorter than its count, it is
   padded with underscores.  Only valid Ascii is typed.

DUMP
   A primitive little dump routine to help you debug after
   you have changed the system source and nothing works any
   more.

These words are in the reference word sets,           29Sep83map
and are only include for completeness.
We prefer to use RECURSIVE rather than RECURSE.
( See RECURSIVE )












\ Resolve Forward References                          06MAR83HHL
We must resolve the forward references that were required in
the Meta Compiler.  These are all run time code which wasn't
known at the time the meta compiling version was defined.  These
are all either defining words or special case immediate words.











\ Resolve Forward References                          06MAR83HHL
These are forward references that were generated in the course
of compiling the system source.  Most of these are here because
(DO) (?DO) and ROLL are written in high level and are defined
very early in the system.  While forward references should be
avoided when possible, they should not be shunned as a matter
of dogma.  Since the meta compiler makes it easy to create and
resolve forward references, why not take advantage of it when
you need to.























\ Initialize DEFERred words                           03Apr84map
In order to run, we must initialize all of the defferred words
that were defined to something meaningful.  Deferred words are
also known as execution vectors.  The most important execution
vectors in the system are listed here.  You can certainly create
your own with the defining word DEFER.  Be sure you initialize
them however, or else you will surely crash.









\ Initialize Variables                                20Apr84map
Initialize the CURRENT vocabulary to point to FORTH
Initialize the CONTEXT vocabulary to point to FORTH
Initialize the Threads in the Forth vocabulary
The value of DP-BODY is only now know, so we must init it here
The rest of the variables that are initialize are ordinary
variables, which are resident in the dictionary, and must be
correct upon cold boot.  You can change some of these depending
on how you want your system to come up initially.







\               The Rest is Silence                   26Sep83map
*************************************************************














































































































































































































































































































































































