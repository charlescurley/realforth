**********************  fig-FORTH  MODEL  **********************
*                                                              *
*                    Through the courtesy of                   *
*                                                              *
*                     FORTH INTEREST GROUP                     *
*                        P. O. BOX 1105                        *
*                    SAN CARLOS, CA. 94070                     *
*                                                              *
*                          RELEASE 1                           *
*                    WITH COMPILER SECURITY                    *
*                                                              *
*                    VARIABLE LENGTH NAMES                     *
*                                                              *
*               Distributed by Charles Curley for              *
*                   Atari ST series computers                  *
*****  Further distribution must include the above notice. *****
     ERROR MESSAGES                         06 12 84 CRC
 Empty Stack
 Dictionary Full
 Has Wrong Addressing Mode
 Isn't Unique
 Branch out of Range
 Disk Range ?
 Full Stack
 Disk Error !!!
Bytes (hex) Dictionary space available.
 CMOS only instruction or addressing mode
Personal Data Base C. Curley    Confidential    28 November 1987
  This can't happen!! msg 12
  This can't happen!! msg 13
     ?? Not in dictionary ??
real-FORTH on Atari ST             (c) 1985-87 by Charles Curley
     ERROR MESSAGES                          7  4 85 CRC
 Compilation Only, Use in definitions
 Execution only
 Conditionals not paired
 Definitions not finished
 In protected dictonary
 Use only when loading
 Off Current Screen
 Declare Vocabulary
  This can't happen!! msg 25
 Centronics Interface Printer Failure!!
  This can't happen!! msg 27
  This can't happen!! msg 28
  This can't happen!! msg 29
  This can't happen!! msg 30
  This can't happen!! msg 31
\ Loader file creation screen             (  3  4 90 CRC 19:59 )
1 +BLK  NEEDED TARGET   EDITOR FLUSH
5.25" IFTRUE
FILING R-W MKF: REAL4TH.5IN
FILING    ORIGIN       DPNEW @ OVER -
B/BUF / 1+ B/BUF *  DUP >R  HANDLE   WTF  R> - 6 .R
CR CLF  LS REAL*.*      IFEND

3.5" IFTRUE
FILING R-W MKF: REAL4TH.3IN
FILING    ORIGIN       DPNEW @ OVER -
B/BUF / 1+ B/BUF *  DUP >R  HANDLE   WTF  R> - 6 .R
CR CLF  LS REAL*.*      IFEND

FORTH DEFINITIONS

( LOAD SCREEN -- serial -- Recompiling    (  1  5 88 CRC 17:15 )
DECIMAL  FILING FORTH DEFINITIONS    \ home
   FORGET TASK
        : MARKER ;              DECIMAL
   1 constant true              0 constant false
   3 +LOAD ( loaders    )        5 +LOAD  ( loud quiet )
   8 +LOAD ( disk size flags )
   TODAY

 EDITOR FLUSH

: OCTAL 8 BASE ! ;

   CR HEX 0F MESSAGE DECIMAL CR  : TASK ;
   HERE 1024 BLANKS \ ."  Disposing... " DISPOSE CTL G EMIT

\ trace file creation screen              ( 15  7 89 CRC 11:48 )
-1 +BLK NEEDED TARGET    PRINTER LEFT @ >R   5 LEFTS

\ CR FILING SETDir: \messdos\rf     dir *.*
  CR FILING  curdrv >r ( *!* ) setdrive: h  SETDir: \  dir *.*

FILING R-W CREATEFILE: TRACE.TXT
CR outfile  CR CR 808x

CR CLOSEOUTFILE  DIR *.*

filing ( *!* ) r> (setdef) drop

R> PRINTER LEFT !
FORTH DEFINITIONS  EDITOR

\ Documenting screen                      ( 13  2 87 CRC 11:51 )
DECIMAL  DOCUMENTING  FORTH SCR @
         0  B/DRV 1-  DOCUMENTING SINCE 26  1 87
NECPAGE  SCR !












\       target compiler: loaders, 132col  ( 24  3 88 CRC 20:20 )
FORTH DEFINITIONS
 53 +BLK LOADER TARGET
 24 +BLK LOADER 8086ASM
  3 +BLK LOADER DOCUMENTED
114 +BLK LOADER 808X            : BOTH TARGET 808X ;
  7 +BLK LOADER FILE
  8 +BLK LOADER RENAMES

: ?CR   OUT @ C/L > IF CR THEN ;

\ : 132COL   ?PRINT IF CR CTL \ EMIT THEN ;

\ : 80COL    ?PRINT IF CR CTL Y EMIT THEN ;

\ : 2CONSTANT  CREATE SWAP  , ,    DOES> 2@ ;
















\ compiling aids                          (  2  6 86 CRC 11:37 )
FORTH DEFINITIONS
\ : LOUD  ASSEMBLER (QUIET) ON  ( 132COL ) ;

\ : QUIET ASSEMBLER (QUIET) OFF ( 80COL )  ;

\ editor atCOLD: FLUSH

: SETBUFS \ n --   | set system to have n buffers
  FLUSH B/BUF 6 + * LIMIT SWAP - 'FIRST !
  EMPTY-BUFFERS FLUSH   #BUFS 4 .R ."  Buffers " ;

  #BUFS 32 = IFTRUE 200 SETBUFS IFEND
\ #BUFS 32 = IFTRUE 100 SETBUFS IFEND


\ Target documentor                       ( 13  9 85 CRC       )
CR ." Cross Compilation of 68000 real-FORTH for Atari."
CR CR TARGET ATARI
?CRT 0= IFTRUE PAGE IFEND        WARNING ON
CR 3 VTAB CR ." Atari " 16 BYTE:IN (ABORT)    COUNT TYPE
CR CR 15 MESSAGE CR CR   ." VLIST  of kernel." CR
TVLIST CR CR
  ?CRT 0= IFTRUE PAGE IFEND
  ." Concordance of kernel" CR CR
  CROSS
?CRT 0= IFTRUE PAGE IFEND





















\ flags for conditional compilation       ( 17  3 88 CRC 19:18 )
0 VARIABLE 3.5IN                0 VARIABLE 5.25IN
0 VARIABLE SERIALDISK           0 VARIABLE FLS

: 3.5"     3.5IN @ ;            : 5.25"    5.25IN @ ;
: SERIAL   SERIALDISK @ ;       : FILES    FLS    @ ;

: DOSERIAL   SERIALDISK ON   3.5IN OFF  5.25IN OFF  FLS OFF ;

: DO3INCH    SERIALDISK OFF  3.5IN ON   5.25IN OFF  FLS OFF ;

: DO5INCH    SERIALDISK OFF  3.5IN OFF  5.25IN ON   FLS OFF ;

: DOFILES    SERIALDISK OFF  3.5IN OFF  5.25IN OFF  FLS ON  ;
DOFILES

\ Loader file creation screen             (  3  4 90 CRC 19:59 )
-9 +BLK  NEEDED TARGET  EDITOR FLUSH
SERIAL IFTRUE
FILING R-W MKF: REAL4TH.SER
FILING    ORIGIN       DPNEW @ OVER -
B/BUF / 1+ B/BUF *  DUP >R  HANDLE   WTF  R> - 6 .R
CR CLF  LS REAL*.*      IFEND

FILES IFTRUE
FILING R-W MKF: REAL4TH.FLS
FILING    ORIGIN       DPNEW @ OVER -
B/BUF / 1+ B/BUF *  DUP >R  HANDLE   WTF  R> - 6 .R
CR CLF  LS REAL*.*      IFEND

FORTH DEFINITIONS

\ Redo all 4 versions of rF               ( 17  3 88 CRC 20:09 )
DECIMAL         home pwd
\ DOSERIAL      808X     -1 +LOAD

\ DO3INCH       808X    -11 +LOAD

\ DO5INCH       808X    -11 +LOAD

  DOFILES    (  808X  )  -1 +LOAD







\ Rename files as needed                  (  7  4 88 CRC 18:06 )
filing
delete:  rff.anc
delete:  rfd.anc
rename:: rff.old rff.anc
rename:: rfd.old rfd.anc
rename:: rff.com rff.old
rename:: rfd.com rfd.old
rename:: real4th.fls rff.com
rename:: real4th.3in rfd.com






















\ copy to floppy disk                     ( 14 11 91 CRC 14:18 )
base @ decimal
(date)  blk @ block  976 + swap cmove flush     base !
'r/w @ >r
editor flush harddisk           disking disking
opening: 8086x                  \ start: this volume
0                               \ destination
sizeof: 8086x                   \ count
10.ds +harddisk                 \ install the floppy
disking verify cr               \ do it
r> 'r/w !                       \ back to usual disk drivers
base @ decimal
(date)  blk @ block  976 + swap cmove update    base !
blank   ;s

last copied:     2  9 92
\ 68000 addressing setup                  (  3  4 88 CRC 12:27 )
\ FORTH DEFINITIONS FORGET TASK   FORTH DEFINITIONS : TASK ;
BASE @ >R HEX
\ ASSEMBLER DEFINITIONS  BEGIN,  \  address in ar0
\   1 # DR1 MOVQ,  WORKSPACE #L AR0 CMP, GE IF,
\   IMAGETOP #L AR0 CMP,  LT IF,     DR1 CLR,   THEN,  THEN,
\  RTS,  1 ?PAIRS  CONSTANT (?TARGET)
FORTH DEFINITIONS

CODE ><      AX POP,  AH AL XCHG,  1PUSH
\ CODE ><   S [ DR0 MOV,   DR0 DR1 MOV,  8 # DR0 LSL,
\   8 # DR1 LSR,  FF # DR1 .W AND,  DR1 DR0 .W OR,
\   FFFF #L DR0 AND,  DR0 S [ MOV,  NEXT  ;C

R> BASE !  -->

\ 68000 addressing setup                  ( 12  8 88 CRC 16:04 )
\ CODE !  S [+ AR0 MOV,  (?TARGET) *+ BSR,  DR1 TST,
\   EQ IF,  HERE >R  S [+ DR0 MOV,  DR0 AR0 [+ .B MOV,
\   8 # DR0 LSR,  DR0 AR0 [ .B MOV,  NEXT
\   THEN,  ' ! 2+ @#L JMP,        ;c

\ CODE ,  OFUSER DP AR0 MOV,  (?TARGET) *+ BSR,  DR1 TST,
\   EQ IF,  2 # OFUSER DP ADDQ,  R> *+ BRA,
\   THEN,  ' , 4+ @#L JMP,        ;C

: TARGETS ;  \ flag for re-compiles
-->




\ 68000 addressing setup                  ( 21 10 92 CRC 11:12 )
\ CODE !  S [+ AR0 MOV,  (?TARGET) *+ BSR,  DR1 TST,
\  EQ IF,  S [+ DR0 MOV,  DR0 AR0 [+ .B MOV,
\   8 # DR0 LSR,  DR0 AR0 [ .B MOV,  NEXT
\   THEN,  S [+ AR0 [ MOV,  NEXT  ;C

\ CODE @  S [ AR0 MOV,  (?TARGET) *+ BSR,  DR1 TST,
\   EQ IF,  AR0 1 &[ DR1 .B MOV,   8 # DR1 LSL,
\           AR0 [ DR1 .B MOV,  DR1 S [ MOV,  NEXT
\   THEN,  AR0 [ S [ MOV,  NEXT  ;C

: ?TARGET  \ addr -- addr fl | indicates target or resident
  DUP  WORKSPACE IMAGETOP WITHIN ;

: ?INTARGET     ( addr )   ?TARGET   0=
  IF  BELL ABORT"  Outside target area! " THEN ;      -->
\ 68000 addressing setup                  ( 21 10 92 CRC 11:11 )
\ CODE @  S [ AR0 MOV,  (?TARGET) *+ BSR,  DR1 TST,
\   EQ IF,  AR0 1 &[ DR1 .B MOV,   8 # DR1 LSL,
\           AR0 [ DR1 .B MOV,  DR1 S [ MOV,  NEXT
\   THEN,  ' @ 2+ @#L JMP,        ;C

: COMPILE   \ <COMPILE> <COMP>
  -FIND 0= 0 ?ERROR DROP , ;        IMMEDIATE

: T@  FUDGE @ + @  ;

: TC@ FUDGE @ + C@ ;

: ? @ . ;
-->

\ old style dictionary traversing         ( 21 10 92 CRC 12:02 )
\ : TRAV   >R
\   BEGIN R + DUP C@ 80 AND UNTIL  RDROP ;

\ : LFA   ?INTARGET  2- ;
\ : CFA   ?INTARGET  2+ ;
\ : PFA   ?INTARGET  1 TRAVERSE 5 + ;
\ : NFA   ?INTARGET  5 - -1 TRAVERSE ;

1 VARIABLE SPEAK

: VERBOSE       SPEAK ON ;

: LACONIC       SPEAK OFF ;


\ frills: dump & ascii print              ( 30 12 87 CRC 20:31 )
;s base @ hex
: (DUMP) \  addr ct ---  | dump as pointed to by reloc
  SPACE  BOUNDS DO  I tC@ 3 .R  LOOP ;
: U.R 0 SWAP D.R ;        : TAB OUT @ - SPACES ;
: LASCI   \  addr ct ---  | asci type as pointed to by reloc
  SPACE  BOUNDS DO  I tC@  7f AND  DUP
    bl ASCII ~ WITHIN 0= IF DROP ASCII . THEN  EMIT  LOOP ;
: HEAD  \ addr --- | headder for dump display
  10 0 DO I OVER + 0f AND 3 .R LOOP DROP ;
  \ N. B: Not responsible for negative counts! -- the MGT.
: DUMP   \  addr ct ---  | dump as pointed to by reloc
  OVER CR 6 SPACES HEAD  BEGIN  DUP  WHILE  CR OVER 5 U.R
     2DUP 10 MIN >R  R 2DUP (DUMP)  36 TAB LASCI
     R R> MINUS D+  ?TERMINAL IF DROP 0 THEN  REPEAT 2DROP ;
base !
















































































































\ Load Screen for 8086 assembler          (  6 12 87 CRC 21:55 )
FORTH DEFINITIONS  \ FORGET TASK  : TASK ;
BASE @ >R DECIMAL
EDITOR   FLUSH  FORTH
VOCABULARY ASSEMBLER   IMMEDIATE
1 17 +THRU

FORTH DEFINITIONS



R> BASE !  EDITOR FLUSH




\ pick & roll in code 68000               ( 13  2 89 CRC 16:42 )
;s  BASE @ HEX  >R
CODE PICK   S [ DR0 MOV,  ( PL IF,)  2 # DR0 ASL,
            0 S 0 &D[ S [ MOV,  ( THEN,)  NEXT ;C
CODE -ROT  S 4 &[ DR0 MOV,  S 8 &[ S 4 &[ MOV,
  S [ S 8 &[ MOV,  DR0 S [ MOV,  NEXT   ;c
R> BASE !      ;s
CODE ROLL   S [ DR0 MOV,  DR0 DR1 MOV,  1 # DR1 SUBQ,
  PL IF,  2 # DR0 ASL,  S DR0 ADD,  DR0 AR0 MOV,  AR0 [ S [ MOV,
  AR0 4 &[ AR1 LEA,  FALSE DR1 DO,  AR0 -[ AR1 -[ MOV,  LOOP,
      AR1 S MOV,  ELSE,  4 # S ADDQ,  THEN,  NEXT ;C
CODE 4DUP  4 1- # DR0 MOVQ,
  FALSE DR0 DO,  S 0C &[ S -[ MOV,  LOOP,  NEXT ;C
CODE TUCK  S [+ AR0 MOV,  S [ S -[ MOV,  AR0 S -[ MOV,  NEXT ;C
R> BASE !

\ 8086 Assembler                          (  6 12 87 CRC 21:59 )
;S
The 8086 Assembler was written by Mike Perry.
To create an assembler language definition, use the defining
word CODE.  It must be terminated with either END-CODE or
its synonym C;.  How the assembler operates is a very
interesting example of the power of CREATE DOES>   Basically
the instructions are categorized and a defining word is
created for each category.  When the nmemonic for the
instruction is interpreted, it compiles itself.

Reworked and modified to run on real-FORTH by Charles Curley,
at the usual address, https://charlescurley.com



\ 8086 Assembler                                      06Apr84map
\ : LABEL  CREATE  [COMPILE] ASSEMBLER   ;
232 CONSTANT DOES-OP
3 CONSTANT DOES-SIZE
: DOES?   ( IP -- IP' F )
   DUP DOES-SIZE + SWAP C@ DOES-OP =  ;
ASSEMBLER DEFINITIONS
\ : C;   ( -- )   END-CODE   ;

: =  = IF -1 ELSE 0 THEN ;    \ due to improper use of flags as
: <  < IF -1 ELSE 0 THEN ;    \ masks in assembler. Tch, tch.
: 0<>  IF -1 ELSE 0 THEN ;
: 0=   IF 0 ELSE -1 THEN ;
: NOT  0= ;
: ON   -1 SWAP ! ;
OCTAL
\ 8086 Assembler   Register Definitions               11OCT83HHL
: REG    11 * SWAP 1000 * OR CONSTANT   ;
: REGS   ( MODE N -- )   SWAP 0 DO  DUP I REG  LOOP  DROP ;

10 0 REGS   AL  CL  DL  BL  AH  CH  DH  BH
10 1 REGS   AX  CX  DX  BX  SP  BP  SI  DI
10 2 REGS   [BX+SI] [BX+DI] [BP+SI] [BP+DI] [SI] [DI] [BP] [BX]
 4 2 REGS   [SI+BX] [DI+BX] [SI+BP] [DI+BP]
 4 3 REGS   ES  CS  SS  DS
 3 4 REGS   #   #)  S#)

: create  create smudge ;
BP CONSTANT RP   [BP] CONSTANT [RP]   ( RETURN STACK POINTER )
SI CONSTANT IP   [SI] CONSTANT [IP]   ( INTERPRETER POINTER )
BX CONSTANT W    [BX] CONSTANT [W]   ;S WORKING REGISTER )
also: sp is data stack, and beware of seg registers
\ Addressing Modes                        ( 22 12 25 CRC 19:58 )
: MD  CREATE 1000 * ,  DOES> @ SWAP 7000 AND = 0<>  ;
0 MD R8?   1 MD R16?   2 MD MEM?   3 MD SEG?   4 MD #?
: REG?   ( n -- f )   7000 AND 2000 < 0<> ;
: BIG?   ( n -- f )   ABS -200 AND 0<>  ;
: RLOW   ( n1 -- n2 )    7 AND ;
: RMID   ( n1 -- n2 )   70 AND ;
0 VARIABLE SIZE   SIZE ON
: .B     ( -- )   SIZE OFF ;
: OP,   ( n op -- )   OR C,  ;
: W,   ( op mr -- )   R16? 1 AND OP,  ;
: SIZE,   ( OP -- OP' )   SIZE @ 1 AND OP,  ;
: ,/C,  ( n f -- )   IF  ,  ELSE  C,  THEN  ;
: RR,   ( mr1 mr2 -- )   RMID SWAP RLOW OR 300 OP,  ;
0 VARIABLE LOGICAL
: B/L?   ( n -- f )   BIG? LOGICAL @ OR  ;
\ Addressing                                          16Oct83map
: MEM,   ( DISP MR RMID -- )   OVER #) =
   IF  RMID 6 OP, DROP ,
   ELSE  RMID OVER RLOW OR ROT ROT [BP] = OVER 0= AND
   IF  SWAP 100 OP, C,  ELSE  SWAP OVER BIG?
   IF  200 OP, ,  ELSE  OVER 0=
   IF  C, DROP  ELSE  100 OP, C,
   THEN THEN THEN THEN  ;
: WMEM,   ( DISP MEM REG OP -- )   OVER W, MEM,  ;
: R/M,   ( MR REG -- )
   OVER REG? IF  RR,  ELSE  MEM,  THEN  ;
: WR/SM,   ( R/M R OP -- )   3 PICK DUP REG?
   IF  W, RR,  ELSE  DROP SIZE, MEM,  THEN  SIZE ON  ;
0 VARIABLE INTER
: FAR    ( -- )   INTER ON  ;
: ?FAR   ( n1 -- n2 )   INTER @ IF  10 OR  THEN  INTER OFF ;
\ Defining Words to Generate Op Codes     ( 11 12 87 CRC 21:13 )
: 1MI  CREATE C,  DOES>  C@ C,  ;
: 2MI  CREATE C,  DOES>  C@ C,  12 C,  ;
: 3MI  CREATE C,  DOES>  C@ C,  DELTA +  HERE - 1-
 DUP -200 177 WITHIN 0= IF ABORT" Branch out of Range" THEN C, ;
 : 4MI  CREATE C,  DOES>  C@ C,  MEM,  ;
: 5MI  CREATE C,  DOES>  C@ SIZE,  SIZE ON ;
: 6MI  CREATE C,  DOES>  C@ SWAP W,  ;
: 7MI  CREATE C,  DOES>  C@ 366 WR/SM, ;
: 8MI  CREATE C,  DOES>  C@ SWAP R16? 1 AND OR  SWAP # =
   IF  C, C,  ELSE  10 OR  C,  THEN  ;
: 9MI  CREATE C,  DOES>  C@  OVER R16?
   IF  100 OR SWAP RLOW OP,  ELSE  376 WR/SM,  THEN  ;
: 10MI CREATE C,  DOES>  C@ OVER CL =
   IF  NIP 322  ELSE  320  THEN  WR/SM,  ;

\ Defining Words to Generate Op Codes                 15MAY84HHL
: 11MI  CREATE C, C,  DOES>  OVER #) =
   IF  NIP C@ INTER @
     IF  1 AND IF  352  ELSE  232  THEN  C,  SWAP , ,  INTER OFF
     ELSE  SWAP HERE - 2- SWAP  2DUP 1 AND SWAP BIG? 0= AND
       IF  2 OP, C,  ELSE  C,  1- ,  THEN  THEN
   ELSE  OVER S#) = IF  NIP #) SWAP  THEN
     377 C, 1+ C@ ?FAR  R/M,  THEN  ;
: 12MI  CREATE C, C, C,  DOES>  OVER REG?
   IF  C@ SWAP RLOW OP,  ELSE  1+ OVER SEG?
     IF  C@ RLOW SWAP RMID OP,
     ELSE  COUNT SWAP C@ C,  MEM,
   THEN THEN  ;
: 14MI  CREATE C,  DOES> C@
   DUP ?FAR C,  1 AND 0= IF  ,  THEN ;

\ Defining Words to Generate Op Codes                 09Apr87TJZ
: 13MI  CREATE C, C,  DOES>  COUNT >R C@ LOGICAL !  DUP REG?
   IF  OVER REG?
     IF  R> OVER W, SWAP RR,  ELSE  OVER DUP MEM? SWAP #) = OR
     IF  R> 2 OR WMEM,  ELSE  ( # ) NIP  DUP RLOW 0= ( ACC? )
     IF  R> 4 OR OVER W, R16? ,/C,
     ELSE  OVER B/L? OVER R16? 2DUP AND
       -ROT 1 AND SWAP NOT 2 AND OR 200 OP,
       SWAP RLOW 300 OR R> OP,  ,/C,
     THEN  THEN  THEN
   ELSE  ( MEM )  ROT DUP REG?
     IF  R> WMEM,
     ELSE  ( # ) DROP  3 PICK B/L? DUP NOT 2 AND 200 OR SIZE,
       -ROT R> MEM,  SIZE @ AND ,/C,  SIZE ON
   THEN  THEN  ;

\ Instructions                                        14MAY84RKG
: TEST,  ( source dest -- )   DUP REG?
   IF  OVER REG?
     IF  204 OVER W, SWAP RR,  ELSE  OVER DUP MEM? SWAP #) = OR
     IF  204 WMEM,  ELSE  ( # ) NIP  DUP RLOW 0= ( ACC? )
     IF  250 OVER W,
     ELSE  366 OVER W,  DUP RLOW 300 OP,
     THEN   R16? ,/C,  THEN  THEN
   ELSE  ( MEM )  ROT DUP REG?
     IF  204 WMEM,
     ELSE  ( # ) DROP  366 SIZE,  0 MEM,  SIZE @ ,/C,  SIZE ON
   THEN  THEN  ;




\ Instructions                                        16Oct83map
HEX
: ESC,  ( source ext-opcode -- )   RLOW 0D8 OP, R/M,  ;
: INT,  ( N -- )   0CD C,  C,  ;
: SEG   ( SEG -- )   RMID 26 OP,  ;

: CS:   CS SEG ;
: DS:   DS SEG ;
: ES:   ES SEG ;
: SS:   SS SEG ;

: XCHG,  ( MR1 MR2 -- )   DUP REG?
   IF  DUP AX =
     IF  DROP RLOW 90 OP,  ELSE  OVER AX =
     IF  NIP  RLOW 90 OP,  ELSE  86 WR/SM,  THEN  THEN
   ELSE  ROT 86 WR/SM,  THEN  ;
\ Instructions                                        18APR83HHL
: MOV,  ( S D -- )   DUP SEG?
   IF  8E C, R/M,  ELSE  DUP REG?
     IF  OVER #) = OVER RLOW 0= AND
       IF  A0 SWAP W,   DROP   ,  ELSE  OVER SEG?
       IF  SWAP 8C C, RR,  ELSE  OVER # =
       IF  NIP DUP R16? SWAP RLOW OVER 8 AND OR B0 OP, ,/C,
       ELSE  8A OVER W, R/M,  THEN THEN THEN
     ELSE  ( MEM ) ROT DUP SEG?
       IF  8C C, MEM,  ELSE  DUP # =
       IF  DROP C6 SIZE, 0 MEM,  SIZE @ ,/C,
       ELSE  OVER #) = OVER RLOW 0= AND
       IF  A2 SWAP W,  DROP   ,   ELSE  88 OVER W, R/M,
   THEN THEN THEN THEN THEN   SIZE ON  ;


\ Instructions                                        12Mar87TJZ
 37  1MI AAA,    D5  2MI AAD,    D4  2MI AAM,    3F  1MI AAS,
0 10 13MI ADC, 0 00 13MI ADD,  2 20 13MI AND, 10 E8 11MI CALL,
 98  1MI CBW,    F8  1MI CLC,    FC  1MI CLD,    FA  1MI CLI,
 F5  1MI CMC,  0 38 13MI CMP,    A6  5MI CMPS,   99  1MI CWD,
 27  1MI DAA,    2F  1MI DAS,    08  9MI DEC,    30  7MI DIV,
       ( esc )   F4  1MI HLT,    38  7MI IDIV,   28  7MI IMUL,
 E4  8MI IN,     00  9MI INC,          ( int )  0CE  1MI INTO,
0CF  1MI IRET,   77  3MI JA,     73  3MI JAE,    72  3MI JB,
 76  3MI JBE,    E3  3MI JCXZ,   74  3MI JE,     7F  3MI JG,
 7D  3MI JGE,    7C  3MI JL,     7E  3MI JLE, 20 E9 11MI JMP,
 75  3MI JNE,    71  3MI JNO,    79  3MI JNS,    70  3MI JO,
 7A  3MI JPE,    7B  3MI JPO,    78  3MI JS,     9F  1MI LAHF,
 C5  4MI LDS,    8D  4MI LEA,    C4  4MI LES,    F0  1MI LOCK,
0AC  6MI LODS,   E2  3MI LOOP,   E1  3MI LOOPE,  E0  3MI LOOPNE,

\ Instructions                                        12Apr84map
       ( mov )   0A4  5MI MOVS,   20  7MI MUL,    18  7MI NEG,
 90  1MI NOP,     10  7MI NOT,  2 08 13MI OR,     E6  8MI OUT,
            8F 07 58 12MI POP,    9D  1MI POPF,
           0FF 36 50 12MI PUSH,   9C  1MI PUSHF,
 10 10MI RCL,     18 10MI RCR,
 F2  1MI REP,     F2  1MI REPNZ,  F3  1MI REPZ,
 C3 14MI RET,     00 10MI ROL,     8 10MI ROR,    9E  1MI SAHF,
 38 10MI SAR,   0 18 13MI SBB,   0AE  5MI SCAS,         ( seg )
 20 10MI SHL,     28 10MI SHR,    F9  1MI STC,    FD  1MI STD,
 FB  1MI STI,    0AA  6MI STOS, 0 28 13MI SUB,          ( test )
 9B  1MI WAIT,          ( xchg )  D7  1MI XLAT, 2 30 13MI XOR,
 C2 14MI +RET,

: BRSIZE   -200 177 WITHIN 0= 5 ?ERROR  ;

\ Structured Conditionals                 ( 10 12 87 CRC 22:23 )
HEX                             109 VARIABLE >>NEXT
75 CONSTANT 0=   74 CONSTANT 0<>   79 CONSTANT 0<
78 CONSTANT 0>=  7D CONSTANT <     7C CONSTANT >=
7F CONSTANT <=   7E CONSTANT >     73 CONSTANT U<
72 CONSTANT U>=  77 CONSTANT U<=   76 CONSTANT U>
71 CONSTANT OV   E3 CONSTANT CX<>0

\ : NEXT    >>NEXT @     #) JMP,  ;
\ : 1PUSH   >>NEXT @ 1-  #) JMP,  ;
\ : 2PUSH   >>NEXT @ 2-  #) JMP,  ;
\ : 3PUSH   >>NEXT @ 3 - #) JMP,  ;
: DO,   HERE  3 ;
: LP   CREATE C,  DOES>  C@ C,  3 ?PAIRS  HERE - 1-
  DUP BRSIZE  C, ;
E2  LP LOOP,    E1  LP LOOPE,   E0  LP LOOPNE,
\ Structured Conditionals                 ( 29 12 87 CRC 21:19 )
: UNTIL,  \ dest.adr 1 br.opcode --
   SWAP 1 ?PAIRS   C,  HERE 1+ - C, ;
: IF,     \ br.opcode -- adr.next.instr 2  | reserve space
   C, 0 C, HERE 2 ;
: ENDIF,  \ adr.instr.after.br 2 -- | patch the forward ref.
   2 ?PAIRS   HERE OVER -  SWAP 1- C! ;
: ELSE,   \ adr.after.br 2 -- adr.after.this.br 2
   2 ?PAIRS   HERE 2+ #) JMP,  HERE SWAP  2 ENDIF, 2 ;
: BEGIN,   HERE 1 ;     \ -- dest.adr 1
: WHILE,  \ dest.adr 1 br.opcode -- adr.after.this 2 dest.adr 1
   IF, 2SWAP ;
: again,   eb until, ;
: REPEAT, \ adr.after.while 2 dest.adr.of.begin 1 --
  again,   ENDIF, ;                     DECIMAL
: THEN,  ENDIF, ;   : END,  UNTIL, ;
































































































































































\ assembler extensions for target compiler( 23 12 19 crc 18:17 )
\ extend the native assembler to save space in memory.
assembler definitions
>next variable >>next   \ initialize to native, patch later

: nextmacro  <builds c,  does>
  c@ >r  >>next @ r -  here  r> 5 + dup allot cmove ;

  0 nextmacro next              1 nextmacro 1push
  2 nextmacro 2push             3 nextmacro 3push

\ : #)  delta - #) ;
forth definitions   ;s



\ Hex word dump                           (  6  2 87 CRC 12:59 )
BASE @ HEX
: TC@  FUDGE @ + C@  ;          : T@  FUDGE @ + @ ;
: (WDUMP) \  from-address-2 cnt-1  ---  | memory displayed
  BOUNDS DO I T@ 0 7 D.R 2 +LOOP ;
\ : HEAD   CR 6 SPACES 0F AND 10 0  \ start  ---  | header
\    DO DUP I + BASE @ 1- AND 3 .R LOOP
\    DROP ."  <<    ASCII   >>" ;
\ : ASCI   OVER +  SWAP   ( from-addr cnt ASCII)
\   DO I TC@ 7F AND  DUP ASCI ~ > IF.  DUP BL < IF. EMIT LOOP ;
: WDUMP  OVER  DUP WHEAD \ from-addr  count ---  | dump
   + SWAP   DO CR I 0 6 D.R I 10 2DUP (WDUMP) SPACE
   ASCI   I  F0 AND F0 = IF I WHEAD THEN
   ?TERMINAL  IF LEAVE  THEN  10 +LOOP CR ;
: DUMP WDUMP ;
 BASE !  FORTH  ."  Word hexdump loaded." CR  ;S
\ 808x       target compiler: load        ( 24 12 87 CRC 10:28 )
EDITOR FLUSH   CR pTODAY CR CR   DECIMAL         WARNING ON
FORTH DEFINITIONS  FORGET TASK
1 +BLK NEEDED COMPILE-ADDR
-42 +BLK NEEDED TARGETS       181 +BLK NEEDED EXIT
( ' WDUMP  ' COMPILE-ADDR < IFTRUE  -1 +LOAD IFEND  )
-2 ( 9) +load   ( asm )         : TASK ;  2 +BLK NEEDED TIBX
: RLOAD DUP BLOCK @ IF  SPEAK @ IF  DUP CR   7 .R SPACE  THEN
      LOAD SPEAK @ IF .S THEN  ELSE DROP THEN ;
: RTHRU  1+ SWAP DO I RLOAD LOOP ;
HEX HERE FIRST OVER - ERASE DECIMAL
0 CONSTANT CPZ                  CPZ 0= CONSTANT CM
  3 +BLK 25 +BLK RTHRU
CR  FORTH DEFINITIONS   pTODAY    ;S
load  25+ & 26+ after  ;s ,  (loop) ,  (+loop) ,  branch  and
0Branch  have been defined in the target memory
\ Target compiler: set fundamentals       ( 12  8 88 CRC 16:00 )
BASE @ HEX                       FORTH  DEFINITIONS
    0 VARIABLE COMPILE-ADDR  \ work-space
COMPILE-ADDR 2100 DUP 2- ALLOT  ERASE \ 8 k. + padding for file
HERE  CONSTANT IMAGETOP
( compile-addr )    0   CONSTANT BASE-ADDR     \ origin --
COMPILE-ADDR CONSTANT WORKSPACE
COMPILE-ADDR BASE-ADDR - CONSTANT DELTA
                                  DELTA FUDGE !
10000 CONSTANT TM             400 CONSTANT   *B/BUF*
     8   *B/BUF*    4     +  *    CONSTANT CO
\ count  b/buf   overhead +  * == count of buffer space
0 VARIABLE 'ORIGIN              : ORIGIN 'ORIGIN @ ;
                              180 CONSTANT US   BASE ! ;S
( compile-addr ) 9000   CONSTANT BASE-ADDR     \ origin --
 D000 CONSTANT TM             400 CONSTANT   *B/BUF*
\ Target compiler: target memory          ( 16 12 87 CRC 22:55 )
BASE @ HEX   \ note the  non-standard memory map!
\ TM   2-  DELTA -    CONSTANT UP
TM  40  -           CONSTANT TOS
TM 1A0  -           CONSTANT BOT
TM 210  -           CONSTANT RTS
TM 400  -           CONSTANT TIBX
TIBX                CONSTANT EM

FORTH DEFINITIONS    BASE  !

0 VARIABLE CHOPLINE   0 , 0 ,

: SETORG    HERE 'ORIGIN ! ;


\ code for floating user pointer          ( 21 10 92 CRC 11:33 )
0 VARIABLE UPARRAY  BL 2- ALLOT   UPARRAY BL ERASE
UPARRAY VARIABLE UDP

: UP,     UDP @ !  2 UDP +! ;
assembler definitions
: UP   HERE DELTA - 2+ UP,  [ TM 2- ] LITERAL ;
forth definitions
: GETUPS   assembler  \ install up addresses in dict.
  UPARRAY  HERE  UDP @ 2+  UPARRAY - DUP ALLOT  CMOVE ;
forth
: MUTATES  [COMPILE] '  DUP  cfa @
  [ ' CHOPLINE cfa @ ] LITERAL
  - IF BELL ABORT" Can't mutate anything but a variable!" THEN
  ! ;

\ Target compiler: compiler addrs         ( 21 10 92 CRC 11:35 )
FORTH  DEFINITIONS
 0 VARIABLE *(.")*               0 VARIABLE *USER*
 0 VARIABLE *DOES>*              0 VARIABLE *COLON*
 0 VARIABLE *(;CODE)*            0 VARIABLE *CONSTANT*
 0 VARIABLE *VARIABLE*           0 VARIABLE *VOCAB*
( 0 VARIABLE *USERCONSTANT* )    0 VARIABLE *;S*
 0 VARIABLE *ABORT*              0 VARIABLE *QUIT*
 0 VARIABLE *@EXEC*
 0 VARIABLE *(LOOP)*             0 VARIABLE *(+LOOP)*
 0 VARIABLE *BRAN*               0 VARIABLE *0BRAN*

 0 VARIABLE *LIT*                0 VARIABLE *CLIT*



\ Target compiler: newforth                 29 09 84 CRC
VOCABULARY NEWFORTH IMMEDIATE        BASE @  HEX
: OF/NF [COMPILE] NEWFORTH DEFINITIONS [COMPILE] FORTH ;
 0 VARIABLE DPOLD   COMPILE-ADDR VARIABLE DPNEW
 0 VARIABLE O/N    \ old/new:  t=new, false=old
  1F  ( 0) VARIABLE TWIDTH   \ target width. 0 = headerless
  1F  ( 0) VARIABLE WID      \ width for a word. use | to make
                             \ an ophan out of it.
: SETOLD   O/N @   IF 0 O/N ! HERE DPNEW !
  DPOLD @ DP ! ( OF*LIT* @ *LIT* !   )
               ( OF*CLIT* @ *CLIT* ! ) THEN ;
: SETNEW   O/N @ 0= IF 1 O/N ! HERE DPOLD !
  DPNEW @ DP ! ( NF*LIT* @ *LIT* !   )
               ( NF*CLIT* @ *CLIT* ! ) THEN ;
DELTA  VARIABLE LAST   \ addr of top of new dictionary
BASE !  ;S
\ Target compiler: ?0s                    ( 12  8 88 CRC 16:09 )
 \ Help detect unresolved forward references --- most useful!
: ?0S  BASE @ HEX CR 15 [ BLK @ ] LITERAL  .LINE
       80 OUT !  DPNEW @ ORIGIN  DO
     I @  0= IF  ?CR  I DELTA - 5 .R  2  ELSE  1  THEN
     ?TERMINAL IF LEAVE THEN  +LOOP BASE ! ;   BASE @ HEX
: TID. PAD BL ASCII _ FILL DUP PFA LFA OVER - \ res.addr
     PAD SWAP CMOVE PAD COUNT 1F AND  2DUP  BOUNDS
     DO I C@ 7F AND I C! LOOP        TYPE SPACE ; BASE !
: THERE  DPNEW @  DELTA - ;
: .HERE  THERE 13 [ BLK @ ] LITERAL .LINE  7 .R ;
: SIZE  DPNEW @  ORIGIN - ;
: .SIZE  SIZE 14 [ BLK @ ] LITERAL  .LINE 7 .R ; ;S
       target here =
       target size =
       Addresses of words containing 0 in them:
\ Target compiler: /smudged               ( 16  2 87 CRC 18:30 )
BASE @ HEX  0 VARIABLE <IMMED> 70 ALLOT  \ st size. Could be 38?
<IMMED> HERE OVER - ERASE       <IMMED> 2+ <IMMED> !
: /SMUDGE <IMMED> @ <IMMED> 2+ 2DUP - IF
  DO I @ BL TOGGLE 2 +LOOP ELSE 2DROP THEN ;
: NFFIND BL WORD HERE DUP COUNT UPPER
  [ ' NEWFORTH  2+ ] LITERAL  @ (FIND) ;
: 'NF  /SMUDGE  NFFIND DUP
   IF SWAP DROP THEN      /SMUDGE 0=
   IF HERE COUNT TYPE SPACE  ." NF? "  0 ERROR THEN ;
: REPLACED:BY     'NF 2- @ SWAP ! ;
: BYTE:IN         'NF 2- @ DELTA + 2+ + ;
: [FROM:NEWFORTH] 'NF 2- @ , ;  IMMEDIATE
: NFSEE:   'NF nfa 2- @ WHERETHEN  R# ! EDIT ;
: NFDUMP   BASE @ HEX  >R DELTA FUDGE !  'NF 2- @ DUP  6 U.R
  10 - -10 AND C/L ( 2DUP)  DUMP ( WDUMP) R> BASE ! ;  BASE !
\ Target compiler: nfcompile              ( 23 10 92 CRC 19:55 )
: <NFCOMPILE>   ?COMP R> DUP 2+ >R  @  , ;

: NFCOMPILE   [ ' <NFCOMPILE> cfa ] LITERAL ,
  'NF 2- @    ,  ;      IMMEDIATE

: NFDIS:   DELTA FUDGE !  'NF 2- @ T@ DISASSEM ;

: NFLIST        \ --  | vlist of newforth
  [ ' NEWFORTH  2+ ] LITERAL  @ (VLST) ;

\ DECIMAL  126 +BLK RLOAD   \ xref load -- not ported to ff yet




\ Target compiler: create-old             ( 14  2 92 CRC 16:47 )
BASE @ HEX
: CREATE-OLD SETOLD FIRST ( TAREA ) PAD - 0< 2 ?ERROR 0 , \ see:
  [COMPILE] NEWFORTH DEFINITIONS
  BL WORD HERE DUP  DUP C@ WIDTH @ MIN 1+ ALLOT \ name
  SPEAK @ IF  DUP COUNT TYPE SPACE  THEN
  80 TOGGLE HERE 1- 80 TOGGLE           \ traverse bits
  LATEST ,  CURRENT @ !         \ update links
  WHERENOW  latest 2- ! ;       \ installs scr & line #s

BASE !





\ Target compiler: create-new             ( 11 12 87 CRC 21:02 )
BASE @ HEX
: CREATE-NEW SETNEW
  SPEAK @  IF  OUT @ 32 > IF CR 6 SPACES THEN  THEN
  IMAGETOP DPNEW @ [ PAD HERE - C/L + ] LITERAL - - 0< 2 ?ERROR
  ( ?-BUF)  WID  @ IF
  BL WORD HERE DUP C@ TWIDTH @ 1F AND MIN 1+ ALLOT
  DUP 80 TOGGLE HERE 1- 80 TOGGLE
  LAST  @ DELTA - , LAST ! THEN
  SPEAK @ IF  BASE  @ HEX HERE DELTA - 5 U.R
      BASE ! SPACE  THEN
  TWIDTH  @ WID ! ;   BASE !




\ boot parameter area access              ( 20  2 89 CRC 10:07 )
0 VARIABLE BOOTS   \ points to base addr: 0 +origin

: +BOOTS   BOOTS @ + DELTA - ;

CODE CHKSM \ addr ct --  |  return byte checksum value
  cx pop,  bx pop,  ax ax sub,  ax dx mov,  1 # dx sub,
  do,  0 [bx] al add,  bx inc,  loop,
  dx ax xor,  1 # ax add,  dx ax and,  1push

: CHECKSUM    \  --  | perform checksum on image, add it in
  ORIGIN  DPNEW @  OVER - 2DUP  CHKSM
  DPNEW @ C!  DPNEW 1+!  1+ CHKSM ." Checksum is: " . ;



\ initialises: easier setup for the colds ( 12  8 88 CRC 16:16 )
    \  send kim paper tape format
\ : SEND  BASE @ HEX  BASE-ADDR DPNEW @ DELTA - OVER - LINES
\   ( LASTLINE for atari stuff ) BASE ! CTL G (EMIT) ;
: INITIALISES  'NF 2- @ DELTA + DUP @ *USER* @ -
    IF ." Invalid user name " 0 ERROR  THEN
    2+ @ ( 11/68k version ) 12 +BOOTS DELTA + + ! ;
;S syntax:  val-1  INITIALISES  username
where  val  is some value, and username is the user variable
it will initialise.
Typical uses:
'NF (EMIT) 2-           INITIALISES 'EMIT
EM US - CO -            INITIALISES 'FIRST

    2+ @ ( 11/68k version ) 12 + COMPILE-ADDR + ! ;

\ Target compiler: nf: nf; ascii txt      ( 14  5 86 CRC 12:25 )
: NF: !CSP CREATE-OLD SMUDGE    [ ' hold cfa @ ] literal , \ cfa
  IMMEDIATE [COMPILE] FORTH ] ;

: NF; [COMPILE] ; ;       IMMEDIATE

: TXT ASCII " WORD  HERE C@ 1+ ALLOT ( ?-BUF)  ;
   IMMEDIATE

: |  ?CR  WID OFF SPEAK @ IF  ."  <orphan>" THEN ;

: MF  CR ?dict  BASE @ HEX
  IMAGETOP DPNEW @ - . ." Target bytes left. " BASE ! ;

: OFDUMP   BASE  @ HEX   >R FUDGE OFF [COMPILE] ' DUP
   6 U.R  16 - -16 AND C/L DUMP R> BASE ! ;
\ Target compiler: literal -- immediate   ( 20 12 25 CRC 22:09 )
BASE @ HEX
: LITERAL
  HERE ?TARGET NIP 0= IF  [COMPILE] LITERAL ELSE
  STATE @ IF  DUP -80 7F WITHIN
  IF *CLIT* @ , C,  ELSE  *LIT* @ , , THEN THEN THEN ;
        IMMEDIATE

: DLITERAL  STATE @ IF SWAP [COMPILE] LITERAL
        [COMPILE] LITERAL  THEN ;                     IMMEDIATE

: IMMEDIATE LAST @ C/L TOGGLE LATEST
        <IMMED> @ ! 2 <IMMED> +! SMUDGE ;
BASE ! ;S
Warning: There is no bounds checking for the <immed> array!!!

\ Target compiler: interpreter            ( 20 12 25 CRC 22:09 )
: INTERPRET   BEGIN -FIND  IF ( fudge @ fudge off  here count
  type  fudge !  space  )      ( found) STATE @ <
  IF  O/N @  IF  ( new ) 2- @  else  2-  THEN ,
    ELSE  2- EXECUTE  THEN
  ELSE  HERE NUMBER DPL @ 1+
    IF [COMPILE] DLITERAL ELSE  DROP [COMPILE] LITERAL
  THEN THEN
\ ?TERMINAL IF IN @ R# ! BLK @ SCR ! ABORT THEN
  AGAIN ;

: V   IN @ NFDUMP IN ! OFDUMP ;
                               1 CONSTANT 1
    2 CONSTANT 2               3 CONSTANT 3
    4 CONSTANT 4               5 CONSTANT 5     ;s
  IF  O/N @  IF  ( new ) 2- @  THEN 2- ,
\ Target compiler: quit -- label          ( 13  5 86 CRC 14:51 )
: NFQUIT BLK OFF [COMPILE] [
  BEGIN BEGIN RP! CR QUERY INTERPRET OK STATE @ 0= UNTIL
     .S ." NK"       AGAIN STOP
: LOAD  DUP BLOCK  @ IF  BASE @ >R
  SPEAK @  IF DUP DECIMAL CR 5 U.R SPACE THEN  HEX
  BLK 2@ >R >R  C/L IN ! BLK ! INTERPRET
  R> R> BLK 2! SPEAK @ IF  ?CR 3 SPACES HEX .S  THEN
  R> BASE !  ELSE DROP THEN ;
: THRU  1+ SWAP DO I LOAD LOOP ;
: CFA 2- @ ;
: ==       ?EXEC SETOLD CURRENT @ >R
  [COMPILE] ASSEMBLER DEFINITIONS CONSTANT
  R> CURRENT ! [COMPILE] FORTH SETNEW ;
: LABEL SETOLD DPNEW @ DELTA - ==
  [COMPILE] ASSEMBLER ;
\ Target compiler: code -- variable       ( 14  5 86 CRC 11:05 )
BASE  @ HEX
: CODE  !CSP IN @ ?EXEC CREATE-NEW
  IN ! HERE DELTA - CREATE-OLD , SMUDGE SETNEW
  HERE DELTA - 2+ ,  [COMPILE] ASSEMBLER ;

: CONSTANT IN @ CREATE-NEW
    IN ! HERE DELTA - *CONSTANT* @ , SWAP   ,
    CREATE-OLD , SETNEW [COMPILE] FORTH ;

: VARIABLE IN @ CREATE-NEW
    IN ! HERE DELTA - *VARIABLE* @ , SWAP   ,
    CREATE-OLD , SETNEW [COMPILE] FORTH ;
 BASE  !   ;S


\ assembler extensions for target compiler( 14  8 88 CRC  8:40 )
ASSEMBLER DEFINITIONS  BASE @ HEX
\ : NEXT    >>NEXT @      HERE  5 DUP ALLOT  CMOVE ;
\ : 1PUSH   >>NEXT @ 1-   HERE  6 DUP ALLOT  CMOVE ;
\ : 2PUSH   >>NEXT @ 2-   HERE  7 DUP ALLOT  CMOVE ;
\ : 3PUSH   >>NEXT @ 3 -  HERE  8 DUP ALLOT  CMOVE ;

: T#)  #) ;                     : #)  DELTA + #) ;
: OFUSER   'NF 2- @  2+ T@  [BX] ;
: ;C ?EXEC ?CSP SMUDGE [COMPILE] FORTH ;
: END-CODE  ;C ;                     : C;  ;C ;
BASE ! FORTH DEFINITIONS

: +LOAD  +BLK  LOAD ;

: +THRU  1+ +BLK SWAP +BLK  DO I ( + )  LOAD LOOP ;
\ Target compiler: vocabulary -- user  68K( 13  5 86 CRC 14:56 )
BASE  @ HEX
\ : VOCABULARY IN @ CREATE-NEW
\     IN ! HERE DELTA - ( *DOES>* , )  *VOCAB* ,  A081 W,
\     LAST @ DELTA - , 0 ,    \ new does>   !!
\     CREATE-OLD , SETNEW [COMPILE] FORTH ;

: USER     IN @ CREATE-NEW
    IN ! HERE DELTA - *USER* @  , SWAP  , \ words for 11!!
    CREATE-OLD , SETNEW [COMPILE] FORTH ;   \ offset is 16 bit

\ : COMPILE   ?COMP R> DUP 2+ >R @ , ;  \ n.b. target only!
BASE !   ;S
    IN ! HERE DELTA - ( *DOES>* @ , )  *VOCAB* ,  A081 ,


\ chop target compiler                    ( 29 12 87 CRC 20:52 )
: GOLDEN  \ -- | saves data to chop xcompiler
  [ ' NEWFORTH   2+ ] LITERAL @ CHOPLINE    !
  [ ' ASSEMBLER  2+ ] LITERAL @ CHOPLINE 2+ !
  HERE                          CHOPLINE 4+ ! ;

: CHOP   [COMPILE] FORTH DEFINITIONS   EDITOR FLUSH  FORTH
  UPARRAY DUP UDP !  BL ERASE
  CHOPLINE 4+ @ DP !  DELTA FUDGE !
  WORKSPACE IMAGETOP OVER - ERASE
  SETNEW  COMPILE-ADDR DP !  SETOLD SETNEW  DELTA LAST !
  <IMMED> 2+ <IMMED> !
  CHOPLINE    @ [ ' NEWFORTH  2+ ] LITERAL !
  CHOPLINE 2+ @ [ ' ASSEMBLER 2+ ] LITERAL !  ;       ;S
WARNING:  no additions to any voc save  NEWFORTH  and  ASSEMBLER
after  GOLDEN  is invoked!!!!!!!!!!!!!!!
\ Target compiler: who                    ( 19 12 87 CRC 17:13 )
: WHO DELTA + 2+ NFA ID. ;














\ Target compiler: : of/nf                ( 11 12 87 CRC 22:03 )
BASE @ HEX
: :   !CSP IN  @ ?EXEC CREATE-NEW
    IN ! HERE DELTA - *COLON* @ ,
    CREATE-OLD  ,  SMUDGE  SETNEW ] ;

NF: OF/NF [COMPILE] NEWFORTH DEFINITIONS [COMPILE] FORTH  NF;


\ ' NFQUIT 4- ' 'NF 40 + !
LATEST pfa lfa OFF      \ break linkage.
 BASE  !




\ Target compiler: nf: x -- [compile]     ( 11  7 86 CRC 11:41 )
BASE  @ HEX
NF: X BLK @    IF ?EXEC THEN R> DROP NF;
80 LATEST 1+ C!                 \ rename it "null"

NF: \ [COMPILE] \ NF;

NF: GAP     0 , NF;

NF: [COMPILE] [COMPILE] [FROM:NEWFORTH]  NF;
 BASE  !   ;S

NF: WHO DELTA + NFA ID.  NF;



\ Target compiler: nf: ;code -- ."        ( 13  5 86 CRC 15:01 )
BASE @ HEX
NF: ;CODE
     *(;CODE)* @ , HERE DELTA - -2  CSP +!    \ adjust csp
     [COMPILE] ASSEMBLER   [COMPILE] [  NF;
\  HERE  is left on the stack. The programmer MUST manually
\ insert it into the proper *xxxxx*  constant
\ e.g. : fred .... ;code ... next  mutates *fred*

\ NF: ASSEMBLER    ASSEMBLER                      NF;

NF: DOES>   *(;CODE)* @ ,  HERE DELTA -  -2 CSP +!  E8 C,
  *DOES>* @ DELTA +  HERE 2+ - , FORTH  NF;   \ in *xxx* consta
 \ absolute .long jsr,
NF: ."           *(.")* @ , [COMPILE]  TXT   NF;
 BASE  !   ;S
\ Target compiler: {         -- }         ( 16  1 87 CRC 18:59 )
NF: {  SETOLD   [COMPILE] FORTH     [COMPILE] [ NF;

NF: }  SETNEW ] [COMPILE] NEWFORTH              NF;

NF: <BUILDS 0 CONSTANT -2 ALLOT NF;

NF: ( [COMPILE] ( NF;

NF: FORTH                      NF;

NF: LITERAL  [COMPILE] LITERAL NF;

NF: SEE: SEE: NF;

NF: WHERE    OF/NF [COMPILE] WHERE   NF;    GOLDEN
\ Target compiler: nf: ;  -- while          09 03 83 CRC
BASE @ HEX
NF: ;      ?CSP NFCOMPILE ;S
     SMUDGE [COMPILE] FORTH [COMPILE] [ NF;
NF: THEN        HERE OVER - SWAP ! NF;
NF: BEGIN       HERE NF;
NF: DO          NFCOMPILE (DO) HERE NF;
NF: LOOP        NFCOMPILE (LOOP)  HERE - , NF;
NF: +LOOP       NFCOMPILE (+LOOP) HERE - , NF;
NF: UNTIL       NFCOMPILE 0BRANCH HERE - , NF;
NF: IF          NFCOMPILE 0BRANCH HERE 0 , NF;
NF: WHILE       NFCOMPILE 0BRANCH HERE 0 , NF;
 BASE  !   ;S
NF: ENDIF       HERE OVER - SWAP ! NF;


\ Target compiler: again  -- stop           09 03 83 CRC
BASE @ HEX
NF: AGAIN       NFCOMPILE BRANCH HERE - , NF;
NF: REPEAT SWAP NFCOMPILE BRANCH HERE - ,
             HERE OVER - SWAP ! NF;
NF: ELSE        NFCOMPILE BRANCH HERE 0 ,
        SWAP HERE OVER - SWAP ! NF;

NF: ASCII  BL WORD HERE 1+ C@ [COMPILE] LITERAL  NF;

NF: STOP    SMUDGE [COMPILE] FORTH [COMPILE] [ NF;
 BASE  !   ;S




\ assembler extensions for target compiler( 14  8 88 CRC  8:40 )
ASSEMBLER DEFINITIONS  BASE @ HEX
: NEXT    >>NEXT @     #) JMP,  ;
: 1PUSH   >>NEXT @ 1-  #) JMP,  ;
: 2PUSH   >>NEXT @ 2-  #) JMP,  ;
: 3PUSH   >>NEXT @ 3 - #) JMP,  ;










\ Target compiler: nf: ;  -- while          09 03 83 CRC
BASE @ HEX
NF: ;      ?CSP COMPILE  [FROM:NEWFORTH] ;S
     SMUDGE [COMPILE] FORTH [COMPILE] [ NF;
NF: THEN        HERE OVER - SWAP ! NF;
NF: BEGIN       HERE NF;
NF: DO          COMPILE [FROM:NEWFORTH] (DO) HERE NF;
NF: LOOP        COMPILE [FROM:NEWFORTH] (LOOP)  HERE - , NF;
NF: +LOOP       COMPILE [FROM:NEWFORTH] (+LOOP) HERE - , NF;
NF: UNTIL       COMPILE [FROM:NEWFORTH] 0BRANCH HERE - , NF;
NF: IF          COMPILE [FROM:NEWFORTH] 0BRANCH HERE 0 , NF;
NF: WHILE       COMPILE [FROM:NEWFORTH] 0BRANCH HERE 0 , NF;
 BASE  !   ;S
NF: ENDIF       HERE OVER - SWAP ! NF;


\ Target compiler: again  -- stop           09 03 83 CRC
BASE @ HEX
NF: AGAIN       COMPILE [FROM:NEWFORTH] BRANCH HERE - , NF;
NF: REPEAT SWAP COMPILE [FROM:NEWFORTH] BRANCH HERE - ,
             HERE OVER - SWAP ! NF;
NF: ELSE        COMPILE [FROM:NEWFORTH] BRANCH HERE 0 ,
        SWAP HERE OVER - SWAP ! NF;

NF: ASCII  BL WORD HERE 1+ C@ [COMPILE] LITERAL  NF;

NF: STOP    SMUDGE [COMPILE] FORTH [COMPILE] [ NF;
 BASE  !   ;S




































































































































































































































































































































































































































































\ debug file builder                      ( 12 12 87 CRC  9:48 )
filing setdrive: c:   setdir: \messdos\f83
14976 load   \ file building code
filing   createfile: rf.blk   closeit
filing   121 130  blockfile: rf.blk    closeit
." File is "  . ." bytes long."
file: rf rf.blk









  real-FORTH decompiler: messages           08 12 84 CRC
     Inline literal, value        = D
     Compiled inline string:
 in-line cfa                    = $
     User variable, current value = D
     Variable, current value      = D
     Constant = D
     Branch on 0 to:
     Unconditional branch to:
     Loop back to:
     +Loop back to:
     ?? Not in dictionary ??
 >>  Immediate  <<
  Disassembled:
  <primitive>
Address Opcode Operand Opcode Operand Mode ASCII
\ 80x86 Source Code: loader               ( 18  1 89 CRC 15:54 )
BASE @ >R       DECIMAL -61 +BLK NEEDED WORKSPACE
EDITOR FLUSH FORTH DEFINITIONS    TODAY  CHOP
SETOLD mf SETNEW   WARNING ON  DECIMAL
   2   10 +THRU   \ source from lit to sp!
 -35  -34 +THRU   \ compiler directives
\ 11   69 +THRU   \ source from (key) on, old overlays
  11   64 +THRU  101 105 +thru \ source from (key) on, new overl
(  73     +LOAD CR (  wdump)
\  CM SERIAL AND IFTRUE  95 98 +THRU  IFEND
SETOLD SETNEW    109 118 +THRU  \ forward references
TXT Copyright 1988-95 C. Curley"
      SETOLD CR mf HEX  DPNEW @ IMAGETOP OVER - ERASE
DECIMAL CR #BUFS . ." Buffers"  R> BASE !
CR EDITOR FLUSH   CHECKSUM

\ base-addr memory map                    ( 16 12 87 CRC 22:43 )
all addresses are offset from base-addr
addr   count   comment
   0       4   jump to cold start
   4       4   jump to warm start
  08       4   "I808X" in radix 36, per fig model
  0C       2   nfa of top of dictionary. Why, I don't know.
  0E       2   backspace characters. Usually 7F & 08
  10       2   user area base address
  12       2   top of parameter stack; orphaned user  S0
  14       2   top of return stack
  16      32   initial values for user variables


      All code which changes segments must restore them.

\ 80x86 : boot parameters area  rot       ( 12  8 88 CRC 16:16 )
SERIAL CM AND IFTRUE  DECIMAL 83 HEX +LOAD   OTHERWISE
  100 DELTA + DP !     SETORG      IFEND  HERE BOOTS !
ASSEMBLER     NOP, 8000 #) JMP, \ cold start, patched later
cr .s         NOP, 8000 #) JMP, \ warm start, patched later
   D301 , 4105 ,      0 ,        7F C, 08 C,     cr .s
\ I808X radix 36   dict top   backspace chrs
3C == COLDS  HERE     ASSEMBLER COLDS 4 - ALLOT
HERE OVER - ERASE

CODE ROT   DX POP,   BX POP,    AX POP,  ( LABEL BPUSH )
  BX PUSH, ( LABEL DPUSH) DX PUSH, ( LABEL APUSH ) AX PUSH,

LABEL >NEXT   AX LODS,  AX W MOV,  0 [W] JMP,

>NEXT ( DELTA +) >>NEXT !                          ;C
\ 80x86 : lit clit ;s drop dup over       ( 24  3 88 CRC 18:12 )
CODE LIT                          AX LODS, 1PUSH  ;C
       'NF LIT   CFA    MUTATES *LIT*

CODE CLIT    ( -- n )      AL LODS,  CBW,  1PUSH  ;C
       'NF CLIT  CFA    MUTATES *CLIT*

CODE ;S   0 [RP] IP MOV,  RP INC,  RP INC,  NEXT  ;C

CODE DROP                          AX POP,  NEXT  ;C

CODE SWAP                DX POP,  AX POP,  2PUSH  ;C

CODE DUP                AX POP,  AX PUSH,  1PUSH  ;C

CODE OVER      DX POP,  AX POP,  AX PUSH,  2PUSH  ;C
\ 80x86 : branch 0branch (of) (loop)      ( 24  3 88 CRC 18:02 )
CODE BRANCH   LABEL BRAN   0 [IP] IP ADD,  NEXT END-CODE
CODE 0BRANCH  ( ?? )    AX POP,  AX AX OR,  BRAN delta + JE,
  LABEL NOBRAN IP INC,  IP INC,  NEXT END-CODE

CODE (OF)  ( ?? ) AX POP,  BX POP,  AX BX CMP,
  NOBRAN delta + JE,  BX PUSH,  BRAN delta + JNE,  ;C

CODE (LOOP)  ( ?? )  1 # AX MOV,  LABEL LP1 AX 0 [RP] ADD,
  LABEL LP2   2 [RP] W MOV,  0 [RP] W CMP,  BRAN delta + JG,
  LABEL LP5   4 # RP ADD,  NOBRAN #) JMP, ;C

CODE EXECUTE   W POP,   0 [W] JMP, END-CODE



\ 80x86 : (+loop) (do) (pause) paws       (  1  1 88 CRC 21:51 )
CODE (+LOOP)  AX POP,   AX 0 [RP] ADD,  8000 # AX TEST,
  LP2 delta + JE,  2 [RP] W MOV,  0 [RP] W CMP,
  LP5 delta + JGE,   BRAN #) JMP,   ;C

CODE (DO)  AX POP,  RP DEC,  RP DEC,  0 [RP] POP,
  ( ??) RP DEC,  RP DEC,  AX 0 [RP] MOV,  NEXT ;C
  ;s   \ call to pause current task.
LABEL (PAUSE)  RP 4 U &[ MOV, ( BEGIN,)  8 U &[ U MOV,
 ( U [ TST,  NE UNTIL,)  4 U &[ RP MOV,  RTS,
  \ call from i/o code definitions inside loops
LABEL PAWS   IP RP -[ MOV,  S RP -[ MOV,
             (PAUSE) *+ BSR,   \ execution resumes here
             RP [+ S MOV,  RP [+ IP MOV,  RTS,


\ 80x86 : i digit pause                   ( 30 12 87 CRC 20:12 )
   \ or expand it out
\ CODE PAUSE  PAWS *+ BSR, NEXT   ;C
        \ temp while we're single tasking.
CODE PAUSE  >>NEXT @          here 2- !  ;C

CODE I                                                       ;C

LABEL FAIL   AX AX SUB,  1PUSH

CODE DIGIT  ( ?? )   ( char base -- n f )
  DX POP,  AX POP,  ASCII 0 # AL SUB,  FAIL delta + JB,
  9 # AL CMP,  > IF,  11 # AL CMP,  FAIL delta + JB,
                 7 # AL SUB,  THEN,
  DL AL CMP,  FAIL delta + JAE,  AL DL MOV,
  TRUE # AX MOV,  2PUSH END-CODE
\ 80x86 : (find)                          ( 18  2 88 crc  9:53 )
CODE (FIND)   W POP,  DI POP,  IP PUSH,  DH DH SUB,
  BEGIN,  DI SI MOV,  0 [W] AL MOV,  0 [SI] AL XOR,
    3F # AL AND,  0= IF,  0 [W] DL MOV,
      BEGIN,  W INC,  SI INC,  0 [W] AL MOV,  0 [SI] AL XOR,
        0<> UNTIL,  7F # AL AND,
      0= IF,  SI POP,  5 # W ADD,  W PUSH,
        1 # AX MOV,  2PUSH
        >R >R THEN,  W INC,  R> R> THEN,  W SI MOV,
    BEGIN,  AL LODS,  80 # AL AND,  0<> UNTIL,
    0 [IP] W MOV,  W W OR,  0= UNTIL,
  SI POP,  W AX MOV,  1PUSH             ;C




















\ 80x86 : enclose                         ( 20  2 89 CRC 10:08 )
  \ addr$ char ---  addr$ off3 off2 off1
CODE ENCLOSE  AX POP,  6 # SP SUB,  SP DI MOV,
  6 [DI] BX MOV,  BX DEC,
  BEGIN,  BX INC,  0 [BX] AL CMP,  0<> UNTIL,
  BX 4 [DI] MOV,  BX DEC,

LABEL ENCL2  BX INC,  0 # 0 [BX] .B CMP,  0<> IF,
  0 [BX] AL CMP,  ENCL2 delta + JNE,
  BX INC,  BX 0 [DI] MOV,  BX DEC,

LABEL ENCL3  BX 2 [DI] MOV,  6 [DI] AX MOV,
  AX 0 [DI] SUB,  AX 2 [DI] SUB,  AX 4 [DI] SUB,  NEXT

  THEN,  BX 0 [DI] MOV,  BX 4 [DI] CMP,  ENCL3 delta + JNE,
  BX INC,  ENCL3 #) JMP,                ;C
\ 80x86 : @execute exec sp@ sp!           (  1  5 88 CRC 17:53 )
CODE @EXECUTE  0 [RP] IP MOV,  RP INC,  RP INC,
               W POP,  0 [W] W MOV,  0 [W] JMP, C;
'NF @EXECUTE CFA  MUTATES *@EXEC*

CODE EXEC   AX POP,  AX SHL,   AX IP ADD,  0 [IP] W MOV,
  0 [RP] IP MOV,  RP INC,  RP INC,   0 [BX] JMP,   ;C

CODE SP!   UP T#) BX MOV,  6 [BX] SP MOV,  NEXT ;C

CODE SP@   SP AX MOV, 1PUSH END-CODE

'NF 0BRANCH CFA  MUTATES *0BRAN*
'NF BRANCH  CFA  MUTATES *BRAN*
'NF ;S      CFA  MUTATES *;S*
'NF (LOOP)  CFA  MUTATES *(LOOP)*
\ 80x86 : (emit) (key) (?terminal) mon    ( 19  8 90 CRC 11:31 )
SERIAL  IFTRUE  DECIMAL 204 CM + LOAD OTHERWISE
LABEL EMASK  7F C,
CODE (EMIT)  2 # AH MOV,  DX POP,
             EMASK T#) DL AND,  ( temp) 21 INT,    NEXT  C;

CODE (KEY)   7 # AH MOV,  21 INT,  AH AH SUB,  1PUSH  C;

CODE (?TERMINAL)  0B # AH MOV,  21 INT,  AL INC,
  0= IF,  7 # AH MOV,  21 INT,  1 # AX MOV,  ELSE,
  AX AX SUB,  THEN,  1PUSH                            C;

CODE MON      AX AX SUB,  AX DX MOV,  21 INT,  C;
IFEND


\ 80x86 : cmove 0= 0< > <                 ( 20  2 89 CRC 10:07 )
CODE CMOVE   CS PUSH,  ES POP,  IP BX MOV,
  CX POP,  DI POP,  IP POP,
  REP, .B MOVS,  BX IP MOV,  NEXT END-CODE

ASSEMBLER  LABEL YES     TRUE # AX MOV,   1PUSH
\          LABEL NO      AX AX SUB,  1PUSH
CODE 0=   AX POP,  AX AX OR,  YES delta + JE,  FAIL #) JMP, ;c

CODE 0<   AX POP,  AX AX OR,  YES delta + JS,  FAIL #) JMP, ;c

CODE >   (  n1 n2 -- f )
  AX POP,  BX POP,  AX BX CMP,  YES delta + JG, FAIL #) JMP, ;c

CODE <
  AX POP,  BX POP,  AX BX CMP,  YES delta + JL, FAIL #) JMP, ;c
\ 80x86 : = u< 2drop u*                   ( 24  3 88 CRC 18:05 )
CODE =
  AX POP,  BX POP,  AX BX CMP,  YES delta + JE,  FAIL #) JMP, ;c

CODE U<      ( n1 n2 -- f )
  AX POP,  BX POP,  AX BX CMP,  YES delta + JB,  FAIL #) JMP, ;c

CODE 2DROP  AX POP,  AX POP,  NEXT  ;C

CODE U*      ( n1 n2 -- d )
  AX POP,  BX POP,  BX MUL,  DX AX XCHG,  2PUSH END-CODE





\ 80x86 : u/ 2+ 1+                        ( 19 12 87 CRC  8:47 )
CODE U/   ( d1 n1 -- Remainder Quotient )
  BX POP,  DX POP,  AX POP,  BX DX CMP,  U>=  \ divide by zero?
  IF,  -1 # AX MOV,  AX DX MOV,  ELSE,  BX DIV,  THEN,  2PUSH
  END-CODE


CODE 1+    AX POP,  AX INC,  1PUSH END-CODE

CODE 2+    AX POP,  AX INC,  AX INC,  1PUSH END-CODE






\ 80x86 : and or xor rp! leave >r r> r    ( 15  7 93 CRC  8:50 )
CODE AND   BX POP,  AX POP,  BX AX AND,  1PUSH END-CODE

CODE OR    BX POP,  AX POP,  BX AX OR,   1PUSH END-CODE

CODE XOR   BX POP,  AX POP,  BX AX XOR,  1PUSH END-CODE

CODE RP!   UP T#) BX MOV,  8 [BX] RP MOV,  NEXT ;C

CODE LEAVE  0 [RP] AX MOV,  AX 2 [RP] MOV,  NEXT ;C

CODE >R   RP DEC,  RP DEC,  0 [RP] POP,  NEXT  ;C

CODE R>   0 [RP] PUSH,  RP INC,  RP INC,  NEXT  END-CODE

CODE R    0 [RP] PUSH,                          NEXT     ;C
\ 80x86 : + - d+                          ( 16 12 87 CRC 23:07 )
CODE +   BX POP,  AX POP,  BX AX ADD,  1PUSH END-CODE

CODE -   BX POP,  AX POP,  BX AX SUB,  1PUSH END-CODE

CODE D+  ( d1 d2 -- dsum )
  AX POP,  DX POP,  BX POP,  CX POP,  CX DX ADD,  BX AX ADC,
  2PUSH END-CODE








\ 80x86 : minus dminus s->d               (  4  4 90 CRC 19:43 )
CODE MINUS   AX POP,  AX NEG,  1PUSH END-CODE

CODE DMINUS   BX POP,  CX POP,  AX AX SUB,  AX DX MOV,
  CX DX SUB,  BX AX SBB,  2PUSH END-CODE

CODE S->D   AX POP,  CWD,  AX PUSH,  DX PUSH, NEXT  END-CODE



;S
CODE S->D   AX POP,  CWD,  AX DX XCHG,  2PUSH   END-CODE




\ 80x86 : -dup 2dup +! toggle             ( 19 12 87 CRC  9:04 )
CODE -DUP   AX POP,  0 # AX CMP,
  0<> IF,  AX PUSH,  THEN,  1PUSH END-CODE

CODE 2DUP   AX POP,  DX POP,  DX PUSH,  AX PUSH,  2PUSH ;C

CODE +!   BX POP,  AX POP,  AX 0 [BX] ADD,  NEXT END-CODE

CODE TOGGLE   AX POP,  BX POP,   AX 0 [BX] XOR,  NEXT ;C

;S
CODE WITHIN  \ n l1 l2 --- fl | is n between lim1 & lim2 incl.?
 1 # DR0 MOVQ,  S [+ DR1 MOV,   S [+ DR2 MOV,
 S [ DR1 CMP,  LT IF,  DR0 CLR,  THEN,
 S [ DR2 CMP,  GT IF,  DR0 CLR,  THEN,  DR0 S [ MOV,  NEXT ;C

\ 80x86 : @ c@ !                          ( 19 12 87 CRC  9:39 )
CODE @     (  addr -- n )
   BX POP,  0 [BX] PUSH,  NEXT END-CODE

CODE C@     (  addr -- char )
   BX POP,  AX AX SUB,  0 [BX] AL MOV,  1PUSH END-CODE

CODE !     (  n addr -- )
   BX POP,  0 [BX] POP,  NEXT END-CODE







\ 80x86 : c!    2- 1- on off 1+!          ( 19 12 87 CRC  9:41 )
CODE C!   BX POP,  AX POP,  AL 0 [BX] MOV,  NEXT END-CODE

CODE 2-   AX POP,  AX DEC,  AX DEC,  1PUSH END-CODE

CODE 1-   AX POP,  AX DEC,  1PUSH END-CODE

CODE ON   BX POP,  1 # 0 [BX] MOV,  NEXT END-CODE

CODE OFF   BX POP,  0 # 0 [BX] MOV,  NEXT END-CODE

CODE 1+!   BX POP,  0 [BX] INC,  NEXT END-CODE




















\ 80x86 : m* pick 2swap                   (  2  1 88 CRC 12:48 )
CODE M*
  AX POP,  BX POP,  BX IMUL,  AX push,  dx PUSH, next  END-CODE

CODE PICK    ( nm ... n2 n1 k -- nm ... n2 n1 nk )
  BX POP,  BX SHL,  SP BX ADD,  -2 [BX] AX MOV,  1PUSH END-CODE

CODE 2SWAP   ( d1 d2 -- d2 d1 )
  BX POP,  CX POP,  AX POP,  DX POP,  CX PUSH,  3PUSH  END-CODE

;S
CODE M*
  AX POP,  BX POP,  BX IMUL,  DX AX XCHG,  2PUSH END-CODE



































\ 80x86 : : ; constant variable           (  4  4 88 CRC 17:37 )
: :     GAP  ( ?exec) GAP ( !csp) GAP ( current)  @
        GAP  ( context)  !  GAP  ( create)  GAP  (  ] )
   ;CODE  W INC,  W INC,  RP DEC,  RP DEC,
   IP 0 [RP] MOV,  W IP MOV, NEXT ;C   IMMEDIATE
MUTATES *COLON*
: ;   GAP ( ?csp) GAP ( compile) ;S GAP ( smudge)
      GAP ( [ ) ;                                     IMMEDIATE

: CONSTANT  GAP ( create) GAP ( smudge) GAP ( , )
   ;CODE  2 [W] PUSH,  NEXT  ;C         MUTATES *CONSTANT*

: VARIABLE  CONSTANT  ;CODE
  W INC,  W INC,  W PUSH,  NEXT  ;C     MUTATES *VARIABLE*


\ 80x86 : user some constants +origin     (  4  4 88 CRC 17:38 )
: USER   CONSTANT
  ;CODE  2 [W] AX MOV,  UP T#) AX ADD,  1PUSH END-CODE
  MUTATES *USER*

    5 CONSTANT 5              40 CONSTANT C/L
    0 CONSTANT 0               1 CONSTANT 1
    2 CONSTANT 2               3 CONSTANT 3
    4 CONSTANT 4              20 CONSTANT BL

*B/BUF*  CONSTANT B/BUF   400 *B/BUF* / CONSTANT B/SCR

CODE +ORIGIN  AX POP,
  0 +BOOTS # AX ADD, 1PUSH ;C


\   11  Source Code: tib    -  'limit       13 12 84 CRC
    |   6 USER S0
       0A USER TIB                0C USER WIDTH
       0E USER WARNING            10 USER FENCE
       12 USER DP                 14 USER VOC-LINK
       16 USER 'KEY               18 USER 'EXPECT
       1A USER '?TERMINAL         1C USER 'EMIT
       1E USER 'TYPE              20 USER 'GOTOXY
       22 USER 'PAGE              24 USER 'LIST
       26 USER 'CR
       28 USER 'R/W               2A USER 'QUIT
       2C USER 'ABORT             2E USER 'CREATE
       30 USER 'FIRST             32 USER 'LIMIT
     ( 34 dummy for vocabs )   |  36 USER VLFTH
     ( 38 dummy for vocabs )   |  3A USER BOTSTACK           ;S
  leave gap to 40 for expansion of initialised user variables
\   11  Source Code: blk    -  first      ( 15  2 87 CRC 14:12 )
   40 USER BLK                42 USER IN
   44 USER OUT                46 USER SCR
   48 USER OFFSET             4A USER CONTEXT
   4C USER CURRENT            4E USER STATE
   50 USER BASE               52 USER DPL
   54 USER FLD                56 USER CSP
   58 USER R#                 5A USER HLD
   5C USER USE                5E USER PREV

\ |  60 USER CURSEG          |  62 USER MEMPTR    \ scr 187
\ |  60 USER >MEM            |  62 USER +HEAD     \ scr 222
: FIRST   'FIRST   @  ;         : LIMIT   'LIMIT   @  ;



\ 80x86 : here allot , c, term i/o        (  4  4 90 CRC 19:44 )
CODE HERE   UP T#) BX MOV,  OFUSER DP PUSH,  NEXT  C;

: ALLOT  ( n -- )      DP +!   ;
CODE ,   UP T#) BX MOV,  OFUSER DP AX MOV,             \  here
  2 # OFUSER DP ADD,                                   \ 2 allot
  AX BX MOV,              0 [BX] POP,  NEXT END-CODE   \ !
CODE C,   UP T#) BX MOV,
  OFUSER DP AX MOV,  OFUSER DP INC,
  AX BX MOV,  CX POP,  CL 0 [BX] MOV,  NEXT END-CODE   \ c!

: KEY             PAUSE  'KEY       @EXECUTE    STOP
: EMIT   OUT 1+!  PAUSE  'EMIT      @EXECUTE    STOP
: PAGE                  'PAGE @ EXECUTE  OUT OFF ;
: CR                    'CR   @ EXECUTE  OUT OFF ;
: R/W        PAUSE  'R/W       @EXECUTE    STOP
\ 80x86 : traverse latest pfa             (  4  4 90 CRC 19:45 )
: ?TERMINAL  PAUSE  '?TERMINAL @EXECUTE    STOP

LABEL (TRAV)   BEGIN,  CX BX ADD,  80 # 0 [BX] .B TEST,
  0<> UNTIL,  RET,
CODE TRAVERSE  CX POP,  BX POP,  (TRAV) #) CALL,  BX PUSH,
  NEXT  ;C

: LATEST CURRENT @ @ ;

: LFA   2- 2- ;                CODE CFA   ;C

CODE PFA   1 # CX MOV,  BX POP,  (TRAV) #) CALL,
  5 # BX ADD,  BX PUSH, NEXT                         ;C
CODE NFA   -1 # CX MOV,  BX POP,  5 # BX SUB,
  (TRAV) #) CALL,  BX PUSH,  NEXT                   ;C
\ 80x86 : space (page) ?align             ( 19 12 87 CRC 11:43 )
: SPACE    BL EMIT  ;

: (PAGE)   0C EMIT  ;

\ : ?ALIGN  ;    immediate


























\ 68000 : !csp ?error ?comp ?exec ?loading( 15  2 86 CRC       )
: !CSP      SP@ CSP ! ;

: ?ERROR    SWAP IF GAP   ( error) ELSE DROP THEN ;

: ?COMP     STATE @ 0=   11 ?ERROR ;

: ?EXEC     STATE @      12 ?ERROR ;

: ?PAIRS    -  13 ?ERROR ;

: ?CSP      SP@ CSP @ - 14 ?ERROR ;

: ?LOADING  BLK @ 0= 16 ?ERROR ;


\ 68000 : compile [ smudge hex bounds     ( 12  2 87 CRC 17:15 )
: COMPILE    ?COMP  R> DUP 2+ >R @ , ;

: [          STATE OFF ;  IMMEDIATE

: ]          C0 STATE ! ;

: SMUDGE     LATEST BL TOGGLE ;

: HEX        10 BASE ! ;          : DECIMAL    0A BASE ! ;

: BOUNDS  OVER + SWAP ;




\ 80x86 : fill erase within abort quit    ( 20  2 89 CRC 10:37 )
CODE FILL  AX POP,  CS PUSH,  (  start-addr count char -- )
  ES POP,  CX POP,  DI POP,  REP,  AL STOS,  NEXT C;

CODE ERASE   AX AX SUB,    'NF FILL CFA 3 + #) JMP, C;

CODE BLANKS  20 # AX MOV,  'NF FILL CFA 3 + #) JMP, C;

: WITHIN   ( n1 min max -- f ) >R  OVER > SWAP R> > OR 0= ;

: QUIT   'QUIT  @EXECUTE STOP   'NF QUIT  CFA MUTATES *QUIT*

: ABORT  'ABORT @EXECUTE STOP   'NF ABORT CFA MUTATES *ABORT*

: TYPE   'TYPE  @EXECUTE STOP

\ 80x86 : (;code) <builds does>           ( 19 12 87 CRC 16:01 )
: (;CODE) R> LATEST PFA CFA ! ;
        'NF (;CODE) CFA MUTATES *(;CODE)*

: <BUILDS   0 CONSTANT -2 ALLOT ;   \ new <builds ... does>
HERE DELTA - MUTATES *DOES>* ?CR

LABEL DODOES
  SP RP XCHG,  IP PUSH,  SP RP XCHG,  IP POP,
  W INC,  W INC,  W PUSH,  NEXT

: DOES>  COMPILE (;CODE)
  { ASSEMBLER DODOES NEWFORTH } LITERAL E8 C,
  HERE 2+ - ,   ; IMMEDIATE         \ absolute .long jsr,


\ 80x86 : count (type) -trailing (.") (cr)(  8  3 88 CRC 17:44 )
CODE COUNT   \  DUP 1+ SWAP C@ ;
   BX POP,  AX AX SUB,  0 [BX] AL MOV,  BX INC,  BX PUSH,
   1PUSH END-CODE

\ : (TYPE) -DUP IF BOUNDS DO R C@ EMIT LOOP  ELSE DROP THEN ;
: (TYPE)   -DUP  IF  0  DO  DUP I + C@ EMIT  LOOP  THEN  DROP ;
CODE -TRAILING   BX POP,  DI POP,  20 # AL MOV,
 BEGIN,  AL -1 [DI+BX] CMP,
     0= IF, >R >R  BX DEC,  0= UNTIL,  R> R> THEN,
  DI PUSH,  BX PUSH,  NEXT        ;C

: (.") R COUNT DUP 1+ R> + >R TYPE ;
   'NF (.")           CFA  MUTATES *(.")*

: (CR)  ."   " ;
\ 68000 : ." (expect) expect query        ( 13  4 86 CRC       )
: ." ASCII "  STATE @
     IF COMPILE (.") GAP ( word)  HERE C@ 1+ ALLOT
     ELSE GAP ( word) HERE COUNT TYPE THEN ;          IMMEDIATE

: (EXPECT) OVER + OVER          \ add for atari/ibm pc keyboard
     DO KEY DUP 0E +ORIGIN C@ =   OVER 0F +ORIGIN C@ = OR
        IF DROP 08 OVER R = DUP R> 2- + >R - ELSE
          DUP 0D = IF LEAVE DROP BL 0 ELSE  DUP THEN R C!
        0 R 1+ C! THEN   EMIT ( DROP)  LOOP     DROP ;

: EXPECT  PAUSE 'EXPECT  @EXECUTE  STOP

: QUERY TIB @ 50  EXPECT  IN OFF  ;


\ 68000 : x hold pad word (number)        ( 12  2 87 CRC 17:20 )
: X       BLK @ IF ?EXEC THEN R> DROP ;         IMMEDIATE
: HOLD    -1 HLD +!  HLD @ C! ;
: PAD     HERE 44 + ;
                          \  gap = block
: WORD BLK @ IF BLK @  GAP  ELSE  TIB @ THEN IN @ + SWAP
  ENCLOSE HERE 22 BLANKS IN +! OVER - >R  R HERE C!
  + HERE 1+ R> CMOVE ;
CODE UPPER   \ addr ct ---  | force to upper case
  CX POP,  BX POP,  ASCII z 1+  8 2*S  ASCII a 1-  OR # DX MOV,
  DO,  0 [BX] AL MOV,  AL DL CMP,
     U< IF,  AL DH CMP,  U> IF,  20 # 0 [BX] .B XOR,
     THEN,  THEN,  BX INC,  LOOP,  NEXT       ;C
: (NUMBER) BEGIN 1+ DUP >R C@ BASE @ DIGIT
  WHILE SWAP BASE @ U* DROP ROT BASE  @ U* D+
       DPL @ 1+ IF DPL 1+! THEN R> REPEAT R> ;
\ 68000 : number -find error id.          ( 29  5 86 CRC 17:14 )
: NUMBER 0 0 ROT DUP 1+ C@ ASCII - = DUP >R + -1
  BEGIN DPL ! (NUMBER) DUP C@ BL -
      WHILE DUP C@ ASCII . - 0 ?ERROR 0 REPEAT
  DROP R> IF DMINUS THEN ;

: -FIND BL WORD HERE COUNT UPPER HERE CONTEXT @ @ (FIND)
  DUP 0= IF DROP HERE LATEST (FIND) THEN ;

: ERROR   WARNING @ 0<
  IF ABORT THEN HERE COUNT TYPE ."  ? "
  GAP ( message) SP!  BLK @ IF IN @ BLK @ THEN
  QUIT                                STOP

: ID. PAD BL ASCII _ FILL DUP PFA LFA OVER -
     PAD SWAP CMOVE PAD COUNT 1F AND TYPE SPACE ;
\ 68000 : b/drv maxblk drive empty-buffers(  3  2 88 CRC 17:21 )
DECIMAL
3.5" IFTRUE                 \  720 k 3.5" floppies
720 CONSTANT B/DRV              1439 CONSTANT MAXBLK   IFEND

5.25"  SERIAL OR  FILES OR  IFTRUE    \  360 k 5.25" floppies
360 CONSTANT B/DRV               719 CONSTANT MAXBLK   IFEND

: DRIVE  B/DRV U* DROP OFFSET ! ;

: SETU/P    FIRST DUP USE !  PREV ! ;

: EMPTY-BUFFERS FIRST LIMIT OVER - ERASE SETU/P ;



\ 80x86 : create {compile] literal +buf up(  3  4 90 CRC 20:30 )
: CREATE  'CREATE   @EXECUTE     STOP

: [COMPILE] -FIND 0= 0 ?ERROR DROP CFA , ;            IMMEDIATE

: LITERAL   ( n -- )
  STATE @ IF  DUP -80 7F WITHIN  IF
  COMPILE  CLIT C,  ELSE  COMPILE LIT ,  THEN THEN ;  IMMEDIATE

CODE UPDATE    UP T#) BX MOV,  OFUSER PREV DI MOV,
  8000 # 0 [DI] OR,  NEXT   ;C

CODE +BUF   UP T#) BX MOV,   AX POP,  B/BUF 4 + # AX ADD,
  OFUSER 'LIMIT AX CMP,  0= IF,  OFUSER 'FIRST AX MOV,  THEN,
  AX PUSH,  OFUSER PREV AX SUB,  1PUSH  ;C

\ 68000 : dliteral ?stack interpret immed   26  2 85 CRC
: DLITERAL  STATE @ IF SWAP [COMPILE] LITERAL
        [COMPILE] LITERAL  THEN ;                   IMMEDIATE

: ?STACK  S0 @ SP@            U< 1 ?ERROR
               SP@ BOTSTACK @ U< 7 ?ERROR ;
\ fixed so that tos & bos are user variables for multitasking

: INTERPRET   BEGIN -FIND  IF  ( found) STATE @ <
        IF CFA , ELSE  CFA EXECUTE THEN
        ELSE HERE NUMBER  DPL @ 1+
        IF [COMPILE] DLITERAL ELSE DROP [COMPILE] LITERAL THEN
        THEN ?STACK AGAIN     STOP

: IMMEDIATE LATEST C/L TOGGLE ;

\ 68000 : vocabulary forth definitions (  ( 12  2 87 CRC 17:27 )
: VOCABULARY <BUILDS  A081   , CURRENT @ CFA ,
       HERE VOC-LINK @ , VOC-LINK ! DOES>
       2+ CONTEXT ! ;
MUTATES *VOCAB*         ( Romable vocabulary !!!!!)

: FORTH  VLFTH CONTEXT  ! ;                           IMMEDIATE

: DEFINITIONS  CONTEXT @ CURRENT ! ;

: (  ASCII ) WORD      ;                              IMMEDIATE

;s
CODE ?DR   \ -- n | return current active drive

  NEXT ;C
\ 80x86 : back (quit) (abort)             (  2  7 88 CRC 16:05 )
DECIMAL \ patch today's date into (abort). automated version ctl
(DATE)  BLK @ BLOCK  555 + SWAP CMOVE  UPDATE
: BACK      HERE - , ;

: (QUIT)   BLK OFF [COMPILE] [  BEGIN BEGIN
  RP! CR QUERY INTERPRET  STATE @ 0= UNTIL ."  OK" AGAIN STOP

: (ABORT) SP! DECIMAL CR ." real-FORTH 1.3 24 12 19"
   [COMPILE] FORTH  DEFINITIONS  OFFSET OFF   QUIT  STOP

SERIAL 0= IFTRUE DECIMAL 209  LOAD   IFEND
FILES IFTRUE  DECIMAL 210 211 THRU   IFEND



\ 80x86 : iob +iob emp startup            ( 14  2 95 CRC 17:01 )
| -1 VARIABLE EMPT  \ should be a constant when we rom

LABEL  STRTUP  ." strtup = " STRTUP 6 U.R

FILES IFTRUE            FILENAME 1+
} SP! EMPT @ IF EMPT OFF EMPTY-BUFFERS THEN   SETU/P
  LITERAL     OPENIT  ABORT {
ASSEMBLER LABEL SEGMENT 0 ,     FORTH
                                       OTHERWISE

} SP! EMPT @ IF EMPT OFF EMPTY-BUFFERS THEN   SETU/P
                     ABORT {
                                      IFEND


\ 80x86 : setsup                          ( 20  2 89 CRC 10:09 )
LABEL SETSUP
  10 +BOOTS T#) DI MOV,              \ set destination
  DI UP T#) MOV,                     \ set user area pointer
  0C +BOOTS # IP MOV,                \ from addr
  CLD,

\ move user area stuff out from cold start area
  REP,  .B MOVS,

  STRTUP # IP MOV,  RET,  \ execute cold start orphan

;s   register usage:
  cx -- count of bytes to move
  di -- destination
  ip -- source
\ user pointer table                      ( 29 12 87 CRC 20:54 )
label useraddrs
getups













\ 80x86 : Memory setup                    (  9  3 88 CRC 20:41 )
     \ do setup for memory here. Return highest addr in dr0
LABEL SETSTUF                       \ top of available memory
SERIAL IFTRUE   FE00 # AX MOV,   OTHERWISE
     6 T#) AX MOV,   0 # AL MOV,  IFEND
  AX DX MOV,  \ save for user area patches
  0 +BOOTS T#) BX LEA,
  TM   TOS - #  AX  SUB,           AX 12 [BX] MOV, \ tos
  TOS  BOT - #  AX  SUB,           AX 46 [BX] MOV, \ bos
  BOT  RTS - #  AX  SUB,           AX 14 [BX] MOV, \ rts
  RTS TIBX - #  AX  SUB,           AX 16 [BX] MOV, \ tib
  US #  AX  SUB,  AX CX   MOV,     AX 10 [BX] MOV, \ uarea
  'NF VLFTH CFA 2+  T@ 2+ #  AX  ADD,  \ get offset into user
  ( of forth vocab )               AX 20 [BX] MOV, \ voc-link
  100        #  CX  SUB,           CX 3E [BX] MOV, \ limit
  CO         #  CX  SUB,           CX 3C [BX] MOV, \ first
\ register usage for setstuf              (  4  4 90 CRC 20:11 )
  2 # DX SUB,    USERADDRS T#) IP LEA,
  BEGIN,  AX LODS,  0 # AX CMP,  0<>  WHILE,
     AX BX MOV,  DX 0 [BX] MOV,  REPEAT,
  RET, ;S

  2 # DX SUB,    USERADDRS T#) BP LEA,
  BEGIN,  0 [BP] BX MOV,  0 # BX CMP,  0<>  WHILE,
     2 # BP ADD,  DX 0 [BX] MOV,  REPEAT,
  RET, ;S

for this & last screen:
 bx -- point to base parameter area
 cx -- top of memory
 ax -- calculated value

















\ 80x86 : cold                            (  4  3 95 CRC 16:18 )
CODE COLD    LABEL COLDSTART
  CS AX MOV,  AX DS MOV,  AX ES MOV,  AX SS MOV,
SERIAL IFTRUE  100 T#) SP LEA,  IFEND
  SETSTUF #) CALL,  COLDS # CX MOV,
  ( *!*) HERE DELTA - D +  CM SERIAL AND 4 * + #) JMP,

LABEL WARM   10 # CX MOV,
  CS AX MOV,  AX DS MOV,  AX ES MOV,  AX SS MOV,
 FILES IFTRUE  CS SEGMENT T#) MOV,  IFEND
SERIAL IFTRUE  100 T#) SP LEA,  IFEND
  ( *!* )  SETSUP #) CALL,
  'NF RP! CFA T@ #) JMP, ;C

;s
CX contains the number of words moved into the user area.
\ 80x86 : +buf update                     (  3  4 90 CRC 20:30 )
;S   moved to 163 so the UP initialisation in COLD will work

CODE UPDATE    UP T#) BX MOV,  OFUSER PREV DI MOV,
  8000 # 0 [DI] OR,  NEXT   ;C

CODE +BUF   UP T#) BX MOV,   AX POP,  B/BUF 4 + # AX ADD,
  OFUSER 'LIMIT AX CMP,  0= IF,  OFUSER 'FIRST AX MOV,  THEN,
  AX PUSH,  OFUSER PREV AX SUB,  1PUSH  ;C

;S
: +BUF   B/BUF 4 + + DUP LIMIT = IF DROP FIRST THEN
       DUP PREV @ - ;

: UPDATE  PREV @ @ 8000 OR PREV @ ! ;

\ 68000 : arithmetic stuff -- +- to mod   ( 22  5 86 CRC 16:56 )
: +-      0< IF  MINUS THEN ;
: D+-     0< IF DMINUS THEN ;
: ABS     DUP  +-  ;
: DABS    DUP D+-  ;
: MIN     2DUP      > IF SWAP THEN DROP ;

: MAX     2DUP      < IF SWAP THEN DROP ;


: M/      OVER >R >R DABS
              R ABS U/ R> R XOR +- SWAP R> +- SWAP ;
: *       U* DROP ;
: /MOD    >R S->D R> M/ ;
: /       /MOD SWAP DROP ;
: MOD     /MOD      DROP ;
\ 68000 : more arithmetic, number output  ( 18  6 86 CRC 11:13 )
: */MOD   >R M* R> M/ ;
: */      */MOD SWAP DROP ;
: M/MOD   >R 0 R U/ R> SWAP >R U/ R> ;
: SPACES  0 MAX -DUP IF 0 DO SPACE LOOP THEN ;
: <#      PAD   HLD ! ;              \ must be moi to use w/
: #>      2DROP HLD @ PAD   OVER - ; \ wp-forth &/or tasker !!!!
: SIGN    ROT 0< IF ASCII - HOLD THEN ;
: #   BASE @ M/MOD ROT 9 OVER < IF 7 + THEN ASCII 0 + HOLD ;

: #S      BEGIN # 2DUP OR 0= UNTIL ;
: D.R     >R SWAP  OVER  DABS  <#  #S  SIGN #>
          R> OVER  -  SPACES  TYPE ;
: D.      0 D.R SPACE ;
: .R      >R S->D R> D.R ;      : .       S->D D. ;
: ?       @ . ;                 : C?      C@ . ;
\ 68000 : vlist buffer                    ( 13  4 86 CRC       )
: VLIST   CR  CONTEXT @  @
     BEGIN OUT @ C/L >   IF  CR THEN
        DUP ID. SPACE SPACE PFA  LFA  @
        DUP 0=  ?TERMINAL OR UNTIL   DROP            ;

: BUFFER   USE @ DUP >R BEGIN +BUF UNTIL  USE !
        R @ 0< IF R 2+ R @ 7FFF AND 0       R/W  THEN
        R ! R PREV ! R> 2+ ;







\ 68000 : block (line) .line message load ( 27 10 86 CRC 13:17 )
: BLOCK   PAUSE OFFSET @ + >R PREV @ DUP @ R - DUP +
    IF BEGIN +BUF 0= IF DROP R BUFFER DUP R 1 R/W 2- THEN
       DUP @ R - DUP + 0= UNTIL DUP PREV ! THEN R> DROP 2+ ;

: (LINE)  >R C/L B/BUF */MOD R>  + BLOCK + C/L ;
: .LINE   (LINE) -TRAILING TYPE ;

: MESSAGE WARNING @ IF ( we have disk ) -DUP
       IF 1 OFFSET @ - .LINE THEN ELSE  \ 4 is fig std.
          ." msg # " .  THEN ;

: LOAD  BLK @ >R  IN @ >R  IN OFF BLK !  INTERPRET
        R> IN !   R> BLK ! ;

: --> ?LOADING IN OFF BLK 1+! ;               IMMEDIATE
\ 68000 : #bufs flush                     ( 17 10 85 CRC       )

: #BUFS  LIMIT FIRST - 0  B/BUF 4 + U/ \ number of buffers
     SWAP IF ." Bad buffers!"  EMPT ON COLD  THEN ;

: FLUSH  #BUFS  1+  0 DO 7FFF BUFFER DROP LOOP ;










\ messdos: bios disk access               (  1  1 88 CRC 16:34 )
SERIAL FILES  OR  IFTRUE   ;S  IFEND
LABEL DISKTABLE  6 ALLOT      DISKTABLE DELTA + 6 ERASE
CODE +DISK   AX POP,  DISKTABLE # AX ADD,  1PUSH C;
DECIMAL
5.25" IFTRUE                  720 CONSTANT SEC/DRV
18 CONSTANT SEC/CYL             9 CONSTANT SEC/SIDE  IFEND
3.5"  IFTRUE                 1440 CONSTANT SEC/DRV
18 CONSTANT SEC/CYL             9 CONSTANT SEC/SIDE  IFEND

: CALC  \ addr s#  ---  | calculate t&s, etc, from blk#.
  SEC/DRV  /MOD  0 +DISK C!   \ drive#
  SEC/CYL  /MOD  3 +DISK C!   \ cylinder
  SEC/SIDE /MOD  1 +DISK C!   \ side
                 2 +DISK C! ; \ sector number
: DERROR   -DUP IF  BASE @ HEX  SWAP .  BASE !  8 ERROR  THEN ;
\ messdos: bios disk access               (  1  1 88 CRC 15:18 )
SERIAL IFTRUE  DECIMAL 201 203 THRU ;S  IFEND
FILES  IFTRUE  DECIMAL 212 213 THRU ;S  IFEND
CODE SR/W       \  1 = read, 0 = write
  AX POP, ( fl )  AX AX OR,   \ count --> al  r/w f --> ah
  0= IF,  ( write ) 301 # AX MOV,  ELSE,  201 # AX MOV,  THEN,
  DISKTABLE T#) BX LEA,
  0 [BX] DX MOV,  \ drive --> dl  side --> dh
  2 [BX] CX MOV,  \ track --> ch  sect --> cl
  4 [BX] BX MOV,  ( addr --> bx )   CL INC,  13 INT,
  < IF,  AH AL MOV,  FF # AX AND,   ELSE,   AX AX SUB,  THEN,
  1PUSH  C;
: (R/W)         \  addr blk# fl ---
  OVER 0 MAXBLK WITHIN 0= 6 ?ERROR   ROT 4 +DISK ! \ addr
  >R  DUP + ( 2* ) DUP  CALC  R  SR/W  DERROR
  200  4 +DISK +!  1+   CALC  R> SR/W  DERROR ;
\ 68000 : ' index list (list)               25 12 84 CRC
: ' -FIND 0= 0 ?ERROR DROP [COMPILE] LITERAL ;        IMMEDIATE

: INDEX   CR  1+  SWAP    DO CR R  5 .R
   SPACE  0  R .LINE  ?TERMINAL  IF  LEAVE  THEN   LOOP ;

: LIST    'LIST @EXECUTE STOP

: (LIST)    DECIMAL
   CR  DUP  SCR !  ." scr # "   .  10 0
   DO  CR R 3 .R SPACE R SCR @ .LINE  LOOP CR ;





\   11  Source Code: fix forget             18  4 85 CRC
| : PFUI   TIB OVER U< IF TIB - THEN  ;

| : PFUI2  PFUI >R PFUI R>         U< ;

: FORGET   [COMPILE] '  NFA  DUP FENCE @ PFUI2 15 ?ERROR
   >R  VOC-LINK @                  BEGIN
     R OVER PFUI2 WHILE [COMPILE] FORTH  DEFINITIONS
     @ DUP VOC-LINK !  REPEAT      BEGIN
        DUP 2- 2- BEGIN PFA LFA @ DUP R PFUI2  UNTIL
     OVER 2- !  @ -DUP 0= UNTIL   R> DP ! ;





\ 68000 : (create)                        (  2  1 88 CRC 16:03 )
: (CREATE)     FIRST HERE 0A0 + U< 2 ?ERROR
  -FIND IF DROP NFA ID.   4 MESSAGE SPACE THEN
\ c/l out @ < if cr then  \ debug temp!
\ here count type  space  \ debug temp!
  HERE  DUP C@ WIDTH @ MIN 1+ ALLOT
  DUP A0 TOGGLE HERE 1- 80 TOGGLE
  LATEST , CURRENT @ ! HERE 2+ , ;








\   11  Source Code: begin -- while         29 07 84 CRC
: BEGIN       ?COMP HERE 1 ;                          IMMEDIATE
: THEN        ?COMP 2 ?PAIRS HERE OVER - SWAP ! ;     IMMEDIATE
: ENDIF       [COMPILE]  THEN  ;                      IMMEDIATE
: DO          COMPILE (DO) HERE 3 ;                   IMMEDIATE
: LOOP        3 ?PAIRS COMPILE (LOOP)  BACK ;         IMMEDIATE
: +LOOP       3 ?PAIRS COMPILE (+LOOP) BACK ;         IMMEDIATE
: UNTIL       1 ?PAIRS COMPILE 0BRANCH BACK ;         IMMEDIATE
: END         [COMPILE]  UNTIL ;                      IMMEDIATE
: AGAIN       1 ?PAIRS COMPILE BRANCH  BACK ;         IMMEDIATE
: REPEAT      >R >R [COMPILE] AGAIN R> R> 2-
                    [COMPILE] ENDIF ;                 IMMEDIATE
: IF          COMPILE 0BRANCH HERE 0 , 2 ;            IMMEDIATE
: ELSE        2 ?PAIRS COMPILE BRANCH HERE 0 ,
       SWAP 2 [COMPILE] ENDIF 2 ;                     IMMEDIATE
: WHILE       [COMPILE] IF 2+ ;                       IMMEDIATE
















\ Overlay Code -- after Greg Stevenson      23 12 81 CRC
DECIMAL
| 1010 CONSTANT SEGSIZE
\ |    0 VARIABLE CURSEG       |         0 VARIABLE MEMPTR
|  60 USER CURSEG          |  62 USER MEMPTR
| : @SEG  DUP CURSEG ! BLOCK  DROP ;  \ Block #-1 ---
| : DESCRIPTORS CURSEG @ BLOCK ;      \ --- addr
| : OBJECT  DESCRIPTORS 14 + ;        \ --- addr
| : NEXTSEG  SEGSIZE MEMPTR +! ;      \ ---
| : ?SEGS     PAD 4 + @   PAD 2+ @ -  \ --- n
        SEGSIZE /MOD SWAP IF 1+ THEN ;
| : RESTOREDES   DESCRIPTORS  4 + @  DP        !
                 DESCRIPTORS  6 + @  CURRENT @ !
                 DESCRIPTORS  8 + @  CONTEXT @ !
                 DESCRIPTORS 10 + @  VOC-LINK  !  ;
." ."
\ Overlay Code -- after Greg Stevenson      29 04 86 crc
DECIMAL
| : SAVEDES        \      ---
                     PAD           OFF    \ overlay marker
    [COMPILE] ' NFA  PAD    2+       !    \ start addr
    HERE             PAD   4 +       !    \ end addr
    LATEST           PAD   6 +       !    \ dictionary link 1
    CONTEXT @ @      PAD   8 +       !    \ dictionary link 2
    VOC-LINK @       PAD  10 +       ! ;  \ dictionary link 3
." ." ;S

Syntax:     SAVEDES   <WORDNAME>
    PAD  is used as a holding area & contents are placed in all
blocks of the image array.


\ Overlay Code -- after Greg Stevenson      18 02 83 CRC
DECIMAL
: SAVEOVER                     \ Block #-1 ---
   [COMPILE] FORTH  SAVEDES
   PAD 2+ @ MEMPTR !
   ?SEGS DUP PAD 12 + !
   BOUNDS           DO
       I BUFFER DROP    \ why read the thing
       I @SEG UPDATE
       PAD DESCRIPTORS 14 CMOVE
       MEMPTR @ OBJECT SEGSIZE CMOVE
       NEXTSEG I 5 .R  LOOP FLUSH ;
." ." ;S
     Syntax:      <BLOCK#>   SAVEOVER  <WORDNAME>
where <BLOCK#> is the starting block and <WORDNAME> is the first
word to be saved to the virtual array.
\ Overlay Code -- after Greg Stevenson      23 12 81 CRC
DECIMAL
: BRING                         \ Block #-1  ---
  [COMPILE] FORTH  DUP @SEG RESTOREDES
  DESCRIPTORS    2+ @ MEMPTR !
  DESCRIPTORS 12 +  @     \ # of segments
   BOUNDS           DO
        I @SEG
        OBJECT MEMPTR @ SEGSIZE CMOVE NEXTSEG
        46 EMIT LOOP CR ;
." ." ;S
       syntax:   <BLOCK#>  BRING
  where <BLOCK#> is the starting block of a previously saved
overlay.


\ frills: dump & ascii print              ( 30 12 87 CRC 20:31 )
: (DUMP) \  addr ct ---  | dump as pointed to by reloc
  SPACE  BOUNDS DO  I C@ 3 .R  LOOP ;
: U.R 0 SWAP D.R ;        : TAB OUT @ - SPACES ;
: LASCI   \  addr ct ---  | asci type as pointed to by reloc
  SPACE  BOUNDS DO  I C@  7f AND  DUP
    bl ASCII ~ WITHIN 0= IF DROP ASCII . THEN  EMIT  LOOP ;
: HEAD  \ addr --- | headder for dump display
  10 0 DO I OVER + 0f AND 3 .R LOOP DROP ;

  \ N. B: Not responsible for negative counts! -- the MGT.
: DUMP   \  addr ct ---  | dump as pointed to by reloc
  OVER CR 6 SPACES HEAD  BEGIN  DUP  WHILE  CR OVER 5 U.R
     2DUP 10 MIN >R  R 2DUP (DUMP)  36 TAB LASCI
     R R> MINUS D+  ?TERMINAL IF DROP 0 THEN  REPEAT 2DROP ;

\ frills: see, other toys                 (  1  1 88 CRC 13:30 )
\ : SEE  CR ."   dr sd sc tk  addr "
\   CR 0 +DISK 6 (DUMP) ;

: U.  0 D. ;

: .S  SP@ U.  OVER U. DUP U. ;

























\   cross reference utility. Ken Bell     ( 12  9 86 CRC  1:02 )
-FIND QU IFTRUE 2DROP OTHERWISE  : QU  DROP 0 ; IFEND

\ cfa in host ---    | cross printed out
: (WHO)   SPACE COL @ >R [ ' NEWFORTH  2+ ] LITERAL @
   BEGIN  PFA DUP 2- @ DELTA + DUP @ *COLON* @ = IF 2+ \ targ p
     BEGIN  DUP @  HEX ( CR .S)  CASE
      R          OF  OVER  NFA TID.  COL      QU  ENDOF
      *LIT*   @ OF 2+  ENDOF    *;S* @     OF QU  ENDOF
      *@EXEC* @ OF QU  ENDOF
      *(.")*  @ OF DUP 2+  C@ 1+ +                ENDOF

-->



\   cross reference utility. Ken Bell     ( 29 04 86 crc       )
      *(;CODE)* @ OF   QU                           ENDOF

      *(LOOP)*  @ OF 2+  ENDOF  *(+LOOP)* @ OF 2+  ENDOF
      *BRAN*    @ OF 2+  ENDOF  *0BRAN*   @ OF 2+  ENDOF
    [ 'NF COMPILE     @ 2+ ] LITERAL  OF 2+   ENDOF
ENDCASE   -DUP WHILE 2+ REPEAT ELSE DROP THEN LFA @ DUP 0=
             UNTIL R> 2DROP   OUT @ IF CR THEN ;

    BLK @ 1+ DUP 1+ RTHRU \  ."  Disposing " DISPOSE  CR
;S
      *(;CODE)* @ OF DUP 4 +  @  *DOES>*
              = IF 4 +  ELSE QU THEN             ENDOF
           \ debugging version
?TERMINAL OR UNTIL R> 2DROP   OUT @ IF CR THEN ;  CR .S
  \   *ABORT* @ OF QU  ENDOF    *QUIT* @  OF QU  ENDOF
\ cross reference utility. Target compiler( 29 04 86 crc       )
: LOC   \ nfa  ---  nfa | print out screen & line # if can
  DECIMAL ' WHERETHEN OVER U< IF SPACE lfa 2- @ WHERETHEN  C/L /
  14 [ BLK @ 1+ ] LITERAL .LINE 3 .R SPACE .SCR SPACE THEN ;

: (CROSS)   CR BASE @ SWAP  \ nfa --- | start cross reference
  BEGIN DUP PFA 2- @ [ ' QUIT 2- @ ] LITERAL -
  IF 15 [ BLK @ 1+ ] LITERAL .LINE  SPACE  DUP TID. 30 TAB
  COL DUP LOC PFA DUP (WHO)
  DUP 2- @ DELTA + 2- @ 0=    \ is target link = 0 ?
  ELSE PFA 0 THEN  ?STACK \  CR .S
  ?TERMINAL OR SWAP LFA @ DUP 0=   \ is host link = 0 ?
  ROT OR UNTIL  DROP BASE ! ;

: WHO:   CR BASE @ 15 [ BLK @ 1+ ] LITERAL .LINE SPACE
  [COMPILE]  'NF HERE COUNT TYPE DUP C>N LOC (WHO) BASE ! ;
\ target vlist    utility. Target compiler( 29 04 86 crc       )
: TVLIST  CR BASE @  [ ' NEWFORTH  2+ ] LITERAL  @
    BEGIN PFA DUP 2- @ [ ' QUIT 2- @ ] LITERAL -
    IF DUP NFA TID. 3 SPACES  OUT @ C/L > IF CR THEN
    DUP 2- @ DELTA + 2- @ 0= ELSE 0 THEN \ is target link = 0 ?
\   10 TAB .S  OVER NFA ID. 20 TAB \ testing stuff
    ?TERMINAL OR SWAP LFA @ DUP 0= \ is host link = 0 ?
    ROT OR ( CR ?STACK) UNTIL  DROP BASE ! ;

: CROSS   [ ' NEWFORTH  2+ ] LITERAL @ (CROSS) ;

: 'CROSS  'NF c>n (CROSS) ; ;S \ start cross at given word
\ e.g  'cross fred  begins a cross ref at  fred .

Line number
Words using:
















































\ strand hosted terminal code             ( 29  4 88 CRC  6:58 )
CODE NYBBL   \ n -- nlo nhi | encode byte into two bytes
   AX POP,  AH AH SUB,  AX DX MOV,  4 # CL MOV,  DX CL SHR,
   0F # AL AND,  30 # AL OR,  30 # DL OR,  2PUSH         ;C

CODE DENYBBL   \ blo bhi -- b | reverse nybbl
  AX POP,  0F # AX AND,  4 # CL MOV,  AX CL SHL,  AX DX MOV,
  AX POP,  0F # AX AND,  DX AX OR,  1PUSH                ;C

CODE ><      AX POP,  AH AL XCHG,  1PUSH    ;C

1 VARIABLE DLY

: (EMIT)  DLY @ 0 DO  LOOP  <EMIT> ;   ;s


\ 6809 Host-system intf. v.2 -- xmitb - rxb 23 08 85 BJR
: XMITB       NYBBL  (EMIT) (EMIT)  ; \ sends lonybl, hinbyl

: XMITW       DUP ><   XMITB  XMITB ; \ sends hibyte, lobyte

: RXB         (KEY)  (KEY)  DENYBBL ; \ expects lonybl, hinyb










\ 6809 Host-system intf. v.2 -- (r/w)       23 08 85 BJR
: READ     1F (EMIT) 31 (EMIT)  XMITW
                              B/BUF BOUNDS DO RXB I C! LOOP ;

: WRITE    1F (EMIT) 30 (EMIT)  XMITW
                              B/BUF BOUNDS DO I C@ XMITB LOOP ;

: (R/W)    OVER MAXBLK > 6 ?ERROR
           OVER       0< 6 ?ERROR
           IF READ ELSE WRITE THEN ;






\ stand alone (key) (emit) (?terminal)    (  9  3 88 CRC 20:40 )
ASSEMBLER   1F8 == CTL-A  ASSEMBLER  CTL-A 2+ == DATA-A
LABEL ?KEY  CTL-A # DX MOV,  DX AL IN,  1 # AL AND,  RET,

CODE <EMIT>  CTL-A # DX MOV,  4 # AH MOV,
  BEGIN, DX AL IN,  AH AL AND,  0<> UNTIL,
  DATA-A # DX MOV,  AX POP,  DX AL OUT,  NEXT     C;

CODE (KEY)   BEGIN,  ?KEY #) CALL, 0<> UNTIL,
  DATA-A # DX MOV,  DX AL IN,  AH AH SUB,  1PUSH  C;

CODE (?TERMINAL)   ?KEY #) CALL,  0= IF,  AX AX SUB,  ELSE,
 DATA-A # DX MOV,  DX AL IN,  1 # AX MOV,  THEN,  1PUSH    C;

CODE MON  C; 0 +BOOTS 'NF MON CFA DELTA + !

\ terminal i/o: 8250 control              ( 15  7 89 CRC 11:25 )
LABEL LSR  3FD ,     LABEL DATA 3F8 ,     LABEL EMASK  7F C,
LABEL ?KEY   LSR T#) DX MOV,  DX AL IN,  1 # AX AND,  RET,

CODE (?TERMINAL) \ --- f | is there a char from the host?
  ?KEY #) CALL,  0<> IF,  DATA T#) DX MOV,  DX AL IN,
  1 # AL MOV,  THEN,  1PUSH                          ;C

CODE <EMIT> \ c --- | send to host
  LSR T#) DX MOV,  20 # ( thre bit ) AH MOV,
  BEGIN,  DX AL IN,  AH AL AND,  0<> UNTIL,  AX POP,
  EMASK T#) AL AND,  DATA T#) DX MOV,  DX AL OUT,  NEXT  ;C

CODE (KEY)  \ --- c | get char from host
  BEGIN,  ?KEY #) CALL,  0<> UNTIL,
  DATA T#) DX MOV,  DX AL IN,  1PUSH  ;C
\ CM rom self-boot routine                ( 20  2 89 CRC 10:22 )
ASSEMBLER      DE DELTA + DP !        SETORG
  AA C,  55 C,   0 C,      \ preboot data
  CS AX MOV,  AX DS MOV,   1C ( *&* ) T#) IP LEA,
  AX LODS,  AX CX MOV,  CX SHR,  \ len
  AX LODS,  AX ES MOV,           \ dest seg
  AX LODS,  AX DI MOV,           \ dest offset
  ES PUSH,  DI PUSH,             \ "return" address
  CLD,                           \ 'upward' move.
  REP, MOVS,  FAR RET,           \ move & go to it

( *&* )
\  len       dest seg  offset
  2000 ,      40  ,    100 ,


\ terminal i/o: 8250 control              ( 15  7 89 CRC 11:42 )
  \ i/o locations for various 8250 machines
  \ chassis master i/o locations
LABEL LSR  115 ,     LABEL DATA 110 ,     LABEL EMASK  7F C,

  \ ibm pc serial port locations
LABEL LSR  3FD ,     LABEL DATA 3F8 ,     LABEL EMASK  7F C,

























\ mess-dos interface:                     (  2  7 88 CRC 20:10 )
| : DOCMD  ( do a command from the command line               )
  80 COUNT DUP IF  CR  >R  TIB @  R CMOVE  80 OFF
    TIB @ R> + OFF  IN OFF  INTERPRET  ELSE  2DROP  THEN ;

| : CMDBOOT    RP! BLK OFF [COMPILE] [
  { 'NF (QUIT) CFA } LITERAL 'QUIT !  DOCMD  QUIT STOP









\ mess-dos interface:                     ( 17  3 88 CRC 19:03 )
LABEL FILENAME TXT RF.SCR " 0 HERE 1- C!
0 CONSTANT RHANDLE              0 CONSTANT WHANDLE

: BADFILE  ( fl -  )  IF
  {  'NF RHANDLE CFA 2+ } LITERAL OFF
  {  'NF WHANDLE CFA 2+ } LITERAL OFF
  ."  File not open!!" ABORT  THEN ;

CODE (OPF) \ addr --- handle/ec | open file at addr
  DX POP,   3D02 # AX MOV,  21 INT,
  U< IF,  AX NEG,  THEN,  1PUSH        ;C




\ mess-dos interface:                     (  7  4 88 CRC 16:21 )
CODE LSEEK   \ dfaddr handle type --- fl/dfaddr |
  AX POP,  ( type )  BX POP, \ handle
  CX POP,  DX POP,  ( dfaddr)   42 # AH MOV,  21 INT,
  U< IF,  AX NEG,  1PUSH  THEN,  AX PUSH,  DX PUSH,  NEXT ;C

: OPENIT   \ addr ---  | open a file
  (OPF)  DUP 0< BADFILE  DUP
  {  'NF RHANDLE CFA 2+ } LITERAL !
  {  'NF WHANDLE CFA 2+ } LITERAL !
  0 0 RHANDLE 2  LSEEK  B/BUF U/  1-
  {  'NF MAXBLK  CFA 2+ } LITERAL !  DROP ;




\ mess-dos interface:                     (  4  3 95 CRC 16:22 )
CODE RDF   \ addr count handle --- ct/er | read from addr for
    \ count bytes to file/handle. Return count read or error.
  3F # AH MOV,    BEGIN,  >R >R
  BX POP,  CX POP,  DX POP,
  SEGMENT T#) DS MOV,
  21 INT,  U< IF,  AX NEG,  THEN,
  CS PUSH,  DS POP,    1PUSH          ;C

CODE WTF   \ addr count handle --- ct/er | read to addr for
    \ count bytes from file/handle. Return count read or error.
  40 # AH MOV,   R> R>  AGAIN,           ;C




\ mess-dos interface:                     ( 17  3 88 CRC 19:08 )
: (R/W)   \ addr blk# r/w ---  | r/w for a file once opened
  RHANDLE 0= BADFILE   >R B/BUF U*
  R IF RHANDLE ELSE WHANDLE THEN  0 LSEEK
  0< IF ."  File Seek Error"  ABORT THEN  DROP
  B/BUF R> IF  RHANDLE RDF  ELSE  WHANDLE WTF  THEN
  B/BUF - IF ."  File Size Overflow"  ABORT  THEN  ;









































\      @L C@L !L C!L                      ( 20  2 89 CRC 10:10 )
CODE @L   BX POP,  ES POP,  ES: 0 [BX] AX MOV,  1PUSH  ;C

CODE C@L   BX POP,  ES POP, ES: 0 [BX] AL MOV,
  AH AH XOR,  1PUSH  ;C

CODE C!L ( byt seg adr )
  BX POP,  ES POP,  AX POP,  ES: AL 0 [BX] MOV,  NEXT  ;C

CODE !L ( n seg adr -- )
  BX POP,  ES POP,  AX POP,  ES: AX 0 [BX] MOV,  NEXT  ;C





\ CMOVEL p@, etc.                         ( 20  2 89 CRC 10:09 )
CODE CMOVEL  ( sseg sptr dseg dptr cnt )
  SI BX MOV,  CX POP,  DI POP,  ES POP,  SI POP,
  DS POP,  REP, .B MOVS,
  CS PUSH,  DS POP,  BX SI MOV,  NEXT  ;C

CODE PC@   \ p# -- c | fetch from i/o space
  DX POP,  DX AL IN,  AH AH SUB,  1PUSH                   ;C
CODE P@    \ p# -- n | fetch from i/o space
  DX POP,  DX AX IN,  1PUSH                               ;C

CODE PC!   \ c p# -- | store to i/o space
  DX POP,  AX POP,  DX AL OUT,  NEXT                      ;C
CODE P!    \ n p# -- | store to i/o space
  DX POP,  AX POP,  DX AX OUT,  NEXT                      ;C

\ relocation words                        ( 16  8 88 CRC 16:06 )
: 2@  DUP 2+ SWAP  @ SWAP @ ;  : 2!  DUP 2+ ROT SWAP  !  ! ;
CODE CS@  CS PUSH,  NEXT   ;C
0 VARIABLE SEG                \ keeps relocation factor
HERE DELTA - 0 , CONSTANT FUDGE \ in 2nd word, seg in first. You
: (T@)   SEG 2@ ROT +  @L ;   \ dump/dis any segment w/ any
                              \ relocation you want by setting
: (TC@)  SEG 2@ ROT + C@L ;   \ FUDGE & SEG  correctly.

: SEG?  SEG @ 0 D. ;            : SETSEG   SEG ! ;

: HOMESEG   CS@ SETSEG FUDGE OFF ;

'NF (T@) CFA VARIABLE 'T@       'NF (TC@) CFA VARIABLE 'TC@

: T@   'T@ @EXECUTE STOP        : TC@  'TC@ @EXECUTE STOP
\ frills: dump & ascii print              ( 16  8 88 CRC 16:08 )
DECIMAL                         : U.  0 D. ;
: (DUMP) \  addr ct ---  | dump as pointed to by reloc
  SPACE  BOUNDS DO  I TC@ 3 .R  LOOP ;
: LASCI   \  addr ct ---  | asci type as pointed to by reloc
  SPACE  BOUNDS DO  I TC@  127 AND  DUP
    BL ASCII ~ WITHIN 0= IF DROP ASCII . THEN  EMIT  LOOP ;
: HEAD  \ addr --- | headder for dump display
  16 0 DO I OVER + 15 AND 3 .R LOOP DROP ;
: TAB  OUT @ - SPACES ;
  \ N. B: Not responsible for negative counts! -- the MGT.
: DUMP   \  addr ct ---  | dump as pointed to by reloc
  OVER CR 6 SPACES HEAD  BEGIN  DUP  WHILE  CR OVER 0 5 D.R
     2DUP 16 MIN >R  R 2DUP (DUMP)  54 TAB LASCI
     R R> MINUS D+  ?TERMINAL IF DROP 0 THEN  REPEAT 2DROP ;

































( improved overlays                       (  4  1 89 crc  7:42 )
\ 0 VARIABLE >MEM      ( --> mem to pick up          )
\ 0 VARIABLE +HEAD     ( --> start in first block    )
|  60 USER >MEM            |  62 USER +HEAD

| : HEAD@+    +HEAD @  2 +HEAD +!  ;

| : NEWBLK    BUFFER  DUP B/BUF ERASE  UPDATE ;

| : ADVANCE   DUP >MEM +!  CMOVE   ASCII . EMIT ;






( improved overlays                       (  4  1 88 crc  8:04 )
| : GETDICT   ( addr ---  | build overlay restoration info     )
  2+ +HEAD !              ( set pointer past raw block flag  )
  [COMPILE] ' NFA 2- DUP      ( starting point               )
    >MEM !        HEAD@+ !    ( starting point               )
  HERE            HEAD@+ !    ( top of dictionary            )
  CURRENT @       HEAD@+ !    ( current vocabulary           )
  CONTEXT @       HEAD@+ !    ( context                      )
  VOC-LINK @      HEAD@+ !    ( vocabulary chain start       )
  VOC-LINK   BEGIN  @  -DUP   ( vocabulary chain             )
      WHILE  DUP 2- @ HEAD@+  !  repeat
  HEAD@+ OFF ;                ( end of data                  )




( improved overlays                       (  4  1 88 crc  8:24 )
| : SETDICT   ( addr ---  | build overlay restoration info     )
  2+ +HEAD !              ( set pointer past raw block flag  )
  HEAD@+ @          >MEM !    ( starting point               )

  HEAD@+ @            DP !    ( top of dictionary            )
  HEAD@+ @       CURRENT !    ( current vocabulary           )
  HEAD@+ @       CONTEXT !    ( context                      )
  HEAD@+ @      VOC-LINK ! ;  ( vocabulary chain start       )

| : SETVOCS   ( addr ---  | install vocabulary link pointers   )
  +HEAD !                     ( set pointer                  )
  VOC-LINK   BEGIN  @  -DUP   ( vocabulary chain             )
      WHILE  HEAD@+ @  OVER 2- !  REPEAT  ;


( improved overlays                       (  4  1 89 crc  7:42 )
: SAVEOVER  ( blk# ---  | save overlays to blk# from given word)
  DUP NEWBLK  DUP >R  GETDICT    ( dict info stored            )
  >MEM @  +HEAD @  B/BUF OVER R> -  -  ( src, dest, ct         )
  ADVANCE
  BEGIN  >MEM @  HERE  U< WHILE
  1+  >MEM @  OVER NEWBLK 2+ B/BUF 2-  ADVANCE  REPEAT
  DROP FLUSH ;








( improved overlays                       (  4  1 88 crc  8:25 )
: BRING     ( blk# ---  | restore overlays from blk#         )
  DUP  BLOCK  DUP SETDICT         ( set dictionary info      )
  +HEAD @ OVER  - >R              ( offset to voc-link data  )
  +HEAD @                         ( begin at voc-link data   )
  BEGIN  DUP @ WHILE 2+ REPEAT 2+ ( skip voclinx for now     )
  OVER - >R  R +  ( SRC)  >MEM @  ( dest                     )
     B/BUF R> -  ADVANCE  DUP     ( move first block to mem  )
  BEGIN  >MEM @  HERE  U< WHILE
  1+  DUP BLOCK 2+  >MEM @  B/BUF 2-  ADVANCE  REPEAT
  DROP
  BLOCK R> + SETVOCS ;




















































\ 68000 : forward refs 1                    17  2 85 CRC
     0A      3 BYTE:IN (CR) C!
   0D        4 BYTE:IN (CR) C!





   'NF R  CFA 2+  -2 BYTE:IN I    !
   'NF 2- CFA 2+  -2 BYTE:IN CFA  !






\   11 Source Code: forward refs 2          07 07 83 CRC

*COLON* @ -2 BYTE:IN : !
   00 BYTE:IN :                REPLACED:BY ?EXEC
   02 BYTE:IN :                REPLACED:BY !CSP
   04 BYTE:IN :                REPLACED:BY CURRENT
   08 BYTE:IN :                REPLACED:BY CONTEXT
   0C BYTE:IN :                REPLACED:BY CREATE
   0E BYTE:IN :                REPLACED:BY ]
   10 BYTE:IN :                REPLACED:BY (;CODE)






\   11 Source Code: forward refs 3          15 07 83 CRC
   00 BYTE:IN ;                REPLACED:BY ?CSP
   02 BYTE:IN ;                REPLACED:BY COMPILE
   06 BYTE:IN ;                REPLACED:BY SMUDGE
   08 BYTE:IN ;                REPLACED:BY [
   *COLON*   @ -2 BYTE:IN ;    !
   *(;CODE)* @  2 BYTE:IN VARIABLE  !
   *(;CODE)* @  2 BYTE:IN USER !

   00 BYTE:IN CONSTANT         REPLACED:BY CREATE
   02 BYTE:IN CONSTANT         REPLACED:BY SMUDGE
   04 BYTE:IN CONSTANT         REPLACED:BY ,
   06 BYTE:IN CONSTANT         REPLACED:BY (;CODE)

    6 BYTE:IN ?ERROR           REPLACED:BY ERROR

\ 80x86 Source Code: forward refs 4       ( 24 12 87 CRC 15:38 )


   0F BYTE:IN ."               REPLACED:BY WORD
   1D BYTE:IN ."               REPLACED:BY WORD
   0C BYTE:IN WORD             REPLACED:BY BLOCK

   18 BYTE:IN ERROR            REPLACED:BY MESSAGE

80  'NF X CFA  3 - DELTA + C!    \ make it null






















































\ 80x86 Source Code: forward refs 8       ( 12  8 88 CRC 16:25 )
ASSEMBLER  COLDSTART 4 +BOOTS -  2 BOOTS @ + !
           WARM  8 +BOOTS -  6 BOOTS @ + ! FORTH
LAST @ DELTA -       0C BOOTS @ +    !  \ 0E = backspace
EM US -       10 BOOTS @ +           !  \  uarea
ASSEMBLER TOS 12 BOOTS @ +           !  \  TOS
 RTS          14 BOOTS @ +           !  \  top of return stack
TIBX                  INITIALISES TIB
  1F                  INITIALISES WIDTH
   1                  INITIALISES WARNING
DPNEW @ DELTA -  DUP  INITIALISES FENCE
                      INITIALISES DP
EM US - 38 + ( user)  INITIALISES VOC-LINK  \ for 4th vocab
'NF (KEY)       CFA   INITIALISES 'KEY
'NF (EXPECT)    CFA   INITIALISES 'EXPECT
;S  fill in boot parameters
\ 68000 : forward refs 8                  (  2  7 88 CRC 16:09 )
'NF (?TERMINAL) CFA          INITIALISES '?TERMINAL
'NF (EMIT)      CFA          INITIALISES 'EMIT
'NF (TYPE)      CFA          INITIALISES 'TYPE
'NF 2DROP       CFA          INITIALISES 'GOTOXY
'NF (PAGE)      CFA          INITIALISES 'PAGE
'NF (LIST)      CFA          INITIALISES 'LIST
'NF (CR)        CFA          INITIALISES 'CR
'NF (R/W)       CFA          INITIALISES 'R/W
SERIAL IFTRUE  'NF (QUIT) OTHERWISE  'NF CMDBOOT  IFEND
                CFA          INITIALISES 'QUIT
'NF (ABORT)     CFA          INITIALISES 'ABORT
'NF (CREATE)    CFA          INITIALISES 'CREATE
TIBX      US - CO - 100 -    INITIALISES 'FIRST
TIBX      US -      100 -    INITIALISES 'LIMIT
;S  fill in more boot parameters
\   11 Source Code: forward refs 9        ( 12  8 88 CRC 16:24 )
     FORTH
A081                40 BOOTS @ +          !  \  dummy vocs
LAST @ DELTA -      42 BOOTS @ +          !  \  vlfth
0000                44 BOOTS @ +          !  \  vlnk
     \ voc-link points to this guy.
BOT                   INITIALISES BOTSTACK
SPEAK @ IFTRUE CR ."  Forward references resolved."  IFEND
WARNING ON  CR .HERE
CR .SIZE  SPEAK @ IFTRUE ?0S IFEND  DECIMAL
CR 08 BYTE:IN (ABORT)    COUNT TYPE   CR 15 MESSAGE    CR
     DPNEW @ C/L ERASE




\ 808sux disassembler. Bleah.                         23Sep87crc
-->
For user information, see screens 41-42 and their shadows.

Coding techniques taken from other disassemblers I have written,
for 68k, LSI-11, 6502 and 65816. Questions, comments, and bomb
threats should be addressed to:

     Charles Curley

     https://charlescurley.com





\ Load screen: 8086 disassembler                      24Jul87crc
FORTH DEFINITIONS  BASE @ >R DECIMAL
\ FORGET TASK                     : TASK ;
\ SCR @  BLK @ 1-  LIST  SCR !
VOCABULARY DISASSEMBLER      IMMEDIATE

  1  36 +THRU
\ 242 277 THRU
               ?STACK
R> BASE !






\ Useful stuff:                           (  9 12 87 CRC 21:51 )
\ CODE SEXT   DR0 CLR,  S [ DR0 MOV,  DR0 .W EXT,  DR0 S [ MOV,
\    NEXT  ;c

\ CODE NIP   S [+ S [ MOV,  NEXT        ;c
code exit  0 [rp] IP mov,  rp inc, rp inc, next
\ : EXIT  ;S  ;
\ BASE @ HEX
\ CR FILING SETDIR: \MESSDOS\F83     DIR *.*
\ OPENFILE: F.COM     COMPILE-ADDR C000 HANDLE RDF  U.
\ DELTA FUDGE !  CLOSEIT         BASE !

: .NAME  \ nfa ---  | print name whose nfa is on the stack
  COUNT 31 AND BOUNDS  DO I C@ 127 AND EMIT LOOP SPACE ;
EXIT
: EXEC  2* R> + PERFORM   ;
\ 2/s, 2*s, other utils                               23Jul87crc
EXIT
CODE 2/S     \ n ct --- n' | shift n right ct times
   CX POP   AX POP  AX CL SHR  1PUSH  END-CODE

CODE 2*S     \ n ct --- n' | shift n left ct times
   CX POP   AX POP  AX CL SHL  1PUSH  END-CODE

: STOP[  ?CSP REVEAL  [COMPILE] [ ; IMMEDIATE

: C?  C@ . ;

: COL   #OUT @  - SPACES ;   \ n ---  | go to column n



\ relocation words                                    12Aug87crc
EXIT
VARIABLE RELOC  0 ,  ?CS: 0 RELOC 2! \ keeps relocation factor
: (T@)   RELOC 2@ ROT +  @L ; \ in first word, seg in 2nd. You
                              \ dump/dis any segment w/ any
: (TC@)  RELOC 2@ ROT + C@L ; \ relocation you want by setting
                              \ RELOC  correctly.
: SETSEG   RELOC 2+ ! ;       : HOMESEG   ?CS: SETSEG ;

: SEG?  RELOC 2+ @ U. ;

DEFER T@                       DEFER TC@
: MEMORY    ['] (TC@) IS TC@       ['] (T@) IS T@ ;   MEMORY

: DUMPBOOT   MEMORY  HOMESEG  [ ' BOOT >BODY @ , ] ;
' DUMPBOOT  IS BOOT
\ cp, cp related words, relocation words              12Aug87crc
0 VARIABLE CP         DISASSEMBLER DEFINITIONS
: CP@    CP @  ;
\ CODE CP@  CP #) AX MOV  1PUSH   END-CODE

: OOPS   CR CR .S
  CTL G EMIT   ABORT"  Oops!"  STOP

: NEXTB  CP@ TC@    CP 1+! ;

: NEXTW  CP@ T@   2 CP +! ;

\ : .MOI       \  ---  | have the current word print out its nam
\   LATEST [COMPILE] LITERAL  COMPILE .NAME ;   IMMEDIATE


\ lookahead for disp addressing modes                 27Jul87crc
0 VARIABLE OPS \ operand count
0 VARIABLE IM  \ 2nd operand extension flag/ct

: ?DISP      \ op ext --- op ext | does MOD operand have a disp?
  DUP 6 2/S  DUP 3 =  OVER 0=  OR
  0= IF  IM !  ELSE
     0= IF DUP 7 AND 6 = IF 2 IM ! THEN  THEN  THEN ;








\ addressing modes selfprinters                       27Jul87crc
\ : .SELF         \  --  | create a word which prints its name
\   <BUILDS DOES> NFA .NAME ;  \ the ultimate in self-doc!

.SELF AL        .SELF AX        .SELF [BX+SI]   .SELF ES
.SELF CL        .SELF CX        .SELF [BX+DI]   .SELF CS
.SELF DL        .SELF DX        .SELF [BP+SI]   .SELF SS
.SELF BL        .SELF BX        .SELF [BP+DI]   .SELF DS
.SELF AH        .SELF SP        .SELF [SI]      .SELF #
.SELF CH        .SELF BP        .SELF [DI]      .SELF #)
.SELF DH        .SELF SI        .SELF [BP]      .SELF S#)
.SELF BH        .SELF DI        .SELF [BX]
.SELF RP        .SELF [RP]      \ return stack pointer
.SELF IP        .SELF [IP]      \ interpreter pointer
.SELF W         .SELF [W]       \ working register

\ symbol table for forth re-entry locations           24Jul87crc
HEX  : .SYMBOL  FFFF AND U. ; DECIMAL ;S
6 CONSTANT SYMBOLCT     0 VARIABLE SYMBOLS -4 ALLOT  ASSEMBLER
>NEXT ,  >NEXT 1- ,  >NEXT 2- ,  >NEXT 3 - ,  ' BRANCH >BODY ,
' (LOOP) 5 + ,       DISASSEMBLER
.SELF NEXT      .SELF 1PUSH     .SELF 2PUSH     .SELF 3PUSH
.SELF BRAN1     .SELF PLOOP

: ?SYMBOL    \ a -- a n | if n = -1 then no symbol, else index
  TRUE  RELOC 2+ @  ?CS: = IF \ iff in code segment.
    SYMBOLCT 0 DO OVER I 2* SYMBOLS + @ =
      IF DROP I LEAVE THEN LOOP THEN ;

: .SYMBOL    \ a ---  | print symbol name else value
  ?SYMBOL  DUP 0< IF DROP U.  EXIT THEN  SWAP U. EXEC
  NEXT 1PUSH  2PUSH  3PUSH  BRAN1  PLOOP  STOP         ;S
\ symbolic debugging, forth style                     17Jul87crc
FORTH DEFINITIONS
0 VARIABLE SYMBOLIC  SYMBOLIC ON

DISASSEMBLER DEFINITIONS
: SYMBOL  <builds [COMPILE] ' nfa ,  [COMPILE] ' nfa ,
  DOES> SYMBOLIC @ IF 2+ THEN @ .NAME ;

.SELF W

SYMBOL BX BX W   SYMBOL [BX] [BX] [W]
SYMBOL SI SI IP  SYMBOL [SI] [SI] [IP]
SYMBOL BP BP RP  SYMBOL [BP] [BP] [RP]



\ Addressing mode decodes                             16Jul87crc
: .16REG     \ r# ---  | register printed out
  7 AND  EXEC  AX CX DX BX  SP BP SI DI  STOP

: .8REG      \ r# ---  | register printed out
  7 AND  EXEC  AL CL DL BL  AH CH DH BH  STOP

: .SEG       \ s# ---  | register printed out
  3 2/S 3 AND  EXEC  ES CS SS DS   STOP

: 0DISP      \  ---  | do if displacement is 0
  ." 0 "  ;

: BDISP      \  ---  | do if displacement is byte
  CP@  IM @ +  TC@ SEXT U.  OPS 1+! IM OFF ;

\ Addressing mode decodes                             17Jul87crc
: WDISP      \  ---  | do if displacement is word
  CP@  IM @ +  T@  U.  2 OPS +!  IM OFF ;

: (.R/M)     \ op ext ---  | print a register
  SWAP 1 AND  IF .16REG ELSE .8REG THEN  IM OFF ;

: .R/M       \ op ext --- op ext | print r/m as register
  2DUP        (.R/M) ;

: .REG       \ op ext --- op ext | print reg as register
  2DUP  3 2/S (.R/M) ;

: .DISP      \ op ext --- op ext | print displacement
  DUP 6 2/S  3 AND  EXEC  0DISP BDISP WDISP .R/M STOP

\ Addressing mode decodes                             31Jul87crc
: BIMM       \  ---  | do if immed. value is byte
  CP@  IM @ +  TC@      .  1 OPS +!  IM OFF ;

: SHOWDISP   \ op ext --- op ext | show disp and reg
  .DISP
  DUP  7 AND EXEC  [BX+SI]  [BX+DI]  [BP+SI]  [BP+DI]
                   [SI]     [DI]     [BP]     [BX]      STOP
HEX
: .MREG     \ op ext --- op ext | register(s) printed out + disp
  DUP C7 AND 6 = IF  WDISP #)  ELSE
  DUP C0 AND C0 - IF  SHOWDISP  ELSE .R/M  IM OFF  THEN  THEN ;

DECIMAL                         .SELF .B        .SELF .W
: .SIZE      \ op ---  | decodes for size
  1 AND  EXEC  .B  .W   STOP
\ opcode decodes: seg: pop, push, segtb   ( 27  1 88 crc  9:09 )
0 VARIABLE SEGTB  -4 ALLOT
ASCII E C, ASCII C C,  ASCII S C,  ASCII D C,

: SEG:       \ op ---  | print segment overrides
  3 2/S 3 AND SEGTB + C@ EMIT  ." S:" ;

: POP,       \ op ---  | print pops
  DUP 8 = IF OOPS THEN  .SEG  .MOI ;

: PUSH,      \ op ---  | print pushes
  .SEG  .MOI ;
BASE @ HEX
: ?SEG   \ op -- fl | is opcode a segment override?
  DUP 3E =  OVER 36 = OR  OVER 2E = OR  SWAP 26 =  OR ;
BASE ! ;S
\ opcode decodes: p/p adjusts p/seg p/adj             15Jul87crc
: P/P        \ op --- | pushes or pops
  DUP 1 AND  EXEC  PUSH, POP,  STOP

.SELF DAA,      .SELF DAS,      .SELF AAA,      .SELF AAS,

: ADJUSTS    \ op ---  | the adjusts
  3 2/S  3 AND  EXEC  DAA,  DAS,  AAA,  AAS,  STOP

: P/SEG      \ op ---  | push or seg overrides
  DUP 5 2/S  1 AND EXEC  P/P SEG:      STOP

: P/ADJ      \ op ---  | pop or adjusts
  DUP 5 2/S  1 AND EXEC  P/P ADJUSTS  STOP


\ opcode decodes: 0gp add, or, 0group                 14Jul87crc
: 0GP        \ op --- op | opcode decoded & printed
  DUP 4 AND IF  DUP 1 AND
            IF WDISP ELSE BIMM THEN  #
            1 AND IF AX ELSE AL THEN  ELSE
  NEXTB  OVER 2 AND
         IF  .MREG .REG  ELSE  ?DISP .REG .MREG
  THEN  2DROP THEN  ;

.SELF ADD,      .SELF ADC,      .SELF AND,      .SELF XOR,
.SELF OR,       .SELF SBB,      .SELF SUB,      .SELF CMP,

: 0GROUP     \ op ---  | select 0 group to print
  DUP 0GP 3 2/S 7 AND  EXEC
  ADD,  OR,   ADC,  SBB,  AND,  SUB,  XOR,  CMP,  STOP

\ opcode decodes: lows .reggp regs                    30Jul87crc
: LOWS       \ op ---  |  0-3f opcodes printed out
  DUP        7 AND  EXEC
  0GROUP  0GROUP  0GROUP  0GROUP
  0GROUP  0GROUP  P/SEG   P/ADJ  STOP

: .REGGP     \ op ---  | register group defining word
  <builds  DOES>  SWAP  .16REG  nfa .NAME ;

.REGGP INC,     .REGGP DEC,     .REGGP PUSH,    .REGGP POP,

: POP,       \ op ---  | handle illegal opcode for cs pop
  DUP 56 AND 8 = IF ." illegal," DROP  ELSE  POP,  THEN ;

: REGS       \ op ---  | 40-5f opcodes printed out
  DUP 3 2/S 3 AND EXEC  INC, DEC, PUSH, POP,   STOP
\ opcode decodes: branches meds           ( 14  3 88 crc 12:32 )
.SELF O,        .SELF NO,       .SELF B/NAE,    .SELF NB/AE,
.SELF E/Z,      .SELF NE/NZ,    .SELF BE/NA,    .SELF NBE/A,
.SELF S,        .SELF NS,       .SELF P/PE,     .SELF NP/PO,
.SELF L/NGE,    .SELF NL/GE,    .SELF LE/NG,    .SELF NLE/JG,

: .BRANCH    \ op ---  | branch printed out w/ dest.
  NEXTB SEXT  CP@ + .SYMBOL  ASCII J EMIT   15 AND EXEC
  O,    NO,   B/NAE, NB/AE, E/Z,   NE/NZ, BE/NA, NBE/A,
  S,    NS,   P/PE,  NP/PO, L/NGE, NL/GE, LE/NG, NLE/JG,  STOP
HEX
: INS&OUTS  FE AND DUP 6C = IF DX [DI] .SIZE ." INS,"   ELSE
   DUP 6E = IF [SI] DX .SIZE ." OUTS,"  ELSE OOPS  THEN THEN ;

: MEDS       \ op ---  | 40-7f opcodes printed out
  DUP 4 2/S  3 AND EXEC  REGS  REGS  INS&OUTS .BRANCH  STOP
\ opcode decodes: 2ndaries 80/81, 83s     ( 10  3 88 crc 12:30 )
: 80/81      \ op ---  | secondary at 80 or 81
  NEXTB  ?DISP OVER 1 AND  IF WDISP ELSE BIMM THEN  # .MREG
  BEGIN  [  >R >R ]
  SWAP .SIZE  3 2/S 7 AND  EXEC
  ADD, OR,  ADC, SBB, AND, SUB, XOR, CMP,   STOP

: 83S        \ op ---  | secondary at 83
  NEXTB  ?DISP BIMM #  .MREG
  [ R> R> ] AGAIN  STOP






\ opcode decodes: 1gp test xchg movrm/reg movd        16Jul87crc
: 1GP        \ op ---  | r/m reg opcodes
  <builds LATEST ,  DOES> @ >R  NEXTB  ?DISP .REG .MREG  2DROP
  R> .NAME ;

1GP TEST,       1GP XCHG,       .SELF LEA,      .SELF MOV,

: MOVRM/REG  NEXTB  ?DISP .REG .MREG  2DROP  MOV, ; \ 88-89

: MOVD       NEXTB        .MREG .REG  2DROP  MOV, ; \ 8A-8B






\ opcode decodes: movs>m 8movs                        17Jul87crc
HEX
: MOVS>M     \ op ---  | display instructions  8C-8E
  NEXTB  OVER 8D = IF  .MREG .REG  LEA,  ELSE
    OVER 8F = IF  .MREG  [ ' POP, cfa ] LITERAL .NAME  ELSE
    SWAP 1 OR SWAP  \ 16 bit moves only, folks!
    OVER 2 AND IF  .MREG DUP .SEG  ELSE
     ( ?DISP) DUP .SEG .MREG  THEN  MOV,  THEN THEN  2DROP ;

: 8MOVS      \ op ---  | display instructions  80-8F
  DUP 2/ 7 AND EXEC  80/81 83S TEST, XCHG,
                     MOVRM/REG  MOVD  MOVS>M  MOVS>M  STOP

DECIMAL


\ opcode decodes: 98-9F                               15Sep87crc
.SELF XCHG,     .SELF CBW,      .SELF CWD,      .SELF CALL,
.SELF WAIT,     .SELF PUSHF,    .SELF POPF,     .SELF SAHF,
.SELF LAHF,     .self nop,

: INTER      \ ---  | decode interseg jmp or call
  NEXTW .SYMBOL  ." : " NEXTW U. ;

: CALLINTER  \ ---  | decode interseg call
  INTER  CALL, ;

: 9HIS       \ op ---  | 98-9F decodes
  7 AND EXEC
  CBW,  CWD,  CALLINTER WAIT,  PUSHF,  POPF, SAHF, LAHF,  STOP


\ opcode decodes: 90-9F xchg movs/cmps                15Sep87crc
: XCHGA      \ op ---  | 98-9F decodes
  DUP 7 AND IF  AX .16REG  XCHG,  ELSE  NOP, DROP  THEN ;

: 90S        \ op ---  | 90-9F decodes
  DUP 3 2/S 1 AND EXEC  XCHGA  9HIS  STOP

.SELF MOVS,     .SELF CMPS,

: MOVS       \ op ---  | A4-A5 decodes
  .SIZE  MOVS, ;





\ opcode decodes: cmps .al/ax movs/acc .test          21Jul87crc
: CMPS       \ op ---  | A6-A7 decodes
  .SIZE  CMPS, ;

: .AL/AX     \ op ---  | decodes for size
  1 AND  EXEC  AL AX STOP

: MOVS/ACC   \ op ---  | A0-A3 decodes
  DUP 2 AND IF  .AL/AX  WDISP #)  ELSE
      WDISP #)  .AL/AX  THEN MOV, ;

.SELF TEST,     .SELF STOS,     .SELF LODS,     .SELF SCAS,

: .TEST      \ op ---  | A8-A9 decodes
  DUP 1 AND IF WDISP ELSE BIMM THEN #  .AL/AX TEST, ;

\ opcode decodes: stos lods scas a0s movs/imm         21Jul87crc
: STOS   ( op --- )  .SIZE  STOS, ;
: LODS   ( op --- )  .SIZE  LODS, ;
: SCAS   ( op --- )  .SIZE  SCAS, ;

: A0S        \ op ---  | A0-AF decodes
  DUP 2/ 7 AND EXEC
  MOVS/ACC MOVS/ACC  MOVS       CMPS
  .TEST    STOS      LODS       SCAS       STOP

: MOVS/IMM   \ op ---  | B0-BF decodes
  DUP 8 AND IF  WDISP # .16REG  ELSE  BIMM # .8REG  THEN
  MOV, ;



\ opcode decodes: hmeds les/lds ret,                  21Jul87crc
: HMEDS      \ op ---  | op codes 80 - C0 displayed
  DUP 4 2/S  3 AND EXEC  8MOVS  90S A0S MOVS/IMM   STOP

.SELF LES,      .SELF LDS,      .SELF INTO,     .SELF IRET,

: LES/LDS    \ op ---  | les/lds instruction  C4-C5
  NEXTB .MREG  .REG  DROP 1 AND EXEC LES, LDS, STOP

: RET,       \ op ---  | return instruction  C2-C3, CA-CB
  DUP 1 AND 0= IF WDISP ."  SP+" THEN
  8 AND IF ."  FAR"  THEN  .MOI ;




\ opcode decodes: mov#r/m c0s into/iret int, mov#r/m  21Jul87crc
: MOV#R/M    \ op ---  | return instruction  C2-C3, CA-CB
  NEXTB  ?DISP  OVER 1 AND  IF  WDISP  ELSE  BIMM  THEN #
  .MREG  MOV, 2DROP ;

: INT,       \ op ---  | int instruction  CC-CD
  1 AND IF NEXTB ELSE 3 THEN U.  .MOI ;

: INTO/IRET  \ op ---  | int & iret instructions  CE-CF
  1 AND EXEC  INTO, IRET, STOP

: C0S        \ op ---  | display instructions  C0-CF
  DUP 2/ 7 AND EXEC
  OOPS RET, LES/LDS  MOV#R/M  OOPS RET, INT,  INTO/IRET  STOP


\ opcode decodes: shifts esc,                         22Jul87crc
: AAS        \ op ---  | does anybody actually use these things?
  <builds LATEST ,  DOES>  @ .NAME  NEXTB 2DROP ;

AAS AAM,        AAS AAD,

.SELF ROL,      .SELF ROR,      .SELF RCL,      .SELF RCR,
.SELF SHL/SAL,  .SELF SHR,      .SELF SAR,

: SHIFTS     \ op ---  | secondary instructions d0-d3
  DUP 2 AND IF CL THEN
  NEXTB  .MREG NIP 3 2/S 7 AND EXEC
  ROL,  ROR,  RCL,  RCR,  SHL/SAL, SHR,  OOPS  SAR,  STOP

: XLAT,   DROP .MOI ;

\ opcode decodes: d0s esc, loops                      22Jul87crc
: ESC,       \ op ---  | esc instructions d8-DF
  NEXTB .MREG  3 2/S 7 AND U.  7 AND U.  .MOI ;

: D0S        \ op ---  | display instructions  D0-DF
  DUP 8 AND IF ESC, EXIT THEN
  DUP 7 AND EXEC
  SHIFTS SHIFTS SHIFTS SHIFTS  AAM, AAD, OOPS XLAT, STOP

.SELF LOOPE/Z   .SELF LOOP,     .SELF JCXZ,     .SELF LOOPNE/NZ,

: LOOPS      \ op ---  | display instructions  E0-E3
  NEXTB SEXT  CP@ + .SYMBOL  3 AND EXEC
  LOOPNE/NZ,  LOOPE/Z  LOOP,  JCXZ,  STOP


\ opcode decodes: in/out call                         23Jul87crc
.SELF IN,       .SELF OUT,      .SELF JMP,

: IN/OUT     \ op ---  | display instructions  E4-E6,EC-EF
  DUP 8 AND IF
       DUP 2 AND  IF  .AL/AX DX  OUT, ELSE
                      DX .AL/AX  IN,  THEN  ELSE
       DUP 2 AND  IF  .AL/AX BIMM # OUT, ELSE
                      BIMM # .AL/AX IN,  THEN  THEN ;

: CALL       \ op ---  | display instructions  E7-EB
  DUP 2 AND IF  DUP 1 AND IF  NEXTB SEXT  CP@ + .SYMBOL \ shor
        ELSE  INTER  THEN  ELSE  NEXTW CP@ + .SYMBOL THEN
  3 AND EXEC CALL, JMP,  JMP,  JMP, STOP


\ opcode decodes: e0s ftest                           24Jul87crc
: E0S        \ op ---  | display instructions  E0-EF
  DUP 2 2/S  3 AND  EXEC  LOOPS  IN/OUT CALL  IN/OUT STOP

: FTEST      \ op ---  | display instructions  F6,7:0
  ?DISP OVER 1 AND IF WDISP ELSE BIMM THEN #
  .MREG DROP  .SIZE  TEST, ;

.SELF NOT,      .SELF NEG,      .SELF MUL,      .SELF IMUL,
.SELF DIV,      .SELF IDIV,     .SELF REP/NZ,   .SELF REPZ,
.SELF LOCK,     .SELF HLT,      .SELF CMC,      .SELF CLC,
.SELF STC,      .SELF CLI,      .SELF STI,      .SELF CLD,
.SELF STD,      .SELF INC,      .SELF DEC,      .SELF PUSH,



\ opcode decodes: mul/div not/neg f6-f7s              24Jul87crc
: MUL/DIV    \ op ext ---  | secondary instructions F6,7:4-7
  .MREG  AX OVER 1 AND IF DX THEN  NIP
  3 2/S 3 AND EXEC MUL, IMUL, DIV, IDIV, STOP

: NOT/NEG    \ op ext ---  | secondary instructions F6,7:2,3
  .MREG SWAP .SIZE  3 2/S 1 AND EXEC NOT, NEG, STOP

: F6-F7S     \ op ---  | display instructions  F6,7
  NEXTB  DUP 3 2/S  7 AND EXEC
  FTEST OOPS NOT/NEG NOT/NEG
  MUL/DIV MUL/DIV MUL/DIV MUL/DIV  STOP




\ opcode decodes: fes fcall/jmp fpush finc(  1  1 88 CRC 14:15 )
: FES        \ op ---  | display instructions  FE
  NEXTB .MREG .B NIP  3 2/S  1 AND EXEC INC, DEC, STOP

: FCALL/JMP  \ op ext ---  | display call instructions  FF
  .MREG  3 2/S DUP 1 AND IF  ." FAR "  THEN  NIP
  2/ 1 AND EXEC JMP, CALL,  STOP

: FPUSH      \ op ext ---  | display push instructions  FF
  DUP 4 AND IF .MREG  2DROP PUSH, EXIT THEN OOPS ;

: FINC       \ op ext ---  | display inc/dec instructions  FF
  .MREG  NIP 3 2/S 1 AND EXEC INC, DEC, STOP



\ opcode decodes: ffs f0s                 ( 27  1 88 crc  9:06 )
: FFS        \ op ---  | display instructions  FF
  NEXTB DUP 4 2/S 3 AND EXEC
  FINC  FCALL/JMP FCALL/JMP  FPUSH   STOP

: F0S        \ op ---  | display instructions  F0-FF
  DUP 15 AND  DUP 7 AND 6 < IF NIP  THEN  EXEC
  LOCK,  OOPS   REP/NZ, REPZ,  HLT, CMC, F6-F7S  F6-F7S
  CLC, STC, CLI, STI, CLD, STD,  FES  FFS                STOP

BASE @ HEX
: ?REP   \ op -- fl | is it a rep prefix?
  FE AND  F2 = ;
BASE !


\ disassembling: (inst) highs                         23Sep87crc
: HIGHS   \ op -- | op codes C0 - FF displayed
  DUP 4 2/S  3 AND EXEC C0S D0S E0S F0S STOP

: (INST)  \ op ---  | highest level vector table
  255 AND  DUP 6 2/S EXEC LOWS  MEDS  HMEDS  HIGHS  STOP

.SELF ESC_TO_EXIT

FORTH DEFINITIONS






\ frills: dump & ascii print                          16Jul87crc
: (DUMP) \  addr ct ---  | dump as pointed to by reloc
  SPACE  BOUNDS DO  I TC@ 3 .R  LOOP ;

: LASCI   \  addr ct ---  | asci type as pointed to by reloc
  SPACE  BOUNDS DO  I TC@  127 AND  DUP
    BL ASCII ~ WITHIN 0= IF DROP ASCII . THEN  EMIT  LOOP ;
: HEAD  \ addr --- | headder for dump display
  16 0 DO I OVER + 15 AND 3 .R LOOP DROP ;

  \ N. B: Not responsible for negative counts! -- the MGT.
: DUMP   \  addr ct ---  | dump as pointed to by reloc
  OVER CR 6 SPACES HEAD  BEGIN  DUP  WHILE  CR OVER 5 U.R
     2DUP 16 MIN >R  R 2DUP (DUMP)  54 TAB LASCI
     R R> MINUS D+  ?TERMINAL IF DROP 0 THEN  REPEAT 2DROP ;

\ disassembling: inst disassem            ( 24  3 88 crc 21:00 )
: INST  \  ---  | display opcode at ip, advancing as needed
  DISASSEMBLER  CR
  CP@ >R R 6 U.R  R TC@ 3 .R 2 SPACES
  NEXTB  DUP ?SEG IF SEG: NEXTB  THEN
         DUP ?REP IF F0S  NEXTB  THEN
  (INST)  OPS @ CP +!  OPS OFF  IM OFF
  R> CP@ OVER - 2DUP  35 TAB (DUMP)
  55 TAB LASCI  ?STACK   ;

: DISASSEM   \  addr --- | disassemble until esc key
  DISASSEMBLER  2 TAB ESC_TO_EXIT  CP !  BASE @ >R  HEX
  BEGIN  INST  (KEY)  DUP CTL M = IF SCR @ LIST THEN
     DUP CTL N = IF  SCR 1+!  SCR @ LIST  THEN
     CTL [ = UNTIL  R> BASE ! ;
32  ' ESC_TO_EXIT  nfa 2DUP 4 + C!  7 + C!
\ integrate into decompiler  dis: un:                 23Sep87crc
: DIS:  ( HOMESEG   RELOC OFF)   ' CFA @ DISASSEM ;
EXIT
: SEE    \ cfa ---   | disassemble if unknown or code
  ' DUP @ [ HIDDEN ] DEFINITION-CLASS
  6 = IF  DUP @ DOES?  NIP  IF  (SEE)
           ELSE  HOMESEG @ DISASSEM  THEN
      ELSE  (SEE)  THEN ;

: UN:  SEE ;    \ made with the un: nut, of course
\S
: FRED  ;  \ temp for use with trial code.




\ Comments: Addressing modes:                          8Jul87crc
Intel name         Mnemonic      E.g.
Register           rr            AX AX SUB
Immediate          #             -1 # AX MOV
Direct             #)            UP #) BX MOV
Register Indirect  [rX]          AX [BX] ADD
Base addressing    dsp [Bx]      ' DP 2+ @ [BX] AX MOV
Indexed            dsp [xI]      20 [SI] AX MOV
Based Indexed      dsp [Bx+xI]   1024 [BP+DI] AX MOV
String             implied       LDS
Port Direct        dsp           AX 44 OUT
Port Indirect      rr            AL DX OUT

  |   7 |   6 |   5 |   4 |   3 |   2 |   1 |   0 |
  |    op1    |       op2       |       op1       |
  |  - mod -  |   --- reg ---   |   --- r/m ---   |
\ test code                                           24Jul87crc
FORGET FRED        HEX
VARIABLE FRED                  CODE TEST   AX AX SUB
  CLC STI  0 [BP+SI] DEC   1234 [BX+SI] BYTE DEC
  0 [SI] CALL   2345 [SI] FAR CALL  34 [BP] PUSH
  5 [W] MUL  0 [BX+SI] IDIV  rep repz hlt cmc
  1234 # 0 [RP] TEST   AX NOT  AL NEG
  86 # 0 [RP] BYTE TEST  AX DX OUT  5 # AL IN
  AX CL SHR  0 [RP] ROR  5 [W] -1 1 ESC  XLAT  AAM
  0 [BX] AX LDS  12 # 5 [W] BYTE MOV  45 INT
  14 # AL MOV   1234 # BP MOV            BYTE SCAS
  FRED #) AL MOV   MOVS  BYTE CMPS   12 # AX TEST AX LODS
                                        -->



\ test code                                           31Jul87crc
  AX CX XCHG  CBW CWD  WAIT
  AX BX ADC   ES PUSH  ES POP  AAA     AX ES MOV
  50 # 200 [BX] ADD
  BX BX SUB  BYTE 20 # 1234 [BX] OR   50 # 20 [BX] BYTE ADD
  5000 # FRED #) ADD   BL 0 [RP] MOV    0 [RP] BL MOV
            0= IF  500 #) BX LEA  FRED #) POP
    ES:     0 [BX] AX ADD   ES PUSH  THEN      NEXT END-CODE

HERE  : SEE  [ 2 CSP +! ]  ['] TEST @  LITERAL OVER -  DUMP ;
FLUSH  EDITOR   BLK @ 1- LIST  FRED 6 U.R SPACE  DIS: TEST





\ User Notes & comments                               28Jul87crc
If you have Henry Laxen's decompiler installed, then load
scr 36. Otherwise fix screen 36 for your decompiler, or ignore
3) below. To use the disassembler:

1) enter  <addr> DISASSEM . This will begin disassembling at
   addr. E.g. 1234 DISASSEM.

2) enter  DIS: <wordname> . This will disassemble the code
   field address of  <wordname> , regardless of the type of
   the word. E.g. DIS: 0

3) enter  SEE <wordname> . If  <wordname>  is a code definition,
   the code at its code field address will be disassembled.
   E.g. SEE DUP

\ User Notes & comments                               28Jul87crc
To add to the symbol table: 1) add code to calculate the address
and add it into the table  SYMBOLS . 2) Increment  SYMBOLCT  by
the correct amount. 3) Add a  .SELF  for each new symbol, and
4) add the new  .SELF  daughter words to the execution array in
.SYMBOL . Then re-compile the disassembler.

The FORTH registers are shown by name: IP, W, RP. This may be
turned off, and the Intel names substituted with the switch
SYMBOLIC , in the  FORTH  vocabulary.






\ 808sux disassembler. Bleah.                         28Jul87crc
Note that errors may yet exist in this disassembler. If so,
when you find one, please report it to me so that I can fix it
and propagate the fix. Thank you.

   Sources: The 8086/8088 Primer, Morse, Hayden
            iAPX 86/88, 186/188 User's Manual, Intel

























































































































































































\ write#s for sector checking                   14:22 21Dec87crc
: write#  \ blk# --  | write block# with its block number
  dup block ! update ;

: write#s  \ start ct  --  | write ct block#s from start
  bounds cr  do  i write#  i 5 .r  loop ;

: read#    \ blk#  --  #  | read first cell of a block
  block @ ;

: read#s   \ start ct  --  | read ct blocks & verify their #s
  bounds  cr do  i read#  i 2dup  -
     if  10 .r 6 .r  else 2drop  then loop  cr ;

: verify   \ start ct --  | check out a range of blocks
  2dup  write#s  read#s ;
